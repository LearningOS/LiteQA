{"result": {"folders": ["lecture21", "课堂问答", "2016"], "nr": 861, "data": {"embed_links": []}, "created": "2016-05-11T03:40:22Z", "bucket_order": 3, "no_answer_followup": 3, "change_log": [{"uid": "hdjonbiyfs62ie", "anon": "no", "when": "2016-05-11T03:40:22Z", "data": "io2biyewli37hz", "type": "create"}, {"uid": "hdjonbiyfs62ie", "anon": "no", "when": "2016-05-11T03:49:22Z", "data": "io2bujhizgz377", "type": "update"}, {"to": "io2biyes9aa7hy", "uid": "hdjonbiyfs62ie", "anon": "no", "when": "2016-05-11T03:50:45Z", "type": "followup"}, {"to": "io2biyes9aa7hy", "uid": "hdjonbiyfs62ie", "anon": "no", "when": "2016-05-11T03:50:58Z", "type": "followup"}, {"to": "io2biyes9aa7hy", "uid": "hdjonbiyfs62ie", "anon": "no", "when": "2016-05-11T03:51:08Z", "type": "followup"}, {"uid": "hdjonbiyfs62ie", "anon": "no", "when": "2016-05-11T08:29:38Z", "data": "io2luyp8lk753j", "type": "update"}, {"to": "io2biyes9aa7hy", "uid": "i0gl5kctugw3xi", "anon": "no", "when": "2016-05-11T08:33:23Z", "type": "feedback"}, {"to": "io2biyes9aa7hy", "uid": "i0c1nsm3911wc", "anon": "no", "when": "2016-05-11T08:38:47Z", "type": "feedback"}, {"to": "io2biyes9aa7hy", "uid": "i0brpl1lbyui6", "anon": "no", "when": "2016-05-11T08:38:50Z", "type": "feedback"}, {"to": "io2biyes9aa7hy", "uid": "i0yuo4o74sx70w", "anon": "no", "when": "2016-05-11T08:59:12Z", "type": "feedback"}, {"to": "io2biyes9aa7hy", "uid": "i6uiksj895B", "anon": "no", "when": "2016-05-11T08:59:26Z", "type": "feedback"}, {"to": "io2biyes9aa7hy", "uid": "i3qk2vs65x276j", "anon": "no", "when": "2016-05-11T08:59:52Z", "type": "feedback"}, {"to": "io2biyes9aa7hy", "uid": "ic226rac4j5jw", "anon": "no", "when": "2016-05-11T09:05:31Z", "type": "feedback"}, {"to": "io2biyes9aa7hy", "uid": "i0eqqq6jvng408", "anon": "no", "when": "2016-05-11T10:44:07Z", "type": "feedback"}, {"to": "io2biyes9aa7hy", "uid": "i6w84pnmjCQ", "anon": "no", "when": "2016-05-11T10:47:54Z", "type": "feedback"}, {"to": "io2biyes9aa7hy", "uid": "ikvcvqz0jx17m1", "anon": "no", "when": "2016-05-11T11:28:08Z", "type": "feedback"}, {"to": "io2biyes9aa7hy", "uid": "ie7xy71bn7b1s2", "anon": "no", "when": "2016-05-11T13:15:07Z", "type": "feedback"}, {"to": "io2biyes9aa7hy", "uid": "i6ub5at2geM", "anon": "no", "when": "2016-05-12T01:15:55Z", "type": "feedback"}, {"to": "io2biyes9aa7hy", "uid": "ikvcvr0o2bs7m3", "anon": "no", "when": "2016-05-12T04:12:57Z", "type": "feedback"}, {"to": "io2biyes9aa7hy", "uid": "i6uaz437IKR", "anon": "no", "when": "2016-05-12T04:52:46Z", "type": "feedback"}, {"to": "io2biyes9aa7hy", "uid": "i6vgn93glrq25f", "anon": "no", "when": "2016-05-12T07:11:07Z", "type": "feedback"}, {"to": "io2biyes9aa7hy", "uid": "i0f24oie8102cr", "anon": "no", "when": "2016-05-12T08:56:15Z", "type": "feedback"}, {"to": "io2biyes9aa7hy", "uid": "i18riqkwrl225m", "anon": "no", "when": "2016-05-12T08:58:13Z", "type": "feedback"}, {"to": "io2biyes9aa7hy", "uid": "i28skba6cd976f", "anon": "no", "when": "2016-05-12T10:22:22Z", "type": "feedback"}, {"to": "io2biyes9aa7hy", "uid": "i0ccqbaxwdz75c", "anon": "no", "when": "2016-05-12T10:25:46Z", "type": "feedback"}, {"to": "io2biyes9aa7hy", "uid": "i21zpwab2z775p", "anon": "no", "when": "2016-05-12T11:28:39Z", "type": "feedback"}, {"to": "io2biyes9aa7hy", "uid": "ikvcvp62fcm7ka", "anon": "no", "when": "2016-05-12T11:43:36Z", "type": "feedback"}, {"to": "io2biyes9aa7hy", "uid": "i70lz5f0QKm", "anon": "no", "when": "2016-05-12T11:44:34Z", "type": "feedback"}, {"to": "io2biyes9aa7hy", "uid": "ikx8y1dzPrM", "anon": "no", "when": "2016-05-12T11:45:34Z", "type": "feedback"}, {"to": "io2biyes9aa7hy", "uid": "im4yagyfl3chl", "anon": "no", "when": "2016-05-12T11:53:46Z", "type": "feedback"}, {"to": "io2biyes9aa7hy", "uid": "i0f7v0qgfm61s6", "anon": "no", "when": "2016-05-12T12:11:48Z", "type": "feedback"}, {"to": "io2biyes9aa7hy", "uid": "i242q8ug7vw40x", "anon": "no", "when": "2016-05-12T12:46:57Z", "type": "feedback"}, {"to": "io2biyes9aa7hy", "uid": "i11v1az5sf83l2", "anon": "no", "when": "2016-05-12T17:48:57Z", "type": "feedback"}, {"to": "io2biyes9aa7hy", "uid": "ikvcvnzpzq7j7", "anon": "no", "when": "2016-05-18T07:34:28Z", "type": "feedback"}, {"to": "io2biyes9aa7hy", "uid": "i0hjdkesg9c5z7", "anon": "no", "when": "2016-05-22T09:32:42Z", "type": "feedback"}, {"uid": "hdjonbiyfs62ie", "anon": "no", "when": "2016-05-28T14:56:56Z", "data": "iora6ilmi77bv", "type": "update"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "data": "izs3sr37wsf4wo", "type": "update", "when": "2017-03-02T08:02:48Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "2016春季-第二十一讲 课堂思考题回答-向勇班", "created": "2017-03-02T08:02:48Z", "content": "<p>请向勇班的同学把第二十一讲中指定小题的回答结果写在此贴中对应题目后面。<br /> <br /><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/09-1-spoc-discussion.md#小组思考题\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/09-1-spoc-discussion.md#小组思考题</a></p>\n<p><br />第二十一讲的回答的截止时间是明天&#xff08;20160512&#xff09;晚20点前。<br /> <br />要求&#xff1a;分小组完思考题&#xff0c;最多二个人一组&#xff0c;也可以独立回答。依据小组成员学号中最小学号除3后的余数&#xff0c;完成与余数相同的题目。</p>\n<p></p>\n<div>1&#xff09;小组思考题(1)&#xff1a;在模拟环境下实现Simple File System的功能&#xff0c;支持应用程序的一般文件操作。</div>\n<div>2&#xff09;小组思考题(2-ZFS)&#xff1a;ZFS文件系统分析</div>\n<div>3&#xff09;小组思考题(2-YAFFS)&#xff1a;YAFFS文件系统分析</div>\n<p><br />优胜者&#xff1a;</p>\n<p>选择做“1&#xff09;小组思考题(1)”的同学</p>\n<p>张浩天2013011416 郑兆衡2013011389<br />高博 2012012139 赵涵 2012011383<br />沈哲言 2013011371 叶子鹏 2013011404</p>\n<p></p>\n<p>选择做“2&#xff09;小组思考题(2-ZFS)”的同学<br />2013011402 钱迪晨 2013011413 高思达<br />朱新瑞 2013011411 &amp; 朱俸民 2012011894<br />霍健炜2016110024</p>\n<p></p>\n<p>选择做“3&#xff09;小组思考题(2-YAFFS)”的同学<br />谢琛睿 2013011406 杨明 2013011412</p>"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "2016春季-第二十一讲 课堂思考题回答-向勇班", "created": "2016-05-28T14:56:56Z", "content": "<p>请向勇班的同学把第二十一讲中指定小题的回答结果写在此贴中对应题目后面。<br /> <br /><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/09-1-spoc-discussion.md#小组思考题\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/09-1-spoc-discussion.md#小组思考题</a></p>\n<p><br />第二十一讲的回答的截止时间是明天&#xff08;20160512&#xff09;晚20点前。<br /> <br />要求&#xff1a;分小组完思考题&#xff0c;最多二个人一组&#xff0c;也可以独立回答。依据小组成员学号中最小学号除3后的余数&#xff0c;完成与余数相同的题目。</p>\n<p></p>\n<div>1&#xff09;小组思考题(1)&#xff1a;在模拟环境下实现Simple File System的功能&#xff0c;支持应用程序的一般文件操作。</div>\n<div>2&#xff09;小组思考题(2-ZFS)&#xff1a;ZFS文件系统分析</div>\n<div>3&#xff09;小组思考题(2-YAFFS)&#xff1a;YAFFS文件系统分析</div>\n<p><br />优胜者&#xff1a;</p>\n<p>选择做“1&#xff09;小组思考题(1)”的同学</p>\n<p>张浩天2013011416 郑兆衡2013011389<br />高博 2012012139 赵涵 2012011383<br />沈哲言 2013011371 叶子鹏 2013011404</p>\n<p></p>\n<p>选择做“2&#xff09;小组思考题(2-ZFS)”的同学<br />2013011402 钱迪晨 2013011413 高思达<br />朱新瑞 2013011411 &amp; 朱俸民 2012011894<br />霍健炜2016110024</p>\n<p></p>\n<p>选择做“3&#xff09;小组思考题(2-YAFFS)”的同学<br />谢琛睿 2013011406 杨明 2013011412</p>"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "2016春季-第二十一讲 课堂思考题回答-向勇班", "created": "2016-05-11T08:29:38Z", "content": "<p>请向勇班的同学把第二十一讲中指定小题的回答结果写在此贴中对应题目后面。<br /> <br /><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/09-1-spoc-discussion.md#小组思考题\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/09-1-spoc-discussion.md#小组思考题</a></p>\n<p><br />第二十一讲的回答的截止时间是明天&#xff08;20160512&#xff09;晚20点前。<br /> <br />要求&#xff1a;分小组完思考题&#xff0c;最多二个人一组&#xff0c;也可以独立回答。依据小组成员学号中最小学号除3后的余数&#xff0c;完成与余数相同的题目。</p>\n<p></p>\n<div>1&#xff09;小组思考题(1)&#xff1a;在模拟环境下实现Simple File System的功能&#xff0c;支持应用程序的一般文件操作。</div>\n<div>2&#xff09;小组思考题(2-ZFS)&#xff1a;ZFS文件系统分析</div>\n<div>3&#xff09;小组思考题(2-YAFFS)&#xff1a;YAFFS文件系统分析</div>\n<p><br />优胜者&#xff1a;</p>\n<p></p>"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "2016春季-第二十一讲 课堂思考题回答-向勇班", "created": "2016-05-11T03:49:22Z", "content": "<p>请向勇班的同学把第二十一讲中指定小题的回答结果写在此贴中对应题目后面。<br /> <br /><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/09-1-spoc-discussion.md#小组思考题\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/09-1-spoc-discussion.md#小组思考题</a></p>\n<p><br />第二十一讲的回答的截止时间是明天&#xff08;20160512&#xff09;晚20点前。<br /> <br />要求&#xff1a;分小组完思考题&#xff0c;最多二个人一组&#xff0c;也可以独立回答。依据小组成员学号中最小学号除3后的余数&#xff0c;完成与余数相同的题目。</p>\n<p></p>\n<div>1&#xff09;小组思考题(1)&#xff1a;在模拟环境下实现Simple File System的功能&#xff0c;支持应用程序的一般文件操作。</div>\n<div>2&#xff09;小组思考题(2-ZFS)&#xff1a;ZFS文件系统分析</div>\n<div>3&#xff09;小组思考题(2-YAFFS)&#xff1a;YAFFS文件系统分析</div>\n<p><br />优胜者&#xff1a;</p>\n<p></p>"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "2016春季-第二十一讲 课堂思考题回答-向勇班", "created": "2016-05-11T03:40:22Z", "content": "<p>请向勇班的同学把第二十一讲中指定小题的回答结果写在此贴中对应题目后面。<br /> <br /><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/09-1-spoc-discussion.md#小组思考题\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/09-1-spoc-discussion.md#小组思考题</a></p>\n<p><br />第二十一讲的回答的截止时间是明天&#xff08;20160512&#xff09;晚20点前。<br /> <br />要求&#xff1a;分小组完思考题&#xff0c;最多二个人一组&#xff0c;也可以独立回答。依据小组成员学号中最小学号除3后的余数&#xff0c;完成与余数相同的题目。</p>\n<p></p>\n<p>1&#xff09;小组思考题(1)&#xff1a;在模拟环境下实现Simple File System的功能&#xff0c;支持应用程序的一般文件操作。<br />2&#xff09;小组思考题(2)&#xff1a;ZFS文件系统分析<br />3&#xff09;小组思考题(2)&#xff1a;YAFFS文件系统分析<br /> <br />优胜者&#xff1a;</p>\n<p></p>"}], "type": "note", "tags": ["2016", "instructor-note", "lecture21", "课堂问答"], "tag_good": [], "unique_views": 228, "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/09-1-spoc-discussion.md#小组思考题\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/09-1-spoc-discussion.md#小组思考题</a></p>\n<p></p>\n<p>选择做“1&#xff09;小组思考题(1)”的同学的回答结果写在此贴后面。<br /><br /></p>", "created": "2016-05-11T03:50:45Z", "bucket_order": 205, "bucket_name": "Week 5/8 - 5/14", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<p>张浩天2013011416  郑兆衡2013011389</p>\n<p></p>\n<p>问题1&#xff1a;</p>\n<p><a href=\"https://github.com/ZhengZhaoHeng/os_2016/blob/master/lec21/answer1.md\">https://github.com/ZhengZhaoHeng/os_2016/blob/master/lec21/answer1.md</a></p>\n<p></p>\n<p>问题2、3源代码&#xff1a;</p>\n<p><a href=\"https://github.com/ZhengZhaoHeng/os_2016/blob/master/lec21/sfs.py\" target=\"_blank\">https://github.com/ZhengZhaoHeng/os_2016/blob/master/lec21/sfs.py</a></p>", "created": "2016-05-11T08:59:12Z", "bucket_order": 205, "bucket_name": "Week 5/8 - 5/14", "type": "feedback", "tag_good": [], "uid": "i0yuo4o74sx70w", "children": [], "tag_good_arr": [], "id": "io2mwz7l3pt72x", "updated": "2016-05-11T08:59:12Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<p>高博 2012012139</p>\n<p>赵涵 2012011383</p>\n<p></p>\n<p><a href=\"https://github.com/gaobo1993/os_course_spoc_exercises/blob/master/all/sys1.txt\" target=\"_blank\">Question 1</a></p>\n<p><a href=\"https://github.com/gaobo1993/os_course_spoc_exercises/blob/master/all/sfs-homework.py\" target=\"_blank\">Question 2</a></p>\n<p><a href=\"https://github.com/gaobo1993/os_course_spoc_exercises/blob/master/all/sfs-homework-3.py\" target=\"_blank\">Question 3</a></p>\n<p>注意soft link是信件了一个文件&#xff0c;而hard link是建了一个entry</p>", "created": "2016-05-11T09:05:31Z", "bucket_order": 205, "bucket_name": "Week 5/8 - 5/14", "type": "feedback", "tag_good": [], "uid": "ic226rac4j5jw", "children": [], "tag_good_arr": [], "id": "io2n53fxa8g2jt", "updated": "2016-05-11T09:05:31Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<p>王智默 2012011355</p>\n<p>高越 2012011379</p>\n<p></p>\n<p>问题1:</p>\n<p><a href=\"http://172.16.13.236/wzm_andy/ucore_lab/blob/master/related_info/lab8/sfs_states.txt\">http://172.16.13.236/wzm_andy/ucore_lab/blob/master/related_info/lab8/sfs_states.txt</a></p>\n<p>问题2 (代码):</p>\n<p><a href=\"http://172.16.13.236/wzm_andy/ucore_lab/blob/master/related_info/lab8/sfs-homework.py\">http://172.16.13.236/wzm_andy/ucore_lab/blob/master/related_info/lab8/sfs-homework.py</a></p>", "created": "2016-05-11T10:47:54Z", "bucket_order": 205, "bucket_name": "Week 5/8 - 5/14", "type": "feedback", "tag_good": [], "uid": "i6w84pnmjCQ", "children": [], "tag_good_arr": [], "id": "io2qsrhv43m7jh", "updated": "2016-05-11T10:47:54Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p><a href=\"https://gist.github.com/gjc13/770d5075e37e4035733c5e01112ea267\">https://gist.github.com/gjc13/770d5075e37e4035733c5e01112ea267</a></p>\n<p>操作参见run函数</p>", "created": "2016-05-11T13:15:07Z", "bucket_order": 205, "bucket_name": "Week 5/8 - 5/14", "type": "feedback", "tag_good": [], "uid": "ie7xy71bn7b1s2", "children": [], "tag_good_arr": [], "id": "io2w23i1w7o1vj", "updated": "2016-05-11T13:15:07Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>沈哲言 2013011371 叶子鹏 2013011404</p>\n<p></p>\n<p><a href=\"https://github.com/qq775193759/OS_ANSWER/blob/master/sfs/result.txt\" target=\"_blank\">结果文件</a></p>\n<p><a href=\"https://github.com/qq775193759/OS_ANSWER/tree/master/sfs\" target=\"_blank\">代码入口</a></p>\n<p><a href=\"https://github.com/qq775193759/OS_ANSWER/blob/master/sfs/report.md\" target=\"_blank\">实验报告</a></p>\n<p>我怀疑我用的版本有点不同&#xff0c;<strong>最后一条指令</strong>不一样&#xff0c;输出结果是[O][K]而不是[O]是不是我版本太新了&#xff1f;不过在这之前的结果都一样。</p>", "created": "2016-05-12T08:56:15Z", "bucket_order": 205, "bucket_name": "Week 5/8 - 5/14", "type": "feedback", "tag_good": [], "uid": "i0f24oie8102cr", "children": [], "tag_good_arr": [], "id": "io42916kvh1wb", "updated": "2016-05-12T08:56:15Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<p>马志明 2013011395 王启圣2013011409</p>\n<p></p>\n<p><a href=\"https://github.com/mazm13/os_work/blob/master/lab8_relatedInfo/answer.md\" target=\"_blank\">第一题</a></p>\n<p><a href=\"https://github.com/mazm13/os_work/blob/master/lab8_relatedInfo/sfs-homework.py\" target=\"_blank\">第二题代码</a></p>\n<p></p>\n<p></p>", "created": "2016-05-12T11:28:39Z", "bucket_order": 205, "bucket_name": "Week 5/8 - 5/14", "type": "feedback", "tag_good": [], "uid": "i21zpwab2z775p", "children": [], "tag_good_arr": [], "id": "io47p17lkn42g0", "updated": "2016-05-12T11:28:39Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<p></p>\n<p>2013011356 董豪宇</p>\n<p>2013011302 李奕昕</p>\n<p></p>\n<p><a href=\"https://github.com/donghy/os_exercise/blob/master/sfs_ans.md\" target=\"_blank\">第一题</a></p>\n<p></p>\n<p><a href=\"https://github.com/donghy/os_exercise/blob/master/sfs-homework.py\" target=\"_blank\">第二三题</a></p>\n<p></p>\n<p>抱歉迟交了.......</p>", "created": "2016-05-12T12:46:57Z", "bucket_order": 205, "bucket_name": "Week 5/8 - 5/14", "type": "feedback", "tag_good": [], "uid": "i242q8ug7vw40x", "children": [], "tag_good_arr": [], "id": "io4ahptjkg86ev", "updated": "2016-05-12T12:46:57Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "io2bwaxo3tf3qk", "updated": "2016-05-11T03:50:45Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/09-1-spoc-discussion.md#小组思考题\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/09-1-spoc-discussion.md#小组思考题</a></p>\n<p></p>\n<p>选择做“2&#xff09;小组思考题(2-ZFS)”的同学的回答结果写在此贴后面。</p>", "created": "2016-05-11T03:50:58Z", "bucket_order": 205, "bucket_name": "Week 5/8 - 5/14", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>2013011402 钱迪晨 2013011413 高思达<br /><br /></p>\n<p>ZFS和其他的文件系统相比的优点包括&#xff1a;</p>\n<p>&#xff08;参考<a href=\"http://www.racktopsystems.com/zfs-is-the-best/\" target=\"_blank\">Top 3 Reasons Why ZFS is the Best</a>, <a href=\"http://www.enterprisestorageforum.com/technology/features/article.php/3849556/10-Reasons-Why-ZFS-Rocks.htm\" target=\"_blank\">10 Reasons Why ZFS Rocks</a>&#xff09;</p>\n<p>1. zpool使得在ZFS上我们可以虚拟别的设备&#xff0c;运行别的文件系统&#xff0c;并且可以热插拔。这一技术使得ZFS拥有最好的混合存储池。尤其适用于混合SSD和RAID-Z等存储技术。</p>\n<p>2. ZFS的Copy on Write机制带来了很多好处。每次写操作会在写在新的位置&#xff0c;写完后才会把指针指向新的内容。这一机制保证了写操作的原子性&#xff08;写操作如果被打断&#xff0c;则原来的数据不会被更改&#xff09;。在这种机制下&#xff0c;旧的数据可能会被保留&#xff0c;方便实现系统快照。</p>\n<p>3. ZFS的自我纠错机制强于一般的文件系统。其关键的区别是&#xff0c;它的256位的校验和并非和数据存在一起&#xff0c;而是和指向数据块的指针存在一起&#xff08;即作为元数据存储&#xff09;。这种方法拥有更强的纠错能力。</p>\n<p>4. 作为一个128位的文件系统&#xff0c;它的容量是足够大的。</p>\n<p></p>\n<p></p>\n<p>更多补充介绍&#xff1a;</p>\n<pre>ZFS是一个128位的文件系统&#xff0c;这意味着它能存储1800亿亿&#xff08;18.4 × 1018&#xff09;倍于当前64位文件系统的数据。\n2^48—任意文件系统的快照数量&#xff08;2 × 1014&#xff09;\n2^48—任何单独文件系统的文件数&#xff08;2 × 1014&#xff09;\n16 exabytes (2^64 byte)—文件系统最大尺寸\n16 exabytes (2^64 byte)—最大单个文件尺寸\n16 exabytes (2^64 byte)—最大属性大小\n128 Zettabytes (2^78 byte)—最大zpool大小\n2^56—单个文件的属性数量&#xff08;受ZFS文件数量的约束&#xff0c;实际为2^48&#xff09;\n2^56—单个目录的文件数&#xff08;受ZFS文件数量的约束&#xff0c;实际为2^48&#xff09;\n2^64—单一zpool的设备数\n2^64—系统的zpools数量\n2^64—单一zpool的文件系统数量</pre>\n<p>ZFS的实现技术有zpools。<br />不同于传统文件系统需要驻留于单独设备或者需要一个卷管理系统去使用一个以上的设备&#xff0c;ZFS创建在虚拟的&#xff0c;被称为“zpools”的存储池之上。每个存储池由若干虚拟设备&#xff08;<i>virtual devices&#xff0c;vdevs</i>&#xff09;组成。这些虚拟设备可以是原始磁盘&#xff0c;也可能是一个RAID1镜像设备&#xff0c;或是非标准RAID等级的多磁盘组。于是zpool上的文件系统可以使用这些虚拟设备的总存储容量。</p>\n<p>这样做的好处是&#xff0c;在使用ZFS的时候就好像在使用ram&#xff0c;一个地址就可以访问特定的数据。<br /><br /><br />ZFS的特点是对于数据的保护性特别好&#xff0c;具体做法是对于任何的数据block&#xff0c;他会进行SHA256计算checksum&#xff0c;将其记录在指向这个block的指针里面。任何一个模块都是这样&#xff0c;比如目录entry&#xff0c;文件entry&#xff0c;数据block。这使得ZFS可以自己校验自己。<br /><br />ZFS使用copy on write机制&#xff0c;所有文件系统中的块指针都包括256位的能在读时被重新校验的关于目标块的校验和。含有活动数据的块从来不被覆盖&#xff1b;而是分配一个新块&#xff0c;并把修改过的数据写在新块上。所有与该块相关的元数据块都被重新读、分配和重写。为了减少该过程的开销&#xff0c;多次读写更新被归纳为一个事件组&#xff0c;并且在必要的时候使用日志来同步写操作。</p>\n<p></p>", "created": "2016-05-11T08:33:23Z", "bucket_order": 205, "bucket_name": "Week 5/8 - 5/14", "type": "feedback", "tag_good": [], "uid": "i0gl5kctugw3xi", "children": [], "tag_good_arr": [], "id": "io2lzry8axk676", "updated": "2016-05-11T08:33:23Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>朱新瑞 2013011411 &amp; 朱俸民 2012011894</p>\n<p></p>\n<p>ZFS是一个128位的文件系统&#xff0c;它的一些理论限制如下</p>\n<ul><li>2<sup>48</sup>: number of entries in any individual directory<sup><a href=\"https://en.wikipedia.org/wiki/ZFS#cite_note-30\">[30]</a></sup></li><li>16 <a href=\"https://en.wikipedia.org/wiki/Exbibyte\">exbibytes</a> (2<sup>64</sup> bytes): maximum size of a single file</li><li>16 exbibytes: maximum size of any attribute</li><li>256 <a href=\"https://en.wikipedia.org/wiki/Zebibyte\">zebibytes</a> (2<sup>78</sup> bytes): maximum size of any zpool</li><li>2<sup>56</sup>: number of attributes of a file (actually constrained to 2<sup>48</sup> for the number of files in a directory)</li><li>2<sup>64</sup>: number of devices in any zpool</li><li>2<sup>64</sup>: number of zpools in a system</li><li>2<sup>64</sup>: number of file systems in a zpool</li></ul>\n<p>Feature如下&#xff1a;</p>\n<ul><li><a href=\"https://en.wikipedia.org/wiki/SHA-256\">SHA-256</a>校验</li><li>加密</li><li>虚拟存储池zpool</li><li>cache</li><li>copy-on-write</li><li>镜像备份</li><li>动态 stripe 大小</li><li>etc.</li></ul>\n<p>参见<a href=\"https://en.wikipedia.org/wiki/ZFS\">https://en.wikipedia.org/wiki/ZFS</a></p>\n<p></p>\n<p>其在硬盘上的 spec 参见<a href=\"http://maczfs.googlecode.com/files/ZFSOnDiskFormat.pdf\">ZFS On-Disk Specification – Draft</a>&#xff0c;里面有详细的架构和实现说明</p>", "created": "2016-05-11T08:38:47Z", "bucket_order": 205, "bucket_name": "Week 5/8 - 5/14", "type": "feedback", "tag_good": [], "uid": "i0c1nsm3911wc", "children": [], "tag_good_arr": [], "id": "io2m6q5tdzk16q", "updated": "2016-05-11T08:38:47Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>赖国堃 2012011372 徐捷 2012011371</p>\n<p></p>\n<p><br />ZFS是一个128位的文件系统&#xff0c;这意味着它能存储1800亿亿&#xff08;18.4 × 1018&#xff09;倍于当前64位文件系统的数据。</p>\n<p>以下是ZFS的一些理论极限&#xff1a;</p>\n<p>248—任意文件系统的快照数量&#xff08;2 × 1014&#xff09;<br />248—任何单独文件系统的文件数&#xff08;2 × 1014&#xff09;<br />16 exabytes (264 byte)—文件系统最大尺寸<br />16 exabytes (264 byte)—最大单个文件尺寸<br />16 exabytes (264 byte)—最大属性大小<br />128 Zettabytes (278 byte)—最大zpool大小<br />256—单个文件的属性数量&#xff08;受ZFS文件数量的约束&#xff0c;实际为248&#xff09;<br />256—单个目录的文件数&#xff08;受ZFS文件数量的约束&#xff0c;实际为248&#xff09;<br />264—单一zpool的设备数<br />264—系统的zpools数量<br />264—单一zpool的文件系统数量</p>\n<p>ZFS使用一种写时拷贝事务模型技术。并且在写新数据的时候&#xff0c;提供快照功能&#xff0c;作为历史版本&#xff0c;同时如果可以创建可写快照&#xff0c;称之为“克隆”。ZFS能动态条带化所有设备以最大化吞吐量。ZFS使用可变大小的块。在ZFS中&#xff0c;在一个文件中所有数据块的逻辑长度必须是相同的&#xff0c;不同文件之间的块大小可以不同。</p>", "created": "2016-05-11T08:59:26Z", "bucket_order": 205, "bucket_name": "Week 5/8 - 5/14", "type": "feedback", "tag_good": [], "uid": "i6uiksj895B", "children": [], "tag_good_arr": [], "id": "io2mxaar65e419", "updated": "2016-05-11T08:59:26Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<p>2012011333 俞寒轩</p>\n<p>2012011306 肖迪</p>\n<p></p>\n<p></p>\n<p>ZFS是第一个128位文件系统。</p>\n<p></p>\n<p><strong>文件卷结构</strong></p>\n<p>ZFS 用“存储池”的概念来管理物理存储空间。ZFS 完全抛弃了“卷管理”&#xff0c;不再创建虚拟的卷&#xff0c;而是把所有设备集中到一个存储池中来进行管。</p>\n<p></p>\n<p><strong>目录结构</strong></p>\n<p>ZFS没有卷的概念&#xff0c;其根目录和“储存池”的含义是等价的&#xff0c;即只有一个根目录&#xff0c;这个目录代表了全部的空间。目录结构仍是树形&#xff0c;与其他文件系统类似。</p>\n<p></p>\n<p><strong>文件分配方式</strong></p>\n<p>ZFS使用一种写时拷贝事务模型技术。所有文件系统中的块指针都包括256位的能在读时被重新校验的关于目标块的校验和。含有活动数据的块从来不被覆盖&#xff1b;而是分配一个新块&#xff0c;并把修改过的数据写在新块上。所有与该块相关的元数据块都被重新读、分配和重写。为了减少该过程的开销&#xff0c;多次读写更新被归纳为一个事件组&#xff0c;并且在必要的时候使用日志来同步写操作。</p>", "created": "2016-05-11T11:28:08Z", "bucket_order": 205, "bucket_name": "Week 5/8 - 5/14", "type": "feedback", "tag_good": [], "uid": "ikvcvqz0jx17m1", "children": [], "tag_good_arr": [], "id": "io2s8icwvrp2r5", "updated": "2016-05-11T11:28:08Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>潘寅旭2012010770</p>\n<p>ZFS:<br /> zfs是一个128位的文件系统&#xff0c;总容量是现有64位文件系统的1.84×10^19倍。<br />- 文件卷结构<br /> zfs基于存储池&#xff0c;不需要创建卷&#xff0c;把所有的设备集中到一个存储池中进行管理。<br />- 目录结构 <br /> zfs用存储池来管理物理存储空间&#xff0c;没有卷的概念。存储池描述存储的物理特征&#xff0c;采用树形的目录结构。<br />- 文件分配方式 <br /> ZFS使用一种写时拷贝事务模型技术。所有文件系统中的块指针都包括256位的能在读时被重新校验的关于目标块的校验和。含有活动数据的块从来不被覆盖&#xff1b;而是分配一个新块&#xff0c;并把修改过的数据写在新块上。所有与该块相关的元数据块都被重新读、分配和重写。为了减少该过程的开销&#xff0c;多次读写更新被归纳为一个事件组&#xff0c;并且在必要的时候使用日志来同步写操作。<br /> 利用写时拷贝使ZFS的快照和事物功能的实现变得更简单和自然&#xff0c;快照功能更灵活。缺点是&#xff0c;COW使碎片化问题更加严重&#xff0c;对于顺序写生成的大文件&#xff0c;如果以后随机的对其中的一部分进行了更改&#xff0c;那么这个文件在硬盘上的物理地址就变得不再连续&#xff0c;未来的顺序读会变得性能比较差。</p>", "created": "2016-05-12T07:11:07Z", "bucket_order": 205, "bucket_name": "Week 5/8 - 5/14", "type": "feedback", "tag_good": [], "uid": "i6vgn93glrq25f", "children": [], "tag_good_arr": [], "id": "io3yhtsza5c6a6", "updated": "2016-05-12T07:11:07Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>2013011297 杨青霖</p>\n<p>ZFS是一款128bit文件系统&#xff0c;总容量是现有64bit文件系统的1.84x10^19倍&#xff0c;其支持的单个存储卷容量达到16EiB&#xff08;2^64byte&#xff0c;即 16x1024x1024TB&#xff09;&#xff1b;一个zpool存储池可以拥有2^64个卷&#xff0c;总容量最大256ZiB&#xff08;2^78byte&#xff09;&#xff1b;整个系统又可以拥有2^64个存储 池。可以说在相当长的未来时间内&#xff0c;ZFS几乎不太可能出现存储空间不足的问题。另外&#xff0c;它还拥有自优化&#xff0c;自动校验数据完整性&#xff0c;存储池/卷系统易管理等诸多优点。较ext3系统有较大运行速率&#xff0c;提高大约30%-40%。</p>\n<p>ZFS是基于存储池的&#xff0c;与典型的映射物理存储设备的传统文件系统不同&#xff0c;ZFS所有在存储池中的文件系统都可以使用存储池的资源。</p>\n<div>\n<p></p>\n</div>\n<p></p>", "created": "2016-05-12T08:58:13Z", "bucket_order": 205, "bucket_name": "Week 5/8 - 5/14", "type": "feedback", "tag_good": [], "uid": "i18riqkwrl225m", "children": [], "tag_good_arr": [], "id": "io42bk8ff272sk", "updated": "2016-05-12T08:58:13Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>周恩泽 2012012617</p>\n<p>ZFS文件系统的英文名称为Zettabyte File System,也叫动态文件系统&#xff08;Dynamic File System&#xff09;,是一个128位文件系统。</p>\n<p></p>\n<p>卷结构</p>\n<p>ZFS 完全抛弃了“卷管理”&#xff0c;不再创建虚拟的卷&#xff0c;而是把所有设备集中到一个存储池中来进行管理。“存储池”描述了存储的物理特征&#xff0c;并扮演一个能够创建文件系统的专门存储空间。因此&#xff0c;文件系统不再局限于单独的物理设备&#xff0c;而且文件系统还允许物理设备把他们自带的那些文件系统共享到这个“池”中。不再需要预先规划好文件系统的大小&#xff0c;因为文件系统可以在“池”的空间内自动的增大。当增加新的存贮介质时&#xff0c;所有“池”中的所有文件系统能立即使用新增的空间&#xff0c;而不需要额外的操作。在很多情况下&#xff0c;存储池扮演了一个虚拟内存。</p>\n<p></p>\n<p>目录结构</p>\n<p>树形目录结构。</p>\n<p></p>\n<p>文件分配方式</p>\n<p>ZFS使用一种写时拷贝事务模型技术。所有文件系统中的块指针都包括256位的能在读时被重新校验的关于目标块的校验和。含有活动数据的块从来不被覆盖&#xff1b;而是分配一个新块&#xff0c;并把修改过的数据写在新块上。所有与该块相关的元数据块都被重新读、分配和重写。为了减少该过程的开销&#xff0c;多次读写更新被归纳为一个事件组&#xff0c;并且在必要的时候使用日志来同步写操作。</p>\n<p></p>", "created": "2016-05-12T11:43:36Z", "bucket_order": 205, "bucket_name": "Week 5/8 - 5/14", "type": "feedback", "tag_good": [], "uid": "ikvcvp62fcm7ka", "children": [], "tag_good_arr": [], "id": "io4888unyg75n3", "updated": "2016-05-12T11:43:36Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p><br />2012011307 黄必胜</p>\n<p>与之前的文件系统如UFS相比&#xff0c;ZFS属于概念性的突破。</p>\n<p>1. 管理简单<br /> ZFS作为一个全新的文件系统&#xff0c;全面抛弃传统File System &#43; Volume Manager &#43; Storage的架构&#xff0c;所有的存储设备是通过ZFS Pool进行管理&#xff0c;只要把各种存储设备加 入同一个ZFS Pool&#xff0c;大家就可以轻松的在这个ZFS Pool管理配置文件系统。</p>\n<p></p>\n<p>2. 极大的容量<br /> ZFS&#xff08;Zettabyte File System&#xff09;文件系统就如其名字所预示&#xff0c;可以提供真正的海量存储&#xff0c;在现实中几乎不可能遇到容量问题。</p>\n<p></p>\n<p>3. 完全保证数据的正确和完整</p>\n<p>由于ZFS所有的数据操作都是基于Transaction&#xff08;事务&#xff09;&#xff0c;一组相应的操作会被ZFS解析为一个事务操作&#xff0c;事务的操作就代表着一组操作要么一起失败&#xff0c;要么一起成功。ZFS对所有的操作是基于COW&#xff08;Copy on Write&#xff09;&#xff0c; 从而保证设备上的数据始终都是有效的&#xff0c;再也不会因为系统崩溃或者意外掉电导致数据文件的inconsistent。</p>\n<p></p>\n<p>4. 提供优异性能和扩展性<br /> ZFS支持多种大小的数据块定义&#xff0c;从512字节到1M字节。在扩展性上&#xff0c;和现有文件系统多是基于一个受限的静态模型不同&#xff0c;ZFS是采用ZFSPool这个动态概念&#xff0c;它的metadata也是动态&#xff0c;并且读写操作都是可并行的&#xff0c;并且具有优先级概念&#xff0c;所以即使在大数据量&#xff0c;多设备的情况下仍可以保证性能的线性增长。</p>\n<p></p>\n<p>5. 安全<br /> 在安全上&#xff0c;ZFS支持类似NT风格NFSv4版的ACL&#xff08;读取控制列表&#xff09;。用户可选择多种验证方式&#xff0c;包括SHA-256验证算法&#xff0c;从而在物理存储单元级别上保证数据的安全性。</p>\n<p></p>", "created": "2016-05-12T11:44:34Z", "bucket_order": 205, "bucket_name": "Week 5/8 - 5/14", "type": "feedback", "tag_good": [], "uid": "i70lz5f0QKm", "children": [], "tag_good_arr": [], "id": "io489hpd5mk3sm", "updated": "2016-05-12T11:44:34Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>krajna 2014010527</p>\n<p>ZFS zettafilesystem 是第一个128位的文件系统&#xff0c;为solaris开发</p>\n<p></p>\n<p>ZFS的理论极限</p>\n<p>2^48 — 任意文件系统的快照数量 (2 × 10^14)<br />2^48 — 任何单独文件系统的文件数 (2 × 10^14)<br />16 exabytes (2^64 byte) — 文件系统最大尺寸<br />16 exabytes (2^64 byte) — 最大单个文件尺寸<br />16 exabytes (2^64 byte) — 最大属性大小<br />3 × 10^23 petabytes (2^78 byte) — 最大zpool大小<br />2^56 — 单个文件的属性数量(受ZFS文件数量的约束&#xff0c;实际为2^48)<br />2^56 — 单个目录的文件数(受ZFS文件数量的约束&#xff0c;实际为2^48)<br />2^64 — 单一zpool的设备数<br />2^64 — 系统的zpools数量<br />2^64 — 单一zpool的文件系统数量</p>\n<p></p>\n<p>ZFS的特点&#xff1a;</p>\n<p>1.ZPOOL动态存储池。其对外提供一个虚拟的设备&#xff0c;可以动态的添加磁盘等。</p>\n<p>2.COW机制以及transaction事务操作。很好地保证了数据的一致性。</p>\n<p>3.智能预读取</p>\n<p>4.动态条带化。在不同设备上分配块&#xff0c;并且并发写入。</p>\n<p>5.Extent技术。实现了可变长度的block&#xff0c;可以优化大文件与小文件读写的优化。</p>\n<p>等等...</p>", "created": "2016-05-12T11:45:34Z", "bucket_order": 205, "bucket_name": "Week 5/8 - 5/14", "type": "feedback", "tag_good": [], "uid": "ikx8y1dzPrM", "children": [], "tag_good_arr": [], "id": "io48asb012s64y", "updated": "2016-05-12T11:45:34Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<div>\n<p><a href=\"http://maczfs.googlecode.com/files/ZFSOnDiskFormat.pdf\">ZFS On-Disk Specification – Draft</a> (ZFSOnDiskFormat.pdf, Sun Microsystems, Inc., 2006-08)</p>\n<p> </p>\n<p>ZFS的storage pool 是虚拟设备&#xff08;virtual device&#xff08;vdev&#xff09;&#xff09;集合组成。</p>\n<p>vdev有两种&#xff1a;物理vdev&#xff08;可写的设备&#xff0c;例如硬盘&#xff09;、逻辑vdev&#xff08;一组物理vdev&#xff09;。</p>\n<p>vdev组成一颗树。每个pool有个特殊vdev “root”。</p>\n<p>root有一些vdev子节点&#xff0c;下一层可能再有一层vdev。如下图。</p>\n<p><img src=\"/img/861-c13c125aadc43a45.png\" width=\"618\" height=\"396\" /></p>\n<p>每个物理vdev有个vdev label&#xff0c;256KB大小。</p>\n<p>label有描述这个物理vdev与其他vdev有共同父节点等信息。</p>\n<p>为了更可靠&#xff0c;每个vdev的label还有4份拷贝&#xff0c;设备的头尾各两个。</p>\n<p>Vdev label包含了8KB的blank space&#xff0c;8KB的boot header&#xff08;现在没有用&#xff09;&#xff0c;112KB的name与value的pairs列表(描述这个物理vdev与哪些vdev有共同父节点)&#xff0c;128KB的uberblock结构&#xff08;每个1KB大小&#xff09;。如下图。</p>\n<p> <img src=\"/img/861-5e3d5d8e3a27a830.png\" width=\"472\" height=\"166\" /></p>\n<p>uberblock有存取pool的内容的信息&#xff0c;类似UFS的superblock。</p>\n<p>还有在任何时间pool都只有一个active的uberblock。</p>\n<p>uberblock有ub_magic (等于0x00bab10c&#xff0c;表示设备有ZFS数据)、ub_version&#xff08;格式版本&#xff0c;目前是1&#xff09;、ub_txg、ub_guid_sum、ub_timestamp&#xff08;uberblock最后写入时间&#xff09;、ub_rootbp。如下图。</p>\n<p><img src=\"/img/861-1188f412e953024d.png\" width=\"581\" height=\"305\" /></p>\n<p> </p>\n<p>也预留了boot block的空间。如下图。</p>\n<p> <img src=\"/img/861-b98f826edb412905.png\" width=\"588\" height=\"177\" /></p>\n<p> </p>\n<p>除了上面的数据&#xff0c;ZFS的大部分数据叫object&#xff0c;每个object用512byte的dnode定义。</p>\n<p>dnode类似UFS的inode。</p>\n<p>Object有下面的这些类型(file, directory...)&#xff1a;</p>\n<p><img src=\"/img/861-96a400b194950887.png\" width=\"404\" height=\"857\" /></p>\n<p>dnode有以下内容。</p>\n<p> <img src=\"/img/861-d136817449244b6c.png\" width=\"532\" height=\"372\" /></p>\n<p>目录的内容在目录object里面。</p>\n<p><img src=\"/img/861-17dd61b4a032960a.png\" width=\"542\" height=\"103\" /></p>\n<p>也有个列表管理访问object的权限。</p>\n<p><img src=\"/img/861-1505e98b90419809.png\" width=\"533\" height=\"95\" /></p>\n<p> </p>\n</div>", "created": "2016-05-12T11:53:46Z", "bucket_order": 205, "bucket_name": "Week 5/8 - 5/14", "type": "feedback", "tag_good": [], "uid": "im4yagyfl3chl", "children": [], "tag_good_arr": [], "id": "io48lc2jq9zkw", "updated": "2016-05-12T11:53:46Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<p>徐涵 2013011355</p>\n<p>白家松 2013011339</p>\n<p></p>\n<p>ZFS是一个128位的文件系统&#xff0c;这意味着它能存储1800亿亿&#xff08;18.4 × 10<sup>18</sup>&#xff09;倍于当前64位文件系统的数据。</p>\n<p>关于ZFS的一些理论极限&#xff1a;</p>\n<p>ZFS的一些理论极限&#xff1a;</p>\n<ul><li>2<sup>48</sup>—任意文件系统的快照数量&#xff08;2 × 10<sup>14</sup>&#xff09;</li><li>2<sup>48</sup>—任何单独文件系统的文件数&#xff08;2 × 10<sup>14</sup>&#xff09;</li><li>16 exabytes (2<sup>64</sup> byte)—文件系统最大尺寸</li><li>16 exabytes (2<sup>64</sup> byte)—最大单个文件尺寸</li><li>16 exabytes (2<sup>64</sup> byte)—最大属性大小</li><li>128 Zettabytes (2<sup>78</sup> byte)—最大zpool大小</li><li>2<sup>56</sup>—单个文件的属性数量&#xff08;受ZFS文件数量的约束&#xff0c;实际为2<sup>48</sup>&#xff09;</li><li>2<sup>56</sup>—单个目录的文件数&#xff08;受ZFS文件数量的约束&#xff0c;实际为2<sup>48</sup>&#xff09;</li><li>2<sup>64</sup>—单一zpool的设备数</li><li>2<sup>64</sup>—系统的zpools数量</li><li>2<sup>64</sup>—单一zpool的文件系统数量</li></ul>\n<p></p>\n<p>ZFS使用一种写时拷贝事务模型技术&#xff0c;含有活动数据的块从来不被覆盖&#xff1b;而是分配一个新块&#xff0c;并把修改过的数据写在新块上。所有与该块相关的元数据块都被重新读、分配和重写。ZFS使用写时拷贝技术的一个优势在于&#xff0c;写新数据时&#xff0c;包含旧数据的块被保留着&#xff0c;提供了一个可以被保留的文件系统的快照版本。由于ZFS在读写操作中已经存储了所有构建快照的数据&#xff0c;所以快照的创建非常快。</p>\n<p>ZFS使用可变大小的块&#xff0c;最大可至128KB。在ZFS中&#xff0c;在一个文件中所有数据块的逻辑长度必须是相同的&#xff0c;不同文件之间的块大小可以不同&#xff0c;因此ZFS可以用直接映射&#xff08;direct map&#xff09;的方式&#xff08;同ufs/ffs/ext2/ext3&#xff09;来来搜索间接块的数据指针数组&#xff08;blkptr&#xff09;。</p>\n<p></p>\n<p></p>", "created": "2016-05-12T12:11:48Z", "bucket_order": 205, "bucket_name": "Week 5/8 - 5/14", "type": "feedback", "tag_good": [], "uid": "i0f7v0qgfm61s6", "children": [], "tag_good_arr": [], "id": "io498iap10j3cu", "updated": "2016-05-12T12:11:48Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "io2bwkz0t681e4", "updated": "2016-05-11T03:50:58Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/09-1-spoc-discussion.md#小组思考题\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/09-1-spoc-discussion.md#小组思考题</a></p>\n<p></p>\n<p>选择做“3&#xff09;小组思考题(2-YAFFS)”的同学的回答结果写在此贴后面。</p>", "created": "2016-05-11T03:51:08Z", "bucket_order": 205, "bucket_name": "Week 5/8 - 5/14", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<p>谢琛睿 2013011406 杨明 2013011412</p>\n<ul><li><strong>YAFFS介绍与分析</strong></li></ul>\n<ol><li style=\"text-align:left\">YAFFS是一个specified的文件系统&#xff0c;针对的存储介质为NandFlash&#xff0c;针对其做了性能优化&#xff0c;提高performance并延长NandFlash的寿命&#xff0c;目前有YAFFS1和YAFFS2两个版本。</li><li style=\"text-align:left\">YAFFS将NandFlash划分为许多block&#xff0c;block又可以继续划分为chunks&#xff0c;擦除&#xff08;erase&#xff09;是以block为单位的&#xff0c;而后者是读写的最小单位。</li><li style=\"text-align:left\">YAFFS1与YAFFS2的区别在于&#xff0c;后者是真正的LFS&#xff08;<strong>日志结构文件系统</strong>&#xff09;&#xff0c;对大容量的data支更好。所谓LFS&#xff0c;是指这样一种文件系统&#xff0c;它可以将多次写地址随机的write操作&#xff0c;转换为少量的写地址连续&#xff08;sequential&#xff09;的write操作&#xff0c;这样&#xff0c;<strong>写数据时就像记录日志一样&#xff0c;不断添加到最后面而不会改动前面的数据</strong>。这与<strong>NandFlash的写特性</strong>有关&#xff0c;详见下面的分析。</li><li style=\"text-align:left\">NandFlash这种闪存介质&#xff0c;体积小、存储密度高、功耗低&#xff0c;在智能移动设备的开发中备受青睐&#xff0c;2010年前增是android官方的storage用材&#xff0c;今天也很活跃。</li><li style=\"text-align:left\">但是它毕竟是闪存&#xff0c;过多次读写操作会令损耗(wear)&#xff0c;而且数据只允许被写入擦除的区域&#xff0c;如果区域<strong>没被erase&#xff0c;是不可写的</strong>。&#xff08;这使得对NandFlash的写操作&#xff0c;在实现上<strong>非常类似我们学过的Copy-on-Write机制</strong>&#xff0c;即<strong>先读到memory&#xff0c;修改后存到另外一个storage区域</strong>&#xff09;。而YAFFS将NandFlash的所有chunk都进行了编号(写的基本单位也是这些chunk)&#xff0c;其所采用的LFS存储结构使得写入的数据地址都是按照chunk编号的升序进行的。这令系统能够对Flash中的数据先读入memory&#xff0c;修改后再写回到Flash时&#xff0c;不是原来取数据的地址&#xff08;这个chunk尚没有erase所以不能写&#xff09;&#xff0c;而是写入到free chunk中编号最小&#xff08;但比所有存储数据的chunk的编号都大&#xff0c;即使所有用过的chunk的上界&#xff09;的chunk里。之前存储原始数据的chunk就变为“废弃”(obsolete)chunk&#xff0c;等待回收(clean)。这样不仅利用了Flash写特性&#xff0c;使得其写入效率更快&#xff08;集中clean&#xff0c;而不是每次写都要erase包含原chunk的block&#xff09;&#xff0c;并且充分利用了整个storage空间&#xff0c;避免部分flash频繁使用。</li></ol>\n<ul><li><strong>再论YAFFS的LFS</strong></li></ul>\n<p>          其想法非常简单&#xff0c;就是使得随机的写访问&#xff0c;转换成顺序的写操作。想法简单&#xff0c;但是要真正搞懂这个思路&#xff0c;需要仔细研究其细节&#xff0c;仅靠在这里介绍是不够的&#xff0c;有兴趣的同学可以参阅reference。</p>\n<p style=\"text-align:center\"><img src=\"/img/861-87a7a6e1358e386a.png\" alt=\"Screen shot 2012-03-18 at 9.02.45 AM\" /></p>\n<p style=\"text-align:center\">注&#xff1a;下面那个log箭头就是storage扩张的方向&#xff0c;按chunk编号的升序扩张&#xff0c;但是伴随着<strong>删除</strong>操作以及<strong>对flash的写</strong>&#xff0c;会产生碎片&#xff0c;所以LFS需要设计有相应的clean机制</p>\n<ul><li><strong>NandFlash</strong></li></ul>\n<p style=\"text-align:center\"><img src=\"/img/861-34cd0b88d6d6614f.png\" alt=\"nand2.png\" /></p>\n<p style=\"text-align:center\">     注&#xff1a;其中的Page就是Chunk</p>\n<ul><li><strong>reference</strong><strong></strong></li></ul>\n<ol><li style=\"text-align:left\"><strong><a href=\"http://subs.emis.de/LNI/Proceedings/Proceedings195/59.pdf\" target=\"_blank\">Forensic Analysis of YAFFS2</a></strong></li><li style=\"text-align:left\"><strong><a href=\"http://pages.cs.wisc.edu/~remzi/OSTEP/file-lfs.pdf\" target=\"_blank\">Log-structured File Systems</a></strong></li></ol>", "created": "2016-05-11T08:38:50Z", "bucket_order": 205, "bucket_name": "Week 5/8 - 5/14", "type": "feedback", "tag_good": [], "uid": "i0brpl1lbyui6", "children": [], "tag_good_arr": [], "id": "io2m6siytaha5", "updated": "2016-05-11T08:38:50Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<p>乔奕 2013011324</p>\n<p>贺子松 2013011296</p>\n<p>YAFFS&#xff08;Yet Another Flash File System&#xff09;是第一个在GPL协议下发布的、基于日志的、专门为NAND Flash存储器设计的、适用于大容量的存储设备的嵌入式文件系统。</p>\n<p>存储</p>\n<p>以数据块进行存储&#xff0c;块大小为512字节&#xff0c;包含16字节的数据块头&#xff08;放在Flash的备用空间中&#xff09;。文件的数据段为树型结构&#xff0c;每个节点32字节&#xff0c;每个内部节点包括8个指向其他节点的指针&#xff0c;叶节点包括16个指向物理地址的指针。时间复杂度为O(log n)</p>\n<p>写入</p>\n<p>YAFFS在文件进行改写时总是先写入新的数据块&#xff0c;然后将旧的数据块从文件中删除。这样即使在修改文件时意外掉电&#xff0c;丢失的也只是这一次修改数据的最小写入单位&#xff0c;从而实现了掉电保护&#xff0c;保证了数据完整性。</p>\n<p>性能</p>\n<p>结合贪心算法的高效性和随机选择的平均性&#xff0c;YAFFS实现了兼顾损耗平均和减小系统开销的目的。当满足特定的小概率条件时&#xff0c;就会尝试随机选择一个可回收的页面&#xff1b;而在其他情况下&#xff0c;则使用贪心算法来回收最“脏”的块</p>", "created": "2016-05-11T08:59:52Z", "bucket_order": 205, "bucket_name": "Week 5/8 - 5/14", "type": "feedback", "tag_good": [], "uid": "i3qk2vs65x276j", "children": [], "tag_good_arr": [], "id": "io2mxujuans7et", "updated": "2016-05-11T08:59:52Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>2013011376 龚拓宇</p>\n<p>2013011379 姚炫容</p>\n<p>  YAFFS对文件系统上的所有内容&#xff08;比如正常文件&#xff0c;目录&#xff0c;链接&#xff0c;设备文件等等&#xff09;都统一当作文件来处理&#xff0c;每个文件都有一个页面专门存放文件头&#xff0c;文件头保存了文件的模式、所有者ID、组ID、长度、文件名、Parent Object ID等信息。因为需要在一页内放下这些内容&#xff0c;所以对文件名的长度&#xff0c;符号链接对象的路径名等长度都有限制。</p>\n<p> </p>\n<p>     YAFFS充分利用了NandFlash的“备用区”空间&#xff0c;这个备用空间是指每个页的16自己的Spare区&#xff0c;通常不作为存储数据的空间。YAFFS用了其中的6个字节作为页面数据的ECC&#xff0c;1个字节用作坏块状态标志字&#xff0c;1个字节用作数据状态标志字&#xff0c;其余的8个字节用来存放文件系统的组织信息</p>", "created": "2016-05-11T10:44:07Z", "bucket_order": 205, "bucket_name": "Week 5/8 - 5/14", "type": "feedback", "tag_good": [], "uid": "i0eqqq6jvng408", "children": [], "tag_good_arr": [], "id": "io2qnwva5gx1rr", "updated": "2016-05-11T10:44:07Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>YAFFS(Yet Another Flash File System)是第一个在GPL协议下发布的、基于日志的、专门为NAND Flash存储器设计的、适用于大容量的存储设备的嵌入式文件系统。</p>\n<ol><li>文件是以固定大小的数据块进行存储&#xff0c;数据块头和每个数据块关联起来&#xff1b;</li><li>YAFFS利用NAND读写特点提高了读写效率&#xff1b;</li><li>YAFFS主要利用了NAND中脏页保存在特定位置的特点&#xff1b;</li><li>YAFFS文件数据段被组织成树形结构&#xff1b;</li></ol>\n<p>2012080059 jinjiayu</p>\n<p>2012011321 zhangye</p>\n<p></p>", "created": "2016-05-12T01:15:55Z", "bucket_order": 205, "bucket_name": "Week 5/8 - 5/14", "type": "feedback", "tag_good": [], "uid": "i6ub5at2geM", "children": [], "tag_good_arr": [], "id": "io3lt1fs94g1ex", "updated": "2016-05-12T01:15:55Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<p></p>\n<p>Yaffs&#xff08;Yet Another Flash File System&#xff09;文件系统是专门针对NAND闪存设计的嵌入式文件系统&#xff0c;目前有YAFFS和YAFFS2两个版本&#xff0c;两个版本的主要区别之一在于YAFFS2能够更好的支持大容量的NAND FLASH芯片&#xff08;相比于NOR&#xff0c;NAND容量可达1GB以上&#xff0c;价格也相对便宜&#xff0c;适合存储数据&#xff09;。</p>\n<p>1、Yaffs对文件系统上的所有内容&#xff08;比如正常文件&#xff0c;目录&#xff0c;链接&#xff0c;设备文件等等&#xff09;都统一当作文件来处理&#xff0c;每个文件都有一个页面专门存放文件头&#xff0c;文件头保存了文件的模式、所有者id、组id、长度、文件名、Parent Object ID等信息。</p>\n<p>以512&#43;16B为一个page的NAND FLASH为例&#xff0c;page的组织结构为</p>\n<table cellspacing=\"0\" cellpadding=\"0\" border=\"1\"><tbody><tr><td width=\"96\">\n<div>0..511</div>\n</td><td width=\"302\">data aera</td></tr><tr><td width=\"96\">\n<div>512..515</div>\n</td><td width=\"302\">YAFFS TAG</td></tr><tr><td width=\"96\">\n<div>516</div>\n</td><td width=\"302\">Data status byte</td></tr><tr><td width=\"96\">\n<div>517</div>\n</td><td width=\"302\">Block status byte </td></tr><tr><td width=\"96\">\n<div>518..519</div>\n</td><td width=\"302\">YAFFS TAG</td></tr><tr><td width=\"96\">\n<div>520..522</div>\n</td><td width=\"302\">check bits of the later 256bits</td></tr><tr><td width=\"96\">\n<div>523..524</div>\n</td><td width=\"302\">YAFFS TAG</td></tr><tr><td width=\"96\">\n<div>525..527</div>\n</td><td width=\"302\">check bits of the first 256bits</td></tr></tbody></table>\n<p></p>\n<p>2、这里YAFFS文件系统共使用了8个字节&#xff08;64Bit&#xff09;用来存放文件系统相关的信息</p>\n<p></p>\n<table cellspacing=\"0\" cellpadding=\"0\" border=\"1\"><tbody><tr><td width=\"144\">\n<div>Bits</div>\n</td><td width=\"360\">Content</td></tr><tr><td width=\"144\">\n<div>20</div>\n</td><td width=\"360\">ChunkID</td></tr><tr><td width=\"144\">\n<div>2</div>\n</td><td width=\"360\">2 bits serial number</td></tr><tr><td width=\"144\">\n<div>10</div>\n</td><td width=\"360\">ByteCount</td></tr><tr><td width=\"144\">\n<div>18</div>\n</td><td width=\"360\">ObjectID</td></tr><tr><td width=\"144\">\n<div>12</div>\n</td><td width=\"360\">Ecc-check-sum</td></tr><tr><td width=\"144\">\n<div>2</div>\n</td><td width=\"360\">Unused</td></tr></tbody></table>\n<p></p>\n<p>3、Yaffs在更新一个PAGE的时候总是在一个新的物理Page上写入数据&#xff0c;再将原先的物理Page删除&#xff0c;所以该serial number可以在断电等特殊情况下&#xff0c;当新的page已经写入但老的page还没有被删除的时候用来识别正确的Page&#xff0c;保证数据的正确性。</p>\n<p></p>\n<p>4、</p>\n<p>YAFFS文件系统的专有数据是yaffs_DeviceStruct的数据结构&#xff0c;主要用来存储软硬件配置信息&#xff0c;相关函数指针和统计信息等。</p>\n<p>YAFFS文件系统的SuperBlock块是在文件系统mount加载的过程中由read_super()函数填充的&#xff0c;由于物理上没有存储SuperBlock块&#xff0c;所以NandFlash上的YAFFS文件系统本身没有存储文件系统的魔术数&#xff0c;也是在文件系统加载的过程中直接赋值的。</p>", "created": "2016-05-12T04:12:57Z", "bucket_order": 205, "bucket_name": "Week 5/8 - 5/14", "type": "feedback", "tag_good": [], "uid": "ikvcvr0o2bs7m3", "children": [], "tag_good_arr": [], "id": "io3s4ph9nm925x", "updated": "2016-05-12T04:12:57Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>金贤林 2012080056</p>\n<p>YAFFS是第一个在GPL协议下发布的、基于日志的、专门为NAND Flash存储器设计的、适用于大容量的存储设备的嵌入式文件系统。</p>\n<p>YAFFS中&#xff0c;文件是以固定大小的数据块进行存储的&#xff0c;块的大小可以是512字节、1 024字节或者2 048字节。这种实现依赖于它能够将一个数据块头和每个数据块关联起来。每个文件&#xff08;包括目录&#xff09;都有一个数据块头与之相对应&#xff0c;数据块头中保存了ECC(Error Correction Code)和文件系统的组织信息&#xff0c;用于错误检测和坏块处理。充分考虑了NAND Flash的特点&#xff0c;YAFFS把这个数据块头存储在Flash的16字节备用空间中。当文件系统被挂载时&#xff0c;只须扫描存储器的备用空间就能将文件系统信息读入内存&#xff0c;并且驻留在内存中&#xff0c;不仅加快了文件系统的加载速度&#xff0c;也提高了文件的访问速度&#xff0c;但是增加了内存的消耗。</p>", "created": "2016-05-12T04:52:46Z", "bucket_order": 205, "bucket_name": "Week 5/8 - 5/14", "type": "feedback", "tag_good": [], "uid": "i6uaz437IKR", "children": [], "tag_good_arr": [], "id": "io3tjwxcvs460q", "updated": "2016-05-12T04:52:46Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "张殿炎 2013011328\n叶方轲 2013011340\n<ol><li>YAFFS中&#xff0c;文件是以固定大小的数据块进行存储的&#xff0c;块的大小可以是512字节、1 024字节或者2 048字节。这种实现依赖于它能够将一个数据块头和每个数据块关联起来。每个文件&#xff08;包括目录&#xff09;都有一个数据块头与之相对应&#xff0c;数据块头中保存了ECC(Error Correction Code)和文件系统的组织信息&#xff0c;用于错误检测和坏块处理。充分考虑了NAND Flash的特点&#xff0c;YAFFS把这个数据块头存储在Flash的16字节备用空间中。当文件系统被挂载时&#xff0c;只须扫描存储器的备用空间就能将文件系统信息读入内存&#xff0c;并且驻留在内存中&#xff0c;不仅加快了文件系统的加载速度&#xff0c;也提高了文件的访问速度&#xff0c;但是增加了内存的消耗。</li><li>为了在节省内存的同时提高文件数据块的查找速度&#xff0c;YAFFS利用更高效的映射结构把文件位置映射到物理位置。文件的数据段被组织成树型结构&#xff0c;这个树型结构具有32字节的节点&#xff0c;每个内部节点都包括8个指向其他节点的指针&#xff0c;叶节点包括16个2字节的指向物理地址的指针。YAFFS在文件进行改写时总是先写入新的数据块&#xff0c;然后将旧的数据块从文件中删除。这样即使在修改文件时意外掉电&#xff0c;丢失的也只是这一次修改数据的最小写入单位&#xff0c;从而实现了掉电保护&#xff0c;保证了数据完整性。</li></ol>", "created": "2016-05-12T10:22:22Z", "bucket_order": 205, "bucket_name": "Week 5/8 - 5/14", "type": "feedback", "tag_good": [], "uid": "i28skba6cd976f", "children": [], "tag_good_arr": [], "id": "io45bseeo1d3ik", "updated": "2016-05-12T10:22:22Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>何乐 2013011351 郭栋2013011334</p>\n<p>YAFFS是第一个在GPL协议下发布的、基于日志的、专门为NAND Flash存储器设计的、适用于大容量的存储设备的嵌入式文件系统。</p>\n<p>YAFFS文件系统中文件以固定大小的数据块为单位进行存储&#xff0c;块大小可以是512、1024或2048字节。而每个数据块与一个数据块头相关联。</p>\n<p>YAFFS充分考虑了NAND Flash的特点&#xff0c;YAFFS把这个数据块头存储在Flash的16字节备用空间中。</p>\n<p>YAFFS在文件进行改写时总是先写入新的数据块&#xff0c;然后将旧的数据块从文件中删除。这样即使在修改文件时意外掉电&#xff0c;丢失的也只是这一次修改数据的最小写入单位&#xff0c;从而实现了掉电保护&#xff0c;保证了数据完整性。</p>\n<p>在数据块回收方面YAFFS结合了贪心算法的高效性和随机的平均性&#xff0c;实现了对损耗平均和减小系统开销的兼顾。</p>", "created": "2016-05-12T10:25:46Z", "bucket_order": 205, "bucket_name": "Week 5/8 - 5/14", "type": "feedback", "tag_good": [], "uid": "i0ccqbaxwdz75c", "children": [], "tag_good_arr": [], "id": "io45g5yse3p30i", "updated": "2016-05-12T10:25:46Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>2013011310 余翔</p>\n<p>2013011308 林婕茵</p>\n<p>Yaffs&#xff08;Yet Another Flash File System&#xff09;文件系统是专门针对NAND闪存设计的嵌入式文件系统&#xff0c;目前有YAFFS和YAFFS2两个版本&#xff0c;两个版本的主要区别之一在于YAFFS2能够更好的支持大容量的NAND FLASH芯片。<br /> Yaffs对文件系统上的所有内容&#xff08;比如正常文件&#xff0c;目录&#xff0c;链接&#xff0c;设备文件等等&#xff09;都统一当作文件来处理&#xff0c;每个文件都有一个页面专门存放文件头&#xff0c;文件头保存了文件的模式、所有者id、组id、长度、文件名、Parent Object ID等信息。因为需要在一页内放下这些内容&#xff0c;所以对文件名的长度&#xff0c;符号链接对象的路径名等长度都有限制。</p>\n<p></p>", "created": "2016-05-12T17:48:57Z", "bucket_order": 205, "bucket_name": "Week 5/8 - 5/14", "type": "feedback", "tag_good": [], "uid": "i11v1az5sf83l2", "children": [], "tag_good_arr": [], "id": "io4la39nmj33s4", "updated": "2016-05-12T17:48:57Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>2012080060 甄显安  2012011308 陆喆</p>\n<ul><li>Yaffs是基于FLASH的文件系统\n<ul><li>Flash的写入操作只能把对应位置的1修改为0&#xff0c;而不能把0修改为1(擦除Flash就是把对应存储块的内容恢复为1)&#xff0c;因此&#xff0c;一般情况下&#xff0c;向Flash写入内容时&#xff0c;需要先擦除对应的存储区间&#xff0c;这种擦除是<strong>以块(block)为单位</strong>进行的。</li><li>闪存主要有NOR和NAND两种技术。Flash存储器的擦写次数是有限的&#xff0c;<strong>NAND闪存</strong>还有特殊的硬件接口和读写时序。因此&#xff0c;必须针对Flash的硬件特性设计符合应用要求的文件系统。</li><li>在嵌入式Linux下&#xff0c;MTD(Memory Technology Device&#xff0c;存储技术设备)为底层硬件(闪存)和上层(文件系统)之间提供一个统一的抽象接口。使用<strong>MTD驱动程序</strong>的主要优点在于&#xff0c;它是专门针对各种非易失性存储器(以闪存为主)而设计的&#xff0c;因而它对Flash有更好的支持、管理和基于扇区的擦除、读/写操作接口。</li><li>一块Flash芯片可以被划分为多个分区&#xff0c;各分区可以采用不同的文件系统&#xff1b;两块Flash芯片也可以合并为一个分区使用&#xff0c;采用一个文件系统。即<strong>文件系统是针对于存储器分区而言的&#xff0c;而非存储芯片</strong>。</li></ul>\n</li><li>特点\n<ul><li>yaffs/yaffs2是专为嵌入式系统使用<strong>NAND FLASH</strong>而设计的一种日志型文件系统。类似于JFFS/JFFS2文件系统&#xff0c;与之不同的是JFFS1/2文件系统最初是针对<strong>NOR FLASH</strong>的应用场合设计的&#xff0c;而NAND闪存芯片因为共用地址和数据总线的原因&#xff0c;不允许对一个字节甚至一个块进行的数据清空&#xff0c;只能对一个固定大小的区域进行清零操作&#xff1b;而NOR芯片可以对字进行操作&#xff0c;所以在处理小数据量的I/O操作的时候的速度要快于NAND的速度。</li><li>与<strong>JFFS2</strong>相比&#xff0c;它减少了一些功能(例如不支持数据压缩)&#xff0c;所以速度更快&#xff0c;挂载时间很短&#xff0c;对内存的占用较小。</li><li>另外&#xff0c;它还是<strong>跨平台</strong>的文件系统&#xff0c;除了Linux和eCos&#xff0c;还支持WinCE&#xff0c;pSOS和ThreadX等。</li><li>yaffs/yaffs2<strong>自带NAND芯片的驱动</strong>&#xff0c;并且为嵌入式系统<strong>提供了直接访问文件系统的API</strong>&#xff0c;用户可以不使用Linux中的MTD与VFS&#xff0c;直接对文件系统操作。当然&#xff0c;yaffs也可与MTD驱动程序配合使用。</li></ul>\n</li><li>文件系统在磁盘上的数据组织方式\n<ul><li>Yaffs<strong>对文件系统上的所有内容&#xff08;比如正常文件&#xff0c;目录&#xff0c;链接&#xff0c;设备文件等等&#xff09;都统一当作文件来处理</strong>&#xff0c;每个文件都有一个页面专门存放文件头&#xff0c;文件头保存了文件的模式、所有者id、组id、长度、文件名、Parent Object ID等信息。因为需要在一页内放下这些内容&#xff0c;所以对文件名的长度&#xff0c;符号链接对象的路径名等长度都有限制。前面说到对于NAND FLASH上的每一页数据&#xff0c;都有额外的空间用来存储附加信息&#xff0c;通常NAND驱动只使用了这些空间的一部分&#xff0c;Yaffs正是利用了这部分空间中剩余的部分来存储文件系统相关的内容。</li><li>Yaffs文件系统本身在NAND Flash上并<strong>不存在所谓的SuperBlock块</strong>&#xff0c;完全是在文件系统mount的过程中由read_super函数填充的。</li><li>通常一个具体的文件系统在VFS的Super_block结构中除了通用的数据外&#xff0c;还有自己专用的数据。Yaffs文件系统的<strong>专用数据是一个yaffs_DeviceStruct结构</strong>&#xff0c;主要用来存储一些相关软硬件配置信息&#xff0c;相关函数指针和统计信息等。</li><li>在mount过程执行read_super的过程中&#xff0c;<strong>Yaffs文件系统还需要将文件系统的目录结构在内存中建立起来</strong>。由于没有super块&#xff0c;所以需要扫描Yaffs分区&#xff0c;根据从OOB中读取出的yaffs_tags信息判断出是文件头page还是数据page。再根据文件头page中的内容以及数据page中的ObjectID/ChunkID/serial Number等信息在内存中为每个文件&#xff08;Object&#xff09;建立一个对应的yaffs_object对象。\n<ul><li>在<strong>yaffs_object结构</strong>中&#xff0c;主要包含了&#xff1a;\n<ul><li>如修改时间&#xff0c;用户ID&#xff0c;组ID等文件属性&#xff1b;</li><li>用作yaffs文件系统维护用的各种标记位如脏&#xff08;dirty&#xff09;标记&#xff0c;删除标记等等&#xff1b;</li><li>用作组织结构的&#xff0c;如指向父目录的Parent指针&#xff0c;指向同级目录中其他对象链表的siblings双向链表头结构</li></ul>\n</li><li>此外根据Object类型的不同&#xff08;目录&#xff0c;文件&#xff0c;链接&#xff09;&#xff0c;对应于某一具体类型的Object&#xff0c;在Yaffs_object中还有其各自专有的数据内容\n<ul><li>普通文件&#xff1a;文件尺寸&#xff0c;用于快速查找文件数据块的yaffs_Tnode 树的指针等</li><li>目录&#xff1a;目录项内容双向链表头&#xff08;children&#xff09;</li><li>链接&#xff1a;softlink的alias&#xff0c;hardlink对应的ObjectID除了对应于存储在NAND FLASH上的object而建立起来的yaffs_object以外&#xff0c;在read_super执行过程中还会建立一些虚拟对象&#xff08;Fake Object&#xff09;&#xff0c;这些Fake Object在NAND FLASH上没有对应的物理实体&#xff0c;比如在建立文件目录结构的最初&#xff0c;yaffs会建立四个虚拟目录&#xff08;Fake Directory&#xff09;&#xff1a;rootDir, unlinkedDir, deleteDir, lostNfoundDir分别用作根目录&#xff0c;unlinked对象挂接的目录&#xff0c;delete对象挂接的目录&#xff0c;无效或零时数据块挂接的目录。通过创建这些yaffs_object&#xff0c;yaffs文件系统就能够将存储在NAND FLASH上数据系统的组织起来&#xff0c;在内存中维护一个完整的文件系统结构。</li></ul>\n</li></ul>\n</li></ul>\n</li><li>它的变种&#xff1a;Yaffs/Yaffs2\n<ul><li>yaffs与yaffs2的主要区别在于&#xff0c;前者仅支持小页(512 Bytes)NAND闪存&#xff0c;后者则可支持大页(2KB)NAND闪存。同时&#xff0c;yaffs2在内存空间占用、垃圾回收速度、读/写速度等方面均有大幅提升。</li></ul>\n</li></ul>", "created": "2016-05-18T07:34:28Z", "bucket_order": 204, "bucket_name": "Week 5/15 - 5/21", "type": "feedback", "tag_good": [], "uid": "ikvcvnzpzq7j7", "children": [], "tag_good_arr": [], "id": "iocjyywfyzm2la", "updated": "2016-05-18T07:34:28Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<p>王苏 2013011301</p>\n<p>王哲 2013012443</p>\n<p></p>\n<p><a href=\"https://github.com/wangsu13/OS/blob/master/21.md\" target=\"_blank\">report</a></p>", "created": "2016-05-22T09:32:42Z", "bucket_order": 204, "bucket_name": "Week 5/15 - 5/21", "type": "feedback", "tag_good": [], "uid": "i0hjdkesg9c5z7", "children": [], "tag_good_arr": [], "id": "ioidyfkp55y2pj", "updated": "2016-05-22T09:32:42Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "io2bwt2l7251fy", "updated": "2016-05-11T03:51:08Z", "config": {}}], "tag_good_arr": [], "id": "io2biyes9aa7hy", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 30, "num_favorites": 0, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643168640513, "default_anonymity": "no"}, "error": null, "aid": "kyv06lfluuw7gk"}