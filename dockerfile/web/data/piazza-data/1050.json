{"result": {"folders": ["lab5"], "nr": 1050, "data": {"embed_links": []}, "created": "2017-04-16T01:59:12Z", "bucket_order": 3, "no_answer_followup": 1, "change_log": [{"anon": "no", "uid": "ie7xy1yxmql1n8", "data": "j1k1mhhwiwm7e4", "type": "create", "when": "2017-04-16T01:59:12Z"}, {"anon": "no", "uid": "ie7xy5cvsc61qg", "to": "j1k1mhhtgoc7e3", "type": "followup", "when": "2017-04-18T00:59:18Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "ie7xy1yxmql1n8", "subject": "[lab5]关于创建的第一个用户进程如何运行hello.c程序的一点分析", "created": "2017-04-16T01:59:12Z", "content": "<p>1.生成的第一个用户进程&#xff0c;要运行程序代码&#xff0c;则也是编译出来的&#xff0c;那这个用户程序怎么编译&#xff0c;这个编译的命令在哪&#xff1f;<br /> 答&#xff1a;把Makefile的第七行注释掉后&#xff0c;查看输出的信息&#xff0c;可以找到&#xff1a;<br /> &#43; cc user/hello.c<br /> cc -Iuser/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector <br /> -Ilibs/ -Iuser/include/ -Iuser/libs/ -c user/hello.c -o obj/user/hello.o<br /> ld -m elf_i386 -nostdlib -T tools/user.ld -o obj/__user_hello.out <br /> obj/user/libs/initcode.o obj/user/libs/panic.o obj/user/libs/stdio.o <br /> obj/user/libs/syscall.o obj/user/libs/ulib.o obj/user/libs/umain.o <br /> obj/libs/hash.o obj/libs/printfmt.o obj/libs/rand.o obj/libs/string.o obj/user/hello.o<br /> 可见hello应用程序不仅是hello.c&#xff0c;还包括了支持hello应用程序的用户态库</p>\n<p></p>\n<p>2.编译过程中是什么命令把用户程序的可执行文件和内核的可执行代码连在一起&#xff1f;<br /> 答&#xff1a;还是查看Makefile的输出信息可以找到&#xff1a;<br /> ld -m elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel <br /> obj/kern/init/entry.o obj/kern/init/init.o ... -b binary ... obj/__user_hello.out ...<br /> 可见是这个ld命令&#xff0c;把hello应用程序的执行码obj/__user_hello.out连在了ucore kernel的结尾</p>\n<p></p>\n<p>3.连在一起以后&#xff0c;是怎么把连好的可执行代码从内核搬到用户进程里的&#xff1f;<br /> 答&#xff1a;在本实验中第一个用户进程是由第二个内核线程initproc通过把hello应用程序执行码覆盖到initproc的<br /> 用户虚拟内存空间来创建的&#xff0c;initproc的执行主体是它的init_main函数&#xff0c;这个函数在缺省情况下执行宏<br /> KERNEL_EXECVE(hello)&#xff0c;而这个宏最终是调用kernel_execve函数来调用SYS_exec系统调用&#xff1a;<br /> vector128(vectors.S)--\\&gt; \\_\\_alltraps(trapentry.S)--\\&gt;trap(trap.c)--\\&gt;trap\\_dispatch(trap.c)<br /> ---\\&gt;syscall(syscall.c)--\\&gt;sys\\_exec&#xff08;syscall.c&#xff09;--\\&gt;do\\_execve(proc.c)<br /> 最终是通过do_execve加载应用程序执行码到当前进程的新创建的用户态虚拟空间中。这里涉及到读ELF格式的文件&#xff0c;<br /> 申请内存空间&#xff0c;建立用户态虚存空间&#xff0c;加载应用程序执行码等。 load_icode函数完成了整个复杂的工作。</p>"}], "type": "note", "tags": ["lab5", "student"], "tag_good": [{"role": "instructor", "name": "Yong XIANG", "endorser": {}, "admin": true, "photo": null, "id": "hdjonbiyfs62ie", "photo_url": null, "us": false, "class_sections": ["课程设计_i5j09fnsl7k5x0", "清华学生_i5j09fnsl7k5x0", "所有老师和助教_i5j09fnsl7k5x0", "os2018spring_i5j09fnsl7k5x0"], "facebook_id": null}, {"role": "student", "name": "王纪开", "endorser": {}, "admin": false, "photo": null, "id": "k6t2yt49jyo348", "photo_url": null, "us": false, "facebook_id": null}], "unique_views": 134, "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>关于“这个函数在缺省情况下执行宏KERNEL_EXECVE(hello)”&#xff0c;我没有找到这个信息&#xff0c;请问是在哪里指定的呢&#xff1f;</p>", "created": "2017-04-18T00:59:18Z", "bucket_order": 166, "bucket_name": "Week 4/16 - 4/22", "type": "followup", "tag_good": [{"role": "student", "name": "Butter", "endorser": {}, "admin": false, "photo": null, "id": "k2b9m8mihv5t5", "photo_url": null, "published": true, "us": false, "facebook_id": null}], "uid": "ie7xy5cvsc61qg", "children": [], "tag_good_arr": ["k2b9m8mihv5t5"], "no_answer": 1, "id": "j1mud5epn5r5bp", "updated": "2017-04-18T00:59:18Z", "config": {}}], "tag_good_arr": ["hdjonbiyfs62ie", "k6t2yt49jyo348"], "id": "j1k1mhhtgoc7e3", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 3, "num_favorites": 2, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169035484, "default_anonymity": "no"}, "error": null, "aid": "kyv0f270ppr5gr"}