{"result": {"history_size": 1, "folders": ["lab5"], "nr": 1526, "data": {"embed_links": []}, "created": "2021-05-14T06:10:46Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "kker3fspnhl7go", "data": "konx9eta45f2k7", "v": "all", "type": "create", "when": "2021-05-14T06:10:46Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "kker3fspnhl7go", "subject": "slob_free不会释放整页page", "created": "2021-05-14T06:10:46Z", "content": "<p><strong>1.问题描述</strong><br />我在做lab5的时候&#xff0c;发现当slob_free释放的碎片内存可以拼出一个完整的page时&#xff0c;这个page并不会被释放掉。如果多次调用kmalloc()申请大碎片内存&#xff08;比如kmalloc(4000)&#xff09;时&#xff0c;<br />当这些碎片被kfree后&#xff0c;空闲page并不会增加&#xff0c;这样势必会造成内存泄露。<br />以下代码可以确认这个问题&#xff1a;</p>\n<p>    size_t nr_free_pages_store = nr_free_pages();<br />    cprintf (&#34;nr_free_pages_store =%d\\n&#34;, nr_free_pages_store);</p>\n<p>    int i;<br />    for (i = 1; i &lt; 33; i &#43;&#43;)<br />    {<br />     void * m = kmalloc (500*i);<br />     cprintf (&#34;after kmalloc(%d),free page=%d\\n&#34;, 500*i, nr_free_pages());<br />     kfree (m);<br />     cprintf (&#34;after kfree(%d),free page=%d\\n&#34;, 500*i, nr_free_pages());<br />    }</p>\n<p>输出的log是&#xff1a;<br />nr_free_pages_store =31860<br />...<br />after kmalloc(3000),free page=31860<br />after kfree(3000),free page=31860<br />after kmalloc(3500),free page=31860<br />after kfree(3500),free page=31860<br />after kmalloc(4000),free page=31859<br />after kfree(4000),free page=31859<br />after kmalloc(4500),free page=31857<br />after kfree(4500),free page=31859<br />after kmalloc(5000),free page=31857<br />after kfree(5000),free page=31859<br />after kmalloc(5500),free page=31857<br />...<br />初始时&#xff0c;free pages是31860&#xff0c;kmalloc(3000),free page依然是31860&#xff0c;这是因为slob还有碎片可以分配&#xff0c;所以没有申请新的page。<br />kfree(4000),free page=31859&#xff0c;申请了新page&#xff0c;用于slob分配&#xff0c;但是free碎片后&#xff0c;并没有free page。</p>\n<p></p>\n<p><strong>2.解决方法</strong></p>\n<p>这是我的解决办法&#xff0c;和大家探讨。<br />1&#xff09;将原有的slob_free函数改为slob_insert&#xff0c;将slob_alloc中的slob_free改为slob_insert。<br />2&#xff09;在slob_free中&#xff0c;保留原有的代码&#xff0c;增加判断释放的block是否包含一个完整的page&#xff0c;如果包含就释放出此page。<br />包括以下几种情况&#xff1a;</p>\n<p><img src=\"/img/1526-57b3410d9ec5b90.png\" width=\"778\" height=\"265\" alt=\"\" /></p>\n<p>3&#xff09;函数check_slob是测试用例</p>\n<p></p>\n<p>具体的代码&#xff1a;</p>\n<pre>\nstatic void slob_free(void *block, int size)\n{\n slob_t *cur, *b = (slob_t *)block, *newb;\n unsigned long flags;\n\n if (!block)\n  return;\n\n// if (size)\n//  b-&gt;units = SLOB_UNITS(size);  //????VJ\n\n /* Find reinsertion point */\n spin_lock_irqsave(&amp;slob_lock, flags);\n for (cur = slobfree; !(b &gt; cur &amp;&amp; b &lt; cur-&gt;next); cur = cur-&gt;next) {\n  if (cur &gt;= cur-&gt;next &amp;&amp; (b &gt; cur || b &lt; cur-&gt;next))\n   break;\n }\n\n if (b &#43; b-&gt;units == cur-&gt;next) {\n  b-&gt;units &#43;= cur-&gt;next-&gt;units;\n  b-&gt;next = cur-&gt;next-&gt;next;\n } else\n  b-&gt;next = cur-&gt;next;\n\n if (cur &#43; cur-&gt;units == b) {\n  cur-&gt;units &#43;= b-&gt;units;\n  cur-&gt;next = b-&gt;next;\n  newb = cur;\n\n } else {\n  cur-&gt;next = b;\n  newb = b;\n }\n\n // free page if size of newb greater than SLOB_UNITS(PAGE_SIZE)\n if (newb-&gt;units &gt;= SLOB_UNITS(PAGE_SIZE)) {\n  slob_t *pdelta = NULL, *aligned = NULL, *remain = NULL;\n  int delta = 0;\n  aligned = (slob_t *)ALIGN((unsigned long)newb, PAGE_SIZE);\n  delta = aligned - newb;\n  if (newb-&gt;units-delta &gt;= SLOB_UNITS(PAGE_SIZE)) {\n   slob_t *prev;\n   if (newb-&gt;units-delta &gt; SLOB_UNITS(PAGE_SIZE)) {\n    remain = aligned &#43; SLOB_UNITS(PAGE_SIZE);\n    remain-&gt;units = newb-&gt;units - delta - SLOB_UNITS(PAGE_SIZE);\n   }\n   // find the previous block of new block\n   for (prev = slobfree; ; prev = prev-&gt;next) {\n    if (prev-&gt;next == newb) {\n     break;\n    }\n   }\n   //prev =&gt; delta =&gt; remain =&gt; cur-&gt;next\n   if (delta) {\n    pdelta = newb;\n    pdelta-&gt;units = delta;\n    prev-&gt;next = pdelta;\n    if (remain) {\n     pdelta-&gt;next = remain;\n     remain-&gt;next = newb-&gt;next;\n    }\n    else {\n     pdelta-&gt;next = newb-&gt;next;\n    }\n   }\n   else {\n    if (remain) {\n     prev-&gt;next = remain;\n     remain-&gt;next = newb-&gt;next;\n    }\n    else {\n     prev-&gt;next = newb-&gt;next;\n    }\n   }\n   cur = prev;\n   __slob_free_pages((unsigned long)aligned, 0);\n  }\n }\n\n slobfree = cur;\n\n spin_unlock_irqrestore(&amp;slob_lock, flags);\n}\n\nvoid check_slob(void)\n{\n unsigned long flags;\n size_t nr_free_pages_store = nr_free_pages();\n slob_t arenb = { .next = &amp;arenb, .units = 1 };\n slob_t *slobfreebak = slobfree;\n void * ba, *bb, *bc;\n\n spin_lock_irqsave(&amp;block_lock, flags);\n slobfree = &amp;arenb;\n\n ba = kmalloc(100);\n assert (nr_free_pages_store == nr_free_pages()&#43;1);\n kfree (ba);\n assert (nr_free_pages_store == nr_free_pages());\n assert (slobfree == &amp;arenb);\n\n ba = kmalloc(100);\n bb = kmalloc(100);\n assert (nr_free_pages_store == nr_free_pages()&#43;1);\n kfree (ba);\n kfree (bb);\n assert (nr_free_pages_store == nr_free_pages());\n assert (slobfree == &amp;arenb);\n\n ba = kmalloc(160);\n bb = kmalloc(160);\n bc = kmalloc(PAGE_SIZE-320-SLOB_UNIT*3);\n assert (nr_free_pages_store == nr_free_pages()&#43;1);\n kfree (ba);\n kfree (bb);\n kfree (bc);\n assert (nr_free_pages_store == nr_free_pages());\n assert (slobfree == &amp;arenb);\n\n ba = kmalloc(3000);\n bb = kmalloc(2000);\n bc = kmalloc(1500);\n assert (nr_free_pages_store == nr_free_pages()&#43;2);\n kfree (bb);\n assert (nr_free_pages_store == nr_free_pages()&#43;2);\n kfree (bc);\n assert (nr_free_pages_store == nr_free_pages()&#43;1);\n kfree (ba);\n assert (nr_free_pages_store == nr_free_pages());\n assert (slobfree == &amp;arenb);\n\n slobfree = slobfreebak;\n spin_unlock_irqrestore(&amp;block_lock, flags);\n cprintf(&#34;check_slob() succeeded!\\n&#34;);\n}</pre>\n<p><a href=\"/redirect/s3?bucket=uploads&amp;prefix=paste%2Fkker3fspnhl7go%2F973a684fc5afb08477601be5322d01471db3ed8cb49efc22ef89075c27503011%2Fkmalloc.c\" target=\"_blank\" rel=\"noopener noreferrer\">kmalloc.c</a></p>\n<p></p>"}], "type": "note", "tags": ["lab5", "student"], "tag_good": [], "unique_views": 154, "children": [], "tag_good_arr": [], "id": "konx9et71ku2k6", "config": {"editor": "rte", "seen": {"110": 9, "485": 4, "1522": 6, "302": 3, "1366": 5, "656": 7, "1166": 0, "1296": 2, "718": 1, "1109": 8}, "has_emails_sent": 1}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 1, "num_favorites": 0, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643170270827, "default_anonymity": "no"}, "error": null, "aid": "kyv15je3bikv8"}