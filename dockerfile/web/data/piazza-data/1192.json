{"result": {"history_size": 1, "folders": ["lab4"], "nr": 1192, "data": {"embed_links": []}, "created": "2018-04-08T02:45:44Z", "bucket_order": 3, "no_answer_followup": 1, "change_log": [{"anon": "full", "data": "jfq7hftd9nx28f", "type": "create", "when": "2018-04-08T02:45:44Z", "uid_a": "a_0"}, {"anon": "no", "uid": "isu0wqaoff5125", "data": "jfqup6bz3eido", "to": "jfq7hft9wkv28e", "type": "s_answer", "when": "2018-04-08T13:35:36Z"}, {"anon": "no", "uid": "it2wrxu13f13sy", "to": "jfq7hft9wkv28e", "type": "followup", "when": "2018-04-09T14:45:27Z"}, {"anon": "no", "uid": "isu0wqaoff5125", "to": "jfq7hft9wkv28e", "type": "followup", "when": "2018-04-10T01:21:46Z"}], "bucket_name": "Today", "history": [{"anon": "full", "uid_a": "a_0", "subject": "为什么交换了上下文后还需要设置中断栈?", "created": "2018-04-08T02:45:44Z", "content": "我能理解idleproc是怎么转换到initproc的,但是在switch_to后是先执行forkret再执行kernel_thrad_entry,为什么要多加这几步? 为什么不在context的eip指向上一次运行后并被切换的第一条未执行的语句?\n上下文用来进行切换线程,idleproc到initproc不是简单第线程切换吗?这里并没有中断的事情啊? 不知道是我哪里没有理解,麻烦老师讲解一下.谢谢."}], "type": "question", "tags": ["lab4", "student"], "tag_good": [], "unique_views": 178, "children": [{"history_size": 1, "folders": [], "data": {"embed_links": []}, "created": "2018-04-08T13:35:36Z", "bucket_order": 3, "tag_endorse": [], "bucket_name": "Today", "history": [{"anon": "no", "uid": "isu0wqaoff5125", "subject": "", "created": "2018-04-08T13:35:36Z", "content": "<p>为了和启动用户进程统一起来&#xff1f;&#xff1f;</p>"}], "type": "s_answer", "tag_endorse_arr": [], "children": [], "id": "jfqup6bt2bsdn", "config": {}, "is_tag_endorse": false}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>首先&#xff0c;涉及到权限切换的时候必须利用中断返回时的iret指令切换到用户态。</p>\n<p></p>\n<p>而lab4只有内核态的进程&#xff0c;我认为其实是可以利用特定函数来实现内核进程切换的&#xff1a;</p>\n<p></p>\n<p>copy_thread的时候&#xff0c;子进程还无法被唤醒&#xff0c;但需要在这个时候告诉子进程醒来后第一件事要做啥&#xff08;eip之类的设置好&#xff09;&#xff0c;告诉完了之后还是在父进程里&#xff0c;父进程生了一个子进程然后执行完就继续做他自己的事情。</p>\n<p></p>\n<p>而lab4的设计比较简单&#xff0c;他会再唤醒一个idle进程来管理schedule&#xff0c;只有schedule才能调用proc_run真正唤醒那个新的子进程&#xff0c;子进程的各个状态才会被设置。问题就出在这里&#xff0c;你需要刚刚告诉子进程他自己醒来后要做啥&#xff0c;但你又不能马上把它的状态设置好&#xff0c;所以得找个地方保存你想告诉他的东西。</p>\n<p></p>\n<p>现在的做法是利用中断帧&#xff0c;子进程醒来后会去forkrets&#xff0c;他会把中断帧压栈然后进入到中断返回入口trapret&#xff0c;然后利用这里来恢复各个寄存器以及利用iret恢复cs、eip。这个过程中如果不利用中断的话&#xff0c;相当于你需要构造一个类似forkrets的函数来实现各个寄存器和cs&#xff08;现在都是内核所以不需要&#xff09;、eip的恢复&#xff0c;感觉理论上是可行的&#xff0c;你需要把那个中断帧作为函数参数压栈&#xff0c;然后这个函数自己内部实现各个寄存器的恢复&#xff0c;其中eip的恢复需要把栈帧指到合适的地方然后用ret指令。所以如果不涉及cs的变化的话好像是可以这么弄的吧&#xff1f;</p>", "created": "2018-04-09T14:45:27Z", "bucket_order": 179, "bucket_name": "Week 4/8 - 4/14", "type": "followup", "tag_good": [], "uid": "it2wrxu13f13sy", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "jfscmurmrl715o", "updated": "2018-04-09T14:45:27Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>请问您的改法是这样的吗&#xff1a;<a href=\"https://github.com/twd2/ucore_os_lab/commit/efce79e5a6c82a939ec840956b2fa78e0e0f122b\">https://github.com/twd2/ucore_os_lab/commit/efce79e5a6c82a939ec840956b2fa78e0e0f122b</a></p>\n<p></p>\n<p>这样是可以正常运行的&#xff0c;不过和产生用户进程的过程就不一致了。</p>", "created": "2018-04-10T01:21:46Z", "bucket_order": 179, "bucket_name": "Week 4/8 - 4/14", "type": "followup", "tag_good": [], "uid": "isu0wqaoff5125", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "jfszd60s9ro5y7", "updated": "2018-04-10T01:21:46Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "jfq7hft9wkv28e", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 3, "num_favorites": 1, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169359271, "default_anonymity": "no"}, "error": null, "aid": "kyv0m0137yq3sx"}