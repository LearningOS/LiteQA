{"result": {"history_size": 2, "folders": ["lecture13", "2020"], "nr": 1440, "data": {"embed_links": []}, "created": "2020-03-30T12:37:36Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "k6okde2x2zv2ck", "data": "k8egjm86fan44e", "type": "create", "when": "2020-03-30T12:37:36Z"}, {"anon": "no", "uid": "k6okde2x2zv2ck", "data": "k8egk80btpq4xa", "type": "update", "when": "2020-03-30T12:38:04Z"}, {"anon": "no", "uid": "k6ofjvmpddj11c", "to": "k8egjm837gw44d", "type": "followup", "when": "2020-03-30T13:40:36Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "k6okde2x2zv2ck", "subject": "对Peterson算法的理解中容易出现的误区", "created": "2020-03-30T12:38:04Z", "content": "<md>  Peterson算法是用软件实现同步互斥算法中的一种&#xff0c;如下为其伪码:  \n&#96;&#96;&#96;\nflag[ i ] = true;\nturn = j;\nwhile (flag[ j ] &amp;&amp; turn == j);\n    CRITICAL SECTION\nflag[ i ] = false;\n    REMAINDER SECTION\n&#96;&#96;&#96;  \n如果不仔细看此处的代码&#xff0c;可能将索引中的&#96;i&#96;与&#96;j&#96;混淆&#xff0c;认为每个进程在进入区会通过将&#96;turn&#96;变量设置为自己的进程号来抢夺资源&#xff0c;但这事实上大大不对。  \n  一方面&#xff0c;若将上代码段的2,3两行中的&#96;j&#96;改为&#96;i&#96;&#xff0c;那么若&#96;j&#96;进程无动作&#xff0c;则程序将在&#96;while&#96;处出现死循环&#xff0c;无法工作&#xff0c;当然有很大的错误。  \n  另一方面&#xff0c;若仅将第2行中的&#96;j&#96;改为&#96;i&#96;&#xff0c;那么&#96;flag[ i ]&#96;的作用与一般的“贴标签”无疑&#xff0c;无法解决忙则等待的问题。而对&#96;turn&#96;的设置也同样无法解决忙则等待的问题。可构造如下的反例&#xff1a;  \n PROCESS 0 | PROCESS 1\n:-----------------:|:-----------------:\nflag[0] = true  |                      |\n中断               |                      |\n                      | flag[1] = true  |\n                      | 中断                |\nturn = 0          |                      |\nwhile(flag[1] ...)|                    |\n中断               |                      |\n                      | turn = 1           |\n                      | while(flag[0] ...) |\nCRITICAL SECTION | CRITICALSECTION |\n\n这样就无法实现忙则等待的要求。  \n  应该注意的是&#xff0c;实际上Peterson算法是一个描述两个进程互相谦让的算法。大致过程如下&#xff1a;\n  进程0与进程1均想要某个资源。他们先均表示自己想要&#xff0c;然后均表示谦让。如果一个进程要最终占有资源&#xff0c;那么其须抢先谦让&#xff0c;让对手不得不随后谦让&#xff0c;然后名正言顺地接过资源的控制权。这样就解决了忙则等待的问题。</md>"}, {"anon": "no", "uid": "k6okde2x2zv2ck", "subject": "对Peterson算法的理解中容易出现的误区", "created": "2020-03-30T12:37:36Z", "content": "<md>  Peterson算法是用软件实现同步互斥算法中的一种&#xff0c;如下为其伪码:  \n&#96;&#96;&#96;\nflag[ i ] = true;\nturn = j;\nwhile (flag[ j ] &amp;&amp; turn == j);\n    CRITICAL SECTION\nflag[ i ] = false;\n    REMAINDER SECTION\n&#96;&#96;&#96;  \n如果不仔细看此处的代码&#xff0c;可能将索引中的&#96;i&#96;与&#96;j&#96;混淆&#xff0c;认为每个进程在进入区会通过将&#96;turn&#96;变量设置为自己的进程号来抢夺资源&#xff0c;但这事实上大大不对。  \n  一方面&#xff0c;若将上代码段的2,3两行中的&#96;j&#96;改为&#96;i&#96;&#xff0c;那么若&#96;j&#96;进程无动作&#xff0c;则程序将在&#96;while&#96;处出现死循环&#xff0c;无法工作&#xff0c;当然有很大的错误。  \n  另一方面&#xff0c;若仅将第2行中的&#96;j&#96;改为&#96;i&#96;&#xff0c;那么&#96;flag[ i ]&#96;的作用与一般的“贴标签”无疑&#xff0c;无法解决忙则等待的问题。而对&#96;turn&#96;的设置也同样无法解决忙则等待的问题。可构造如下的反例&#xff1a;  \n PROCESS 0 | PROCESS 1\n:-----------------:|:-----------------:\nflag[0] = true  |                      |\n中断               |                      |\n                      | flag[1] = true  |\n                      | 中断                |\nturn = 0          |                      |\nwhile(flag[1] ...)|                    |\n中断               |                      |\n                      | turn = 1           |\n                      | while(flag[0] ...) |\nCRITICAL SECTION | CRITICALSECTION |\n这样就无法实现忙则等待的要求。  \n  应该注意的是&#xff0c;实际上Peterson算法是一个描述两个进程互相谦让的算法。大致过程如下&#xff1a;\n  进程0与进程1均想要某个资源。他们先均表示自己想要&#xff0c;然后均表示谦让。如果一个进程要最终占有资源&#xff0c;那么其须抢先谦让&#xff0c;让对手不得不随后谦让&#xff0c;然后名正言顺地接过资源的控制权。这样就解决了忙则等待的问题。</md>"}], "type": "note", "tags": ["lecture13", "student"], "tag_good": [{"role": "student", "name": "Gertrude", "endorser": {}, "admin": false, "photo": null, "id": "ks93y5sq4x81ll", "photo_url": null, "published": true, "us": false, "facebook_id": null}], "unique_views": 79, "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<md>### 回答课堂问题为什么Peterson用于三线程不满足忙则等待的原则\n\n~~~\nflag[ i ] = true;\nturn = j;\t// 将turn设置为其它线程\nwhile (flag[ j ] &amp;&amp; turn == j);\n    CRITICAL SECTION\nflag[ i ] = false;\n    REMAINDER SECTION\n~~~\n\n​\t\t考虑这样一种情况&#xff0c;线程1、2、3同时对turn做修改并想访问临界区&#xff1a;\n\n&#43; 1线程将turn指向3\n&#43; 2线程将turn指向3\n&#43; 3线程最后写&#xff0c;将turn覆盖重写为1\n&#43; 这样最后1&#xff0c;2线程看到的turn == 1&#xff0c;不符合while条件。于是他们都决定进入临界区&#xff0c;这违背了**忙则等待**的原则。\n\n​\t\t事实上这里Peterson只能用于两线程根本原因是turn只能指定一者&#xff0c;所以很显然它不会适用于第三者的情况。\n\n</md>", "created": "2020-03-30T13:40:36Z", "bucket_order": 94, "bucket_name": "Week 3/29 - 4/4", "type": "followup", "tag_good": [], "uid": "k6ofjvmpddj11c", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "k8eisn46rri3sp", "updated": "2020-03-30T13:40:36Z", "config": {}}], "tag_good_arr": ["ks93y5sq4x81ll"], "id": "k8egjm837gw44d", "config": {"seen": {"881": 1, "366": 3, "6": 8, "1166": 4, "866": 7, "835": 2, "1030": 0, "1183": 6, "1308": 5}}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 2, "num_favorites": 0, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643170051472, "default_anonymity": "no"}, "error": null, "aid": "kyv10u4wkv53qt"}