{"result": {"folders": ["exam"], "nr": 255, "data": {"embed_links": []}, "created": "2015-04-08T05:58:37Z", "bucket_order": 3, "no_answer_followup": 24, "change_log": [{"uid": "hcrrjuyequh4bt", "anon": "no", "when": "2015-04-08T05:58:37Z", "data": "i88bruqt6074f0", "type": "create"}, {"to": "i88bruqqbj84ez", "uid": "i6vi7mt1I4G", "anon": "no", "when": "2015-04-08T05:58:49Z", "type": "followup"}, {"to": "i88bruqqbj84ez", "uid": "i6tezdpdQbq", "anon": "no", "when": "2015-04-08T05:59:11Z", "type": "followup"}, {"to": "i88bruqqbj84ez", "uid": "i6vi7mt1I4G", "anon": "no", "when": "2015-04-08T05:59:43Z", "type": "feedback"}, {"uid": "hcrrjuyequh4bt", "anon": "no", "when": "2015-04-08T06:00:01Z", "data": "i88bto2bmsx79y", "type": "update"}, {"to": "i88bruqqbj84ez", "uid": "i7bfq2txxyw689", "anon": "no", "when": "2015-04-08T06:00:45Z", "type": "followup"}, {"to": "i88bruqqbj84ez", "uid": "i6uswob7jl4242", "anon": "no", "when": "2015-04-08T06:05:47Z", "type": "followup"}, {"to": "i88bruqqbj84ez", "uid": "i6unpz8nUza", "anon": "no", "when": "2015-04-08T06:08:55Z", "type": "followup"}, {"to": "i88bruqqbj84ez", "uid": "i6tz0qianu33p3", "anon": "no", "when": "2015-04-08T06:09:16Z", "type": "followup"}, {"to": "i88bruqqbj84ez", "uid": "i6uji18l8j51ob", "anon": "no", "when": "2015-04-08T06:13:10Z", "type": "followup"}, {"to": "i88bruqqbj84ez", "uid": "i718aanx0OS", "anon": "no", "when": "2015-04-08T06:32:06Z", "type": "followup"}, {"to": "i88bruqqbj84ez", "uid": "i6vi7mt1I4G", "anon": "no", "when": "2015-04-08T06:38:51Z", "type": "feedback"}, {"to": "i88bruqqbj84ez", "uid": "i6un4iacNGX", "anon": "no", "when": "2015-04-08T06:39:27Z", "type": "followup"}, {"to": "i88bruqqbj84ez", "uid": "i6un4iacNGX", "anon": "no", "when": "2015-04-08T06:41:59Z", "type": "feedback"}, {"to": "i88bruqqbj84ez", "uid": "i7bfq2txxyw689", "anon": "no", "when": "2015-04-08T06:42:07Z", "type": "feedback"}, {"to": "i88bruqqbj84ez", "uid": "i7bfvegt8am5ir", "anon": "no", "when": "2015-04-08T06:47:24Z", "type": "followup"}, {"to": "i88bruqqbj84ez", "uid": "i6uehzyhtye4i2", "anon": "no", "when": "2015-04-08T06:54:50Z", "type": "feedback"}, {"to": "i88bruqqbj84ez", "uid": "i7oaxkxhxjo3ui", "anon": "no", "when": "2015-04-08T06:55:29Z", "type": "followup"}, {"to": "i88bruqqbj84ez", "uid": "i6uehzyhtye4i2", "anon": "no", "when": "2015-04-08T06:57:09Z", "type": "followup"}, {"to": "i88bruqqbj84ez", "uid": "i718mp903qx", "anon": "no", "when": "2015-04-08T06:59:35Z", "type": "followup"}, {"to": "i88bruqqbj84ez", "uid": "i6urm1j1ynv6sm", "anon": "no", "when": "2015-04-08T06:59:41Z", "type": "followup"}, {"to": "i88bruqqbj84ez", "uid": "i718mp903qx", "anon": "no", "when": "2015-04-08T07:02:27Z", "type": "feedback"}, {"to": "i88bruqqbj84ez", "uid": "i6xgf2t8N7w", "anon": "no", "when": "2015-04-08T07:29:48Z", "type": "followup"}, {"to": "i88bruqqbj84ez", "uid": "i7w0q2p8Cmz", "anon": "no", "when": "2015-04-08T07:41:38Z", "type": "followup"}, {"to": "i88bruqqbj84ez", "uid": "i6t1byqz5dE", "anon": "no", "when": "2015-04-08T08:07:45Z", "type": "followup"}, {"to": "i88bruqqbj84ez", "uid": "i6vi7mt1I4G", "anon": "no", "when": "2015-04-08T08:22:55Z", "type": "feedback"}, {"to": "i88bruqqbj84ez", "uid": "i6vgn93glrq25f", "anon": "no", "when": "2015-04-08T08:52:38Z", "type": "followup"}, {"to": "i88bruqqbj84ez", "uid": "i6vgn93glrq25f", "anon": "no", "when": "2015-04-08T08:53:07Z", "type": "feedback"}, {"to": "i88bruqqbj84ez", "uid": "i6tezdpdQbq", "anon": "no", "when": "2015-04-08T09:40:59Z", "type": "feedback"}, {"to": "i88bruqqbj84ez", "uid": "i6ut6cjo5lj4aa", "anon": "no", "when": "2015-04-08T10:53:28Z", "type": "followup"}, {"to": "i88bruqqbj84ez", "uid": "i6ut6cjo5lj4aa", "anon": "no", "when": "2015-04-08T10:55:47Z", "type": "followup"}, {"to": "i88bruqqbj84ez", "uid": "i6tawpo5Fm8", "anon": "no", "when": "2015-04-08T13:16:14Z", "type": "followup"}, {"to": "i88bruqqbj84ez", "uid": "i6tawpo5Fm8", "anon": "no", "when": "2015-04-08T13:19:16Z", "type": "feedback"}, {"to": "i88bruqqbj84ez", "uid": "i6tawpo5Fm8", "anon": "no", "when": "2015-04-08T13:20:24Z", "type": "feedback"}, {"to": "i88bruqqbj84ez", "uid": "i71i9kso8Gp", "anon": "no", "when": "2015-04-08T13:38:07Z", "type": "followup"}, {"to": "i88bruqqbj84ez", "uid": "i6urr6is7yo3jv", "anon": "no", "when": "2015-04-08T15:24:46Z", "type": "followup"}, {"to": "i88bruqqbj84ez", "uid": "i6utvrywozd2vd", "anon": "no", "when": "2015-04-08T15:30:54Z", "type": "followup"}, {"to": "i88bruqqbj84ez", "uid": "i6ugdh143r52f9", "anon": "no", "when": "2015-04-08T15:59:48Z", "type": "feedback"}, {"uid": "hcrrjuyequh4bt", "anon": "no", "when": "2015-04-16T02:59:00Z", "data": "i8jkvp1h2xi42l", "type": "update"}, {"uid": "hcrrjuyequh4bt", "anon": "no", "when": "2015-04-16T03:01:03Z", "data": "i8jkybq9hcs6l3", "type": "update"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hcrrjuyequh4bt", "subject": "lec12&#xff08;第六周第二次课&#xff09;spoc小组练习", "created": "2015-04-16T03:01:03Z", "content": "<p>请完成的同学follow</p>\n<p><a href=\"https://github.com/xuyongjiande/os_exercises/blob/master/all/05-2-spoc-discussion.md\">https://github.com/xuyongjiande/os_exercises/blob/master/all/05-2-spoc-discussion.md</a></p>\n<p></p>\n<p>优胜者&#xff1a;</p>\n<p>黄杰 2012011272</p>\n<p>袁源 2012011294</p>"}, {"anon": "no", "uid": "hcrrjuyequh4bt", "subject": "lec12&#xff08;第六周第二次课&#xff09;spoc小组练习", "created": "2015-04-16T02:59:00Z", "content": "<p>请完成的同学follow</p>\n<p><a href=\"https://github.com/xuyongjiande/os_exercises/blob/master/all/05-2-spoc-discussion.md\">https://github.com/xuyongjiande/os_exercises/blob/master/all/05-2-spoc-discussion.md</a></p>\n<p></p>\n<p>优胜者&#xff1a;</p>\n<p>黄杰 </p>\n<p>袁源</p>"}, {"anon": "no", "uid": "hcrrjuyequh4bt", "subject": "lec12&#xff08;第六周第二次课&#xff09;spoc小组练习", "created": "2015-04-08T06:00:01Z", "content": "<p>请完成的同学follow</p>\n<p>https://github.com/xuyongjiande/os_exercises/blob/master/all/05-2-spoc-discussion.md</p>"}, {"anon": "no", "uid": "hcrrjuyequh4bt", "subject": "lec12&#xff08;第六周第二次课&#xff09;spoc小组练习", "created": "2015-04-08T05:58:37Z", "content": "<p>请完成的同学follow</p>"}], "type": "note", "tags": ["exam", "instructor-note"], "tag_good": [], "unique_views": 123, "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>黄杰 袁源</p>\n<p></p>\n<pre>#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\n\n# process switch behavior\nSCHED_SWITCH_ON_IO = &#39;SWITCH_ON_IO&#39;\n\n# io finished behavior\nIO_RUN_LATER = &#39;IO_RUN_LATER&#39;\n\n# process states\nSTATE_RUNNING = &#39;RUNNING&#39;\nSTATE_READY = &#39;READY&#39;\nSTATE_DONE = &#39;DONE&#39;\nSTATE_WAIT = &#39;WAITING&#39;\n\n# members of process structure\nPROC_CODE = &#39;code_&#39;\nPROC_PC = &#39;pc_&#39;\nPROC_ID = &#39;pid_&#39;\nPROC_STATE = &#39;proc_state_&#39;\n\n# things a process can do\nDO_COMPUTE = &#39;cpu&#39;\nDO_YIELD = &#39;yld&#39;\nDO_IO = &#39;io&#39;\n\nclass scheduler:\n    def __init__(self, process_switch_behavior, io_done_behavior, io_length):\n        # keep set of instructions for each of the processes\n        self.proc_info = {}\n        self.process_switch_behavior = process_switch_behavior\n        self.io_done_behavior = io_done_behavior\n        self.io_length = io_length\n        return\n\n    def new_process(self):\n        proc_id = len(self.proc_info)\n        self.proc_info[proc_id] = {}\n        self.proc_info[proc_id][PROC_PC] = 0\n        self.proc_info[proc_id][PROC_ID] = proc_id\n        self.proc_info[proc_id][PROC_CODE] = []\n        self.proc_info[proc_id][PROC_STATE] = STATE_READY\n        return proc_id\n\n    def load(self, program_description):\n        proc_id = self.new_process()\n        tmp = program_description.split(&#39;:&#39;)\n        if len(tmp) != 3:\n            print &#39;Bad description (%s): Must be number &lt;x:y:z&gt;&#39;\n            print &#39;  where X is the number of instructions&#39;\n            print &#39;  and Y is the percent change that an instruction is YIELD&#39;\n            print &#39;  and Z is the percent change that an instruction is IO&#39;\n            exit(1)\n\n        num_instructions, chance_yield, chance_io = int(tmp[0]), float(tmp[1])/100.0, float(tmp[2])/100.0\n        assert(chance_yield&#43;chance_io&lt;1)\n\n        #print &#34;proc %d, num_instr %d, change_cpu %f&#34; % (proc_id,num_instructions, chance_cpu)\n        for i in range(num_instructions):\n            randnum=random.random();\n            if randnum &lt; (1.0-chance_yield-chance_io):\n                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)\n            elif randnum &gt;= (1.0-chance_yield-chance_io) and randnum &lt; (1.0-chance_io):\n                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)\n            else:\n                self.proc_info[proc_id][PROC_CODE].append(DO_IO)\n            #print &#34;proc %d, instr idx %d, instr cxt %s&#34; % (proc_id, i, self.proc_info[proc_id][PROC_CODE][i])\n        return\n\n    #change to READY STATE, the current proc&#39;s state should be expected\n    #if pid==-1, then pid=self.curr_proc\n    def move_to_ready(self, expected, pid=-1):\n\n        #YOUR CODE\n        if pid==-1:\n            pid=self.curr_proc\n        self.proc_info[pid][PROC_STATE] = STATE_READY\n        return\n\n    #change to RUNNING STATE, the current proc&#39;s state should be expected\n    def move_to_running(self, expected):\n        #YOUR CODE\n        assert expected == STATE_READY\n        pid=self.curr_proc\n        self.proc_info[pid][PROC_STATE] = STATE_RUNNING\n        return\n\n    #change to DONE STATE, the current proc&#39;s state should be expected\n    def move_to_done(self, expected):\n        #YOUR CODE\n        assert expected == STATE_RUNNING\n        pid=self.curr_proc\n        self.proc_info[pid][PROC_STATE] = STATE_DONE\n        return\n    def move_to_waiting(self, expected):\n        #YOUR CODE\n        assert expected == STATE_RUNNING\n        pid=self.curr_proc\n        self.proc_info[pid][PROC_STATE] = STATE_WAIT\n        return\n    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc\n    def next_proc(self, pid=-1):\n        #YOUR CODE\n        if pid==-1:\n            pid=self.curr_proc\n        n=len(self.proc_info)\n    #print &#39;0:&#39;,self.proc_info[0][PROC_STATE]\n    #print &#39;1:&#39;,self.proc_info[1][PROC_STATE]\n        for i in range(pid&#43;1,n):\n            if (self.proc_info[i][PROC_STATE]==STATE_READY):\n                self.curr_proc = i\n                self.move_to_running(STATE_READY);\n                #print &#34;pid&#34;,pid\n                return \n    for i in range(0,pid&#43;1):\n        if (self.proc_info[i][PROC_STATE]==STATE_READY):\n        self.curr_proc = i\n                self.move_to_running(STATE_READY);\n                #print &#34;pid&#34;,pid\n                return \n\n        return\n\n    def get_num_processes(self):\n        return len(self.proc_info)\n\n    def get_num_instructions(self, pid):\n        return len(self.proc_info[pid][PROC_CODE])\n\n    def get_instruction(self, pid, index):\n        return self.proc_info[pid][PROC_CODE][index]\n\n    def get_num_active(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] != STATE_DONE:\n                num_active &#43;= 1\n        return num_active\n    def get_num_running(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if  self.proc_info[pid][PROC_STATE] == STATE_RUNNING:\n                num_active &#43;= 1\n        return num_active\n    def get_num_runnable(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\\n                   self.proc_info[pid][PROC_STATE] == STATE_RUNNING:\n                num_active &#43;= 1\n        return num_active\n\n    def get_ios_in_flight(self, current_time):\n        num_in_flight = 0\n        for pid in range(len(self.proc_info)):\n            for t in self.io_finish_times[pid]:\n                if t &gt; current_time:\n                    num_in_flight &#43;= 1\n        return num_in_flight\n\n\n    def space(self, num_columns):\n        for i in range(num_columns):\n            print &#39;%10s&#39; % &#39; &#39;,\n\n    def check_if_done(self):\n        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n                self.move_to_done(STATE_RUNNING)\n                self.next_proc()\n        return\n\n    def run(self):\n        clock_tick = 0\n\n        if len(self.proc_info) == 0:\n            return\n\n        # track outstanding IOs, per process\n        self.io_finish_times = {}\n        for pid in range(len(self.proc_info)):\n            self.io_finish_times[pid] = []\n\n        # make first one active\n        self.curr_proc = 0\n        self.move_to_running(STATE_READY)\n\n        # OUTPUT: heade&#96;[rs for each column\n        print &#39;%s&#39; % &#39;Time&#39;, \n        for pid in range(len(self.proc_info)):\n            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),\n        print &#39;%10s&#39; % &#39;CPU&#39;,\n        print &#39;%10s&#39; % &#39;IOs&#39;,\n        print &#39;&#39;\n\n        # init statistics\n        io_busy = 0\n        cpu_busy = 0\n\n        while self.get_num_active() &gt; 0:\n            clock_tick &#43;= 1\n\n            # check for io finish\n            io_done = False\n            for pid in range(len(self.proc_info)):\n                if clock_tick in self.io_finish_times[pid]:\n                    # if IO finished, the should do something for related process\n                    #YOUR CODE\n                    #print &#39;pid&#39;,pid\n            self.move_to_ready(STATE_WAIT,pid)\n            #print &#39;num: &#39;,self.get_num_runnable()\n            if self.get_num_running()==0:\n                        self.next_proc()\n                    #pass #YOU should delete this\n            #print self.proc_info[0][PROC_STATE]\n            #print self.proc_info[1][PROC_STATE]\n\n\n\n            # if current proc is RUNNING and has an instruction, execute it\n            instruction_to_execute = &#39;&#39;\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n                   len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)\n                #pop a instruction from proc_info[self.curr_proc][PROC_CODE]to instruction_to_execute\n                #YOUR CODE\n                #pass #YOU should delete this\n\n            # OUTPUT: print what everyone is up to\n            if io_done:\n                print &#39;%3d*&#39; % clock_tick,\n            else:\n                print &#39;%3d &#39; % clock_tick,\n            for pid in range(len(self.proc_info)):\n                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n                    print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),\n                    cpu_busy=cpu_busy&#43;1\n                else:\n                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),\n            if instruction_to_execute == &#39;&#39;:\n                print &#39;%10s&#39; % &#39; &#39;,\n            else:\n                print &#39;%10s&#39; % 1,\n            num_outstanding = self.get_ios_in_flight(clock_tick)\n            if num_outstanding &gt; 0:\n                print &#39;%10s&#39; % str(num_outstanding),\n                io_busy &#43;= 1\n            else:\n                print &#39;%10s&#39; % &#39; &#39;,\n            print &#39;&#39;\n\n            # if this is an YIELD instruction, switch to ready state\n            # and add an io completion in the future\n            if instruction_to_execute == DO_YIELD:\n                #print &#34;-------------------------&#34;\n                #YOUR CODE\n                if len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                    self.move_to_ready(STATE_RUNNING)\n                else:\n                    self.move_to_done(STATE_RUNNING)\n                self.next_proc();\n                #pass #YOU should delete this\n            # if this is an IO instruction, switch to waiting state\n            # and add an io completion in the future\n            elif instruction_to_execute == DO_IO:\n                #YOUR CODE\n                pid = self.curr_proc\n        self.io_finish_times[pid].append(clock_tick&#43;io_length)\n        self.move_to_waiting(STATE_RUNNING)\n        self.next_proc();\n\n\n                #pass #YOU should delete this\n\n            # ENDCASE: check if currently running thing is out of instructions\n            self.check_if_done()\n        return (cpu_busy, io_busy, clock_tick)\n\n#\n# PARSE ARGUMENTS\n#\n\nparser = OptionParser()\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default</pre>", "created": "2015-04-08T05:58:49Z", "bucket_order": 265, "bucket_name": "Week 4/5 - 4/11", "type": "followup", "tag_good": [], "uid": "i6vi7mt1I4G", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>黄杰2012011272 袁源2012011294</p>", "created": "2015-04-08T05:59:43Z", "bucket_order": 265, "bucket_name": "Week 4/5 - 4/11", "type": "feedback", "tag_good": [], "uid": "i6vi7mt1I4G", "children": [], "tag_good_arr": [], "id": "i88bt9p11ln25j", "updated": "2015-04-08T05:59:43Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<pre>            # if this is an YIELD instruction, switch to ready state\n            # and add an io completion in the future\n            if instruction_to_execute == DO_YIELD:\n                #print &#34;-------------------------&#34;\n                #YOUR CODE\n                if len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                    self.move_to_ready(STATE_RUNNING)\n                else:\n                    self.move_to_done(STATE_RUNNING)\n                self.next_proc();\n                #pass #YOU should delete this\n            # if this is an IO instruction, switch to waiting state\n            # and add an io completion in the future\n            elif instruction_to_execute == DO_IO:\n                #YOUR CODE\n                pid = self.curr_proc\n        self.io_finish_times[pid].append(clock_tick&#43;io_length)\n        self.move_to_waiting(STATE_RUNNING)\n        self.next_proc();\n\n\n                #pass #YOU should delete this\n\n            # ENDCASE: check if currently running thing is out of instructions\n            self.check_if_done()\n        return (cpu_busy, io_busy, clock_tick)\n\n#\n# PARSE ARGUMENTS\n#\n\nparser = OptionParser()\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0, help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)\nparser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,\n                  help=&#39;a comma-separated list of processes to run, in the form X1:Y1:Z1,X2:Y2:Z2,... where X is the number of instructions that process should run, and Y/Z the chances (from 0 to 100) issue an YIELD/IO&#39;,\n                  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)\nparser.add_option(&#39;-L&#39;, &#39;--iolength&#39;, default=3, help=&#39;how long an IO takes&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;io_length&#39;)\nparser.add_option(&#39;-p&#39;, &#39;--printstats&#39;, help=&#39;print statistics at end; only useful with -c flag (otherwise stats are not printed)&#39;, action=&#39;store_true&#39;, default=False, dest=&#39;print_stats&#39;)\n(options, args) = parser.parse_args()\n\nrandom.seed(options.seed)\n\nprocess_switch_behavior = SCHED_SWITCH_ON_IO\nio_done_behavior = IO_RUN_LATER\nio_length=options.io_length\n\n\ns = scheduler(process_switch_behavior, io_done_behavior, io_length)\n\n# example process description (10:100,10:100)\nfor p in options.process_list.split(&#39;,&#39;):\n    s.load(p)\n\nprint &#39;Produce a trace of what would happen when you run these processes:&#39;\nfor pid in range(s.get_num_processes()):\n    print &#39;Process %d&#39; % pid\n    for inst in range(s.get_num_instructions(pid)):\n        print &#39;  %s&#39; % s.get_instruction(pid, inst)\n    print &#39;&#39;\nprint &#39;Important behaviors:&#39;\nprint &#39;  System will switch when&#39;,\nif process_switch_behavior == SCHED_SWITCH_ON_IO:\n    print &#39;the current process is FINISHED or ISSUES AN YIELD or IO&#39;\nelse:\n    print &#39;error in sched switch on iobehavior&#39;\n    exit (-1)\nprint &#39;  After IOs, the process issuing the IO will&#39;,\nif io_done_behavior == IO_RUN_LATER:\n    print &#39;run LATER (when it is its turn)&#39;\nelse:\n    print &#39;error in IO done behavior&#39;\n    exit (-1)\nprint &#39;&#39;\n\n(cpu_busy, io_busy, clock_tick) = s.run()\n\nprint &#39;&#39;\nprint &#39;Stats: Total Time %d&#39; % clock_tick\nprint &#39;Stats: CPU Busy %d (%.2f%%)&#39; % (cpu_busy, 100.0 * float(cpu_busy)/clock_tick)\nprint &#39;Stats: IO Busy  %d (%.2f%%)&#39; % (io_busy, 100.0 * float(io_busy)/clock_tick)\nprint &#39;&#39;</pre>", "created": "2015-04-08T08:22:55Z", "bucket_order": 265, "bucket_name": "Week 4/5 - 4/11", "type": "feedback", "tag_good": [], "uid": "i6vi7mt1I4G", "children": [], "tag_good_arr": [], "id": "i88gxfezl61zb", "updated": "2015-04-08T08:22:55Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "i88bs44ng5h6rl", "updated": "2015-04-08T05:58:49Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>周昊 2012011326</p>\n<pre>#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\n\n# process switch behavior\nSCHED_SWITCH_ON_IO = &#39;SWITCH_ON_IO&#39;\n\n# io finished behavior\nIO_RUN_LATER = &#39;IO_RUN_LATER&#39;\n\n# process states\nSTATE_RUNNING = &#39;RUNNING&#39;\nSTATE_READY = &#39;READY&#39;\nSTATE_DONE = &#39;DONE&#39;\nSTATE_WAIT = &#39;WAITING&#39;\n\n# members of process structure\nPROC_CODE = &#39;code_&#39;\nPROC_PC = &#39;pc_&#39;\nPROC_ID = &#39;pid_&#39;\nPROC_STATE = &#39;proc_state_&#39;\n\n# things a process can do\nDO_COMPUTE = &#39;cpu&#39;\nDO_YIELD = &#39;yld&#39;\nDO_IO = &#39;io&#39;\n\nclass scheduler:\n    def __init__(self, process_switch_behavior, io_done_behavior, io_length):\n        # keep set of instructions for each of the processes\n        self.proc_info = {}\n        self.process_switch_behavior = process_switch_behavior\n        self.io_done_behavior = io_done_behavior\n        self.io_length = io_length\n        return\n\n    def new_process(self):\n        proc_id = len(self.proc_info)\n        self.proc_info[proc_id] = {}\n        self.proc_info[proc_id][PROC_PC] = 0\n        self.proc_info[proc_id][PROC_ID] = proc_id\n        self.proc_info[proc_id][PROC_CODE] = []\n        self.proc_info[proc_id][PROC_STATE] = STATE_READY\n        return proc_id\n\n    def load(self, program_description):\n        proc_id = self.new_process()\n        tmp = program_description.split(&#39;:&#39;)\n        if len(tmp) != 3:\n            print &#39;Bad description (%s): Must be number &lt;x:y:z&gt;&#39;\n            print &#39;  where X is the number of instructions&#39;\n            print &#39;  and Y is the percent change that an instruction is YIELD&#39;\n            print &#39;  and Z is the percent change that an instruction is IO&#39;\n            exit(1)\n\n        num_instructions, chance_yield, chance_io = int(tmp[0]), float(tmp[1])/100.0, float(tmp[2])/100.0\n        assert(chance_yield&#43;chance_io&lt;1)\n\n        #print &#34;proc %d, num_instr %d, change_cpu %f&#34; % (proc_id,num_instructions, chance_cpu)\n        for i in range(num_instructions):\n            randnum=random.random();\n            if randnum &lt; (1.0-chance_yield-chance_io):\n                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)\n            elif randnum &gt;= (1.0-chance_yield-chance_io) and randnum &lt; (1.0-chance_io):\n                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)\n            else:\n                self.proc_info[proc_id][PROC_CODE].append(DO_IO)\n            #print &#34;proc %d, instr idx %d, instr cxt %s&#34; % (proc_id, i, self.proc_info[proc_id][PROC_CODE][i])\n        return\n\n    def move_to_wait(self, expected, pid=-1):\n        if pid == -1:\n            pid = self.curr_proc\n        if self.proc_info[pid][PROC_STATE] == expected:\n            self.proc_info[pid][PROC_STATE] = STATE_WAIT\n        else:\n            assert(1 == 0)\n        #YOUR CODE\n        return\n\n    #change to READY STATE, the current proc&#39;s state should be expected\n    #if pid==-1, then pid=self.curr_proc\n    def move_to_ready(self, expected, pid=-1):\n        if pid == -1:\n            pid = self.curr_proc\n        if self.proc_info[pid][PROC_STATE] == expected:\n            self.proc_info[pid][PROC_STATE] = STATE_READY\n        else:\n            assert(1 == 0)\n        #YOUR CODE\n        return\n\n    #change to RUNNING STATE, the current proc&#39;s state should be expected\n    def move_to_running(self, expected):\n        if self.proc_info[self.curr_proc][PROC_STATE] == expected:\n            self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING\n        else:\n            assert(1 == 0)\n        #YOUR CODE\n        return\n\n    #change to DONE STATE, the current proc&#39;s state should be expected\n    def move_to_done(self, expected):\n        if self.proc_info[self.curr_proc][PROC_STATE] == expected:\n            self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE\n        else:\n            assert(1 == 0)\n        #YOUR CODE\n        return\n\n    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc\n    def next_proc(self, pid=-1):\n        if pid == -1:\n            pid = self.curr_proc\n        n = self.get_num_processes()\n        for i in range(1, n):\n            if self.proc_info[(pid&#43;i)%n][PROC_STATE] == STATE_READY:\n                self.curr_proc = (pid&#43;i)%n\n                break\n        if self.proc_info[self.curr_proc][PROC_STATE] == STATE_READY:\n            self.move_to_running(STATE_READY)\n        #YOUR CODE\n        return\n\n    def get_num_processes(self):\n        return len(self.proc_info)\n\n    def get_num_instructions(self, pid):\n        return len(self.proc_info[pid][PROC_CODE])\n\n    def get_instruction(self, pid, index):\n        return self.proc_info[pid][PROC_CODE][index]\n\n    def get_num_active(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] != STATE_DONE:\n                num_active &#43;= 1\n        return num_active\n\n    def get_num_runnable(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\\n                   self.proc_info[pid][PROC_STATE] == STATE_RUNNING:\n                num_active &#43;= 1\n        return num_active\n\n    def get_ios_in_flight(self, current_time):\n        num_in_flight = 0\n        for pid in range(len(self.proc_info)):\n            for t in self.io_finish_times[pid]:\n                if t &gt; current_time:\n                    num_in_flight &#43;= 1\n        return num_in_flight\n\n\n    def space(self, num_columns):\n        for i in range(num_columns):\n            print &#39;%10s&#39; % &#39; &#39;,\n\n    def check_if_done(self):\n        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n                self.move_to_done(STATE_RUNNING)\n                self.next_proc()\n        return\n\n    def run(self):\n        clock_tick = 0\n\n        if len(self.proc_info) == 0:\n            return\n\n        # track outstanding IOs, per process\n        self.io_finish_times = {}\n        for pid in range(len(self.proc_info)):\n            self.io_finish_times[pid] = []\n\n        # make first one active\n        self.curr_proc = 0\n        self.move_to_running(STATE_READY)\n\n        # OUTPUT: heade&#96;[rs for each column\n        print &#39;%s&#39; % &#39;Time&#39;, \n        for pid in range(len(self.proc_info)):\n            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),\n        print &#39;%10s&#39; % &#39;CPU&#39;,\n        print &#39;%10s&#39; % &#39;IOs&#39;,\n        print &#39;&#39;\n\n        # init statistics\n        io_busy = 0\n        cpu_busy = 0\n\n        while self.get_num_active() &gt; 0:\n            clock_tick &#43;= 1\n\n            # check for io finish\n            io_done = False\n            for pid in range(len(self.proc_info)):\n                if clock_tick in self.io_finish_times[pid]:\n                    # if IO finished, the should do something for related process\n       \t            #YOUR CODE\n                    io_done = True\n                    if self.get_num_runnable() == 0:\n                        self.move_to_ready(STATE_WAIT, pid)\n                        self.next_proc()\n                    else:\n                        self.move_to_ready(STATE_WAIT, pid)\n            \n\n            \n            # if current proc is RUNNING and has an instruction, execute it\n            instruction_to_execute = &#39;&#39;\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n                   len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                #pop a instruction from proc_info[self.curr_proc][PROC_CODE]to instruction_to_execute\n                #YOUR CODE\n                instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)\n\n            # OUTPUT: print what everyone is up to\n            if io_done:\n                print &#39;%3d*&#39; % clock_tick,\n            else:\n                print &#39;%3d &#39; % clock_tick,\n            for pid in range(len(self.proc_info)):\n                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n                    print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),\n                    cpu_busy &#43;= 1\n                else:\n                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),\n            if instruction_to_execute == &#39;&#39;:\n                print &#39;%10s&#39; % &#39; &#39;,\n            else:\n                print &#39;%10s&#39; % 1,\n            num_outstanding = self.get_ios_in_flight(clock_tick)\n            if num_outstanding &gt; 0:\n                print &#39;%10s&#39; % str(num_outstanding),\n                io_busy &#43;= 1\n            else:\n                print &#39;%10s&#39; % &#39; &#39;,\n            print &#39;&#39;\n\n            # if this is an YIELD instruction, switch to ready state\n            # and add an io completion in the future\n            if instruction_to_execute == DO_YIELD:</pre>", "created": "2015-04-08T05:59:11Z", "bucket_order": 265, "bucket_name": "Week 4/5 - 4/11", "type": "followup", "tag_good": [], "uid": "i6tezdpdQbq", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>", "created": "2015-04-08T06:38:51Z", "bucket_order": 265, "bucket_name": "Week 4/5 - 4/11", "type": "feedback", "tag_good": [], "uid": "i6vi7mt1I4G", "children": [], "tag_good_arr": [], "id": "i88d7loj3187f7", "updated": "2015-04-08T06:38:51Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p><pre>#YOUR CODE\n                self.move_to_ready(STATE_RUNNING, self.curr_proc)\n                self.next_proc()\n            # if this is an IO instruction, switch to waiting state\n            # and add an io completion in the future\n            elif instruction_to_execute == DO_IO:\n                self.move_to_wait(STATE_RUNNING, self.curr_proc)\n                self.io_finish_times[self.curr_proc].append(clock_tick &#43; self.io_length)\n                self.next_proc()\n                #YOUR CODE\n                pass #YOU should delete this\n\n            # ENDCASE: check if currently running thing is out of instructions\n            self.check_if_done()\n        return (cpu_busy, io_busy, clock_tick)\n\n#\n# PARSE ARGUMENTS\n#\n\nparser = OptionParser()\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0, help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)\nparser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,\n                  help=&#39;a comma-separated list of processes to run, in the form X1:Y1:Z1,X2:Y2:Z2,... where X is the number of instructions that process should run, and Y/Z the chances (from 0 to 100) issue an YIELD/IO&#39;,\n                  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)\nparser.add_option(&#39;-L&#39;, &#39;--iolength&#39;, default=3, help=&#39;how long an IO takes&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;io_length&#39;)\nparser.add_option(&#39;-p&#39;, &#39;--printstats&#39;, help=&#39;print statistics at end; only useful with -c flag (otherwise stats are not printed)&#39;, action=&#39;store_true&#39;, default=False, dest=&#39;print_stats&#39;)\n(options, args) = parser.parse_args()\n\nrandom.seed(options.seed)\n\nprocess_switch_behavior = SCHED_SWITCH_ON_IO\nio_done_behavior = IO_RUN_LATER\nio_length=options.io_length\n\n\ns = scheduler(process_switch_behavior, io_done_behavior, io_length)\n\n# example process description (10:100,10:100)\nfor p in options.process_list.split(&#39;,&#39;):\n    s.load(p)\n\nprint &#39;Produce a trace of what would happen when you run these processes:&#39;\nfor pid in range(s.get_num_processes()):\n    print &#39;Process %d&#39; % pid\n    for inst in range(s.get_num_instructions(pid)):\n        print &#39;  %s&#39; % s.get_instruction(pid, inst)\n    print &#39;&#39;\nprint &#39;Important behaviors:&#39;\nprint &#39;  System will switch when&#39;,\nif process_switch_behavior == SCHED_SWITCH_ON_IO:\n    print &#39;the current process is FINISHED or ISSUES AN YIELD or IO&#39;\nelse:\n    print &#39;error in sched switch on iobehavior&#39;\n    exit (-1)\nprint &#39;  After IOs, the process issuing the IO will&#39;,\nif io_done_behavior == IO_RUN_LATER:\n    print &#39;run LATER (when it is its turn)&#39;\nelse:\n    print &#39;error in IO done behavior&#39;\n    exit (-1)\nprint &#39;&#39;\n\n(cpu_busy, io_busy, clock_tick) = s.run()\n\nprint &#39;&#39;\nprint &#39;Stats: Total Time %d&#39; % clock_tick\nprint &#39;Stats: CPU Busy %d (%.2f%%)&#39; % (cpu_busy, 100.0 * float(cpu_busy)/clock_tick)\nprint &#39;Stats: IO Busy  %d (%.2f%%)&#39; % (io_busy, 100.0 * float(io_busy)/clock_tick)\nprint &#39;&#39;</pre>\n<p></p>", "created": "2015-04-08T09:40:59Z", "bucket_order": 265, "bucket_name": "Week 4/5 - 4/11", "type": "feedback", "tag_good": [], "uid": "i6tezdpdQbq", "children": [], "tag_good_arr": [], "id": "i88jptygm6z368", "updated": "2015-04-08T09:40:59Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "i88bskwx4k51xe", "updated": "2015-04-08T05:59:11Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>覃伟 2012011278</p>\n<p>徐天宇 2012011275</p>\n<p></p>\n<pre>#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\n\n# process switch behavior\nSCHED_SWITCH_ON_IO = &#39;SWITCH_ON_IO&#39;\n\n# io finished behavior\nIO_RUN_LATER = &#39;IO_RUN_LATER&#39;\n\n# process states\nSTATE_RUNNING = &#39;RUNNING&#39;\nSTATE_READY = &#39;READY&#39;\nSTATE_DONE = &#39;DONE&#39;\nSTATE_WAIT = &#39;WAITING&#39;\n\n# members of process structure\nPROC_CODE = &#39;code_&#39;\nPROC_PC = &#39;pc_&#39;\nPROC_ID = &#39;pid_&#39;\nPROC_STATE = &#39;proc_state_&#39;\n\n# things a process can do\nDO_COMPUTE = &#39;cpu&#39;\nDO_YIELD = &#39;yld&#39;\nDO_IO = &#39;io&#39;\n\nclass scheduler:\n    def __init__(self, process_switch_behavior, io_done_behavior, io_length):\n        # keep set of instructions for each of the processes\n        self.proc_info = {}\n        self.process_switch_behavior = process_switch_behavior\n        self.io_done_behavior = io_done_behavior\n        self.io_length = io_length\n        return\n\n    def new_process(self):\n        proc_id = len(self.proc_info)\n        self.proc_info[proc_id] = {}\n        self.proc_info[proc_id][PROC_PC] = 0\n        self.proc_info[proc_id][PROC_ID] = proc_id\n        self.proc_info[proc_id][PROC_CODE] = []\n        self.proc_info[proc_id][PROC_STATE] = STATE_READY\n        return proc_id\n\n    def load(self, program_description):\n        proc_id = self.new_process()\n        tmp = program_description.split(&#39;:&#39;)\n        if len(tmp) != 3:\n            print &#39;Bad description (%s): Must be number &lt;x:y:z&gt;&#39;\n            print &#39;  where X is the number of instructions&#39;\n            print &#39;  and Y is the percent change that an instruction is YIELD&#39;\n            print &#39;  and Z is the percent change that an instruction is IO&#39;\n            exit(1)\n\n        num_instructions, chance_yield, chance_io = int(tmp[0]), float(tmp[1])/100.0, float(tmp[2])/100.0\n        assert(chance_yield&#43;chance_io&lt;1)\n\n        #print &#34;proc %d, num_instr %d, change_cpu %f&#34; % (proc_id,num_instructions, chance_cpu)\n        for i in range(num_instructions):\n            randnum=random.random();\n            if randnum &lt; (1.0-chance_yield-chance_io):\n                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)\n            elif randnum &gt;= (1.0-chance_yield-chance_io) and randnum &lt; (1.0-chance_io):\n                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)\n            else:\n                self.proc_info[proc_id][PROC_CODE].append(DO_IO)\n            #print &#34;proc %d, instr idx %d, instr cxt %s&#34; % (proc_id, i, self.proc_info[proc_id][PROC_CODE][i])\n        return\n\n    #change to READY STATE, the current proc&#39;s state should be expected\n    #if pid==-1, then pid=self.curr_proc\n    def move_to_ready(self, expected, pid=-1):\n        #YOUR CODE\n        temp = self.curr_proc\n        if pid!=-1:\n            temp = pid\n        if self.proc_info[temp][PROC_STATE]==expected:\n            self.proc_info[temp][PROC_STATE] = STATE_READY\n        else:\n            print &#39;move_to_ready error&#39;\n        return\n\n    #change to RUNNING STATE, the current proc&#39;s state should be expected\n    def move_to_running(self, expected):\n        #YOUR CODE\n        if self.proc_info[self.curr_proc][PROC_STATE] == expected:\n            self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING\n        else:\n            print &#39;move_to_running error&#39;\n        return\n\n    #change to DONE STATE, the current proc&#39;s state should be expected\n    def move_to_done(self, expected):\n        #YOUR CODE\n        if self.proc_info[self.curr_proc][PROC_STATE] == expected:\n            self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE\n        else:\n            print &#39;move_to_done error&#39;\n        return\n\n    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc\n    def next_proc(self, pid=-1):\n        #YOUR CODE\n        if pid != -1:\n            self.curr_proc = pid\n        roundTime=1\n        self.curr_proc = (self.curr_proc&#43;1)%len(self.proc_info)\n        while self.proc_info[self.curr_proc][PROC_STATE] != STATE_READY:\n            self.curr_proc = (self.curr_proc&#43;1)%len(self.proc_info)\n            roundTime&#43;=1\n            if roundTime==len(self.proc_info):\n                break\n        if self.proc_info[self.curr_proc][PROC_STATE] == STATE_READY:\n            self.move_to_running(STATE_READY)\n        return\n\n    def get_num_processes(self):\n        return len(self.proc_info)\n\n    def get_num_instructions(self, pid):\n        return len(self.proc_info[pid][PROC_CODE])\n\n    def get_instruction(self, pid, index):\n        return self.proc_info[pid][PROC_CODE][index]\n\n    def get_num_active(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] != STATE_DONE:\n                num_active &#43;= 1\n        return num_active\n\n    def get_num_runnable(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\\n                   self.proc_info[pid][PROC_STATE] == STATE_RUNNING:\n                num_active &#43;= 1\n        return num_active\n\n    def get_ios_in_flight(self, current_time):\n        num_in_flight = 0\n        for pid in range(len(self.proc_info)):\n            for t in self.io_finish_times[pid]:\n                if t &gt; current_time:\n                    num_in_flight &#43;= 1\n        return num_in_flight\n\n\n    def space(self, num_columns):\n        for i in range(num_columns):\n            print &#39;%10s&#39; % &#39; &#39;,\n\n    def check_if_done(self):\n        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n                self.move_to_done(STATE_RUNNING)\n                self.next_proc()\n        return\n\n    def run(self):\n        clock_tick = 0\n\n        if len(self.proc_info) == 0:\n            return\n\n        # track outstanding IOs, per process\n        self.io_finish_times = {}\n        for pid in range(len(self.proc_info)):\n            self.io_finish_times[pid] = []\n\n        # make first one active\n        self.curr_proc = 0\n        self.move_to_running(STATE_READY)\n\n        # OUTPUT: heade&#96;[rs for each column\n        print &#39;%s&#39; % &#39;Time&#39;, \n        for pid in range(len(self.proc_info)):\n            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),\n        print &#39;%10s&#39; % &#39;CPU&#39;,\n        print &#39;%10s&#39; % &#39;IOs&#39;,\n        print &#39;&#39;\n\n        # init statistics\n        io_busy = 0\n        cpu_busy = 0\n\n        while self.get_num_active() &gt; 0:\n            clock_tick &#43;= 1\n\n            # check for io finish\n            io_done = False\n            for pid in range(len(self.proc_info)):\n                if clock_tick in self.io_finish_times[pid]:\n                    # if IO finished, the should do something for related process\n       \t            #YOUR CODE\n       \t            self.proc_info[pid][PROC_STATE] = STATE_READY\n       \t            self.next_proc()\n       \t            io_done = True\n       \t            #self.io_done_behavior = IO_RUN_LATER\n                    #pass #YOU should delete this\n            \n            # if current proc is RUNNING and has an instruction, execute it\n            instruction_to_execute = &#39;&#39;\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n                   len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                #pop a instruction from proc_info[self.curr_proc][PROC_CODE]to instruction_to_execute\n                #YOUR CODE\n                instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)\n                self.proc_info[self.curr_proc][PROC_PC] &#43;= 1\n                #pass #YOU should delete this\n\n            # OUTPUT: print what everyone is up to\n            if io_done:\n                print &#39;%3d*&#39; % clock_tick,\n            else:\n                print &#39;%3d &#39; % clock_tick,\n            for pid in range(len(self.proc_info)):\n                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n                    print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),\n                else:\n                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),\n            if instruction_to_execute == &#39;&#39;:\n                print &#39;%10s&#39; % &#39; &#39;,\n            else:\n                print &#39;%10s&#39; % 1,\n            num_outstanding = self.get_ios_in_flight(clock_tick)\n            if num_outstanding &gt; 0:\n                print &#39;%10s&#39; % str(num_outstanding),\n                io_busy &#43;= 1\n            else:\n                print &#39;%10s&#39; % &#39; &#39;,\n            print &#39;&#39;\n\n            # if this is an YIELD instruction, switch to ready state\n            # and add an io completion in the future\n            if instruction_to_execute == DO_YIELD:\n                #YOUR CODE\n                self.move_to_ready(STATE_RUNNING)\n                self.next_proc()\n                #pass #YOU should delete this\n            # if this is an IO instruction, switch to waiting state\n            # and add an io completion in the future\n            elif instruction_to_execute == DO_IO:\n                #YOUR CODE\n       \t        self.proc_info[self.curr_proc][PROC_STATE] = STATE_WAIT\n                self.io_finish_times[self.curr_proc].append(clock_tick&#43;self.io_length&#43;1)\n                #self.process_switch_behavior = SCHED_SWITCH_ON_IO\n                self.next_proc()\n                #pass #YOU should delete this\n\n            # ENDCASE: check if currently running thing is out of instructions\n            self.check_if_done()\n            &#39;&#39;&#39;\n            for pid in range(len(self.proc_info)):\n                print &#39;qw...&#39;\n                print self.proc_info[pid][PROC_STATE]\n            &#39;&#39;&#39;\n        return (cpu_busy, io_busy, clock_tick)\n        \n#\n# PARSE ARGUMENTS\n#\n\nparser = OptionParser()\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0, help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)\nparser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,\n                  help=&#39;a comma-separated list of processes to run, in the form X1:Y1:Z1,X2:Y2:Z2,... where X is the number of instructions that process should run, </pre>", "created": "2015-04-08T06:00:45Z", "bucket_order": 265, "bucket_name": "Week 4/5 - 4/11", "type": "followup", "tag_good": [], "uid": "i7bfq2txxyw689", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>最终修正后的正确代码&#xff1a;</p>\n<p></p>\n<pre>#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\n\n# process switch behavior\nSCHED_SWITCH_ON_IO = &#39;SWITCH_ON_IO&#39;\n\n# io finished behavior\nIO_RUN_LATER = &#39;IO_RUN_LATER&#39;\n\n# process states\nSTATE_RUNNING = &#39;RUNNING&#39;\nSTATE_READY = &#39;READY&#39;\nSTATE_DONE = &#39;DONE&#39;\nSTATE_WAIT = &#39;WAITING&#39;\n\n# members of process structure\nPROC_CODE = &#39;code_&#39;\nPROC_PC = &#39;pc_&#39;\nPROC_ID = &#39;pid_&#39;\nPROC_STATE = &#39;proc_state_&#39;\n\n# things a process can do\nDO_COMPUTE = &#39;cpu&#39;\nDO_YIELD = &#39;yld&#39;\nDO_IO = &#39;io&#39;\n\nclass scheduler:\n    def __init__(self, process_switch_behavior, io_done_behavior, io_length):\n        # keep set of instructions for each of the processes\n        self.proc_info = {}\n        self.process_switch_behavior = process_switch_behavior\n        self.io_done_behavior = io_done_behavior\n        self.io_length = io_length\n        return\n\n    def new_process(self):\n        proc_id = len(self.proc_info)\n        self.proc_info[proc_id] = {}\n        self.proc_info[proc_id][PROC_PC] = 0\n        self.proc_info[proc_id][PROC_ID] = proc_id\n        self.proc_info[proc_id][PROC_CODE] = []\n        self.proc_info[proc_id][PROC_STATE] = STATE_READY\n        return proc_id\n\n    def load(self, program_description):\n        proc_id = self.new_process()\n        tmp = program_description.split(&#39;:&#39;)\n        if len(tmp) != 3:\n            print &#39;Bad description (%s): Must be number &lt;x:y:z&gt;&#39;\n            print &#39;  where X is the number of instructions&#39;\n            print &#39;  and Y is the percent change that an instruction is YIELD&#39;\n            print &#39;  and Z is the percent change that an instruction is IO&#39;\n            exit(1)\n\n        num_instructions, chance_yield, chance_io = int(tmp[0]), float(tmp[1])/100.0, float(tmp[2])/100.0\n        assert(chance_yield&#43;chance_io&lt;1)\n\n        #print &#34;proc %d, num_instr %d, change_cpu %f&#34; % (proc_id,num_instructions, chance_cpu)\n        for i in range(num_instructions):\n            randnum=random.random();\n            if randnum &lt; (1.0-chance_yield-chance_io):\n                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)\n            elif randnum &gt;= (1.0-chance_yield-chance_io) and randnum &lt; (1.0-chance_io):\n                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)\n            else:\n                self.proc_info[proc_id][PROC_CODE].append(DO_IO)\n            #print &#34;proc %d, instr idx %d, instr cxt %s&#34; % (proc_id, i, self.proc_info[proc_id][PROC_CODE][i])\n        return\n\n    #change to READY STATE, the current proc&#39;s state should be expected\n    #if pid==-1, then pid=self.curr_proc\n    def move_to_ready(self, expected, pid=-1):\n        #YOUR CODE\n        temp = self.curr_proc\n        if pid!=-1:\n            temp = pid\n        if self.proc_info[temp][PROC_STATE]==expected:\n            self.proc_info[temp][PROC_STATE] = STATE_READY\n        else:\n            print &#39;move_to_ready error&#39;\n        return\n\n    #change to RUNNING STATE, the current proc&#39;s state should be expected\n    def move_to_running(self, expected):\n        #YOUR CODE\n        if self.proc_info[self.curr_proc][PROC_STATE] == expected:\n            self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING\n        else:\n            print &#39;move_to_running error&#39;\n        return\n\n    #change to DONE STATE, the current proc&#39;s state should be expected\n    def move_to_done(self, expected):\n        #YOUR CODE\n        if self.proc_info[self.curr_proc][PROC_STATE] == expected:\n            self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE\n        else:\n            print &#39;move_to_done error&#39;\n        return\n\n    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc\n    def next_proc(self, pid=-1):\n        #YOUR CODE\n        if pid != -1:\n            self.curr_proc = pid\n        roundTime=1\n        self.curr_proc = (self.curr_proc&#43;1)%len(self.proc_info)\n        while self.proc_info[self.curr_proc][PROC_STATE] != STATE_READY:\n            self.curr_proc = (self.curr_proc&#43;1)%len(self.proc_info)\n            roundTime&#43;=1\n            if roundTime==len(self.proc_info):\n                break\n        if self.proc_info[self.curr_proc][PROC_STATE] == STATE_READY:\n            self.move_to_running(STATE_READY)\n        return\n\n    def get_num_processes(self):\n        return len(self.proc_info)\n\n    def get_num_instructions(self, pid):\n        return len(self.proc_info[pid][PROC_CODE])\n\n    def get_instruction(self, pid, index):\n        return self.proc_info[pid][PROC_CODE][index]\n\n    def get_num_active(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] != STATE_DONE:\n                num_active &#43;= 1\n        return num_active\n\n    def get_num_runnable(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\\n                   self.proc_info[pid][PROC_STATE] == STATE_RUNNING:\n                num_active &#43;= 1\n        return num_active\n\n    def get_ios_in_flight(self, current_time):\n        num_in_flight = 0\n        for pid in range(len(self.proc_info)):\n            for t in self.io_finish_times[pid]:\n                if t &gt; current_time:\n                    num_in_flight &#43;= 1\n        return num_in_flight\n\n\n    def space(self, num_columns):\n        for i in range(num_columns):\n            print &#39;%10s&#39; % &#39; &#39;,\n\n    def check_if_done(self):\n        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n                self.move_to_done(STATE_RUNNING)\n                self.next_proc()\n        return\n\n    def run(self):\n        clock_tick = 0\n\n        if len(self.proc_info) == 0:\n            return\n\n        # track outstanding IOs, per process\n        self.io_finish_times = {}\n        for pid in range(len(self.proc_info)):\n            self.io_finish_times[pid] = []\n\n        # make first one active\n        self.curr_proc = 0\n        self.move_to_running(STATE_READY)\n\n        # OUTPUT: heade&#96;[rs for each column\n        print &#39;%s&#39; % &#39;Time&#39;, \n        for pid in range(len(self.proc_info)):\n            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),\n        print &#39;%10s&#39; % &#39;CPU&#39;,\n        print &#39;%10s&#39; % &#39;IOs&#39;,\n        print &#39;&#39;\n\n        # init statistics\n        io_busy = 0\n        cpu_busy = 0\n\n        while self.get_num_active() &gt; 0:\n            clock_tick &#43;= 1\n\n            # check for io finish\n            io_done = False\n            for pid in range(len(self.proc_info)):\n                if clock_tick in self.io_finish_times[pid]:\n                    # if IO finished, the should do something for related process\n       \t            #YOUR CODE\n       \t            self.proc_info[pid][PROC_STATE] = STATE_READY\n       \t            if self.proc_info[self.curr_proc][PROC_STATE] != STATE_RUNNING:\n       \t                self.curr_proc = pid\n       \t                self.proc_info[pid][PROC_STATE] = STATE_RUNNING\n       \t            #    self.proc_info[self.curr_proc][PROC_STATE] = STATE_READY\n       \t            #self.next_proc()\n       \t            io_done = True\n       \t            #self.io_done_behavior = IO_RUN_LATER\n                    #pass #YOU should delete this\n            \n            # if current proc is RUNNING and has an instruction, execute it\n            instruction_to_execute = &#39;&#39;\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n                   len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                #pop a instruction from proc_info[self.curr_proc][PROC_CODE]to instruction_to_execute\n                #YOUR CODE\n                instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)\n                self.proc_info[self.curr_proc][PROC_PC] &#43;= 1\n                #pass #YOU should delete this\n\n            # OUTPUT: print what everyone is up to\n            if io_done:\n                print &#39;%3d*&#39; % clock_tick,\n            else:\n                print &#39;%3d &#39; % clock_tick,\n            for pid in range(len(self.proc_info)):\n                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n                    print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),\n                else:\n                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),\n            if instruction_to_execute == &#39;&#39;:\n                print &#39;%10s&#39; % &#39; &#39;,\n            else:\n                print &#39;%10s&#39; % 1,\n                cpu_busy&#43;=1\n            num_outstanding = self.get_ios_in_flight(clock_tick)\n            if num_outstanding &gt; 0:\n                print &#39;%10s&#39; % str(num_outstanding),\n                io_busy &#43;= 1\n            else:\n                print &#39;%10s&#39; % &#39; &#39;,\n            print &#39;&#39;\n\n            # if this is an YIELD instruction, switch to ready state\n            # and add an io completion in the future\n            if instruction_to_execute == DO_YIELD:\n                #YOUR CODE\n                self.move_to_ready(STATE_RUNNING)\n                self.next_proc()\n                #pass #YOU should delete this\n            # if this is an IO instruction, switch to waiting state\n            # and add an io completion in the future\n            elif instruction_to_execute == DO_IO:\n                #YOUR CODE\n       \t        self.proc_info[self.curr_proc][PROC_STATE] = STATE_WAIT\n                self.io_finish_times[self.curr_proc].append(clock_tick&#43;self.io_length)\n                #self.process_switch_behavior = SCHED_SWITCH_ON_IO\n                self.next_proc()\n                #pass #YOU should delete this\n\n            # ENDCASE: check if currently running thing is out of instructions\n            self.check_if_done()\n            &#39;&#39;&#39;\n            for pid in range(len(self.proc_info)):\n                print &#39;qw...&#39;\n                print self.proc_info[pid][PROC_STATE]\n            &#39;&#39;&#39;\n        return (cpu_busy, io_busy, clock_tick)\n        \n#\n# PARSE ARGUMENTS\n#\n\nparser = OptionParser()\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=</pre>", "created": "2015-04-08T06:42:07Z", "bucket_order": 265, "bucket_name": "Week 4/5 - 4/11", "type": "feedback", "tag_good": [], "uid": "i7bfq2txxyw689", "children": [], "tag_good_arr": [], "id": "i88dbt20a51cn", "updated": "2015-04-08T06:42:07Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "i88bulof3if5n6", "updated": "2015-04-08T06:00:45Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>马晓彬 2012011402</p>\n<pre>#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\n\n# process switch behavior\nSCHED_SWITCH_ON_IO = &#39;SWITCH_ON_IO&#39;\n\n# io finished behavior\nIO_RUN_LATER = &#39;IO_RUN_LATER&#39;\n\n# process states\nSTATE_RUNNING = &#39;RUNNING&#39;\nSTATE_READY = &#39;READY&#39;\nSTATE_DONE = &#39;DONE&#39;\nSTATE_WAIT = &#39;WAITING&#39;\n\n# members of process structure\nPROC_CODE = &#39;code_&#39;\nPROC_PC = &#39;pc_&#39;\nPROC_ID = &#39;pid_&#39;\nPROC_STATE = &#39;proc_state_&#39;\n\n# things a process can do\nDO_COMPUTE = &#39;cpu&#39;\nDO_YIELD = &#39;yld&#39;\nDO_IO = &#39;io&#39;\n\nclass scheduler:\n    def __init__(self, process_switch_behavior, io_done_behavior, io_length):\n        # keep set of instructions for each of the processes\n        self.proc_info = {}\n        self.process_switch_behavior = process_switch_behavior\n        self.io_done_behavior = io_done_behavior\n        self.io_length = io_length\n        return\n\n    def new_process(self):\n        proc_id = len(self.proc_info)\n        self.proc_info[proc_id] = {}\n        self.proc_info[proc_id][PROC_PC] = 0\n        self.proc_info[proc_id][PROC_ID] = proc_id\n        self.proc_info[proc_id][PROC_CODE] = []\n        self.proc_info[proc_id][PROC_STATE] = STATE_READY\n        return proc_id\n\n    def load(self, program_description):\n        proc_id = self.new_process()\n        tmp = program_description.split(&#39;:&#39;)\n        if len(tmp) != 3:\n            print &#39;Bad description (%s): Must be number &lt;x:y:z&gt;&#39;\n            print &#39;  where X is the number of instructions&#39;\n            print &#39;  and Y is the percent change that an instruction is YIELD&#39;\n            print &#39;  and Z is the percent change that an instruction is IO&#39;\n            exit(1)\n\n        num_instructions, chance_yield, chance_io = int(tmp[0]), float(tmp[1])/100.0, float(tmp[2])/100.0\n        assert(chance_yield&#43;chance_io&lt;1)\n\n        #print &#34;proc %d, num_instr %d, change_cpu %f&#34; % (proc_id,num_instructions, chance_cpu)\n        for i in range(num_instructions):\n            randnum=random.random();\n            if randnum &lt; (1.0-chance_yield-chance_io):\n                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)\n            elif randnum &gt;= (1.0-chance_yield-chance_io) and randnum &lt; (1.0-chance_io):\n                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)\n            else:\n                self.proc_info[proc_id][PROC_CODE].append(DO_IO)\n            #print &#34;proc %d, instr idx %d, instr cxt %s&#34; % (proc_id, i, self.proc_info[proc_id][PROC_CODE][i])\n        return\n\n    #change to READY STATE, the current proc&#39;s state should be expected\n    #if pid==-1, then pid=self.curr_proc\n    def move_to_ready(self, expected, pid=-1):\n        #YOUR CODE\n        if pid == -1:\n            pid = self.curr_proc\n        assert expected == self.proc_info[pid][PROC_STATE]\n        self.proc_info[pid][PROC_STATE] = STATE_READY\n        return\n\n    #change to RUNNING STATE, the current proc&#39;s state should be expected\n    def move_to_running(self, expected):\n        #YOUR CODE\n        assert(STATE_READY == expected)\n        self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING\n        return\n\n    #change to DONE STATE, the current proc&#39;s state should be expected\n    def move_to_done(self, expected):\n        #YOUR CODE\n        assert expected == STATE_RUNNING\n        #print &#39;done&#39;\n        #print self.proc_info[self.curr_proc][PROC_STATE]\n        self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE\n        return\n\n    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc\n    def next_proc(self, pid=-1):\n        #YOUR CODE\n        if pid == -1:\n            pid = self.curr_proc\n        num_process = len(self.proc_info)\n\n        for i in range(1,num_process) :\n          if self.proc_info[(i&#43;pid)%num_process][PROC_STATE] == STATE_READY :\n            self.curr_proc = (i&#43;pid)%num_process\n            \n        if self.proc_info[self.curr_proc][PROC_STATE] != STATE_DONE and  self.proc_info[self.curr_proc][PROC_STATE] != STATE_WAIT:\n            self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING\n        return\n\n    def get_num_processes(self):\n        return len(self.proc_info)\n\n    def get_num_instructions(self, pid):\n        return len(self.proc_info[pid][PROC_CODE])\n\n    def get_instruction(self, pid, index):\n        return self.proc_info[pid][PROC_CODE][index]\n\n    def get_num_active(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] != STATE_DONE:\n                num_active &#43;= 1\n        return num_active\n\n    def get_num_runnable(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\\n                   self.proc_info[pid][PROC_STATE] == STATE_RUNNING:\n                num_active &#43;= 1\n        return num_active\n\n    def get_ios_in_flight(self, current_time):\n        num_in_flight = 0\n        for pid in range(len(self.proc_info)):\n            for t in self.io_finish_times[pid]:\n                if t &gt; current_time:\n                    num_in_flight &#43;= 1\n        return num_in_flight\n\n\n    def space(self, num_columns):\n        for i in range(num_columns):\n            print &#39;%10s&#39; % &#39; &#39;,\n\n    def check_if_done(self):\n        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n                self.move_to_done(STATE_RUNNING)\n                self.next_proc()\n        return\n\n    def run(self):\n        clock_tick = 0\n\n        if len(self.proc_info) == 0:\n            return\n\n        # track outstanding IOs, per process\n        self.io_finish_times = {}\n        for pid in range(len(self.proc_info)):\n            self.io_finish_times[pid] = []\n\n        # make first one active\n        self.curr_proc = 0\n        self.move_to_running(STATE_READY)\n\n        # OUTPUT: heade&#96;[rs for each column\n        print &#39;%s&#39; % &#39;Time&#39;, \n        for pid in range(len(self.proc_info)):\n            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),\n        print &#39;%10s&#39; % &#39;CPU&#39;,\n        print &#39;%10s&#39; % &#39;IOs&#39;,\n        print &#39;&#39;\n\n        # init statistics\n        io_busy = 0\n        cpu_busy = 0\n\n        while self.get_num_active() &gt; 0:\n            clock_tick &#43;= 1\n\n            # check for io finish\n            io_done = False\n            for pid in range(len(self.proc_info)):\n                if clock_tick in self.io_finish_times[pid]:\n                    # if IO finished, the should do something for related process\n                    #YOUR CODE\n                    self.move_to_ready(STATE_WAIT,pid)\n                    self.next_proc()\n                    io_done = True\n            \n            # if current proc is RUNNING and has an instruction, execute it\n            instruction_to_execute = &#39;&#39;\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n                   len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                #pop a instruction from proc_info[self.curr_proc][PROC_CODE]to instruction_to_execute\n                #YOUR CODE\n                instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)\n\n            # OUTPUT: print what everyone is up to\n            if io_done:\n                print &#39;%3d*&#39; % clock_tick,\n            else:\n                print &#39;%3d &#39; % clock_tick,\n            for pid in range(len(self.proc_info)):\n                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n                    print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),\n                    cpu_busy &#43;= 1\n                else:\n                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),\n            if instruction_to_execute == &#39;&#39;:\n                print &#39;%10s&#39; % &#39; &#39;,\n            else:\n                print &#39;%10s&#39; % 1,\n            num_outstanding = self.get_ios_in_flight(clock_tick)\n            if num_outstanding &gt; 0:\n                print &#39;%10s&#39; % str(num_outstanding),\n                io_busy &#43;= 1\n            else:\n                print &#39;%10s&#39; % &#39; &#39;,\n            print &#39;&#39;\n\n            # if this is an YIELD instruction, switch to ready state\n            # and add an io completion in the future\n            if instruction_to_execute == DO_YIELD:\n                #YOUR CODE\n                self.move_to_ready(STATE_RUNNING)\n                self.next_proc()\n\n            # if this is an IO instruction, switch to waiting state\n            # and add an io completion in the future\n            elif instruction_to_execute == DO_IO:\n                #YOUR CODE\n                self.proc_info[self.curr_proc][PROC_STATE] = STATE_WAIT\n                #print self.curr_proc\n                self.io_finish_times[self.curr_proc].append(clock_tick&#43;io_length&#43;1)\n                self.next_proc()\n\n            # ENDCASE: check if currently running thing is out of instructions\n            self.check_if_done()\n            raw_input()\n        return (cpu_busy, io_busy, clock_tick)\n        \n#\n# PARSE ARGUMENTS\n#\n\nparser = OptionParser()\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0, help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)\nparser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,\n                  help=&#39;a comma-separated list of processes to run, in the form X1:Y1:Z1,X2:Y2:Z2,... where X is the number of instructions that process should run, and Y/Z the chances (from 0 to 100) issue an YIELD/IO&#39;,\n                  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)\nparser.add_option(&#39;-L&#39;, &#39;--iolength&#39;, default=3, help=&#39;how long an IO takes&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;io_length&#39;)\nparser.add_option(&#39;-p&#39;, &#39;--printstats&#39;, help=&#39;print statistics at end; only useful with -c flag (otherwise stats are not printed)&#39;, action=&#39;store_true&#39;, default=False, dest=&#39;print_stats&#39;)\n(options, args) = parser.parse_args()\n\nrandom.seed(options.seed)\n\nprocess_switch_behavior = SCHED_SWITCH_ON_IO<br />\nio_done_behavior = IO_RUN_LATER\nio_length=options.io_</pre>", "created": "2015-04-08T06:05:47Z", "bucket_order": 265, "bucket_name": "Week 4/5 - 4/11", "type": "followup", "tag_good": [], "uid": "i6uswob7jl4242", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i88c12lpk783tb", "updated": "2015-04-08T06:05:47Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>李国豪 2012011303<br />金嘉宇 2012080059</p>\n<pre>#! /usr/bin/env python<br /><br />import sys<br />from optparse import OptionParser<br />import random<br /><br /># process switch behavior<br />SCHED_SWITCH_ON_IO = &#39;SWITCH_ON_IO&#39;<br /><br /># io finished behavior<br />IO_RUN_LATER = &#39;IO_RUN_LATER&#39;<br /><br /># process states<br />STATE_RUNNING = &#39;RUNNING&#39;<br />STATE_READY = &#39;READY&#39;<br />STATE_DONE = &#39;DONE&#39;<br />STATE_WAIT = &#39;WAITING&#39;<br /><br /># members of process structure<br />PROC_CODE = &#39;code_&#39;<br />PROC_PC = &#39;pc_&#39;<br />PROC_ID = &#39;pid_&#39;<br />PROC_STATE = &#39;proc_state_&#39;<br /><br /># things a process can do<br />DO_COMPUTE = &#39;cpu&#39;<br />DO_YIELD = &#39;yld&#39;<br />DO_IO = &#39;io&#39;<br /><br />class scheduler:<br />    def __init__(self, process_switch_behavior, io_done_behavior, io_length):<br />        # keep set of instructions for each of the processes<br />        self.proc_info = {}<br />        self.process_switch_behavior = process_switch_behavior<br />        self.io_done_behavior = io_done_behavior<br />        self.io_length = io_length<br />        return<br /><br />    def new_process(self):<br />        proc_id = len(self.proc_info)<br />        self.proc_info[proc_id] = {}<br />        self.proc_info[proc_id][PROC_PC] = 0<br />        self.proc_info[proc_id][PROC_ID] = proc_id<br />        self.proc_info[proc_id][PROC_CODE] = []<br />        self.proc_info[proc_id][PROC_STATE] = STATE_READY<br />        return proc_id<br /><br />    def load(self, program_description):<br />        proc_id = self.new_process()<br />        tmp = program_description.split(&#39;:&#39;)<br />        if len(tmp) != 3:<br />            print &#39;Bad description (%s): Must be number &lt;x:y:z&gt;&#39;<br />            print &#39;  where X is the number of instructions&#39;<br />            print &#39;  and Y is the percent change that an instruction is YIELD&#39;<br />            print &#39;  and Z is the percent change that an instruction is IO&#39;<br />            exit(1)<br /><br />        num_instructions, chance_yield, chance_io = int(tmp[0]), float(tmp[1])/100.0, float(tmp[2])/100.0<br />        assert(chance_yield&#43;chance_io&lt;1)<br /><br />        #print &#34;proc %d, num_instr %d, change_cpu %f&#34; % (proc_id,num_instructions, chance_cpu)<br />        for i in range(num_instructions):<br />            randnum=random.random();<br />            if randnum &lt; (1.0-chance_yield-chance_io):<br />                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)<br />            elif randnum &gt;= (1.0-chance_yield-chance_io) and randnum &lt; (1.0-chance_io):<br />                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)<br />            else:<br />                self.proc_info[proc_id][PROC_CODE].append(DO_IO)<br />            #print &#34;proc %d, instr idx %d, instr cxt %s&#34; % (proc_id, i, self.proc_info[proc_id][PROC_CODE][i])<br />        return<br /><br />    #change to READY STATE, the current proc&#39;s state should be expected<br />    #if pid==-1, then pid=self.curr_proc<br />    def move_to_ready(self, expected, pid=-1):<br />        #YOUR CODE<br />        if expected == STATE_DONE:<br />            assert False<br />        if pid == -1:<br />            pid = self.curr_proc<br />        self.proc_info[pid][PROC_STATE] = STATE_READY<br />        return<br /><br />    #change to RUNNING STATE, the current proc&#39;s state should be expected<br />    def move_to_running(self, expected):<br />        #YOUR CODE<br />        if expected == STATE_DONE:<br />            assert False<br />        self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING<br />        return<br /><br />    #change to DONE STATE, the current proc&#39;s state should be expected<br />    def move_to_done(self, expected):<br />        #YOUR CODE<br />        if expected == STATE_DONE:<br />            assert False<br />        self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE<br />        return<br /><br />    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc<br />    def next_proc(self, pid=-1):<br />        #YOUR CODE<br />        curr_id = self.curr_proc<br />        next_id = (curr_id &#43; 1) % len(self.proc_info)<br />        while next_id != curr_id:<br />            if self.proc_info[next_id][PROC_STATE] == STATE_READY:<br />                break<br />            next_id = (next_id &#43; 1) % len(self.proc_info)<br />        if self.proc_info[next_id][PROC_STATE] == STATE_READY:<br />            self.curr_proc = next_id<br />            self.proc_info[next_id][PROC_ID] = next_id<br />            self.proc_info[next_id][PROC_STATE] = STATE_RUNNING<br />        return<br /><br />    def get_num_processes(self):<br />        return len(self.proc_info)<br /><br />    def get_num_instructions(self, pid):<br />        return len(self.proc_info[pid][PROC_CODE])<br /><br />    def get_instruction(self, pid, index):<br />        return self.proc_info[pid][PROC_CODE][index]<br /><br />    def get_num_active(self):<br />        num_active = 0<br />        for pid in range(len(self.proc_info)):<br />            if self.proc_info[pid][PROC_STATE] != STATE_DONE:<br />                num_active &#43;= 1<br />        return num_active<br /><br />    def get_num_runnable(self):<br />        num_active = 0<br />        for pid in range(len(self.proc_info)):<br />            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\<br />                   self.proc_info[pid][PROC_STATE] == STATE_RUNNING:<br />                num_active &#43;= 1<br />        return num_active<br /><br />    def get_ios_in_flight(self, current_time):<br />        num_in_flight = 0<br />        for pid in range(len(self.proc_info)):<br />            for t in self.io_finish_times[pid]:<br />                if t &gt; current_time:<br />                    num_in_flight &#43;= 1<br />        return num_in_flight<br /><br /><br />    def space(self, num_columns):<br />        for i in range(num_columns):<br />            print &#39;%10s&#39; % &#39; &#39;,<br /><br />    def check_if_done(self):<br />        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:<br />            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:<br />                self.move_to_done(STATE_RUNNING)<br />                self.next_proc()<br />        return<br /><br />    def run(self):<br />        clock_tick = 0<br /><br />        if len(self.proc_info) == 0:<br />            return<br /><br />        # track outstanding IOs, per process<br />        self.io_finish_times = {}<br />        for pid in range(len(self.proc_info)):<br />            self.io_finish_times[pid] = []<br /><br />        # make first one active<br />        self.curr_proc = 0<br />        self.move_to_running(STATE_READY)<br /><br />        # OUTPUT: heade&#96;[rs for each column<br />        print &#39;%s&#39; % &#39;Time&#39;, <br />        for pid in range(len(self.proc_info)):<br />            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),<br />        print &#39;%10s&#39; % &#39;CPU&#39;,<br />        print &#39;%10s&#39; % &#39;IOs&#39;,<br />        print &#39;&#39;<br /><br />        # init statistics<br />        io_busy = 0<br />        cpu_busy = 0<br /><br />        while self.get_num_active() &gt; 0:<br />            clock_tick &#43;= 1<br /><br />            # check for io finish<br />            io_done = False<br />            for pid in range(len(self.proc_info)):<br />                if clock_tick in self.io_finish_times[pid]:<br />                    # if IO finished, the should do something for related process<br />       \t            #YOUR CODE<br />                    io_done = True<br />                    self.io_finish_times[pid].remove(clock_tick)<br />                    self.proc_info[pid][PROC_STATE] = STATE_READY<br />                    if not self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING or \\<br />                       len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:<br />                        self.next_proc()<br />                       <br />            <br />            # if current proc is RUNNING and has an instruction, execute it<br />            instruction_to_execute = &#39;&#39;<br />            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\<br />                   len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:<br />                #pop a instruction from proc_info[self.curr_proc][PROC_CODE]to instruction_to_execute<br />                #YOUR CODE<br />                instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)<br /><br />            # OUTPUT: print what everyone is up to<br />            if io_done:<br />                print &#39;%3d*&#39; % clock_tick,<br />            else:<br />                print &#39;%3d &#39; % clock_tick,<br />            for pid in range(len(self.proc_info)):<br />                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:<br />                    print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),<br />                else:<br />                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),<br />            if instruction_to_execute == &#39;&#39;:<br />                print &#39;%10s&#39; % &#39; &#39;,<br />            else:<br />                print &#39;%10s&#39; % 1,<br />            num_outstanding = self.get_ios_in_flight(clock_tick)<br />            if num_outstanding &gt; 0:<br />                print &#39;%10s&#39; % str(num_outstanding),<br />                io_busy &#43;= 1<br />            else:<br />                print &#39;%10s&#39; % &#39; &#39;,<br />            print &#39;&#39;<br /><br />            # if this is an YIELD instruction, switch to ready state<br />            # and add an io completion in the future<br />            if instruction_to_execute == DO_YIELD:<br />                #YOUR CODE<br />                self.move_to_ready(self.proc_info[self.curr_proc][PROC_STATE])<br />                self.next_proc()<br />            # if this is an IO instruction, switch to waiting state<br />            # and add an io completion in the future<br />            elif instruct</pre>", "created": "2015-04-08T06:08:55Z", "bucket_order": 265, "bucket_name": "Week 4/5 - 4/11", "type": "followup", "tag_good": [], "uid": "i6unpz8nUza", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i88c53k0jm21yk", "updated": "2015-04-08T06:08:55Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>周圣凯 2012011342</p>\n<pre>#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\n\n# process switch behavior\nSCHED_SWITCH_ON_IO = &#39;SWITCH_ON_IO&#39;\n\n# io finished behavior\nIO_RUN_LATER = &#39;IO_RUN_LATER&#39;\n\n# process states\nSTATE_RUNNING = &#39;RUNNING&#39;\nSTATE_READY = &#39;READY&#39;\nSTATE_DONE = &#39;DONE&#39;\nSTATE_WAIT = &#39;WAITING&#39;\n\n# members of process structure\nPROC_CODE = &#39;code_&#39;\nPROC_PC = &#39;pc_&#39;\nPROC_ID = &#39;pid_&#39;\nPROC_STATE = &#39;proc_state_&#39;\n\n# things a process can do\nDO_COMPUTE = &#39;cpu&#39;\nDO_YIELD = &#39;yld&#39;\nDO_IO = &#39;io&#39;\n\nclass scheduler:\n    def __init__(self, process_switch_behavior, io_done_behavior, io_length):\n        # keep set of instructions for each of the processes\n        self.proc_info = {}\n        self.process_switch_behavior = process_switch_behavior\n        self.io_done_behavior = io_done_behavior\n        self.io_length = io_length\n        return\n\n    def new_process(self):\n        proc_id = len(self.proc_info)\n        self.proc_info[proc_id] = {}\n        self.proc_info[proc_id][PROC_PC] = 0\n        self.proc_info[proc_id][PROC_ID] = proc_id\n        self.proc_info[proc_id][PROC_CODE] = []\n        self.proc_info[proc_id][PROC_STATE] = STATE_READY\n        return proc_id\n\n    def load(self, program_description):\n        proc_id = self.new_process()\n        tmp = program_description.split(&#39;:&#39;)\n        if len(tmp) != 3:\n            print &#39;Bad description (%s): Must be number &lt;x:y:z&gt;&#39;\n            print &#39;  where X is the number of instructions&#39;\n            print &#39;  and Y is the percent change that an instruction is YIELD&#39;\n            print &#39;  and Z is the percent change that an instruction is IO&#39;\n            exit(1)\n\n        num_instructions, chance_yield, chance_io = int(tmp[0]), float(tmp[1])/100.0, float(tmp[2])/100.0\n        assert(chance_yield&#43;chance_io&lt;1)\n\n        #print &#34;proc %d, num_instr %d, change_cpu %f&#34; % (proc_id,num_instructions, chance_cpu)\n        for i in range(num_instructions):\n            randnum=random.random();\n            if randnum &lt; (1.0-chance_yield-chance_io):\n                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)\n            elif randnum &gt;= (1.0-chance_yield-chance_io) and randnum &lt; (1.0-chance_io):\n                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)\n            else:\n                self.proc_info[proc_id][PROC_CODE].append(DO_IO)\n            #print &#34;proc %d, instr idx %d, instr cxt %s&#34; % (proc_id, i, self.proc_info[proc_id][PROC_CODE][i])\n        return\n\n    #change to READY STATE, the current proc&#39;s state should be expected\n    #if pid==-1, then pid=self.curr_proc\n    def move_to_ready(self, expected, pid=-1):\n        #YOUR CODE\n        if pid == -1:\n            pid = self.curr_proc\n        assert pid in self.proc_info\n        assert self.proc_info[pid][PROC_STATE] == expected\n        self.proc_info[pid][PROC_STATE] = STATE_READY\n        return\n\n    #change to RUNNING STATE, the current proc&#39;s state should be expected\n    def move_to_running(self, expected):\n        #YOUR CODE\n        assert self.proc_info[self.curr_proc][PROC_STATE] == expected\n        self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING\n        return\n\n    #change to DONE STATE, the current proc&#39;s state should be expected\n    def move_to_done(self, expected):\n        #YOUR CODE\n        assert self.proc_info[self.curr_proc][PROC_STATE] == expected\n        self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE\n        return\n\n    def move_to_wait(self, expected):\n        assert self.proc_info[self.curr_proc][PROC_STATE] == expected\n        self.proc_info[self.curr_proc][PROC_STATE] = STATE_WAIT\n\n    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc\n    def next_proc(self, pid=-1):\n        #YOUR CODE\n        if pid == -1:\n            pid = self.curr_proc\n        for i in range(pid&#43;1,\n                self.get_num_processes())&#43;range(0, pid):\n            if self.proc_info[i][PROC_STATE] == STATE_READY:\n                self.curr_proc = i\n                self.move_to_running(STATE_READY)\n                return\n        if self.proc_info[pid][PROC_STATE] == STATE_READY:\n            self.move_to_running(STATE_READY)\n        return\n\n    def get_num_processes(self):\n        return len(self.proc_info)\n\n    def get_num_instructions(self, pid):\n        return len(self.proc_info[pid][PROC_CODE])\n\n    def get_instruction(self, pid, index):\n        return self.proc_info[pid][PROC_CODE][index]\n\n    def get_num_active(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] != STATE_DONE:\n                num_active &#43;= 1\n        return num_active\n\n    def get_num_runnable(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\\n                   self.proc_info[pid][PROC_STATE] == STATE_RUNNING:\n                num_active &#43;= 1\n        return num_active\n\n    def get_ios_in_flight(self, current_time):\n        num_in_flight = 0\n        for pid in range(len(self.proc_info)):\n            for t in self.io_finish_times[pid]:\n                if t &gt; current_time:\n                    num_in_flight &#43;= 1\n        return num_in_flight\n\n\n    def space(self, num_columns):\n        for i in range(num_columns):\n            print &#39;%10s&#39; % &#39; &#39;,\n\n    def check_if_done(self):\n        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n                self.move_to_done(STATE_RUNNING)\n                self.next_proc()\n        return\n\n    def run(self):\n        clock_tick = 0\n\n        if len(self.proc_info) == 0:\n            return\n\n        # track outstanding IOs, per process\n        self.io_finish_times = {}\n        for pid in range(len(self.proc_info)):\n            self.io_finish_times[pid] = []\n\n        # make first one active\n        self.curr_proc = 0\n        self.move_to_running(STATE_READY)\n\n        # OUTPUT: heade&#96;[rs for each column\n        print &#39;%s&#39; % &#39;Time&#39;, \n        for pid in range(len(self.proc_info)):\n            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),\n        print &#39;%10s&#39; % &#39;CPU&#39;,\n        print &#39;%10s&#39; % &#39;IOs&#39;,\n        print &#39;&#39;\n\n        # init statistics\n        io_busy = 0\n        cpu_busy = 0\n\n        while self.get_num_active() &gt; 0:\n            clock_tick &#43;= 1\n\n            assert clock_tick &lt;= 100\n\n            # check for io finish\n            io_done = False\n            for pid in range(len(self.proc_info)):\n                if clock_tick in self.io_finish_times[pid]:\n                    # if IO finished, the should do something for related process\n       \t            #YOUR CODE\n                    #pass #YOU should delete this\n                    self.move_to_ready(STATE_WAIT, pid)\n                    io_done = True\n            if io_done and self.proc_info[self.curr_proc][PROC_STATE] != STATE_RUNNING:\n                self.next_proc()\n            \n            # if current proc is RUNNING and has an instruction, execute it\n            instruction_to_execute = &#39;&#39;\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n                   len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                #pop a instruction from proc_info[self.curr_proc][PROC_CODE]to instruction_to_execute\n                #YOUR CODE\n                #pass #YOU should delete this\n                instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)\n\n            # OUTPUT: print what everyone is up to\n            if io_done:\n                print &#39;%3d*&#39; % clock_tick,\n            else:\n                print &#39;%3d &#39; % clock_tick,\n            for pid in range(len(self.proc_info)):\n                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n                    print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),\n                else:\n                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),\n            if instruction_to_execute == &#39;&#39;:\n                print &#39;%10s&#39; % &#39; &#39;,\n            else:\n                print &#39;%10s&#39; % 1,\n            num_outstanding = self.get_ios_in_flight(clock_tick)\n            if num_outstanding &gt; 0:\n                print &#39;%10s&#39; % str(num_outstanding),\n                io_busy &#43;= 1\n            else:\n                print &#39;%10s&#39; % &#39; &#39;,\n            print &#39;&#39;\n\n            # if this is an YIELD instruction, switch to ready state\n            # and add an io completion in the future\n            if instruction_to_execute == DO_YIELD:\n                #YOUR CODE\n                #pass #YOU should delete this\n                self.move_to_ready(STATE_RUNNING)\n                self.next_proc()\n            # if this is an IO instruction, switch to waiting state\n            # and add an io completion in the future\n            elif instruction_to_execute == DO_IO:\n                #YOUR CODE\n                #pass #YOU should delete this\n                self.move_to_wait(STATE_RUNNING)\n                self.io_finish_times[self.curr_proc].append(clock_tick&#43;self.io_length)\n                self.next_proc()\n\n            # ENDCASE: check if currently running thing is out of instructions\n            self.check_if_done()\n        return (cpu_busy, io_busy, clock_tick)\n        \n#\n# PARSE ARGUMENTS\n#\n\nparser = OptionParser()\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0, help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)\nparser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,\n                  help=&#39;a comma-separated list of processes to run, in the form X1:Y1:Z1,X2:Y2:Z2,... where X is the number of instructions that process should run, and Y/Z the chances (from 0 to 100) issue an YIELD/IO&#39;,\n                  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)\nparser.add_option(&#39;-L&#39;, &#39;--iolength&#39;, default=3, help=&#39;how long an IO takes&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;io_length&#39;)\nparser.add_option(&#39;-p&#39;, &#39;--printstats&#39;, help=&#39;print statistics at end; only useful with -c</pre>", "created": "2015-04-08T06:09:16Z", "bucket_order": 265, "bucket_name": "Week 4/5 - 4/11", "type": "followup", "tag_good": [], "uid": "i6tz0qianu33p3", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i88c5kcg62kr", "updated": "2015-04-08T06:09:16Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>裴中煜 2012010685</p>\n<p>李若愚 2012011353</p>\n<p></p>\n<pre>#! /usr/bin/env python<br /><br />import sys<br />from optparse import OptionParser<br />import random<br /><br /># process switch behavior<br />SCHED_SWITCH_ON_IO = &#39;SWITCH_ON_IO&#39;<br /><br /># io finished behavior<br />IO_RUN_LATER = &#39;IO_RUN_LATER&#39;<br /><br /># process states<br />STATE_RUNNING = &#39;RUNNING&#39;<br />STATE_READY = &#39;READY&#39;<br />STATE_DONE = &#39;DONE&#39;<br />STATE_WAIT = &#39;WAITING&#39;<br /><br /># members of process structure<br />PROC_CODE = &#39;code_&#39;<br />PROC_PC = &#39;pc_&#39;<br />PROC_ID = &#39;pid_&#39;<br />PROC_STATE = &#39;proc_state_&#39;<br /><br /># things a process can do<br />DO_COMPUTE = &#39;cpu&#39;<br />DO_YIELD = &#39;yld&#39;<br />DO_IO = &#39;io&#39;<br /><br />class scheduler:<br />    def __init__(self, process_switch_behavior, io_done_behavior, io_length):<br />        # keep set of instructions for each of the processes<br />        self.proc_info = {}<br />        self.process_switch_behavior = process_switch_behavior<br />        self.io_done_behavior = io_done_behavior<br />        self.io_length = io_length<br />        return<br /><br />    def new_process(self):<br />        proc_id = len(self.proc_info)<br />        self.proc_info[proc_id] = {}<br />        self.proc_info[proc_id][PROC_PC] = 0<br />        self.proc_info[proc_id][PROC_ID] = proc_id<br />        self.proc_info[proc_id][PROC_CODE] = []<br />        self.proc_info[proc_id][PROC_STATE] = STATE_READY<br />        return proc_id<br /><br />    def load(self, program_description):<br />        proc_id = self.new_process()<br />        tmp = program_description.split(&#39;:&#39;)<br />        if len(tmp) != 3:<br />            print &#39;Bad description (%s): Must be number &lt;x:y:z&gt;&#39;<br />            print &#39;  where X is the number of instructions&#39;<br />            print &#39;  and Y is the percent change that an instruction is YIELD&#39;<br />            print &#39;  and Z is the percent change that an instruction is IO&#39;<br />            exit(1)<br /><br />        num_instructions, chance_yield, chance_io = int(tmp[0]), float(tmp[1])/100.0, float(tmp[2])/100.0<br />        assert(chance_yield&#43;chance_io&lt;1)<br /><br />        #print &#34;proc %d, num_instr %d, change_cpu %f&#34; % (proc_id,num_instructions, chance_cpu)<br />        for i in range(num_instructions):<br />            randnum=random.random();<br />            if randnum &lt; (1.0-chance_yield-chance_io):<br />                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)<br />            elif randnum &gt;= (1.0-chance_yield-chance_io) and randnum &lt; (1.0-chance_io):<br />                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)<br />            else:<br />                self.proc_info[proc_id][PROC_CODE].append(DO_IO)<br />            #print &#34;proc %d, instr idx %d, instr cxt %s&#34; % (proc_id, i, self.proc_info[proc_id][PROC_CODE][i])<br />        return<br /><br />    #change to READY STATE, the current proc&#39;s state should be expected<br />    #if pid==-1, then pid=self.curr_proc<br />    def move_to_ready(self, expected, pid=-1):<br />        #YOUR CODE<br />        if pid == -1:<br />            pid = self.curr_proc<br />        assert expected == STATE_RUNNING or expected == STATE_WAIT<br />        self.proc_info[pid][PROC_STATE] = STATE_READY <br />        return<br /><br />    def move_to_wait(self, expected):<br />        #MY CODE<br />        assert expected == STATE_RUNNING<br />        self.proc_info[self.curr_proc][PROC_STATE] = STATE_WAIT<br />        return<br /><br />    #change to RUNNING STATE, the current proc&#39;s state should be expected<br />    def move_to_running(self, expected):<br />        #YOUR CODE<br />        assert expected == STATE_READY or expected == STATE_RUNNING<br />        self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING<br />        return<br /><br />    #change to DONE STATE, the current proc&#39;s state should be expected<br />    def move_to_done(self, expected):<br />        #YOUR CODE<br />        assert expected == STATE_RUNNING<br />        self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE<br />        return<br /><br />    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc<br />    def next_proc(self, pid=-1):<br />        #YOUR CODE<br />        if pid == -1:<br />            pid = self.curr_proc<br />        n = len(self.proc_info)<br />        for i in range(1,n&#43;1):<br />            if self.proc_info[(pid&#43;i)%n][PROC_STATE] == STATE_READY:<br />                self.curr_proc = (pid&#43;i)%n<br />                break<br />        if self.proc_info[self.curr_proc][PROC_STATE] == STATE_READY:<br />            self.move_to_running(STATE_READY)<br />        return<br /><br />    def get_num_processes(self):<br />        return len(self.proc_info)<br /><br />    def get_num_instructions(self, pid):<br />        return len(self.proc_info[pid][PROC_CODE])<br /><br />    def get_instruction(self, pid, index):<br />        return self.proc_info[pid][PROC_CODE][index]<br /><br />    def get_num_active(self):<br />        num_active = 0<br />        for pid in range(len(self.proc_info)):<br />            if self.proc_info[pid][PROC_STATE] != STATE_DONE:<br />                num_active &#43;= 1<br />        return num_active<br /><br />    def get_num_runnable(self):<br />        num_active = 0<br />        for pid in range(len(self.proc_info)):<br />            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\<br />                   self.proc_info[pid][PROC_STATE] == STATE_RUNNING:<br />                num_active &#43;= 1<br />        return num_active<br /><br />    def get_ios_in_flight(self, current_time):<br />        num_in_flight = 0<br />        for pid in range(len(self.proc_info)):<br />            for t in self.io_finish_times[pid]:<br />                if t &gt; current_time:<br />                    num_in_flight &#43;= 1<br />        return num_in_flight<br /><br /><br />    def space(self, num_columns):<br />        for i in range(num_columns):<br />            print &#39;%10s&#39; % &#39; &#39;,<br /><br />    def check_if_done(self):<br />        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:<br />            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:<br />                self.move_to_done(STATE_RUNNING)<br />                self.next_proc()<br />        return<br /><br />    def run(self):<br />        clock_tick = 0<br /><br />        if len(self.proc_info) == 0:<br />            return<br /><br />        # track outstanding IOs, per process<br />        self.io_finish_times = {}<br />        for pid in range(len(self.proc_info)):<br />            self.io_finish_times[pid] = []<br /><br />        # make first one active<br />        self.curr_proc = 0<br />        self.move_to_running(STATE_READY)<br /><br />        # OUTPUT: heade&#96;[rs for each column<br />        print &#39;%s&#39; % &#39;Time&#39;, <br />        for pid in range(len(self.proc_info)):<br />            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),<br />        print &#39;%10s&#39; % &#39;CPU&#39;,<br />        print &#39;%10s&#39; % &#39;IOs&#39;,<br />        print &#39;&#39;<br /><br />        # init statistics<br />        io_busy = 0<br />        cpu_busy = 0<br /><br />        while self.get_num_active() &gt; 0:<br />            clock_tick &#43;= 1<br /><br />            # check for io finish<br />            io_done = False<br />            for pid in range(len(self.proc_info)):<br />                if clock_tick in self.io_finish_times[pid]:<br />                    # if IO finished, the should do something for related process<br />       \t            #YOUR CODE<br />                    io_done = True<br />                    self.io_finish_times[pid].remove(clock_tick)<br />                    self.move_to_ready(expected=STATE_WAIT, pid=pid)   <br />            <br />            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_WAIT:<br />                self.next_proc()<br />            # if current proc is RUNNING and has an instruction, execute it<br />            instruction_to_execute = &#39;&#39;<br />            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\<br />                   len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:<br />                #pop a instruction from proc_info[self.curr_proc][PROC_CODE]to instruction_to_execute<br />                #YOUR CODE<br />                instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)<br />                cpu_busy &#43;= 1<br />                self.proc_info[self.curr_proc][PROC_PC] &#43;= 1<br /><br />            # OUTPUT: print what everyone is up to<br />            if io_done:<br />                print &#39;%3d*&#39; % clock_tick,<br />            else:<br />                print &#39;%3d &#39; % clock_tick,<br />            for pid in range(len(self.proc_info)):<br />                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:<br />                    print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),<br />                else:<br />                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),<br />            if instruction_to_execute == &#39;&#39;:<br />                print &#39;%10s&#39; % &#39; &#39;,<br />            else:<br />                print &#39;%10s&#39; % 1,<br />            num_outstanding = self.get_ios_in_flight(clock_tick)<br />            if num_outstanding &gt; 0:<br />                print &#39;%10s&#39; % str(num_outstanding),<br />                io_busy &#43;= 1<br />            else:<br />                print &#39;%10s&#39; % &#39; &#39;,<br />            print &#39;&#39;<br /><br />            # if this is an YIELD instruction, switch to ready state<br />            # and add an io completion in the future<br />            if instruction_to_execute == DO_YIELD:<br />                #YOUR CODE<br />                self.move_to_ready(STATE_RUNNING)<br />                self.next_proc()<br />            # if this is an IO instruction, switch to waiting state<br />            # and add an io completion in the future<br />            </pre>", "created": "2015-04-08T06:13:10Z", "bucket_order": 265, "bucket_name": "Week 4/5 - 4/11", "type": "followup", "tag_good": [], "uid": "i6uji18l8j51ob", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i88cak8n1t62q2", "updated": "2015-04-08T06:13:10Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>2012011359 路云飞</p>\n<pre>#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\n\n# process switch behavior\nSCHED_SWITCH_ON_IO = &#39;SWITCH_ON_IO&#39;\n\n# io finished behavior\nIO_RUN_LATER = &#39;IO_RUN_LATER&#39;\n\n# process states\nSTATE_RUNNING = &#39;RUNNING&#39;\nSTATE_READY = &#39;READY&#39;\nSTATE_DONE = &#39;DONE&#39;\nSTATE_WAIT = &#39;WAITING&#39;\n\n# members of process structure\nPROC_CODE = &#39;code_&#39;\nPROC_PC = &#39;pc_&#39;\nPROC_ID = &#39;pid_&#39;\nPROC_STATE = &#39;proc_state_&#39;\n\n# things a process can do\nDO_COMPUTE = &#39;cpu&#39;\nDO_YIELD = &#39;yld&#39;\nDO_IO = &#39;io&#39;\n\nclass scheduler:\n    def __init__(self, process_switch_behavior, io_done_behavior, io_length):\n        # keep set of instructions for each of the processes\n        self.proc_info = {}\n        self.process_switch_behavior = process_switch_behavior\n        self.io_done_behavior = io_done_behavior\n        self.io_length = io_length\n        return\n\n    def new_process(self):\n        proc_id = len(self.proc_info)\n        self.proc_info[proc_id] = {}\n        self.proc_info[proc_id][PROC_PC] = 0\n        self.proc_info[proc_id][PROC_ID] = proc_id\n        self.proc_info[proc_id][PROC_CODE] = []\n        self.proc_info[proc_id][PROC_STATE] = STATE_READY\n        return proc_id\n\n    def load(self, program_description):\n        proc_id = self.new_process()\n        tmp = program_description.split(&#39;:&#39;)\n        if len(tmp) != 3:\n            print &#39;Bad description (%s): Must be number &lt;x:y:z&gt;&#39;\n            print &#39;  where X is the number of instructions&#39;\n            print &#39;  and Y is the percent change that an instruction is YIELD&#39;\n            print &#39;  and Z is the percent change that an instruction is IO&#39;\n            exit(1)\n\n        num_instructions, chance_yield, chance_io = int(tmp[0]), float(tmp[1])/100.0, float(tmp[2])/100.0\n        assert(chance_yield&#43;chance_io&lt;1)\n\n        #print &#34;proc %d, num_instr %d, change_cpu %f&#34; % (proc_id,num_instructions, chance_cpu)\n        for i in range(num_instructions):\n            randnum=random.random();\n            if randnum &lt; (1.0-chance_yield-chance_io):\n                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)\n            elif randnum &gt;= (1.0-chance_yield-chance_io) and randnum &lt; (1.0-chance_io):\n                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)\n            else:\n                self.proc_info[proc_id][PROC_CODE].append(DO_IO)\n            #print &#34;proc %d, instr idx %d, instr cxt %s&#34; % (proc_id, i, self.proc_info[proc_id][PROC_CODE][i])\n        return\n\n    #change to READY STATE, the current proc&#39;s state should be expected\n    #if pid==-1, then pid=self.curr_proc\n    def move_to_ready(self, expected, pid=-1):\n        if pid == -1:\n            pid = self.curr_proc\n        assert expected == self.proc_info[pid][PROC_STATE]\n        self.proc_info[pid][PROC_STATE] = STATE_READY\n        return\n\n    #change to RUNNING STATE, the current proc&#39;s state should be expected\n    def move_to_running(self, expected):\n        assert STATE_READY == expected\n        self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING\n        return\n\n    #change to DONE STATE, the current proc&#39;s state should be expected\n    def move_to_done(self, expected):\n        assert STATE_RUNNING == expected\n        self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE\n        return\n\n    def move_to_wait(self, expected, pid=-1):\n        if pid == -1:\n            pid = self.curr_proc\n        assert expected == self.proc_info[pid][PROC_STATE]\n        self.proc_info[pid][PROC_STATE] = STATE_WAIT\n        return\n\n    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc\n    def next_proc(self, pid=-1):\n        if pid == -1:\n            pid = self.curr_proc\n        n = len(self.proc_info)\n        for i in range(pid &#43; 1, n):\n            if (self.proc_info[i][PROC_STATE] == STATE_READY):\n                self.curr_proc = i\n                self.move_to_running(STATE_READY)\n                return \n        for i in range(0, pid &#43; 1):\n            if (self.proc_info[i][PROC_STATE] == STATE_READY):\n                self.curr_proc = i\n                self.move_to_running(STATE_READY)\n                return \n        return\n\n    def get_num_processes(self):\n        return len(self.proc_info)\n\n    def get_num_instructions(self, pid):\n        return len(self.proc_info[pid][PROC_CODE])\n\n    def get_instruction(self, pid, index):\n        return self.proc_info[pid][PROC_CODE][index]\n\n    def get_num_active(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] != STATE_DONE:\n                num_active &#43;= 1\n        return num_active\n\n    def get_num_runnable(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\\n                   self.proc_info[pid][PROC_STATE] == STATE_RUNNING:\n                num_active &#43;= 1\n        return num_active\n\n    def get_ios_in_flight(self, current_time):\n        num_in_flight = 0\n        for pid in range(len(self.proc_info)):\n            for t in self.io_finish_times[pid]:\n                if t &gt; current_time:\n                    num_in_flight &#43;= 1\n        return num_in_flight\n\n\n    def space(self, num_columns):\n        for i in range(num_columns):\n            print &#39;%10s&#39; % &#39; &#39;,\n\n    def check_if_done(self):\n        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n                self.move_to_done(STATE_RUNNING)\n                self.next_proc()\n        return\n\n    def run(self):\n        clock_tick = 0\n\n        if len(self.proc_info) == 0:\n            return\n\n        # track outstanding IOs, per process\n        self.io_finish_times = {}\n        for pid in range(len(self.proc_info)):\n            self.io_finish_times[pid] = []\n\n        # make first one active\n        self.curr_proc = 0\n        self.move_to_running(STATE_READY)\n\n        # OUTPUT: heade&#96;[rs for each column\n        print &#39;%s&#39; % &#39;Time&#39;, \n        for pid in range(len(self.proc_info)):\n            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),\n        print &#39;%10s&#39; % &#39;CPU&#39;,\n        print &#39;%10s&#39; % &#39;IOs&#39;,\n        print &#39;&#39;\n\n        # init statistics\n        io_busy = 0\n        cpu_busy = 0\n\n        while self.get_num_active() &gt; 0:\n            clock_tick &#43;= 1\n\n            # check for io finish\n            io_done = False\n            for pid in range(len(self.proc_info)):\n                if clock_tick in self.io_finish_times[pid]:\n                    # if IO finished, the should do something for related process                   \n                    self.move_to_ready(STATE_WAIT, pid)\n                    self.next_proc()\n                    io_done = True\n            \n            # if current proc is RUNNING and has an instruction, execute it\n            instruction_to_execute = &#39;&#39;\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n                   len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                #pop a instruction from proc_info[self.curr_proc][PROC_CODE]to instruction_to_execute\n                instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)\n\n            # OUTPUT: print what everyone is up to\n            if io_done:\n                print &#39;%3d*&#39; % clock_tick,\n            else:\n                print &#39;%3d &#39; % clock_tick,\n            for pid in range(len(self.proc_info)):\n                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n                    print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),\n                else:\n                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),\n            if instruction_to_execute == &#39;&#39;:\n                print &#39;%10s&#39; % &#39; &#39;,\n            else:\n                print &#39;%10s&#39; % 1,\n            num_outstanding = self.get_ios_in_flight(clock_tick)\n            if num_outstanding &gt; 0:\n                print &#39;%10s&#39; % str(num_outstanding),\n                io_busy &#43;= 1\n            else:\n                print &#39;%10s&#39; % &#39; &#39;,\n            print &#39;&#39;\n\n            # if this is an YIELD instruction, switch to ready state\n            # and add an io completion in the future\n            if instruction_to_execute == DO_YIELD:\n                self.move_to_ready(STATE_RUNNING)\n                self.next_proc()\n            # if this is an IO instruction, switch to waiting state\n            # and add an io completion in the future\n            elif instruction_to_execute == DO_IO:\n                self.move_to_wait(STATE_RUNNING, self.curr_proc)\n                self.io_finish_times[self.curr_proc].append(clock_tick&#43;self.io_length&#43;1)\n                self.next_proc()\n\n            # ENDCASE: check if currently running thing is out of instructions\n            self.check_if_done()\n        return (cpu_busy, io_busy, clock_tick)\n        \n#\n# PARSE ARGUMENTS\n#\n\nparser = OptionParser()\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0, help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)\nparser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,\n                  help=&#39;a comma-separated list of processes to run, in the form X1:Y1:Z1,X2:Y2:Z2,... where X is the number of instructions that process should run, and Y/Z the chances (from 0 to 100) issue an YIELD/IO&#39;,\n                  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)\nparser.add_option(&#39;-L&#39;, &#39;--iolength&#39;, default=3, help=&#39;how long an IO takes&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;io_length&#39;)\nparser.add_option(&#39;-p&#39;, &#39;--printstats&#39;, help=&#39;print statistics at end; only useful with -c flag (otherwise stats are not printed)&#39;, action=&#39;store_true&#39;, default=False, dest=&#39;print_stats&#39;)\n(options, args) = parser.parse_args()\n\nrandom.seed(options.seed)\n\nprocess_switch_behavior = SCHED_SWITCH_ON_IO\nio_done_behavior = IO_RUN_LATER\nio_length=options.io_length\n\n\ns = scheduler(process_switch_behavior, io_done_behavior, io_length)\n\n# example process description (10:100,10:100)\nfor p in options.process_list.sp</pre>", "created": "2015-04-08T06:32:06Z", "bucket_order": 265, "bucket_name": "Week 4/5 - 4/11", "type": "followup", "tag_good": [], "uid": "i718aanx0OS", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i88cyws9gwt5gl", "updated": "2015-04-08T06:32:06Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>计24 杜鹃 2012011354 </p>\n<p>计24 王妍 2012011352</p>\n<p></p>\n<pre>#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\n\n# process switch behavior\nSCHED_SWITCH_ON_IO = &#39;SWITCH_ON_IO&#39;\n\n# io finished behavior\nIO_RUN_LATER = &#39;IO_RUN_LATER&#39;\n\n# process states\nSTATE_RUNNING = &#39;RUNNING&#39;\n\nSTATE_READY = &#39;READY&#39;\nSTATE_DONE = &#39;DONE&#39;\nSTATE_WAIT = &#39;WAITING&#39;\n\n# members of process structure\nPROC_CODE = &#39;code_&#39;\nPROC_PC = &#39;pc_&#39;\nPROC_ID = &#39;pid_&#39;\nPROC_STATE = &#39;proc_state_&#39;\n\n# things a process can do\nDO_COMPUTE = &#39;cpu&#39;\nDO_YIELD = &#39;yld&#39;\nDO_IO = &#39;io&#39;\n\nclass scheduler:\n    def __init__(self, process_switch_behavior, io_done_behavior, io_length):\n        # keep set of instructions for each of the processes\n        self.proc_info = {}\n        self.process_switch_behavior = process_switch_behavior\n        self.io_done_behavior = io_done_behavior\n        self.io_length = io_length\n        return\n\n    def new_process(self):\n        proc_id = len(self.proc_info)\n        self.proc_info[proc_id] = {}\n        self.proc_info[proc_id][PROC_PC] = 0\n        self.proc_info[proc_id][PROC_ID] = proc_id\n        self.proc_info[proc_id][PROC_CODE] = []\n        self.proc_info[proc_id][PROC_STATE] = STATE_READY\n        return proc_id\n\n    def load(self, program_description):\n        proc_id = self.new_process()\n        tmp = program_description.split(&#39;:&#39;)\n        if len(tmp) != 3:\n            print &#39;Bad description (%s): Must be number &lt;x:y:z&gt;&#39;\n            print &#39;  where X is the number of instructions&#39;\n            print &#39;  and Y is the percent change that an instruction is YIELD&#39;\n            print &#39;  and Z is the percent change that an instruction is IO&#39;\n            exit(1)\n\n        num_instructions, chance_yield, chance_io = int(tmp[0]), float(tmp[1])/100.0, float(tmp[2])/100.0\n        assert(chance_yield&#43;chance_io&lt;1)\n\n        #print &#34;proc %d, num_instr %d, change_cpu %f&#34; % (proc_id,num_instructions, chance_cpu)\n        for i in range(num_instructions):\n            randnum=random.random();\n            if randnum &lt; (1.0-chance_yield-chance_io):\n                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)\n            elif randnum &gt;= (1.0-chance_yield-chance_io) and randnum &lt; (1.0-chance_io):\n                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)\n            else:\n                self.proc_info[proc_id][PROC_CODE].append(DO_IO)\n            #print &#34;proc %d, instr idx %d, instr cxt %s&#34; % (proc_id, i, self.proc_info[proc_id][PROC_CODE][i])\n        return\n\n    #change to READY STATE, the current proc&#39;s state should be expected\n    #if pid==-1, then pid=self.curr_proc\n    def move_to_ready(self, expected, pid=-1):\n        assert ( expected != STATE_DONE )\n        if pid == -1:\n            pid = self.curr_proc\n        self.proc_info[pid][PROC_STATE] = STATE_READY\n        self.next_proc()\n        self.move_to_running(STATE_READY)\n        \n        return\n\n    #change to RUNNING STATE, the current proc&#39;s state should be expected\n    def move_to_running(self, expected, pid=-1):\n        if pid == -1:\n            pid = self.curr_proc\n\n        self.proc_info[pid][PROC_STATE] = STATE_RUNNING\n        self.curr_proc = pid\n        return\n\n    def move_to_waiting(self, expected):\n        pid = self.curr_proc\n        self.next_proc()\n        self.move_to_running(STATE_READY)\n        self.proc_info[pid][PROC_STATE] = STATE_WAIT\n        \n        return\n\n\n    #change to DONE STATE, the current proc&#39;s state should be expected\n    def move_to_done(self, expected):\n        pid = self.curr_proc\n\n        if  self.get_num_active() != 0 :\n            self.next_proc() \n            self.move_to_running(STATE_READY)\n        self.proc_info[pid][PROC_STATE] = STATE_DONE\n\n        \n        return\n\n    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc\n    def next_proc(self, pid=-1):\n        #YOUR CODE\n        if pid == -1:\n            pid = self.curr_proc\n        self.curr_proc = (self.curr_proc &#43; 1 ) % len(self.proc_info)\n        if self.proc_info[self.curr_proc][PROC_STATE] == STATE_DONE or self.proc_info[self.curr_proc][PROC_STATE] == STATE_WAIT :\n            self.curr_proc = (self.curr_proc &#43; 1 ) % len(self.proc_info)\n                \n       # self.check_if_done();\n        return\n\n    def get_num_processes(self):\n        return len(self.proc_info)\n\n    def get_num_instructions(self, pid):\n        return len(self.proc_info[pid][PROC_CODE])\n\n    def get_instruction(self, pid, index):\n        return self.proc_info[pid][PROC_CODE][index]\n\n    def get_num_active(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] != STATE_DONE:\n                num_active &#43;= 1\n        return num_active\n\n    def get_num_runnable(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\\n                   self.proc_info[pid][PROC_STATE] == STATE_RUNNING:\n                num_active &#43;= 1\n        return num_active\n\n    def get_ios_in_flight(self, current_time):\n        num_in_flight = 0\n        for pid in range(len(self.proc_info)):\n            for t in self.io_finish_times[pid]:\n                if t &gt; current_time:\n                    num_in_flight &#43;= 1\n        return num_in_flight\n\n\n    def space(self, num_columns):\n        for i in range(num_columns):\n            print &#39;%10s&#39; % &#39; &#39;,\n\n    def check_if_done(self):\n        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n                self.move_to_done(STATE_RUNNING)\n        return\n\n    def run(self):\n        clock_tick = 0\n\n        if len(self.proc_info) == 0:\n            return\n\n        # track outstanding IOs, per process\n        self.io_finish_times = {}\n        for pid in range(len(self.proc_info)):\n            self.io_finish_times[pid] = []\n\n        # make first one active\n        self.curr_proc = 0\n        self.move_to_running(STATE_READY)\n\n        # OUTPUT: heade&#96;[rs for each column\n        print &#39;%s&#39; % &#39;Time&#39;, \n        for pid in range(len(self.proc_info)):\n            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),\n        print &#39;%10s&#39; % &#39;CPU&#39;,\n        print &#39;%10s&#39; % &#39;IOs&#39;,\n        print &#39;&#39;\n\n        # init statistics\n        io_busy = 0\n        cpu_busy = 0\n\n        while self.get_num_active() &gt; 0:\n            clock_tick &#43;= 1\n\n            # check for io finish\n            io_done = False\n            for pid in range(len(self.proc_info)):\n                if clock_tick in self.io_finish_times[pid]:\n                    #self.next_proc()\n                    self.move_to_running(STATE_WAIT, pid)\n                    #pass\n                    \n            \n            # if current proc is RUNNING and has an instruction, execute it\n            instruction_to_execute = &#39;&#39;\n            \n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n                   len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                #pop a instruction from proc_info[self.curr_proc][PROC_CODE]to instruction_to_execute\n                instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)\n                \n\n            # OUTPUT: print what everyone is up to\n            if io_done:\n                print &#39;%3d*&#39; % clock_tick,\n            else:\n                print &#39;%3d &#39; % clock_tick,\n            for pid in range(len(self.proc_info)):\n                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n                    print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),\n                else:\n                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),\n            if instruction_to_execute == &#39;&#39;:\n                print &#39;%10s&#39; % &#39; &#39;,\n            else:\n                cpu_busy &#43;= 1\n                print &#39;%10s&#39; % 1,\n            num_outstanding = self.get_ios_in_flight(clock_tick)\n            if num_outstanding &gt; 0:\n                print &#39;%10s&#39; % str(num_outstanding),\n                io_busy &#43;= 1\n            else:\n                print &#39;%10s&#39; % &#39; &#39;,\n            print &#39;&#39;\n\n            # if this is an YIELD instruction, switch to ready state\n            # and add an io completion in the future\n            if instruction_to_execute == DO_YIELD:\n                self.move_to_ready(STATE_RUNNING)\n\n            # if this is an IO instruction, switch to waiting state\n            # and add an io completion in the future\n            elif instruction_to_execute == DO_IO:\n                self.io_finish_times[self.curr_proc].append(clock_tick&#43;5)\n                self.move_to_waiting(STATE_RUNNING)\n                \n\n            # ENDCASE: check if currently running thing is out of instructions\n            self.check_if_done()\n        return (cpu_busy, io_busy, clock_tick)\n        \n#\n# PARSE ARGUMENTS\n#\n\nparser = OptionParser()\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0, help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)\nparser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,\n                  help=&#39;a comma-separated list of processes to run, in the form X1:Y1:Z1,X2:Y2:Z2,... where X is the number of instructions that process should run, and Y/Z the chances (from 0 to 100) issue an YIELD/IO&#39;,\n                  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)\nparser.add_option(&#39;-L&#39;, &#39;--iolength&#39;, default=3, help=&#39;how long an IO takes&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;io_length&#39;)\nparser.add_option(&#39;-p&#39;, &#39;--printstats&#39;, help=&#39;print statistics at end; only useful with -c flag (otherwise stats are not printed)&#39;, action=&#39;store_true&#39;, default=False, dest=&#39;print_stats&#39;)\n(options, args) = parser.parse_args()\n\nrandom.seed(options.seed)\n\nprocess_switch_behavior = SCHED_SWITCH_ON_IO\nio_done_behavior = IO_RUN_LATER\nio_length=options.io_length\n\n\ns = scheduler(process_switch_behavior, io_done_behavior, io_length)\n\n# example process description (10:100,10:100)\nfor p in options.process_list.split(&#39;,&#39;</pre>", "created": "2015-04-08T06:39:27Z", "bucket_order": 265, "bucket_name": "Week 4/5 - 4/11", "type": "followup", "tag_good": [], "uid": "i6un4iacNGX", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>代码贴不全&#xff0c;链接在 &#xff1a; https://github.com/Azalea94/os_exercises/blob/master/all/sys2.py</p>", "created": "2015-04-08T06:41:59Z", "bucket_order": 265, "bucket_name": "Week 4/5 - 4/11", "type": "feedback", "tag_good": [], "uid": "i6un4iacNGX", "children": [], "tag_good_arr": [], "id": "i88dbmmo4p94tj", "updated": "2015-04-08T06:41:59Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "i88d8de0a5m44t", "updated": "2015-04-08T06:39:27Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>韩慧阳 2012011276</p>\n<p>杨博文 2012011288</p>\n<pre>代码行数超过限制, 链接https://github.com/hanhy/os_exercises/blob/master/all/05-02-wait.py</pre>", "created": "2015-04-08T06:47:24Z", "bucket_order": 265, "bucket_name": "Week 4/5 - 4/11", "type": "followup", "tag_good": [], "uid": "i7bfvegt8am5ir", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>", "created": "2015-04-08T06:54:50Z", "bucket_order": 265, "bucket_name": "Week 4/5 - 4/11", "type": "feedback", "tag_good": [], "uid": "i6uehzyhtye4i2", "children": [], "tag_good_arr": [], "id": "i88ds5xa1v86x2", "updated": "2015-04-08T06:54:50Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "i88dili0d114ac", "updated": "2015-04-08T06:47:24Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>罗鸿胤 2012011319</p>\n<p>杨元 2012011331</p>\n<p></p>\n<pre>#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\n\n# process switch behavior\nSCHED_SWITCH_ON_IO = &#39;SWITCH_ON_IO&#39;\n\n# io finished behavior\nIO_RUN_LATER = &#39;IO_RUN_LATER&#39;\n\n# process states\nSTATE_RUNNING = &#39;RUNNING&#39;\nSTATE_READY = &#39;READY&#39;\nSTATE_DONE = &#39;DONE&#39;\nSTATE_WAIT = &#39;WAITING&#39;\n\n# members of process structure\nPROC_CODE = &#39;code_&#39;\nPROC_PC = &#39;pc_&#39;\nPROC_ID = &#39;pid_&#39;\nPROC_STATE = &#39;proc_state_&#39;\n\n# things a process can do\nDO_COMPUTE = &#39;cpu&#39;\nDO_YIELD = &#39;yld&#39;\nDO_IO = &#39;io&#39;\n\n\nclass scheduler:\n    def __init__(self, process_switch_behavior, io_done_behavior, io_length):\n        # keep set of instructions for each of the processes\n        self.proc_info = {}\n        self.process_switch_behavior = process_switch_behavior\n        self.io_done_behavior = io_done_behavior\n        self.io_length = io_length\n        return\n\n    def new_process(self):\n        proc_id = len(self.proc_info)\n        self.proc_info[proc_id] = {}\n        self.proc_info[proc_id][PROC_PC] = 0\n        self.proc_info[proc_id][PROC_ID] = proc_id\n        self.proc_info[proc_id][PROC_CODE] = []\n        self.proc_info[proc_id][PROC_STATE] = STATE_READY\n        return proc_id\n\n    def load(self, program_description):\n        proc_id = self.new_process()\n        tmp = program_description.split(&#39;:&#39;)\n        if len(tmp) != 3:\n            print &#39;Bad description (%s): Must be number &lt;x:y:z&gt;&#39;\n            print &#39;  where X is the number of instructions&#39;\n            print &#39;  and Y is the percent change that an instruction is YIELD&#39;\n            print &#39;  and Z is the percent change that an instruction is IO&#39;\n            exit(1)\n\n        num_instructions, chance_yield, chance_io = int(tmp[0]), float(tmp[1])/100.0, float(tmp[2])/100.0\n        assert(chance_yield&#43;chance_io&lt;1)\n\n        #print &#34;proc %d, num_instr %d, change_cpu %f&#34; % (proc_id,num_instructions, chance_cpu)\n        for i in range(num_instructions):\n            randnum=random.random();\n            if randnum &lt; (1.0-chance_yield-chance_io):\n                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)\n            elif randnum &gt;= (1.0-chance_yield-chance_io) and randnum &lt; (1.0-chance_io):\n                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)\n            else:\n                self.proc_info[proc_id][PROC_CODE].append(DO_IO)\n            #print &#34;proc %d, instr idx %d, instr cxt %s&#34; % (proc_id, i, self.proc_info[proc_id][PROC_CODE][i])\n        return\n\n    #change to READY STATE, the current proc&#39;s state should be expected\n    #if pid==-1, then pid=self.curr_proc\n    def move_to_ready(self, expected, pid=-1):\n        #YOUR CODE\n        if expected != STATE_RUNNING and expected != STATE_WAIT:\n            print &#34;Expected error&#34;\n            return\n        if pid == -1:\n            pid = self.curr_proc\n        self.proc_info[pid][PROC_STATE] = STATE_READY\n        return\n\n    #change to WAIT STATE, the current proc&#39;s state should be expected\n    #if pid==-1, then pid=self.curr_proc\n    def move_to_wait(self, expected, pid=-1):\n        #YOUR CODE\n        if expected != STATE_RUNNING:\n            print &#34;Expected error&#34;\n            return\n        if pid == -1:\n            pid = self.curr_proc\n        self.proc_info[pid][PROC_STATE] = STATE_WAIT\n        return\n\n    #change to RUNNING STATE, the current proc&#39;s state should be expected\n    def move_to_running(self, expected):\n        #YOUR CODE\n        if expected != STATE_READY:\n            print &#34;Expected error&#34;\n            return\n        self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING\n        return\n\n    #change to DONE STATE, the current proc&#39;s state should be expected\n    def move_to_done(self, expected):\n        #YOUR CODE\n        if expected != STATE_RUNNING:\n            print &#34;Expected error&#34;\n            return\n        self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE\n        return\n\n    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc\n    def next_proc(self, pid=-1):\n        #YOUR CODE\n        if pid == -1:\n            pid = self.curr_proc\n        for i in range(len(self.proc_info)):\n            if self.proc_info[(self.curr_proc &#43; i) % len(self.proc_info)][PROC_STATE] == STATE_READY:\n                self.curr_proc = (self.curr_proc &#43; i) % len(self.proc_info)\n                self.move_to_running(self.proc_info[self.curr_proc][PROC_STATE])\n                break\n        return\n\n    def get_num_processes(self):\n        return len(self.proc_info)\n\n    def get_num_instructions(self, pid):\n        return len(self.proc_info[pid][PROC_CODE])\n\n    def get_instruction(self, pid, index):\n        return self.proc_info[pid][PROC_CODE][index]\n\n    def get_num_active(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] != STATE_DONE:\n                num_active &#43;= 1\n        return num_active\n\n    def get_num_runnable(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\\n                   self.proc_info[pid][PROC_STATE] == STATE_RUNNING:\n                num_active &#43;= 1\n        return num_active\n\n    def get_ios_in_flight(self, current_time):\n        num_in_flight = 0\n        for pid in range(len(self.proc_info)):\n            for t in self.io_finish_times[pid]:\n                if t &gt; current_time:\n                    num_in_flight &#43;= 1\n        return num_in_flight\n\n    def space(self, num_columns):\n        for i in range(num_columns):\n            print &#39;%10s&#39; % &#39; &#39;,\n\n    def check_if_done(self):\n        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n                self.move_to_done(STATE_RUNNING)\n                self.next_proc()\n        return\n\n    def run(self):\n        clock_tick = 0\n\n        if len(self.proc_info) == 0:\n            return\n\n        # track outstanding IOs, per process\n        self.io_finish_times = {}\n        for pid in range(len(self.proc_info)):\n            self.io_finish_times[pid] = []\n\n        # make first one active\n        self.curr_proc = 0\n        self.move_to_running(STATE_READY)\n\n        # OUTPUT: heade&#96;[rs for each column\n        print &#39;%s&#39; % &#39;Time&#39;, \n        for pid in range(len(self.proc_info)):\n            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),\n        print &#39;%10s&#39; % &#39;CPU&#39;,\n        print &#39;%10s&#39; % &#39;IOs&#39;,\n        print &#39;&#39;\n\n        # init statistics\n        io_busy = 0\n        cpu_busy = 0\n\n        while self.get_num_active() &gt; 0:\n            clock_tick &#43;= 1\n\n            # check for io finish\n            io_done = False\n            for pid in range(len(self.proc_info)):\n                if clock_tick in self.io_finish_times[pid]:\n                    # if IO finished, the should do something for related process\n                    #YOUR CODE\n                    io_done = True\n                    self.move_to_ready(STATE_WAIT,pid)\n                    self.next_proc()\n            \n            # if current proc is RUNNING and has an instruction, execute it\n            # statistics clock_tick\n            instruction_to_execute = &#39;&#39;\n            #if self.curr_proc == 1:\n            #    print self.proc_info[self.curr_proc][PROC_CODE]\n            #    return\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n                   len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                #YOUR CODE\n                instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE][0]\n                self.proc_info[self.curr_proc][PROC_CODE].pop(0)\n\n            # OUTPUT: print what everyone is up to\n            if io_done:\n                print &#39;%3d*&#39; % clock_tick,\n            else:\n                print &#39;%3d &#39; % clock_tick,\n            for pid in range(len(self.proc_info)):\n                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n                    print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),\n                else:\n                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),\n            if instruction_to_execute == &#39;&#39;:\n                print &#39;%10s&#39; % &#39; &#39;,\n            else:\n                print &#39;%10s&#39; % 1,\n            num_outstanding = self.get_ios_in_flight(clock_tick)\n            if num_outstanding &gt; 0:\n                print &#39;%10s&#39; % str(num_outstanding),\n                io_busy &#43;= 1\n            else:\n                print &#39;%10s&#39; % &#39; &#39;,\n            print &#39;&#39;\n\n            # if this is an YIELD instruction, switch to ready state\n            # and add an io completion in the future\n            if instruction_to_execute == DO_YIELD:\n                #YOUR CODE\n                self.move_to_ready(STATE_RUNNING)\n                self.next_proc()\n            # if this is an IO instruction, switch to waiting state\n            # and add an io completion in the future\n            elif instruction_to_execute == DO_IO:\n                #YOUR CODE\n                self.move_to_wait(STATE_RUNNING)\n                self.io_finish_times[self.curr_proc].append(clock_tick&#43;5)\n                self.next_proc()\n\n            # ENDCASE: check if currently running thing is out of instructions\n            self.check_if_done()\n        return (cpu_busy, io_busy, clock_tick)\n        \n#\n# PARSE ARGUMENTS\n#\n\nparser = OptionParser()\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0, help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)\nparser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,\n                  help=&#39;a comma-separated list of processes to run, in the form X1:Y1:Z1,X2:Y2:Z2,... where X is the number of instructions that process should run, and Y/Z the chances (from 0 to 100) issue an YIELD/IO&#39;,\n                  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)\nparser.add_option(&#39;-L&#39;, &#39;--iolength&#39;, default=3, help=&#39;how long an IO takes&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;io_length&#39;)\nparser.add_option</pre>", "created": "2015-04-08T06:55:29Z", "bucket_order": 265, "bucket_name": "Week 4/5 - 4/11", "type": "followup", "tag_good": [], "uid": "i7oaxkxhxjo3ui", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i88dszgoadp3i5", "updated": "2015-04-08T06:55:29Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>史佳欣 2012011299   林子钏 2012011322</p>\n<pre>#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\n\n# process switch behavior\nSCHED_SWITCH_ON_IO = &#39;SWITCH_ON_IO&#39;\n\n# io finished behavior\nIO_RUN_LATER = &#39;IO_RUN_LATER&#39;\n\n# process states\nSTATE_RUNNING = &#39;RUNNING&#39;\nSTATE_READY = &#39;READY&#39;\nSTATE_DONE = &#39;DONE&#39;\nSTATE_WAIT = &#39;WAITING&#39;\n\n# members of process structure\nPROC_CODE = &#39;code_&#39;\nPROC_PC = &#39;pc_&#39;\nPROC_ID = &#39;pid_&#39;\nPROC_STATE = &#39;proc_state_&#39;\n\n# things a process can do\nDO_COMPUTE = &#39;cpu&#39;\nDO_YIELD = &#39;yld&#39;\nDO_IO = &#39;io&#39;\n\nclass scheduler:\n    def __init__(self, process_switch_behavior, io_done_behavior, io_length):\n        # keep set of instructions for each of the processes\n        self.proc_info = {}\n        self.process_switch_behavior = process_switch_behavior\n        self.io_done_behavior = io_done_behavior\n        self.io_length = io_length\n        return\n\n    def new_process(self):\n        proc_id = len(self.proc_info)\n        self.proc_info[proc_id] = {}\n        self.proc_info[proc_id][PROC_PC] = 0\n        self.proc_info[proc_id][PROC_ID] = proc_id\n        self.proc_info[proc_id][PROC_CODE] = []\n        self.proc_info[proc_id][PROC_STATE] = STATE_READY\n        return proc_id\n\n    def load(self, program_description):\n        proc_id = self.new_process()\n        tmp = program_description.split(&#39;:&#39;)\n        if len(tmp) != 3:\n            print &#39;Bad description (%s): Must be number &lt;x:y:z&gt;&#39;\n            print &#39;  where X is the number of instructions&#39;\n            print &#39;  and Y is the percent change that an instruction is YIELD&#39;\n            print &#39;  and Z is the percent change that an instruction is IO&#39;\n            exit(1)\n\n        num_instructions, chance_yield, chance_io = int(tmp[0]), float(tmp[1])/100.0, float(tmp[2])/100.0\n        assert(chance_yield&#43;chance_io&lt;1)\n\n        #print &#34;proc %d, num_instr %d, change_cpu %f&#34; % (proc_id,num_instructions, chance_cpu)\n        for i in range(num_instructions):\n            randnum=random.random();\n            if randnum &lt; (1.0-chance_yield-chance_io):\n                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)\n            elif randnum &gt;= (1.0-chance_yield-chance_io) and randnum &lt; (1.0-chance_io):\n                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)\n            else:\n                self.proc_info[proc_id][PROC_CODE].append(DO_IO)\n            #print &#34;proc %d, instr idx %d, instr cxt %s&#34; % (proc_id, i, self.proc_info[proc_id][PROC_CODE][i])\n        return\n\n    #change to READY STATE, the current proc&#39;s state should be expected\n    #if pid==-1, then pid=self.curr_proc\n    def move_to_ready(self, expected, pid=-1):\n        #YOUR CODE\n        if pid==-1:\n            pid = self.curr_proc\n        assert self.proc_info[self.curr_proc][PROC_STATE] == expected\n        self.proc_info[pid][PROC_STATE] = STATE_READY\n        return\n\n    #change to RUNNING STATE, the current proc&#39;s state should be expected\n    def move_to_running(self, expected):\n        #YOUR CODE\n        assert self.proc_info[self.curr_proc][PROC_STATE] == expected\n        self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING\n        return\n\n    #change to DONE STATE, the current proc&#39;s state should be expected\n    def move_to_done(self, expected):\n        #YOUR CODE\n        assert self.proc_info[self.curr_proc][PROC_STATE] == expected\n        self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE\n        return\n\n    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc\n    def next_proc(self, pid=-1):\n        #YOUR CODE\n        if pid==-1:\n            pid = self.curr_proc\n        for i in range(1, self.get_num_processes()&#43;1):\n            nextpid = (pid&#43;i)%self.get_num_processes()\n            if self.proc_info[nextpid][PROC_STATE] == STATE_READY:\n                if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n                    self.proc_info[self.curr_proc][PROC_STATE] = STATE_READY\n                self.curr_proc = nextpid\n                self.move_to_running(STATE_READY)\n                break\n        return\n\n    def get_num_processes(self):\n        return len(self.proc_info)\n\n    def get_num_instructions(self, pid):\n        return len(self.proc_info[pid][PROC_CODE])\n\n    def get_instruction(self, pid, index):\n        return self.proc_info[pid][PROC_CODE][index]\n\n    def get_num_active(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] != STATE_DONE:\n                num_active &#43;= 1\n        return num_active\n\n    def get_num_runnable(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\\n                   self.proc_info[pid][PROC_STATE] == STATE_RUNNING:\n                num_active &#43;= 1\n        return num_active\n\n    def get_ios_in_flight(self, current_time):\n        num_in_flight = 0\n        for pid in range(len(self.proc_info)):\n            for t in self.io_finish_times[pid]:\n                if t &gt; current_time:\n                    num_in_flight &#43;= 1\n        return num_in_flight\n\n\n    def space(self, num_columns):\n        for i in range(num_columns):\n            print &#39;%10s&#39; % &#39; &#39;,\n\n    def check_if_done(self):\n        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n                self.move_to_done(STATE_RUNNING)\n                self.next_proc()\n        return\n\n    def run(self):\n        clock_tick = 0\n\n        if len(self.proc_info) == 0:\n            return\n\n        # track outstanding IOs, per process\n        self.io_finish_times = {}\n        for pid in range(len(self.proc_info)):\n            self.io_finish_times[pid] = []\n\n        # make first one active\n        self.curr_proc = 0\n        self.move_to_running(STATE_READY)\n\n        # OUTPUT: heade&#96;[rs for each column\n        print &#39;%s&#39; % &#39;Time&#39;, \n        for pid in range(len(self.proc_info)):\n            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),\n        print &#39;%10s&#39; % &#39;CPU&#39;,\n        print &#39;%10s&#39; % &#39;IOs&#39;,\n        print &#39;&#39;\n\n        # init statistics\n        io_busy = 0\n        cpu_busy = 0\n\n        while self.get_num_active() &gt; 0:\n            clock_tick &#43;= 1\n\n            # check for io finish\n            io_done = False\n            for pid in range(len(self.proc_info)):\n                if clock_tick in self.io_finish_times[pid]:\n                    # if IO finished, the should do something for related process\n       \t            #YOUR CODE\n                    self.proc_info[pid][PROC_STATE] = STATE_READY\n                    io_done = True\n                    io_busy -= 1\n                    self.next_proc()\n            # if current proc is RUNNING and has an instruction, execute it\n            instruction_to_execute = &#39;&#39;\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n                   len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                #pop a instruction from proc_info[self.curr_proc][PROC_CODE]to instruction_to_execute\n                #YOUR CODE\n                instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)\n\n            # OUTPUT: print what everyone is up to\n            if io_done:\n                print &#39;%3d*&#39; % clock_tick,\n            else:\n                print &#39;%3d &#39; % clock_tick,\n            for pid in range(len(self.proc_info)):\n                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n                    print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),\n                else:\n                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),\n            if instruction_to_execute == &#39;&#39;:\n                print &#39;%10s&#39; % &#39; &#39;,\n            else:\n                print &#39;%10s&#39; % 1,\n            num_outstanding = self.get_ios_in_flight(clock_tick)\n            if num_outstanding &gt; 0:\n                print &#39;%10s&#39; % str(num_outstanding),\n                io_busy &#43;= 1\n            else:\n                print &#39;%10s&#39; % &#39; &#39;,\n            print &#39;&#39;\n\n            # if this is an YIELD instruction, switch to ready state\n            # and add an io completion in the future\n            if instruction_to_execute == DO_YIELD:\n                #YOUR CODE\n                self.move_to_ready(STATE_RUNNING)\n                self.next_proc()\n            # if this is an IO instruction, switch to waiting state\n            # and add an io completion in the future\n            elif instruction_to_execute == DO_IO:\n                #YOUR CODE\n                self.proc_info[self.curr_proc][PROC_STATE] = STATE_WAIT\n                self.io_finish_times[self.curr_proc].append(clock_tick&#43;self.io_length&#43;1)\n                self.next_proc()\n\n            # ENDCASE: check if currently running thing is out of instructions\n            self.check_if_done()\n        return (cpu_busy, io_busy, clock_tick)\n        \n#\n# PARSE ARGUMENTS\n#\n\nparser = OptionParser()\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0, help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)\nparser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,\n                  help=&#39;a comma-separated list of processes to run, in the form X1:Y1:Z1,X2:Y2:Z2,... where X is the number of instructions that process should run, and Y/Z the chances (from 0 to 100) issue an YIELD/IO&#39;,\n                  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)\nparser.add_option(&#39;-L&#39;, &#39;--iolength&#39;, default=3, help=&#39;how long an IO takes&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;io_length&#39;)\nparser.add_option(&#39;-p&#39;, &#39;--printstats&#39;, help=&#39;print statistics at end; only useful with -c flag (otherwise stats are not printed)&#39;, action=&#39;store_true&#39;, default=False, dest=&#39;print_stats&#39;)\n(options, args) = parser.parse_args()\n\nrandom.seed(options.seed)\n\nprocess_switch_behavior = SCHED_SWITCH_ON_IO\nio_done_behavior = IO_RUN_LATER\nio_length=options.io_length\n\n\ns = scheduler(process_switch_behavior, io_done_behavior, io_length)\n\n# example pro</pre>", "created": "2015-04-08T06:57:09Z", "bucket_order": 265, "bucket_name": "Week 4/5 - 4/11", "type": "followup", "tag_good": [], "uid": "i6uehzyhtye4i2", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i88dv5174lo7pm", "updated": "2015-04-08T06:57:09Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>李日灵 2012011332</p>\n<p>楼华哲 2012011327</p>", "created": "2015-04-08T06:59:35Z", "bucket_order": 265, "bucket_name": "Week 4/5 - 4/11", "type": "followup", "tag_good": [], "uid": "i718mp903qx", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>#! /usr/bin/env python</p>\n<p>import sys<br />from optparse import OptionParser<br />import random</p>\n<p># process switch behavior<br />SCHED_SWITCH_ON_IO = &#39;SWITCH_ON_IO&#39;</p>\n<p># io finished behavior<br />IO_RUN_LATER = &#39;IO_RUN_LATER&#39;</p>\n<p># process states<br />STATE_RUNNING = &#39;RUNNING&#39;<br />STATE_READY = &#39;READY&#39;<br />STATE_DONE = &#39;DONE&#39;<br />STATE_WAIT = &#39;WAITING&#39;</p>\n<p># members of process structure<br />PROC_CODE = &#39;code_&#39;<br />PROC_PC = &#39;pc_&#39;<br />PROC_ID = &#39;pid_&#39;<br />PROC_STATE = &#39;proc_state_&#39;</p>\n<p># things a process can do<br />DO_COMPUTE = &#39;cpu&#39;<br />DO_YIELD = &#39;yld&#39;<br />DO_IO = &#39;io&#39;</p>\n<p>class scheduler:<br /> def __init__(self, process_switch_behavior, io_done_behavior, io_length):<br /> # keep set of instructions for each of the processes<br /> self.proc_info = {}<br /> self.process_switch_behavior = process_switch_behavior<br /> self.io_done_behavior = io_done_behavior<br /> self.io_length = io_length<br /> return</p>\n<p>def new_process(self):<br /> proc_id = len(self.proc_info)<br /> self.proc_info[proc_id] = {}<br /> self.proc_info[proc_id][PROC_PC] = 0<br /> self.proc_info[proc_id][PROC_ID] = proc_id<br /> self.proc_info[proc_id][PROC_CODE] = []<br /> self.proc_info[proc_id][PROC_STATE] = STATE_READY<br /> return proc_id</p>\n<p>def load(self, program_description):<br /> proc_id = self.new_process()<br /> tmp = program_description.split(&#39;:&#39;)<br /> if len(tmp) != 3:<br /> print &#39;Bad description (%s): Must be number &lt;x:y:z&gt;&#39;<br /> print &#39; where X is the number of instructions&#39;<br /> print &#39; and Y is the percent change that an instruction is YIELD&#39;<br /> print &#39; and Z is the percent change that an instruction is IO&#39;<br /> exit(1)</p>\n<p>num_instructions, chance_yield, chance_io = int(tmp[0]), float(tmp[1])/100.0, float(tmp[2])/100.0<br /> assert(chance_yield&#43;chance_io&lt;1)</p>\n<p>#print &#34;proc %d, num_instr %d, change_cpu %f&#34; % (proc_id,num_instructions, chance_cpu)<br /> for i in range(num_instructions):<br /> randnum=random.random();<br /> if randnum &lt; (1.0-chance_yield-chance_io):<br /> self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)<br /> elif randnum &gt;= (1.0-chance_yield-chance_io) and randnum &lt; (1.0-chance_io):<br /> self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)<br /> else:<br /> self.proc_info[proc_id][PROC_CODE].append(DO_IO)<br /> #print &#34;proc %d, instr idx %d, instr cxt %s&#34; % (proc_id, i, self.proc_info[proc_id][PROC_CODE][i])<br /> return</p>\n<p>#change to READY STATE, the current proc&#39;s state should be expected<br /> #if pid==-1, then pid=self.curr_proc<br /> def move_to_ready(self, expected, pid=-1):<br /> #YOUR CODE<br /> if (expected != STATE_DONE):<br /> if pid == -1:<br /> pid = self.curr_proc<br /> self.proc_info[pid][PROC_STATE] = STATE_READY<br /> return</p>\n<p>#change to RUNNING STATE, the current proc&#39;s state should be expected<br /> def move_to_running(self, expected):<br /> #YOUR CODE<br /> if (expected == STATE_READY):<br /> self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING<br /> return</p>\n<p>#change to DONE STATE, the current proc&#39;s state should be expected<br /> def move_to_done(self, expected):<br /> #YOUR CODE<br /> if (expected != STATE_DONE):<br /> self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE<br /> return</p>\n<p>#choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc<br /> def next_proc(self, pid=-1):<br /> #YOUR CODE<br /> kk = 0<br /> if pid == -1:<br /> pid=self.curr_proc<br /> while (1==1):<br /> pid &#43;= 1<br /> kk &#43;= 1<br /> if (pid &gt;= self.get_num_processes()):<br /> pid = 0<br /> if (self.proc_info[pid][PROC_STATE] == STATE_READY):<br /> self.curr_proc = pid<br /> break<br /> if kk&gt;self.get_num_processes():<br /> break<br /> if self.proc_info[self.curr_proc][PROC_STATE] == STATE_READY:<br /> self.move_to_running(STATE_READY)<br /> return</p>\n<p>def get_num_processes(self):<br /> return len(self.proc_info)</p>\n<p>def get_num_instructions(self, pid):<br /> return len(self.proc_info[pid][PROC_CODE])</p>\n<p>def get_instruction(self, pid, index):<br /> return self.proc_info[pid][PROC_CODE][index]</p>\n<p>def get_num_active(self):<br /> num_active = 0<br /> for pid in range(len(self.proc_info)):<br /> if self.proc_info[pid][PROC_STATE] != STATE_DONE:<br /> num_active &#43;= 1<br /> return num_active</p>\n<p>def get_num_runnable(self):<br /> num_active = 0<br /> for pid in range(len(self.proc_info)):<br /> if self.proc_info[pid][PROC_STATE] == STATE_READY or \\<br /> self.proc_info[pid][PROC_STATE] == STATE_RUNNING:<br /> num_active &#43;= 1<br /> return num_active</p>\n<p>def get_ios_in_flight(self, current_time):<br /> num_in_flight = 0<br /> for pid in range(len(self.proc_info)):<br /> for t in self.io_finish_times[pid]:<br /> if t &gt; current_time:<br /> num_in_flight &#43;= 1<br /> return num_in_flight</p>\n<p><br /> def space(self, num_columns):<br /> for i in range(num_columns):<br /> print &#39;%10s&#39; % &#39; &#39;,</p>\n<p>def check_if_done(self):<br /> if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:<br /> if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:<br /> self.move_to_done(STATE_RUNNING)<br /> self.next_proc()<br /> return</p>\n<p>def run(self):<br /> clock_tick = 0</p>\n<p>if len(self.proc_info) == 0:<br /> return</p>\n<p># track outstanding IOs, per process<br /> self.io_finish_times = {}<br /> for pid in range(len(self.proc_info)):<br /> self.io_finish_times[pid] = []</p>\n<p># make first one active<br /> self.curr_proc = 0<br /> self.move_to_running(STATE_READY)</p>\n<p># OUTPUT: heade&#96;[rs for each column<br /> print &#39;%s&#39; % &#39;Time&#39;, <br /> for pid in range(len(self.proc_info)):<br /> print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),<br /> print &#39;%10s&#39; % &#39;CPU&#39;,<br /> print &#39;%10s&#39; % &#39;IOs&#39;,<br /> print &#39;&#39;</p>\n<p># init statistics<br /> io_busy = 0<br /> cpu_busy = 0</p>\n<p>while self.get_num_active() &gt; 0:<br /> clock_tick &#43;= 1</p>\n<p># check for io finish<br /> io_done = False<br /> for pid in range(len(self.proc_info)):<br /> if clock_tick in self.io_finish_times[pid]:<br /> # if IO finished, the should do something for related process<br /> #YOUR CODE<br /> io_done = True<br /> self.move_to_ready(STATE_WAIT,pid)<br /> if io_done:<br /> if self.proc_info[self.curr_proc][PROC_STATE] == STATE_WAIT:<br /> self.next_proc()<br /> if self.proc_info[self.curr_proc][PROC_STATE] == STATE_DONE:<br /> self.next_proc()<br /> #if clock_tick &gt; 10:<br /> # print self.curr_proc<br /> # if current proc is RUNNING and has an instruction, execute it<br /> instruction_to_execute = &#39;&#39;<br /> if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\<br /> len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:<br /> #pop a instruction from proc_info[self.curr_proc][PROC_CODE]to instruction_to_execute<br /> #YOUR CODE<br /> instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)<br /> cpu_busy &#43;= 1<br /> # OUTPUT: print what everyone is up to<br /> if io_done:<br /> print &#39;%3d*&#39; % clock_tick,<br /> else:<br /> print &#39;%3d &#39; % clock_tick,<br /> for pid in range(len(self.proc_info)):<br /> if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:<br /> print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),<br /> else:<br /> print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),<br /> if instruction_to_execute == &#39;&#39;:<br /> print &#39;%10s&#39; % &#39; &#39;,<br /> else:<br /> print &#39;%10s&#39; % 1,<br /> num_outstanding = self.get_ios_in_flight(clock_tick)<br /> if num_outstanding &gt; 0:<br /> print &#39;%10s&#39; % str(num_outstanding),<br /> io_busy &#43;= 1<br /> else:<br /> print &#39;%10s&#39; % &#39; &#39;,<br /> print &#39;&#39;</p>\n<p># if this is an YIELD instruction, switch to ready state<br /> # and add an io completion in the future<br /> if instruction_to_execute == DO_YIELD:<br /> #YOUR CODE<br /> self.move_to_ready(STATE_RUNNING)<br /> self.next_proc()</p>\n<p>if clock_tick == 15:<br /> while True:<br /> a = 1<br /> # if this is an IO instruction, switch to waiting state<br /> # and add an io completion in the future<br /> elif instruction_to_execute == DO_IO:<br /> #YOUR CODE<br /> self.proc_info[self.curr_proc][PROC_STATE] = STATE_WAIT<br /> self.io_finish_times[self.curr_proc].append(clock_tick&#43;self.io_length&#43;1)<br /> self.next_proc()</p>\n<p># ENDCASE: check if currently running thing is out of instructions<br /> self.check_if_done()<br /> #if clock_tick &gt; 8:<br /> # print self.curr_proc<br /> return (cpu_busy, io_busy, clock_tick)<br /> <br />#<br /># PARSE ARGUMENTS<br />#</p>\n<p>parser = OptionParser()<br />parser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0, help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)<br />parser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,<br /> help=&#39;a comma-separated list of processes to run, in the form X1:Y1:Z1,X2:Y2:Z2,... where X is the number of instructions that process should run, and Y/Z the chances (from 0 to 100) issue an YIELD/IO&#39;,<br /> action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)<br />parser.add_option(&#39;-L&#39;, &#39;--iolength&#39;, default=3, help=&#39;how long an IO takes&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;io_length&#39;)<br />parser.add_option(&#39;-p&#39;, &#39;--printstats&#39;, help=&#39;print statistics at end; only useful with -c flag (otherwise stats are not printed)&#39;, action=&#39;store_true&#39;, default=False, dest=&#39;print_stats&#39;)<br />(options, args) = parser.parse_args()</p>\n<p>random.seed(options.seed)</p>\n<p>process_switch_behavior = SCHED_SWITCH_ON_IO<br />io_done_behavior = IO_RUN_LATER<br />io_length=options.io_length</p>\n<p><br />s = scheduler(process_switch_behavior, io_done_behavior, io_length)</p>\n<p># example process description (10:100,10:100)<br />for p in options.process_list.split(&#39;,&#39;):<br /> s.load(p)</p>\n<p>print &#39;Produce a trace of what would happen when you run these processes:&#39;<br />for pid in range(s.get_num_processes()):<br /> print &#39;Process %d&#39; % pid<br /> for inst in range(s.get_num_instructions(pid)):<br /> print &#39; %s&#39; % s.get_instruction(pid, inst)<br /> print &#39;&#39;<br />print &#39;Important behaviors:&#39;<br />print &#39; System will switch when&#39;,<br />if process_switch_behavior == SCHED_SWIT</p>", "created": "2015-04-08T07:02:27Z", "bucket_order": 265, "bucket_name": "Week 4/5 - 4/11", "type": "feedback", "tag_good": [], "uid": "i718mp903qx", "children": [], "tag_good_arr": [], "id": "i88e1ymo3sgiw", "updated": "2015-04-08T07:02:27Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "i88dy9c8w3e5l9", "updated": "2015-04-08T06:59:35Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>陆喆 2012011308</p>\n<pre>#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\n\n# process switch behavior\nSCHED_SWITCH_ON_IO = &#39;SWITCH_ON_IO&#39;\n\n# io finished behavior\nIO_RUN_LATER = &#39;IO_RUN_LATER&#39;\n\n# process states\nSTATE_RUNNING = &#39;RUNNING&#39;\nSTATE_READY = &#39;READY&#39;\nSTATE_DONE = &#39;DONE&#39;\nSTATE_WAIT = &#39;WAITING&#39;\n\n# members of process structure\nPROC_CODE = &#39;code_&#39;\nPROC_PC = &#39;pc_&#39;\nPROC_ID = &#39;pid_&#39;\nPROC_STATE = &#39;proc_state_&#39;\n\n# things a process can do\nDO_COMPUTE = &#39;cpu&#39;\nDO_YIELD = &#39;yld&#39;\nDO_IO = &#39;io&#39;\n\nclass scheduler:\n    def __init__(self, process_switch_behavior, io_done_behavior, io_length):\n        # keep set of instructions for each of the processes\n        self.proc_info = {}\n        self.process_switch_behavior = process_switch_behavior\n        self.io_done_behavior = io_done_behavior\n        self.io_length = io_length\n        return\n\n    def new_process(self):\n        proc_id = len(self.proc_info)\n        self.proc_info[proc_id] = {}\n        self.proc_info[proc_id][PROC_PC] = 0\n        self.proc_info[proc_id][PROC_ID] = proc_id\n        self.proc_info[proc_id][PROC_CODE] = []\n        self.proc_info[proc_id][PROC_STATE] = STATE_READY\n        return proc_id\n\n    def load(self, program_description):\n        proc_id = self.new_process()\n        tmp = program_description.split(&#39;:&#39;)\n        if len(tmp) != 3:\n            print &#39;Bad description (%s): Must be number &lt;x:y:z&gt;&#39;\n            print &#39;  where X is the number of instructions&#39;\n            print &#39;  and Y is the percent change that an instruction is YIELD&#39;\n            print &#39;  and Z is the percent change that an instruction is IO&#39;\n            exit(1)\n\n        num_instructions, chance_yield, chance_io = int(tmp[0]), float(tmp[1])/100.0, float(tmp[2])/100.0\n        assert(chance_yield&#43;chance_io&lt;1)\n\n        #print &#34;proc %d, num_instr %d, change_cpu %f&#34; % (proc_id,num_instructions, chance_cpu)\n        for i in range(num_instructions):\n            randnum=random.random();\n            if randnum &lt; (1.0-chance_yield-chance_io):\n                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)\n            elif randnum &gt;= (1.0-chance_yield-chance_io) and randnum &lt; (1.0-chance_io):\n                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)\n            else:\n                self.proc_info[proc_id][PROC_CODE].append(DO_IO)\n            #print &#34;proc %d, instr idx %d, instr cxt %s&#34; % (proc_id, i, self.proc_info[proc_id][PROC_CODE][i])\n        return\n\n    #change to READY STATE, the current proc&#39;s state should be expected\n    #if pid==-1, then pid=self.curr_proc\n    def move_to_ready(self, expected, pid=-1):\n        #YOUR CODE\n        if pid == -1:\n            pid = self.curr_proc\n        if self.proc_info[self.curr_proc][PROC_STATE] == expected:\n            self.proc_info[pid][PROC_STATE] = STATE_READY\n        return\n\n    #change to RUNNING STATE, the current proc&#39;s state should be expected\n    def move_to_running(self, expected):\n        #YOUR CODE\n        if self.proc_info[self.curr_proc][PROC_STATE] == expected:\n            self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING\n        return\n\n    #change to DONE STATE, the current proc&#39;s state should be expected\n    def move_to_done(self, expected):\n        #YOUR CODE\n        if self.proc_info[self.curr_proc][PROC_STATE] == expected:\n            self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE\n        return\n\n    # MY CODE\n    def move_to_waiting(self, expected, clock_tick, pid=-1):\n        if pid == -1:\n            pid = self.curr_proc\n        clock_tick &#43;= 4\n        if self.proc_info[self.curr_proc][PROC_STATE] == expected:\n            self.proc_info[pid][PROC_STATE] = STATE_WAIT\n            self.io_finish_times[pid].append(clock_tick)\n        return\n\n    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc\n    def next_proc(self, pid=-1):\n        #YOUR CODE\n        if pid == -1:\n            pid = self.curr_proc\n        size = len(self.proc_info)\n        pid = 0\n        while pid &lt; size:\n            if (self.proc_info[pid][PROC_STATE] == STATE_READY):\n                self.curr_proc = pid\n                self.move_to_running(STATE_READY)\n                return\n            pid &#43;= 1\n        self.move_to_running(STATE_READY)\n        return\n\n    def get_num_processes(self):\n        return len(self.proc_info)\n\n    def get_num_instructions(self, pid):\n        return len(self.proc_info[pid][PROC_CODE])\n\n    def get_instruction(self, pid, index):\n        return self.proc_info[pid][PROC_CODE][index]\n\n    def get_num_active(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] != STATE_DONE:\n                num_active &#43;= 1\n        return num_active\n\n    def get_num_runnable(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\\n                   self.proc_info[pid][PROC_STATE] == STATE_RUNNING:\n                num_active &#43;= 1\n        return num_active\n\n    def get_ios_in_flight(self, current_time):\n        num_in_flight = 0\n        for pid in range(len(self.proc_info)):\n            for t in self.io_finish_times[pid]:\n                if t &gt; current_time:\n                    num_in_flight &#43;= 1\n        return num_in_flight\n\n\n    def space(self, num_columns):\n        for i in range(num_columns):\n            print &#39;%10s&#39; % &#39; &#39;,\n\n    def check_if_done(self):\n        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n                self.move_to_done(STATE_RUNNING)\n                self.next_proc()\n        return\n\n    def run(self):\n        clock_tick = 0\n\n        if len(self.proc_info) == 0:\n            return\n\n        # track outstanding IOs, per process\n        self.io_finish_times = {}\n        for pid in range(len(self.proc_info)):\n            self.io_finish_times[pid] = []\n\n        # make first one active\n        self.curr_proc = 0\n        self.move_to_running(STATE_READY)\n\n        # OUTPUT: heade&#96;[rs for each column\n        print &#39;%s&#39; % &#39;Time&#39;, \n        for pid in range(len(self.proc_info)):\n            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),\n        print &#39;%10s&#39; % &#39;CPU&#39;,\n        print &#39;%10s&#39; % &#39;IOs&#39;,\n        print &#39;&#39;\n\n        # init statistics\n        io_busy = 0\n        cpu_busy = 0\n\n        while self.get_num_active() &gt; 0:\n            clock_tick &#43;= 1\n\n            # check for io finish\n            io_done = False\n            for pid in range(len(self.proc_info)):\n                if clock_tick in self.io_finish_times[pid]:\n                    # if IO finished, the should do something for related process\n       \t            #YOUR CODE\n                    self.move_to_ready(STATE_RUNNING, pid)\n                    if self.proc_info[self.curr_proc][PROC_STATE] != STATE_RUNNING:\n                        # self.move_to_running(STATE_WAIT, pid)\n                        self.proc_info[pid][PROC_STATE] = STATE_RUNNING\n                        self.curr_proc = pid\n                    io_done = True\n                    pass #YOU should delete this\n            \n            # if current proc is RUNNING and has an instruction, execute it\n            instruction_to_execute = &#39;&#39;\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n                   len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                #pop a instruction from proc_info[self.curr_proc][PROC_CODE]to instruction_to_execute\n                #YOUR CODE\n                instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)\n                #YOU should delete this\n\n            # OUTPUT: print what everyone is up to\n            if io_done:\n                print &#39;%3d*&#39; % clock_tick,\n            else:\n                print &#39;%3d &#39; % clock_tick,\n            for pid in range(len(self.proc_info)):\n                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n                    cpu_busy &#43;= 1\n                    print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),\n                else:\n                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),\n            if instruction_to_execute == &#39;&#39;:\n                print &#39;%10s&#39; % &#39; &#39;,\n            else:\n                print &#39;%10s&#39; % 1,\n            num_outstanding = self.get_ios_in_flight(clock_tick)\n            if num_outstanding &gt; 0:\n                print &#39;%10s&#39; % str(num_outstanding),\n                io_busy &#43;= 1\n            else:\n                print &#39;%10s&#39; % &#39; &#39;,\n            print &#39;&#39;\n\n            # if this is an YIELD instruction, switch to ready state\n            # and add an io completion in the future\n            if instruction_to_execute == DO_YIELD:\n                #YOUR CODE\n                self.move_to_ready(STATE_RUNNING)\n                self.next_proc()\n                #YOU should delete this\n            # if this is an IO instruction, switch to waiting state\n            # and add an io completion in the future\n            elif instruction_to_execute == DO_IO:\n                #YOUR CODE\n                self.move_to_waiting(STATE_RUNNING, clock_tick)\n                self.next_proc()\n                #YOU should delete this\n\n            # ENDCASE: check if currently running thing is out of instructions\n            self.check_if_done()\n        return (cpu_busy, io_busy, clock_tick)\n        \n#\n# PARSE ARGUMENTS\n#\n\nparser = OptionParser()\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0, help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)\nparser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,\n                  help=&#39;a comma-separated list of processes to run, in the form X1:Y1:Z1,X2:Y2:Z2,... where X is the number of instructions that process should run, and Y/Z the chances (from 0 to 100) issue an YIELD/IO&#39;,\n                  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)\nparser.add_option(&#39;-L&#39;, &#39;--iolength&#39;, default=3, help=</pre>", "created": "2015-04-08T06:59:41Z", "bucket_order": 265, "bucket_name": "Week 4/5 - 4/11", "type": "followup", "tag_good": [], "uid": "i6urm1j1ynv6sm", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i88dydsn65m4yz", "updated": "2015-04-08T06:59:41Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "战裕隆 2012011388\n杨俊 2012011400\nhttps://github.com/zhanyl12/os_exercises/blob/master/05-2-spoc-discussion.md", "created": "2015-04-08T07:29:48Z", "bucket_order": 265, "bucket_name": "Week 4/5 - 4/11", "type": "followup", "tag_good": [], "uid": "i6xgf2t8N7w", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i88f1435rel3ro", "updated": "2015-04-08T07:29:48Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>丁延卓 2012011395</p>\n<p>周界 2012011394</p>\n<p></p>\n<pre>#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\n\n# process switch behavior\nSCHED_SWITCH_ON_IO = &#39;SWITCH_ON_IO&#39;\n\n# io finished behavior\nIO_RUN_LATER = &#39;IO_RUN_LATER&#39;\n\n# process states\nSTATE_RUNNING = &#39;RUNNING&#39;\nSTATE_READY = &#39;READY&#39;\nSTATE_DONE = &#39;DONE&#39;\nSTATE_WAIT = &#39;WAITING&#39;\n\n# members of process structure\nPROC_CODE = &#39;code_&#39;\nPROC_PC = &#39;pc_&#39;\nPROC_ID = &#39;pid_&#39;\nPROC_STATE = &#39;proc_state_&#39;\n\n# things a process can do\nDO_COMPUTE = &#39;cpu&#39;\nDO_YIELD = &#39;yld&#39;\nDO_IO = &#39;io&#39;\n\nclass scheduler:\n    def __init__(self, process_switch_behavior, io_done_behavior, io_length):\n        # keep set of instructions for each of the processes\n        self.proc_info = {}\n        self.process_switch_behavior = process_switch_behavior\n        self.io_done_behavior = io_done_behavior\n        self.io_length = io_length\n        return\n\n    def new_process(self):\n        proc_id = len(self.proc_info)\n        self.proc_info[proc_id] = {}\n        self.proc_info[proc_id][PROC_PC] = 0\n        self.proc_info[proc_id][PROC_ID] = proc_id\n        self.proc_info[proc_id][PROC_CODE] = []\n        self.proc_info[proc_id][PROC_STATE] = STATE_READY\n        return proc_id\n\n    def load(self, program_description):\n        proc_id = self.new_process()\n        tmp = program_description.split(&#39;:&#39;)\n        if len(tmp) != 3:\n            print (&#39;Bad description (%s): Must be number &lt;x:y:z&gt;&#39;)\n            print (&#39;  where X is the number of instructions&#39;)\n            print (&#39;  and Y is the percent change that an instruction is YIELD&#39;)\n            print (&#39;  and Z is the percent change that an instruction is IO&#39;)\n            exit(1)\n\n        num_instructions, chance_yield, chance_io = int(tmp[0]), float(tmp[1])/100.0, float(tmp[2])/100.0\n        assert(chance_yield&#43;chance_io&lt;1)\n\n        #print &#34;proc %d, num_instr %d, change_cpu %f&#34; % (proc_id,num_instructions, chance_cpu)\n        for i in range(num_instructions):\n            randnum=random.random();\n            if randnum &lt; (1.0-chance_yield-chance_io):\n                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)\n            elif randnum &gt;= (1.0-chance_yield-chance_io) and randnum &lt; (1.0-chance_io):\n                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)\n            else:\n                self.proc_info[proc_id][PROC_CODE].append(DO_IO)\n            #print &#34;proc %d, instr idx %d, instr cxt %s&#34; % (proc_id, i, self.proc_info[proc_id][PROC_CODE][i])\n        return\n\n    #change to READY STATE, the current proc&#39;s state should be expected\n    #if pid==-1, then pid=self.curr_proc\n    def move_to_ready(self, expected, pid=-1):\n        if pid == -1:\n            pid = self.curr_proc\n        print(&#34;adf\\n&#34;)\n        if self.proc_info[self.curr_proc][PROC_STATE] == expected:\n            self.proc_info[pid][PROC_STATE] = STATE_READY\n        else:\n            assert &#34;error&#34;\n        return\n\n    #change to RUNNING STATE, the current proc&#39;s state should be expected\n    def move_to_running(self, expected):\n        #YOUR CODE\n        if self.proc_info[self.curr_proc][PROC_STATE] == expected:\n            self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING\n        else:\n            assert &#34;error&#34;\n        return\n\n    #change to DONE STATE, the current proc&#39;s state should be expected\n    def move_to_done(self, expected):\n        #YOUR CODE\n        if self.proc_info[self.curr_proc][PROC_STATE] == expected:\n            self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE\n        else:\n            assert &#34;error&#34;\n        return\n\n    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc\n    def next_proc(self, pid=-1):\n        check = 0\n        num = -1\n        if pid == -1:\n            pid = self.curr_proc\n        for i in range(pid&#43;1,len(self.proc_info)):\n            if self.proc_info[i][PROC_STATE] == STATE_READY:\n                num = i\n                check = 1\n                break\n        \n        if check == 0:\n            for i in range(0,pid):\n                if self.proc_info[i][PROC_STATE] == STATE_READY:\n                    num = i\n        return num\n\n    def get_num_processes(self):\n        return len(self.proc_info)\n\n    def get_num_instructions(self, pid):\n        return len(self.proc_info[pid][PROC_CODE])\n\n    def get_instruction(self, pid, index):\n        return self.proc_info[pid][PROC_CODE][index]\n\n    def get_num_active(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] != STATE_DONE:\n                num_active &#43;= 1\n        return num_active\n\n    def get_num_runnable(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\\n                   self.proc_info[pid][PROC_STATE] == STATE_RUNNING:\n                num_active &#43;= 1\n        return num_active\n\n    def get_ios_in_flight(self, current_time):\n        num_in_flight = 0\n        for pid in range(len(self.proc_info)):\n            for t in self.io_finish_times[pid]:\n                if t &gt; current_time:\n                    num_in_flight &#43;= 1\n        return num_in_flight\n\n\n    def space(self, num_columns):\n        for i in range(num_columns):\n            print (&#39;%10s&#39; % &#39; &#39;,)\n\n    def check_if_done(self):\n        #print(len(self.proc_info[self.curr_proc][PROC_CODE]))\n        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n                #print(&#34;afad\\n&#34;)\n                self.move_to_done(STATE_RUNNING)\n                self.next_proc()\n        return\n\n    def run(self):\n        clock_tick = 0\n\n        if len(self.proc_info) == 0:\n            return\n\n        # track outstanding IOs, per process\n        self.io_finish_times = {}\n        for pid in range(len(self.proc_info)):\n            self.io_finish_times[pid] = []\n\n        # make first one active\n        self.curr_proc = 0\n        self.move_to_running(STATE_READY)\n\n        # OUTPUT: heade&#96;[rs for each column\n        print (&#39;%s&#39; % &#39;Time&#39;,) \n        for pid in range(len(self.proc_info)):\n            print (&#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),)\n        print (&#39;%10s&#39; % &#39;CPU&#39;,)\n        print (&#39;%10s&#39; % &#39;IOs&#39;,)\n        print (&#39;&#39;)\n\n        # init statistics\n        io_busy = 0\n        cpu_busy = 0\n        cpu_busy2 = 0\n        while self.get_num_active() &gt; 0:\n            clock_tick &#43;= 1\n\n            # check for io finish\n            io_done = False\n            for pid in range(len(self.proc_info)):\n                if clock_tick in self.io_finish_times[pid]:\n                    # if IO finished, the should do something for related process\n                    self.proc_info[pid][PROC_STATE] = STATE_READY\n                    num1 = self.next_proc(self.curr_proc)\n                    \n                    if self.proc_info[self.curr_proc][PROC_STATE] == STATE_WAIT:\n                        self.proc_info[pid][PROC_STATE] = STATE_RUNNING\n                        self.curr_proc = pid\n                     #YOU should delete this\n            \n            # if current proc is RUNNING and has an instruction, execute it\n            instruction_to_execute = &#39;&#39;\n            \n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n                   len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                #pop a instruction from proc_info[self.curr_proc][PROC_CODE]to instruction_to_execute\n                #YOUR CODE\n                #print(self.proc_info[self.curr_proc][PROC_CODE])\n                instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)\n                #print(self.proc_info[self.curr_proc][PROC_CODE])\n                cpu_busy &#43;= 1\n\n            # OUTPUT: print what everyone is up to\n            if io_done:\n                print(&#39;%3d*&#39; % clock_tick,)\n            else:\n                print(&#39;%3d &#39; % clock_tick,)\n            for pid in range(len(self.proc_info)):\n                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n                    print(&#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),)\n                else:\n                    print(&#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),)\n            if instruction_to_execute == &#39;&#39;:\n                print(&#39;%10s&#39; % &#39; &#39;,)\n            else:\n                print(&#39;%10s&#39; % 1,)\n            num_outstanding = self.get_ios_in_flight(clock_tick)\n            if num_outstanding &gt; 0:\n                print(&#39;%10s&#39; % str(num_outstanding),)\n                io_busy &#43;= 1\n            else:\n                print(&#39;%10s&#39; % &#39; &#39;,)\n            print(&#39;&#39;)\n\n            # if this is an YIELD instruction, switch to ready state\n            # and add an io completion in the future\n            if instruction_to_execute == DO_YIELD:\n                #YOUR CODE\n                \n                nums = self.next_proc(self.curr_proc)\n                \n                if nums == -1:\n                    \n                    self.check_if_done()\n                    \n                else:\n                   \n                    if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:\n                        self.check_if_done()\n                    else:\n                        self.move_to_ready(STATE_RUNNING,self.curr_proc)\n                    self.curr_proc = nums\n                    self.move_to_running(STATE_READY)\n\n                #pass #YOU should delete this\n            # if this is an IO instruction, switch to waiting state\n            # and add an io completion in the future\n            elif instruction_to_execute == DO_IO:\n                #YOUR CODE\n                self.check_if_done()\n                self.proc_info[self.curr_proc][PROC_STATE] = STATE_WAIT\n                self.io_finish_times[self.curr_proc].append(clock_tick &#43; 1 &#43; self.io_length)\n                nums = self.next_proc(self.curr_proc)\n                if nums == -1:\n                    pass\n                e</pre>", "created": "2015-04-08T07:41:38Z", "bucket_order": 265, "bucket_name": "Week 4/5 - 4/11", "type": "followup", "tag_good": [], "uid": "i7w0q2p8Cmz", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i88fgceck865nq", "updated": "2015-04-08T07:41:38Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>石伟男 王轩</p>\n<p>https://github.com/swnhieian/os_exercises/blob/master/all/process-cpuio-homework.py</p>", "created": "2015-04-08T08:07:45Z", "bucket_order": 265, "bucket_name": "Week 4/5 - 4/11", "type": "followup", "tag_good": [], "uid": "i6t1byqz5dE", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i88gdxgohnw63o", "updated": "2015-04-08T08:07:45Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p></p><pre>#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\n\n# process switch behavior\nSCHED_SWITCH_ON_IO = &#39;SWITCH_ON_IO&#39;\n\n# io finished behavior\nIO_RUN_LATER = &#39;IO_RUN_LATER&#39;\n\n# process states\nSTATE_RUNNING = &#39;RUNNING&#39;\nSTATE_READY = &#39;READY&#39;\nSTATE_DONE = &#39;DONE&#39;\nSTATE_WAIT = &#39;WAITING&#39;\n\n# members of process structure\nPROC_CODE = &#39;code_&#39;\nPROC_PC = &#39;pc_&#39;\nPROC_ID = &#39;pid_&#39;\nPROC_STATE = &#39;proc_state_&#39;\n\n# things a process can do\nDO_COMPUTE = &#39;cpu&#39;\nDO_YIELD = &#39;yld&#39;\nDO_IO = &#39;io&#39;\n\nclass scheduler:\n    def __init__(self, process_switch_behavior, io_done_behavior, io_length):\n        # keep set of instructions for each of the processes\n        self.proc_info = {}\n        self.process_switch_behavior = process_switch_behavior\n        self.io_done_behavior = io_done_behavior\n        self.io_length = io_length\n        return\n\n    def new_process(self):\n        proc_id = len(self.proc_info)\n        self.proc_info[proc_id] = {}\n        self.proc_info[proc_id][PROC_PC] = 0\n        self.proc_info[proc_id][PROC_ID] = proc_id\n        self.proc_info[proc_id][PROC_CODE] = []\n        self.proc_info[proc_id][PROC_STATE] = STATE_READY\n        return proc_id\n\n    def load(self, program_description):\n        proc_id = self.new_process()\n        tmp = program_description.split(&#39;:&#39;)\n        if len(tmp) != 3:\n            print &#39;Bad description (%s): Must be number &lt;x:y:z&gt;&#39;\n            print &#39;  where X is the number of instructions&#39;\n            print &#39;  and Y is the percent change that an instruction is YIELD&#39;\n            print &#39;  and Z is the percent change that an instruction is IO&#39;\n            exit(1)\n\n        num_instructions, chance_yield, chance_io = int(tmp[0]), float(tmp[1])/100.0, float(tmp[2])/100.0\n        assert(chance_yield&#43;chance_io&lt;1)\n\n        #print &#34;proc %d, num_instr %d, change_cpu %f&#34; % (proc_id,num_instructions, chance_cpu)\n        for i in range(num_instructions):\n            randnum=random.random();\n            if randnum &lt; (1.0-chance_yield-chance_io):\n                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)\n            elif randnum &gt;= (1.0-chance_yield-chance_io) and randnum &lt; (1.0-chance_io):\n                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)\n            else:\n                self.proc_info[proc_id][PROC_CODE].append(DO_IO)\n            #print &#34;proc %d, instr idx %d, instr cxt %s&#34; % (proc_id, i, self.proc_info[proc_id][PROC_CODE][i])\n        return\n\n    #change to READY STATE, the current proc&#39;s state should be expected\n    #if pid==-1, then pid=self.curr_proc\n    def move_to_ready(self, expected, pid=-1):\n        #YOUR CODE\n\tif pid==-1:\n\t    pid=self.curr_proc\n\tassert self.proc_info[pid][PROC_STATE]==expected\n\tself.proc_info[pid][PROC_STATE]=STATE_READY\n        return\n\n    #change to RUNNING STATE, the current proc&#39;s state should be expected\n    def move_to_running(self, expected):\n        #YOUR CODE\n\tassert self.proc_info[self.curr_proc][PROC_STATE]==expected\n\tself.proc_info[self.curr_proc][PROC_STATE]=STATE_RUNNING\n        return\n\n    #change to DONE STATE, the current proc&#39;s state should be expected\n    def move_to_done(self, expected):\n        #YOUR CODE\n\tassert self.proc_info[self.curr_proc][PROC_STATE]==expected\n\tself.proc_info[self.curr_proc][PROC_STATE]=STATE_DONE\n        return\n    \n    #my function\n    #change to WAIT STATE, the current proc&#39;s state should be expected\n    def move_to_wait(self,expected):\n\tassert self.proc_info[self.curr_proc][PROC_STATE]==expected\n\tself.proc_info[self.curr_proc][PROC_STATE]=STATE_WAIT\n\n    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc\n    def next_proc(self, pid=-1):\n        #YOUR CODE\n\tif pid==-1:\n\t    pid=self.curr_proc;\n\tn=len(self.proc_info)\n\tfor i in range(1,n&#43;1):\n\t    if self.proc_info[(pid&#43;i)%n][PROC_STATE]==STATE_READY:\n\t\tself.curr_proc=(pid&#43;i)%n\n\tif self.proc_info[self.curr_proc][PROC_STATE]==STATE_READY:\n\t    self.move_to_running(STATE_READY)\t\n        return\n\n    def get_num_processes(self):\n        return len(self.proc_info)\n\n    def get_num_instructions(self, pid):\n        return len(self.proc_info[pid][PROC_CODE])\n\n    def get_instruction(self, pid, index):\n        return self.proc_info[pid][PROC_CODE][index]\n\n    def get_num_active(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] != STATE_DONE:\n                num_active &#43;= 1\n        return num_active\n\n    def get_num_runnable(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\\n                   self.proc_info[pid][PROC_STATE] == STATE_RUNNING:\n                num_active &#43;= 1\n        return num_active\n    \n    def get_num_running(self):\n\tnum_running=0\n\tfor pid in range(len(self.proc_info)):\n\t    if self.proc_info[pid][PROC_STATE]==STATE_RUNNING:\n\t\tnum_running&#43;=1\n\treturn num_running\n\n    def get_ios_in_flight(self, current_time):\n        num_in_flight = 0\n        for pid in range(len(self.proc_info)):\n            for t in self.io_finish_times[pid]:\n                if t &gt; current_time:\n                    num_in_flight &#43;= 1\n        return num_in_flight\n\n\n    def space(self, num_columns):\n        for i in range(num_columns):\n            print &#39;%10s&#39; % &#39; &#39;,\n\n    def check_if_done(self):\n        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n                self.move_to_done(STATE_RUNNING)\n                self.next_proc()\n        return\n\n    def run(self):\n        clock_tick = 0\n\n        if len(self.proc_info) == 0:\n            return\n\n        # track outstanding IOs, per process\n        self.io_finish_times = {}\n        for pid in range(len(self.proc_info)):\n            self.io_finish_times[pid] = []\n\n        # make first one active\n        self.curr_proc = 0\n        self.move_to_running(STATE_READY)\n\n        # OUTPUT: heade&#96;[rs for each column\n        print &#39;%s&#39; % &#39;Time&#39;, \n        for pid in range(len(self.proc_info)):\n            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),\n        print &#39;%10s&#39; % &#39;CPU&#39;,\n        print &#39;%10s&#39; % &#39;IOs&#39;,\n        print &#39;&#39;\n\n        # init statistics\n        io_busy = 0\n        cpu_busy = 0\n\n        while self.get_num_active() &gt; 0:\n            clock_tick &#43;= 1\n\n            # check for io finish\n            io_done = False\n            for pid in range(len(self.proc_info)):\n                if clock_tick in self.io_finish_times[pid]:\n                    # if IO finished, the should do something for related process\n       \t            #YOUR CODE\n\t\t    io_done=True\n\t\t    self.move_to_ready(STATE_WAIT,pid)\n\t    if self.get_num_running()==0:\n\t\tself.next_proc()\n                    #pass #YOU should delete this\n            \n            # if current proc is RUNNING and has an instruction, execute it\n            instruction_to_execute = &#39;&#39;\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n                   len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                #pop a instruction from proc_info[self.curr_proc][PROC_CODE]to instruction_to_execute\n                #YOUR CODE\n\t\tinstruction_to_execute=self.proc_info[self.curr_proc][PROC_CODE].pop(0)    \n\t\tself.proc_info[self.curr_proc][PROC_PC]&#43;=1\n\t\t#pass #YOU should delete this\n\n            # OUTPUT: print what everyone is up to\n            if io_done:\n                print &#39;%3d*&#39; % clock_tick,\n            else:\n                print &#39;%3d &#39; % clock_tick,\n            for pid in range(len(self.proc_info)):\n                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n                    print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),\n                    cpu_busy&#43;=1\n                else:\n                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),\n            if instruction_to_execute == &#39;&#39;:\n                print &#39;%10s&#39; % &#39; &#39;,\n            else:\n                print &#39;%10s&#39; % 1,\n            num_outstanding = self.get_ios_in_flight(clock_tick)\n            if num_outstanding &gt; 0:\n                print &#39;%10s&#39; % str(num_outstanding),\n                io_busy &#43;= 1\n            else:\n                print &#39;%10s&#39; % &#39; &#39;,\n\t    print &#39;&#39;\n\t    #print &#34;curr_proc=%d&#34;%self.curr_proc\n\t    #print self.io_finish_times\n\t    #print self.proc_info\n\t    #print instruction_to_execute\n\n            # if this is an YIELD instruction, switch to ready state\n            # and add an io completion in the future\n            if instruction_to_execute == DO_YIELD:\n                #YOUR CODE\n\t\tself.move_to_ready(STATE_RUNNING)\n\t\tself.next_proc()\n               # pass #YOU should delete this\n            # if this is an IO instruction, switch to waiting state\n            # and add an io completion in the future\n            elif instruction_to_execute == DO_IO:\n                #YOUR CODE\n\t\tself.move_to_wait(STATE_RUNNING)\n\t\tself.io_finish_times[self.curr_proc].append(clock_tick&#43;self.io_length)\n\t\tself.next_proc()\n                #pass #YOU should delete this\n\n            # ENDCASE: check if currently running thing is out of instructions\n            self.check_if_done()\n        return (cpu_busy, io_busy, clock_tick)\n        \n#\n# PARSE ARGUMENTS\n#\n\nparser = OptionParser()\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0, help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)\nparser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,\n                  help=&#39;a comma-separated list of processes to run, in the form X1:Y1:Z1,X2:Y2:Z2,... where X is the number of instructions that process should run, and Y/Z the chances (from 0 to 100) issue an YIELD/IO&#39;,\n                  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)\nparser.add_option(&#39;-L&#39;, &#39;--iolength&#39;, default=3, help=&#39;how long an IO takes&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;io_length&#39;)\nparser.add_option(&#39;-p&#39;, &#39;--printstats&#39;, help=&#39;print statistics at end; only useful with -c flag (otherwise stats are not printed)&#39;, </pre>", "created": "2015-04-08T08:52:38Z", "bucket_order": 265, "bucket_name": "Week 4/5 - 4/11", "type": "followup", "tag_good": [], "uid": "i6vgn93glrq25f", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>潘寅旭2012010770</p>", "created": "2015-04-08T08:53:07Z", "bucket_order": 265, "bucket_name": "Week 4/5 - 4/11", "type": "feedback", "tag_good": [], "uid": "i6vgn93glrq25f", "children": [], "tag_good_arr": [], "id": "i88i09owziu56", "updated": "2015-04-08T08:53:07Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "i88hznjfhgg1q", "updated": "2015-04-08T08:52:38Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>韦福超2012011392&#xff08;又迟交了&#xff09;</p>\n<p>王振2012011397</p>\n<blockquote>\n<pre><code>    #! /usr/bin/env python\n</code></pre>\n</blockquote>\n<pre><code>import sys\nfrom optparse import OptionParser\nimport random\n\n# process switch behavior\nSCHED_SWITCH_ON_IO = &#39;SWITCH_ON_IO&#39;\n\n# io finished behavior\nIO_RUN_LATER = &#39;IO_RUN_LATER&#39;\n\n# process states\nSTATE_RUNNING = &#39;RUNNING&#39;\nSTATE_READY = &#39;READY&#39;\nSTATE_DONE = &#39;DONE&#39;\nSTATE_WAIT = &#39;WAITING&#39;\n\n# members of process structure\nPROC_CODE = &#39;code_&#39;\nPROC_PC = &#39;pc_&#39;\nPROC_ID = &#39;pid_&#39;\nPROC_STATE = &#39;proc_state_&#39;\n\n# things a process can do\nDO_COMPUTE = &#39;cpu&#39;\nDO_YIELD = &#39;yld&#39;\nDO_IO = &#39;io&#39;\n\n\nclass scheduler:\n\n    def __init__(self, process_switch_behavior, io_done_behavior, io_length):\n        # keep set of instructions for each of the processes\n        self.proc_info = {}\n        self.process_switch_behavior = process_switch_behavior\n        self.io_done_behavior = io_done_behavior\n        self.io_length = io_length\n        return\n\n    def new_process(self):\n        proc_id = len(self.proc_info)\n        self.proc_info[proc_id] = {}\n        self.proc_info[proc_id][PROC_PC] = 0\n        self.proc_info[proc_id][PROC_ID] = proc_id\n        self.proc_info[proc_id][PROC_CODE] = []\n        self.proc_info[proc_id][PROC_STATE] = STATE_READY\n        return proc_id\n\n    def load(self, program_description):\n        proc_id = self.new_process()\n        tmp = program_description.split(&#39;:&#39;)\n        if len(tmp) != 3:\n            print &#39;Bad description (%s): Must be number &lt;x:y:z&gt;&#39;\n            print &#39;  where X is the number of instructions&#39;\n            print &#39;  and Y is the percent change that an instruction is YIELD&#39;\n            print &#39;  and Z is the percent change that an instruction is IO&#39;\n            exit(1)\n\n        num_instructions, chance_yield, chance_io = int(\n            tmp[0]), float(tmp[1]) / 100.0, float(tmp[2]) / 100.0\n        assert(chance_yield &#43; chance_io &lt; 1)\n\n        # print &#34;proc %d, num_instr %d, change_cpu %f&#34; %\n        # (proc_id,num_instructions, chance_cpu)\n        for i in range(num_instructions):\n            randnum = random.random()\n            if randnum &lt; (1.0 - chance_yield - chance_io):\n                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)\n            elif randnum &gt;= (1.0 - chance_yield - chance_io) and randnum &lt; (1.0 - chance_io):\n                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)\n            else:\n                self.proc_info[proc_id][PROC_CODE].append(DO_IO)\n            # print &#34;proc %d, instr idx %d, instr cxt %s&#34; % (proc_id, i,\n            # self.proc_info[proc_id][PROC_CODE][i])\n        return\n\n    # change to READY STATE, the current proc&#39;s state should be expected\n    # if pid==-1, then pid=self.curr_proc\n    def move_to_ready(self, expected, pid=-1):\n        # YOUR CODE\n        assert expected != STATE_DONE\n        if pid == -1:\n            pid = self.curr_proc\n        self.proc_info[pid][PROC_STATE] = STATE_READY\n        return\n\n    # change to RUNNING STATE, the current proc&#39;s state should be expected\n    def move_to_running(self, expected):\n        # YOUR CODE\n        assert expected == STATE_READY\n        self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING\n        return\n\n    # change to DONE STATE, the current proc&#39;s state should be expected\n    def move_to_done(self, expected):\n        # YOUR CODE\n        assert expected == STATE_RUNNING\n        self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE\n        return\n\n    # choose next proc using FIFO/FCFS scheduling, If pid==-1, then\n    # pid=self.curr_proc\n    def next_proc(self, pid=-1):\n        # YOUR CODE\n        if pid == -1:\n            pid = self.curr_proc\n        pidx = pid &#43; 1\n        while pidx &lt; len(self.proc_info):\n            if self.proc_info[pidx][PROC_STATE] == STATE_READY:\n                self.curr_proc = pidx\n                self.move_to_running(STATE_READY)\n                return\n            pidx &#43;= 1\n        pidx = 0\n        while pidx &lt;= pid:\n            if self.proc_info[pidx][PROC_STATE] == STATE_READY:\n                self.curr_proc = pidx\n                self.move_to_running(STATE_READY)\n                return\n            pidx &#43;= 1\n\n    def get_num_processes(self):\n        return len(self.proc_info)\n\n    def get_num_instructions(self, pid):\n        return len(self.proc_info[pid][PROC_CODE])\n\n    def get_instruction(self, pid, index):\n        return self.proc_info[pid][PROC_CODE][index]\n\n    def get_num_active(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] != STATE_DONE:\n                num_active &#43;= 1\n        return num_active\n\n    def get_num_runnable(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\\n                    self.proc_info[pid][PROC_STATE] == STATE_RUNNING:\n                num_active &#43;= 1\n        return num_active\n\n    def get_ios_in_flight(self, current_time):\n        num_in_flight = 0\n        for pid in range(len(self.proc_info)):\n            for t in self.io_finish_times[pid]:\n                if t &gt; current_time:\n                    num_in_flight &#43;= 1\n        return num_in_flight\n\n    def space(self, num_columns):\n        for i in range(num_columns):\n            print &#39;%10s&#39; % &#39; &#39;,\n\n    def check_if_done(self):\n        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n                self.move_to_done(STATE_RUNNING)\n                self.next_proc()\n        return\n\n    def run(self):\n        clock_tick = 0\n\n        if len(self.proc_info) == 0:\n            return\n\n        # track outstanding IOs, per process\n        self.io_finish_times = {}\n        for pid in range(len(self.proc_info)):\n            self.io_finish_times[pid] = []\n\n        # make first one active\n        self.curr_proc = 0\n        self.move_to_running(STATE_READY)\n\n        # OUTPUT: heade&#96;[rs for each column\n        print &#39;%s&#39; % &#39;Time&#39;,\n        for pid in range(len(self.proc_info)):\n            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),\n        print &#39;%10s&#39; % &#39;CPU&#39;,\n        print &#39;%10s&#39; % &#39;IOs&#39;,\n        print &#39;&#39;\n\n        # init statistics\n        io_busy = 0\n        cpu_busy = 0\n\n        while self.get_num_active() &gt; 0:\n            clock_tick &#43;= 1\n            # check for io finish\n            io_done = False\n            for pid in range(len(self.proc_info)):\n                if clock_tick in self.io_finish_times[pid]:\n                    # if IO finished, the should do something for related process\n                    # YOUR CODE\n                    self.move_to_ready(STATE_WAIT, pid)\n                    self.io_finish_times[pid].pop(0)\n                    # YOU should delete this\n\n                    # if current proc is RUNNING and has an instruction,\n                    # execute it\n            instruction_to_execute = &#39;&#39;\n\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n                    len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                # YOUR CODE\n                instruction_to_execute = self.proc_info[\n                    self.curr_proc][PROC_CODE].pop(0)\n                cpu_busy &#43;= 1\n\n            # OUTPUT: print what everyone is up to\n            if io_done:\n                print &#39;%3d*&#39; % clock_tick,\n            else:\n                print &#39;%3d &#39; % clock_tick,\n            for pid in range(len(self.proc_info)):\n                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n                    print &#39;%10s&#39; % (&#39;RUN:&#39; &#43; instruction_to_execute),\n                else:\n                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),\n            if instruction_to_execute == &#39;&#39;:\n                print &#39;%10s&#39; % &#39; &#39;,\n            else:\n                print &#39;%10s&#39; % 1,\n            num_outstanding = self.get_ios_in_flight(clock_tick)\n            if num_outstanding &gt; 0:\n                print &#39;%10s&#39; % str(num_outstanding),\n                io_busy &#43;= 1\n            else:\n                print &#39;%10s&#39; % &#39; &#39;,\n            print &#39;&#39;\n\n            # if this is an YIELD instruction, switch to ready state\n            # and add an io completion in the future\n            if instruction_to_execute == DO_YIELD:\n                # YOUR CODE\n                self.move_to_ready(STATE_RUNNING)\n                self.next_proc()\n            # if this is an IO instruction, switch to waiting state\n            # and add an io completion in the future\n            elif instruction_to_execute == DO_IO:\n                # YOUR CODE\n                self.proc_info[self.curr_proc][PROC_STATE] = STATE_WAIT\n                self.io_finish_times[self.curr_proc].append(\n                    clock_tick &#43; io_length &#43; 1)\n                self.next_proc()\n                # YOU should delete this\n            if (self.proc_info[self.curr_proc][PROC_STATE] == STATE_WAIT\n                    or self.proc_info[self.curr_proc][PROC_STATE] == STATE_DONE):\n                self.next_proc()\n            # ENDCASE: check if currently running thing is out of\n            # instructions\n            self.check_if_done()\n        return (cpu_busy, io_busy, clock_tick)\n\n#\n# PARSE ARGUMENTS\n#\n\nparser = OptionParser()\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0,\n                  help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)\nparser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,\n                  help=&#39;a comma-separated list of processes to run, in the form X1:Y1:Z1,X2:Y2:Z2,... where X is the number of instructions that process should run, and Y/Z the chances (from 0 to 100) issue an YIELD/IO&#39;,\n                  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)\nparser.add_option(&#39;-L&#39;, &#39;--iolength&#39;, default=3,\n                  help=&#39;how long an IO takes&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;io_length&#39;)\nparser.add_option(&#39;-p&#39;, &#39;--printstats&#39;, help=&#39;print statistics at end; only useful wit</code></pre>", "created": "2015-04-08T10:53:28Z", "bucket_order": 265, "bucket_name": "Week 4/5 - 4/11", "type": "followup", "tag_good": [], "uid": "i6ut6cjo5lj4aa", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i88mb155jde1v0", "updated": "2015-04-08T10:53:28Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>韦福超2012011392</p>\n<p>王振2012011397</p>\n<pre><code>parser = OptionParser()\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0,\n                  help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)\nparser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,\n                  help=&#39;a comma-separated list of processes to run, in the form X1:Y1:Z1,X2:Y2:Z2,... where X is the number of instructions that process should run, and Y/Z the chances (from 0 to 100) issue an YIELD/IO&#39;,\n                  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)\nparser.add_option(&#39;-L&#39;, &#39;--iolength&#39;, default=3,\n                  help=&#39;how long an IO takes&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;io_length&#39;)\nparser.add_option(&#39;-p&#39;, &#39;--printstats&#39;, help=&#39;print statistics at end; only useful with -c flag (otherwise stats are not printed)&#39;,\n                  action=&#39;store_true&#39;, default=False, dest=&#39;print_stats&#39;)\n(options, args) = parser.parse_args()\n\nrandom.seed(options.seed)\n\nprocess_switch_behavior = SCHED_SWITCH_ON_IO\nio_done_behavior = IO_RUN_LATER\nio_length = options.io_length\n\n\ns = scheduler(process_switch_behavior, io_done_behavior, io_length)\n\n# example process description (10:100,10:100)\nfor p in options.process_list.split(&#39;,&#39;):\n    s.load(p)\n\nprint &#39;Produce a trace of what would happen when you run these processes:&#39;\nfor pid in range(s.get_num_processes()):\n    print &#39;Process %d&#39; % pid\n    for inst in range(s.get_num_instructions(pid)):\n        print &#39;  %s&#39; % s.get_instruction(pid, inst)\n    print &#39;&#39;\nprint &#39;Important behaviors:&#39;\nprint &#39;  System will switch when&#39;,\nif process_switch_behavior == SCHED_SWITCH_ON_IO:\n    print &#39;the current process is FINISHED or ISSUES AN YIELD or IO&#39;\nelse:\n    print &#39;error in sched switch on iobehavior&#39;\n    exit(-1)\nprint &#39;  After IOs, the process issuing the IO will&#39;,\nif io_done_behavior == IO_RUN_LATER:\n    print &#39;run LATER (when it is its turn)&#39;\nelse:\n    print &#39;error in IO done behavior&#39;\n    exit(-1)\nprint &#39;&#39;\n\n(cpu_busy, io_busy, clock_tick) = s.run()\n\nprint &#39;&#39;\nprint &#39;Stats: Total Time %d&#39; % clock_tick\nprint &#39;Stats: CPU Busy %d (%.2f%%)&#39; % (cpu_busy, 100.0 * float(cpu_busy) / clock_tick)\nprint &#39;Stats: IO Busy  %d (%.2f%%)&#39; % (io_busy, 100.0 * float(io_busy) / clock_tick)\nprint &#39;&#39;\n</code>\n<code>运行结果&#xff1a;\n</code>\n<code>Time     PID: 0     PID: 1        CPU        IOs \n  1      RUN:io      READY          1            \n  2     WAITING    RUN:yld          1          1 \n  3     WAITING     RUN:io          1          1 \n  4     WAITING    WAITING                     2 \n  5       READY    WAITING                     1 \n  6      RUN:io    WAITING          1          1 \n  7     WAITING      READY                     1 \n  8     WAITING    RUN:yld          1          1 \n  9     WAITING    RUN:yld          1          1 \n 10       READY    RUN:yld          1            \n 11     RUN:yld      READY          1            \n 12     RUN:cpu       DONE          1            \n 13     RUN:yld       DONE          1            \n\nStats: Total Time 13\nStats: CPU Busy 10 (76.92%)\nStats: IO Busy  8 (61.54%)</code></pre>", "created": "2015-04-08T10:55:47Z", "bucket_order": 265, "bucket_name": "Week 4/5 - 4/11", "type": "followup", "tag_good": [], "uid": "i6ut6cjo5lj4aa", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i88me0r13tj46r", "updated": "2015-04-08T10:55:47Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "2012011401 张梦豪\n#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\n\n# process switch behavior\nSCHED_SWITCH_ON_IO = &#39;SWITCH_ON_IO&#39;\n\n# io finished behavior\nIO_RUN_LATER = &#39;IO_RUN_LATER&#39;\n\n# process states\nSTATE_RUNNING = &#39;RUNNING&#39;\nSTATE_READY = &#39;READY&#39;\nSTATE_DONE = &#39;DONE&#39;\nSTATE_WAIT = &#39;WAITING&#39;\n\n# members of process structure\nPROC_CODE = &#39;code_&#39;\nPROC_PC = &#39;pc_&#39;\nPROC_ID = &#39;pid_&#39;\nPROC_STATE = &#39;proc_state_&#39;\n\n# things a process can do\nDO_COMPUTE = &#39;cpu&#39;\nDO_YIELD = &#39;yld&#39;\nDO_IO = &#39;io&#39;\n\nclass scheduler:\n    def __init__(self, process_switch_behavior, io_done_behavior, io_length):\n        # keep set of instructions for each of the processes\n        self.proc_info = {}\n        self.process_switch_behavior = process_switch_behavior\n        self.io_done_behavior = io_done_behavior\n        self.io_length = io_length\n        return\n\n    def new_process(self):\n        proc_id = len(self.proc_info)\n        self.proc_info[proc_id] = {}\n        self.proc_info[proc_id][PROC_PC] = 0\n        self.proc_info[proc_id][PROC_ID] = proc_id\n        self.proc_info[proc_id][PROC_CODE] = []\n        self.proc_info[proc_id][PROC_STATE] = STATE_READY\n        return proc_id\n\n    def load(self, program_description):\n        proc_id = self.new_process()\n        tmp = program_description.split(&#39;:&#39;)\n        if len(tmp) != 3:\n            print &#39;Bad description (%s): Must be number &#39;\n            print &#39;  where X is the number of instructions&#39;\n            print &#39;  and Y is the percent change that an instruction is YIELD&#39;\n            print &#39;  and Z is the percent change that an instruction is IO&#39;\n            exit(1)\n\n        num_instructions, chance_yield, chance_io = int(tmp[0]), float(tmp[1])/100.0, float(tmp[2])/100.0\n        assert(chance_yield&#43;chance_io&lt;1)\n\n        #print &#34;proc %d, num_instr %d, change_cpu %f&#34; % (proc_id,num_instructions, chance_cpu)\n        for i in range(num_instructions):\n            randnum=random.random();\n            if randnum &lt; (1.0-chance_yield-chance_io):\n                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)\n            elif randnum &gt;= (1.0-chance_yield-chance_io) and randnum &lt; (1.0-chance_io):\n                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)\n            else:\n                self.proc_info[proc_id][PROC_CODE].append(DO_IO)\n            #print &#34;proc %d, instr idx %d, instr cxt %s&#34; % (proc_id, i, self.proc_info[proc_id][PROC_CODE][i])\n        return\n\n    #change to READY STATE, the current proc&#39;s state should be expected\n    #if pid==-1, then pid=self.curr_proc\n    def move_to_ready(self, expected, pid=-1):\n        #YOUR CODE \n        if pid == -1:\n            pid = self.curr_proc\n        assert expected == self.proc_info[pid][PROC_STATE]\n        self.proc_info[pid][PROC_STATE] = STATE_READY\n        return\n\n    #change to RUNNING STATE, the current proc&#39;s state should be expected\n    def move_to_running(self, expected):\n        #YOUR CODE \n        assert expected == self.proc_info[self.curr_proc][PROC_STATE] \n        self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING\n        return\n\n    #change to DONE STATE, the current proc&#39;s state should be expected\n    def move_to_done(self, expected):\n        #YOUR CODE \n        assert expected == self.proc_info[self.curr_proc][PROC_STATE]\n        self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE\n        return\n        \n    def move_to_wait(self, expected):\n        assert self.proc_info[self.curr_proc][PROC_STATE] == expected\n        self.proc_info[self.curr_proc][PROC_STATE] = STATE_WAIT\n        return\n\n    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc\n    def next_proc(self, pid=-1):\n        #YOUR CODE \n        if pid == -1:\n            pid = self.curr_proc\n        for i in range(pid&#43;1,\n                self.get_num_processes())&#43;range(0, pid):\n            if self.proc_info[i][PROC_STATE] == STATE_READY:\n                self.curr_proc = i\n                self.move_to_running(STATE_READY)\n                return\n        if self.proc_info[pid][PROC_STATE] == STATE_READY:\n            self.move_to_running(STATE_READY)\n        return\n\n    def get_num_processes(self):\n        return len(self.proc_info)\n\n    def get_num_instructions(self, pid):\n        return len(self.proc_info[pid][PROC_CODE])\n\n    def get_instruction(self, pid, index):\n        return self.proc_info[pid][PROC_CODE][index]\n\n    def get_num_active(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] != STATE_DONE:\n                num_active &#43;= 1\n        return num_active\n\n    def get_num_runnable(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\\n                   self.proc_info[pid][PROC_STATE] == STATE_RUNNING:\n                num_active &#43;= 1\n        return num_active\n\n    def get_ios_in_flight(self, current_time):\n        num_in_flight = 0\n        for pid in range(len(self.proc_info)):\n            for t in self.io_finish_times[pid]:\n                if t &gt; current_time:\n                    num_in_flight &#43;= 1\n        return num_in_flight\n\n\n    def space(self, num_columns):\n        for i in range(num_columns):\n            print &#39;%10s&#39; % &#39; &#39;,\n\n    def check_if_done(self):\n        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n                self.move_to_done(STATE_RUNNING)\n                self.next_proc()\n        return\n\n    def run(self):\n        clock_tick = 0\n\n        if len(self.proc_info) == 0:\n            return\n\n        # track outstanding IOs, per process\n        self.io_finish_times = {}\n        for pid in range(len(self.proc_info)):\n            self.io_finish_times[pid] = []\n\n        # make first one active\n        self.curr_proc = 0\n        self.move_to_running(STATE_READY)\n\n        # OUTPUT: heade&#96;[rs for each column\n        print &#39;%s&#39; % &#39;Time&#39;, \n        for pid in range(len(self.proc_info)):\n            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),\n        print &#39;%10s&#39; % &#39;CPU&#39;,\n        print &#39;%10s&#39; % &#39;IOs&#39;,\n        print &#39;&#39;\n\n        # init statistics\n        io_busy = 0\n        cpu_busy = 0\n\n        while self.get_num_active() &gt; 0:\n            clock_tick &#43;= 1\n            \n            #assert clock_tick &lt;= 30\n            # check for io finish\n            io_done = False\n            for pid in range(len(self.proc_info)):\n                if clock_tick in self.io_finish_times[pid]:\n                    # if IO finished, the should do something for related process\n       \t            #YOUR CODE\n                    self.move_to_ready(STATE_WAIT,pid) \n\t\t    io_done = True \n\t    if io_done and self.proc_info[self.curr_proc][PROC_STATE] != STATE_RUNNING:\n                self.next_proc()\n\t\t\n            \n            # if current proc is RUNNING and has an instruction, execute it\n            instruction_to_execute = &#39;&#39;\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n                   len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                #pop a instruction from proc_info[self.curr_proc][PROC_CODE]to instruction_to_execute\n                #YOUR CODE\n                instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)\n                #print instruction_to_execute\n                self.proc_info[self.curr_proc][PROC_PC] &#43;= 1\n\n            # OUTPUT: print what everyone is up to\n            if io_done:\n                print &#39;%3d*&#39; % clock_tick,\n            else:\n                print &#39;%3d &#39; % clock_tick,\n            for pid in range(len(self.proc_info)):\n                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n                    print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),\n                else:\n                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),\n            if instruction_to_execute == &#39;&#39;:\n                print &#39;%10s&#39; % &#39; &#39;,\n            else:\n                cpu_busy &#43;= 1\n                print &#39;%10s&#39; % 1,\n            num_outstanding = self.get_ios_in_flight(clock_tick)\n            if num_outstanding &gt; 0:\n                print &#39;%10s&#39; % str(num_outstanding),\n                io_busy &#43;= 1\n            else:\n                print &#39;%10s&#39; % &#39; &#39;,\n            print &#39;&#39;\n\n            # if this is an YIELD instruction, switch to ready state\n            # and add an io completion in the future\n            if instruction_to_execute == DO_YIELD:\n                #YOUR CODE\n                self.move_to_ready(STATE_RUNNING)\n                self.next_proc()\n            # if this is an IO instruction, switch to waiting state\n            # and add an io completion in the future\n            elif instruction_to_execute == DO_IO:\n                self.move_to_wait(STATE_RUNNING)\n                self.io_finish_times[self.curr_proc].append(clock_tick&#43;self.io_length)\n                self.next_proc()\n            #else:\n                #self.next_proc()\n                #YOUR CODE\n\n            # ENDCASE: check if currently running thing is out of instructions\n            self.check_if_done()\n        return (cpu_busy, io_busy, clock_tick)\n        \n#\n# PARSE ARGUMENTS\n#\n\nparser = OptionParser()\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0, help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)\nparser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,\n                  help=&#39;a comma-separated list of processes to run, in the form X1:Y1:Z1,X2:Y2:Z2,... where X is the number of instructions that process should run, and Y/Z the chances (from 0 to 100) issue an YIELD/IO&#39;,\n                  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)\nparser.add_option(&#39;-L&#39;, &#39;--iolength&#39;, default=5, help=&#39;how long an IO takes&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;io_length&#39;)\nparser.add_option(&#39;-p&#39;, &#39;--printstats&#39;, help=&#39;print statistics at end; only useful with -c flag (otherwise stats are not printed)&#39;, action=&#39;store_tr", "created": "2015-04-08T13:16:14Z", "bucket_order": 265, "bucket_name": "Week 4/5 - 4/11", "type": "followup", "tag_good": [], "uid": "i6tawpo5Fm8", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "吐槽一下&#xff0c;总算把python语法弄得差不多了", "created": "2015-04-08T13:19:16Z", "bucket_order": 265, "bucket_name": "Week 4/5 - 4/11", "type": "feedback", "tag_good": [], "uid": "i6tawpo5Fm8", "children": [], "tag_good_arr": [], "id": "i88rijb145m5yd", "updated": "2015-04-08T13:19:16Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\n\n# process switch behavior\nSCHED_SWITCH_ON_IO = &#39;SWITCH_ON_IO&#39;\n\n# io finished behavior\nIO_RUN_LATER = &#39;IO_RUN_LATER&#39;\n\n# process states\nSTATE_RUNNING = &#39;RUNNING&#39;\nSTATE_READY = &#39;READY&#39;\nSTATE_DONE = &#39;DONE&#39;\nSTATE_WAIT = &#39;WAITING&#39;\n\n# members of process structure\nPROC_CODE = &#39;code_&#39;\nPROC_PC = &#39;pc_&#39;\nPROC_ID = &#39;pid_&#39;\nPROC_STATE = &#39;proc_state_&#39;\n\n# things a process can do\nDO_COMPUTE = &#39;cpu&#39;\nDO_YIELD = &#39;yld&#39;\nDO_IO = &#39;io&#39;\n\nclass scheduler:\n    def __init__(self, process_switch_behavior, io_done_behavior, io_length):\n        # keep set of instructions for each of the processes\n        self.proc_info = {}\n        self.process_switch_behavior = process_switch_behavior\n        self.io_done_behavior = io_done_behavior\n        self.io_length = io_length\n        return\n\n    def new_process(self):\n        proc_id = len(self.proc_info)\n        self.proc_info[proc_id] = {}\n        self.proc_info[proc_id][PROC_PC] = 0\n        self.proc_info[proc_id][PROC_ID] = proc_id\n        self.proc_info[proc_id][PROC_CODE] = []\n        self.proc_info[proc_id][PROC_STATE] = STATE_READY\n        return proc_id\n\n    def load(self, program_description):\n        proc_id = self.new_process()\n        tmp = program_description.split(&#39;:&#39;)\n        if len(tmp) != 3:\n            print &#39;Bad description (%s): Must be number &#39;\n            print &#39;  where X is the number of instructions&#39;\n            print &#39;  and Y is the percent change that an instruction is YIELD&#39;\n            print &#39;  and Z is the percent change that an instruction is IO&#39;\n            exit(1)\n\n        num_instructions, chance_yield, chance_io = int(tmp[0]), float(tmp[1])/100.0, float(tmp[2])/100.0\n        assert(chance_yield&#43;chance_io&lt;1)\n\n        #print &#34;proc %d, num_instr %d, change_cpu %f&#34; % (proc_id,num_instructions, chance_cpu)\n        for i in range(num_instructions):\n            randnum=random.random();\n            if randnum &lt; (1.0-chance_yield-chance_io):\n                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)\n            elif randnum &gt;= (1.0-chance_yield-chance_io) and randnum &lt; (1.0-chance_io):\n                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)\n            else:\n                self.proc_info[proc_id][PROC_CODE].append(DO_IO)\n            #print &#34;proc %d, instr idx %d, instr cxt %s&#34; % (proc_id, i, self.proc_info[proc_id][PROC_CODE][i])\n        return\n\n    #change to READY STATE, the current proc&#39;s state should be expected\n    #if pid==-1, then pid=self.curr_proc\n    def move_to_ready(self, expected, pid=-1):\n        #YOUR CODE \n        if pid == -1:\n            pid = self.curr_proc\n        assert expected == self.proc_info[pid][PROC_STATE]\n        self.proc_info[pid][PROC_STATE] = STATE_READY\n        return\n\n    #change to RUNNING STATE, the current proc&#39;s state should be expected\n    def move_to_running(self, expected):\n        #YOUR CODE \n        assert expected == self.proc_info[self.curr_proc][PROC_STATE] \n        self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING\n        return\n\n    #change to DONE STATE, the current proc&#39;s state should be expected\n    def move_to_done(self, expected):\n        #YOUR CODE \n        assert expected == self.proc_info[self.curr_proc][PROC_STATE]\n        self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE\n        return\n        \n    def move_to_wait(self, expected):\n        assert self.proc_info[self.curr_proc][PROC_STATE] == expected\n        self.proc_info[self.curr_proc][PROC_STATE] = STATE_WAIT\n        return\n\n    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc\n    def next_proc(self, pid=-1):\n        #YOUR CODE \n        if pid == -1:\n            pid = self.curr_proc\n        for i in range(pid&#43;1,\n                self.get_num_processes())&#43;range(0, pid):\n            if self.proc_info[i][PROC_STATE] == STATE_READY:\n                self.curr_proc = i\n                self.move_to_running(STATE_READY)\n                return\n        if self.proc_info[pid][PROC_STATE] == STATE_READY:\n            self.move_to_running(STATE_READY)\n        return\n\n    def get_num_processes(self):\n        return len(self.proc_info)\n\n    def get_num_instructions(self, pid):\n        return len(self.proc_info[pid][PROC_CODE])\n\n    def get_instruction(self, pid, index):\n        return self.proc_info[pid][PROC_CODE][index]\n\n    def get_num_active(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] != STATE_DONE:\n                num_active &#43;= 1\n        return num_active\n\n    def get_num_runnable(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\\n                   self.proc_info[pid][PROC_STATE] == STATE_RUNNING:\n                num_active &#43;= 1\n        return num_active\n\n    def get_ios_in_flight(self, current_time):\n        num_in_flight = 0\n        for pid in range(len(self.proc_info)):\n            for t in self.io_finish_times[pid]:\n                if t &gt; current_time:\n                    num_in_flight &#43;= 1\n        return num_in_flight\n\n\n    def space(self, num_columns):\n        for i in range(num_columns):\n            print &#39;%10s&#39; % &#39; &#39;,\n\n    def check_if_done(self):\n        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n                self.move_to_done(STATE_RUNNING)\n                self.next_proc()\n        return\n\n    def run(self):\n        clock_tick = 0\n\n        if len(self.proc_info) == 0:\n            return\n\n        # track outstanding IOs, per process\n        self.io_finish_times = {}\n        for pid in range(len(self.proc_info)):\n            self.io_finish_times[pid] = []\n\n        # make first one active\n        self.curr_proc = 0\n        self.move_to_running(STATE_READY)\n\n        # OUTPUT: heade&#96;[rs for each column\n        print &#39;%s&#39; % &#39;Time&#39;, \n        for pid in range(len(self.proc_info)):\n            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),\n        print &#39;%10s&#39; % &#39;CPU&#39;,\n        print &#39;%10s&#39; % &#39;IOs&#39;,\n        print &#39;&#39;\n\n        # init statistics\n        io_busy = 0\n        cpu_busy = 0\n\n        while self.get_num_active() &gt; 0:\n            clock_tick &#43;= 1\n            \n            #assert clock_tick &lt;= 30\n            # check for io finish\n            io_done = False\n            for pid in range(len(self.proc_info)):\n                if clock_tick in self.io_finish_times[pid]:\n                    # if IO finished, the should do something for related process\n       \t            #YOUR CODE\n                    self.move_to_ready(STATE_WAIT,pid) \n\t\t    io_done = True \n\t    if io_done and self.proc_info[self.curr_proc][PROC_STATE] != STATE_RUNNING:\n                self.next_proc()\n\t\t\n            \n            # if current proc is RUNNING and has an instruction, execute it\n            instruction_to_execute = &#39;&#39;\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n                   len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                #pop a instruction from proc_info[self.curr_proc][PROC_CODE]to instruction_to_execute\n                #YOUR CODE\n                instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)\n                #print instruction_to_execute\n                self.proc_info[self.curr_proc][PROC_PC] &#43;= 1\n\n            # OUTPUT: print what everyone is up to\n            if io_done:\n                print &#39;%3d*&#39; % clock_tick,\n            else:\n                print &#39;%3d &#39; % clock_tick,\n            for pid in range(len(self.proc_info)):\n                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n                    print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),\n                else:\n                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),\n            if instruction_to_execute == &#39;&#39;:\n                print &#39;%10s&#39; % &#39; &#39;,\n            else:\n                cpu_busy &#43;= 1\n                print &#39;%10s&#39; % 1,\n            num_outstanding = self.get_ios_in_flight(clock_tick)\n            if num_outstanding &gt; 0:\n                print &#39;%10s&#39; % str(num_outstanding),\n                io_busy &#43;= 1\n            else:\n                print &#39;%10s&#39; % &#39; &#39;,\n            print &#39;&#39;\n\n            # if this is an YIELD instruction, switch to ready state\n            # and add an io completion in the future\n            if instruction_to_execute == DO_YIELD:\n                #YOUR CODE\n                self.move_to_ready(STATE_RUNNING)\n                self.next_proc()\n            # if this is an IO instruction, switch to waiting state\n            # and add an io completion in the future\n            elif instruction_to_execute == DO_IO:\n                self.move_to_wait(STATE_RUNNING)\n                self.io_finish_times[self.curr_proc].append(clock_tick&#43;self.io_length)\n                self.next_proc()\n            #else:\n                #self.next_proc()\n                #YOUR CODE\n\n            # ENDCASE: check if currently running thing is out of instructions\n            self.check_if_done()\n        return (cpu_busy, io_busy, clock_tick)\n        \n#\n# PARSE ARGUMENTS\n#\n\nparser = OptionParser()\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0, help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)\nparser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,\n                  help=&#39;a comma-separated list of processes to run, in the form X1:Y1:Z1,X2:Y2:Z2,... where X is the number of instructions that process should run, and Y/Z the chances (from 0 to 100) issue an YIELD/IO&#39;,\n                  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)\nparser.add_option(&#39;-L&#39;, &#39;--iolength&#39;, default=5, help=&#39;how long an IO takes&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;io_length&#39;)\nparser.add_option(&#39;-p&#39;, &#39;--printstats&#39;, help=&#39;print statistics at end; only useful with -c flag (otherwise stats are not printed)&#39;, action=&#39;store_true&#39;, default=Fa", "created": "2015-04-08T13:20:24Z", "bucket_order": 265, "bucket_name": "Week 4/5 - 4/11", "type": "feedback", "tag_good": [], "uid": "i6tawpo5Fm8", "children": [], "tag_good_arr": [], "id": "i88rjzrqgax2v", "updated": "2015-04-08T13:20:24Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "i88rempt5in5qj", "updated": "2015-04-08T13:16:14Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>闵延泽 2012011291</p>\n<p>应杰夫 2012011293</p>\n<p>#! /usr/bin/env python</p>\n<p>import sys<br />from optparse import OptionParser<br />import random</p>\n<p># process switch behavior<br />SCHED_SWITCH_ON_IO = &#39;SWITCH_ON_IO&#39;</p>\n<p># io finished behavior<br />IO_RUN_LATER = &#39;IO_RUN_LATER&#39;</p>\n<p># process states<br />STATE_RUNNING = &#39;RUNNING&#39;<br />STATE_READY = &#39;READY&#39;<br />STATE_DONE = &#39;DONE&#39;<br />STATE_WAIT = &#39;WAITING&#39;</p>\n<p># members of process structure<br />PROC_CODE = &#39;code_&#39;<br />PROC_PC = &#39;pc_&#39;<br />PROC_ID = &#39;pid_&#39;<br />PROC_STATE = &#39;proc_state_&#39;</p>\n<p># things a process can do<br />DO_COMPUTE = &#39;cpu&#39;<br />DO_YIELD = &#39;yld&#39;<br />DO_IO = &#39;io&#39;</p>\n<p>class scheduler:<br /> def __init__(self, process_switch_behavior, io_done_behavior, io_length):<br /> # keep set of instructions for each of the processes<br /> self.proc_info = {}<br /> self.process_switch_behavior = process_switch_behavior<br /> self.io_done_behavior = io_done_behavior<br /> self.io_length = io_length<br /> return</p>\n<p>def new_process(self):<br /> proc_id = len(self.proc_info)<br /> self.proc_info[proc_id] = {}<br /> self.proc_info[proc_id][PROC_PC] = 0<br /> self.proc_info[proc_id][PROC_ID] = proc_id<br /> self.proc_info[proc_id][PROC_CODE] = []<br /> self.proc_info[proc_id][PROC_STATE] = STATE_READY<br /> return proc_id</p>\n<p>def load(self, program_description):<br /> proc_id = self.new_process()<br /> tmp = program_description.split(&#39;:&#39;)<br /> if len(tmp) != 3:<br /> print &#39;Bad description (%s): Must be number &lt;x:y:z&gt;&#39;<br /> print &#39; where X is the number of instructions&#39;<br /> print &#39; and Y is the percent change that an instruction is YIELD&#39;<br /> print &#39; and Z is the percent change that an instruction is IO&#39;<br /> exit(1)</p>\n<p>num_instructions, chance_yield, chance_io = int(tmp[0]), float(tmp[1])/100.0, float(tmp[2])/100.0<br /> assert(chance_yield&#43;chance_io&lt;1)</p>\n<p>#print &#34;proc %d, num_instr %d, change_cpu %f&#34; % (proc_id,num_instructions, chance_cpu)<br /> for i in range(num_instructions):<br /> randnum=random.random();<br /> if randnum &lt; (1.0-chance_yield-chance_io):<br /> self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)<br /> elif randnum &gt;= (1.0-chance_yield-chance_io) and randnum &lt; (1.0-chance_io):<br /> self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)<br /> else:<br /> self.proc_info[proc_id][PROC_CODE].append(DO_IO)<br /> #print &#34;proc %d, instr idx %d, instr cxt %s&#34; % (proc_id, i, self.proc_info[proc_id][PROC_CODE][i])<br /> return</p>\n<p>#change to READY STATE, the current proc&#39;s state should be expected<br /> #if pid==-1, then pid=self.curr_proc<br /> def move_to_ready(self, expected, pid=-1):<br /> #YOUR CODE<br /> assert expected == STATE_RUNNING or STATE_WAIT;<br /> if pid==-1:<br /> self.proc_info[self.curr_proc][PROC_STATE] = STATE_READY<br /> return<br /> self.proc_info[pid][PROC_STATE] = STATE_READY<br /> return</p>\n<p>#change to RUNNING STATE, the current proc&#39;s state should be expected<br /> def move_to_running(self, expected):<br /> #YOUR CODE<br /> assert expected == STATE_READY<br /> self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING<br /> return</p>\n<p>#change to DONE STATE, the current proc&#39;s state should be expected<br /> def move_to_done(self, expected):<br /> #YOUR CODE<br /> assert expected == STATE_RUNNING<br /> self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE<br /> return</p>\n<p>#choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc<br /> def next_proc(self, pid=-1):<br /> #YOUR CODE<br /> if pid==-1:<br /> pid=self.curr_proc<br /> l=len(self.proc_info)<br /> for i in range(pid&#43;1,l):<br /> if self.proc_info[i][PROC_STATE]==STATE_READY:<br /> self.curr_proc=i<br /> self.move_to_running(STATE_READY)<br /> return <br /> for i in range(0,pid&#43;1):<br /> if self.proc_info[i][PROC_STATE]==STATE_READY:<br /> self.curr_proc = i<br /> self.move_to_running(STATE_READY)<br /> return <br /> return</p>\n<p>def get_num_processes(self):<br /> return len(self.proc_info)</p>\n<p>def get_num_instructions(self, pid):<br /> return len(self.proc_info[pid][PROC_CODE])</p>\n<p>def get_instruction(self, pid, index):<br /> return self.proc_info[pid][PROC_CODE][index]</p>\n<p>def get_num_active(self):<br /> num_active = 0<br /> for pid in range(len(self.proc_info)):<br /> if self.proc_info[pid][PROC_STATE] != STATE_DONE:<br /> num_active &#43;= 1<br /> return num_active</p>\n<p>def get_num_runnable(self):<br /> num_active = 0<br /> for pid in range(len(self.proc_info)):<br /> if self.proc_info[pid][PROC_STATE] == STATE_READY or \\<br /> self.proc_info[pid][PROC_STATE] == STATE_RUNNING:<br /> num_active &#43;= 1<br /> return num_active</p>\n<p>def get_ios_in_flight(self, current_time):<br /> num_in_flight = 0<br /> for pid in range(len(self.proc_info)):<br /> for t in self.io_finish_times[pid]:<br /> if t &gt; current_time:<br /> num_in_flight &#43;= 1<br /> return num_in_flight</p>\n<p><br /> def space(self, num_columns):<br /> for i in range(num_columns):<br /> print &#39;%10s&#39; % &#39; &#39;,</p>\n<p>def check_if_done(self):<br /> if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:<br /> if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:<br /> self.move_to_done(STATE_RUNNING)<br /> self.next_proc()<br /> #else:<br /> # print &#34;########################&#34;,self.proc_info[self.curr_proc][PROC_CODE]<br /> return</p>\n<p>def run(self):<br /> clock_tick = 0</p>\n<p>if len(self.proc_info) == 0:<br /> return</p>\n<p># track outstanding IOs, per process<br /> self.io_finish_times = {}<br /> for pid in range(len(self.proc_info)):<br /> self.io_finish_times[pid] = []</p>\n<p># make first one active<br /> self.curr_proc = 0<br /> self.move_to_running(STATE_READY)</p>\n<p># OUTPUT: heade&#96;[rs for each column<br /> print &#39;%s&#39; % &#39;Time&#39;, <br /> for pid in range(len(self.proc_info)):<br /> print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),<br /> print &#39;%10s&#39; % &#39;CPU&#39;,<br /> print &#39;%10s&#39; % &#39;IOs&#39;,<br /> print &#39;&#39;</p>\n<p># init statistics<br /> io_busy = 0<br /> cpu_busy = 0</p>\n<p>while self.get_num_active() &gt; 0:<br /> clock_tick &#43;= 1</p>\n<p># check for io finish<br /> io_done = False<br /> for pid in range(len(self.proc_info)):<br /> if clock_tick in self.io_finish_times[pid]:<br /> # if IO finished, the should do something for related process<br /> #YOUR CODE<br /> self.move_to_ready(STATE_WAIT,pid)<br /> if self.proc_info[self.curr_proc][PROC_STATE] != STATE_RUNNING: #everyone is waiting<br /> self.curr_proc = pid<br /> self.proc_info[pid][PROC_STATE] = STATE_RUNNING<br /> io_done = True<br /> <br /> # if current proc is RUNNING and has an instruction, execute it<br /> instruction_to_execute = &#39;&#39;<br /> if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\<br /> len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:<br /> #pop a instruction from proc_info[self.curr_proc][PROC_CODE]to instruction_to_execute<br /> #YOUR CODE<br /> instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)</p>\n<p># OUTPUT: print what everyone is up to<br /> if io_done:<br /> print &#39;%3d*&#39; % clock_tick,<br /> else:<br /> print &#39;%3d &#39; % clock_tick,<br /> for pid in range(len(self.proc_info)):<br /> if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:<br /> print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),<br /> else:<br /> print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),<br /> if instruction_to_execute == &#39;&#39;:<br /> print &#39;%10s&#39; % &#39; &#39;,<br /> else:<br /> print &#39;%10s&#39; % 1,<br /> num_outstanding = self.get_ios_in_flight(clock_tick)<br /> if num_outstanding &gt; 0:<br /> print &#39;%10s&#39; % str(num_outstanding),<br /> io_busy &#43;= 1<br /> else:<br /> print &#39;%10s&#39; % &#39; &#39;,<br /> print &#39;&#39;</p>\n<p># if this is an YIELD instruction, switch to ready state<br /> # and add an io completion in the future<br /> if instruction_to_execute == DO_YIELD:<br /> #YOUR CODE<br /> self.move_to_ready(STATE_RUNNING)<br /> self.next_proc()<br /> # if this is an IO instruction, switch to waiting state<br /> # and add an io completion in the future<br /> elif instruction_to_execute == DO_IO:<br /> #YOUR CODE<br /> self.proc_info[self.curr_proc][PROC_STATE]=STATE_WAIT<br /> self.io_finish_times[self.curr_proc].append(clock_tick&#43;self.io_length)<br /> self.next_proc()</p>\n<p># ENDCASE: check if currently running thing is out of instructions<br /> self.check_if_done()<br /> #print &#34;########################&#34;<br /> return (cpu_busy, io_busy, clock_tick)<br /> <br />#<br /># PARSE ARGUMENTS<br />#</p>\n<p>parser = OptionParser()<br />parser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0, help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)<br />parser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,<br /> help=&#39;a comma-separated list of processes to run, in the form X1:Y1:Z1,X2:Y2:Z2,... where X is the number of instructions that process should run, and Y/Z the chances (from 0 to 100) issue an YIELD/IO&#39;,<br /> action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)<br />parser.add_option(&#39;-L&#39;, &#39;--iolength&#39;, default=3, help=&#39;how long an IO takes&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;io_length&#39;)<br />parser.add_option(&#39;-p&#39;, &#39;--printstats&#39;, help=&#39;print statistics at end; only useful with -c flag (otherwise stats are not printed)&#39;, action=&#39;store_true&#39;, default=False, dest=&#39;print_stats&#39;)<br />(options, args) = parser.parse_args()</p>\n<p>random.seed(options.seed)</p>\n<p>process_switch_behavior = SCHED_SWITCH_ON_IO<br />io_done_behavior = IO_RUN_LATER<br />io_length=options.io_length</p>\n<p><br />s = scheduler(process_switch_behavior, io_done_behavior, io_length)</p>\n<p># example process description (10:100,10:100)<br />for p in options.process_list.split(&#39;,&#39;):<br /> s.load(p)</p>\n<p>print &#39;Produce a trace of what would happen when you run these processes:&#39;<br />for pid in range(s.get_num_processes()):<br /> print &#39;Process %d&#39; % pid<br /> for inst in range(s.get_num_instructions(pid)):<br /> print &#39; %s&#39; % s.get_instruction(pid, inst)<br /> print &#39;&#39;<br />print &#39;Important behaviors:&#39;<br />print &#39; System will switch when&#39;,<br />if process_switch_behavior == SCHED_SW</p>", "created": "2015-04-08T13:38:07Z", "bucket_order": 265, "bucket_name": "Week 4/5 - 4/11", "type": "followup", "tag_good": [], "uid": "i71i9kso8Gp", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i88s6rydm0b4v8", "updated": "2015-04-08T13:38:07Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>2012011314 鲁逸沁</p>\n<p>2012011315 谢晓晖</p>\n<p>https://github.com/daaqing452/os_exercises/blob/master/all/05-2-spoc-discussion.md</p>", "created": "2015-04-08T15:24:46Z", "bucket_order": 265, "bucket_name": "Week 4/5 - 4/11", "type": "followup", "tag_good": [], "uid": "i6urr6is7yo3jv", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i88vzxbsilqko", "updated": "2015-04-08T15:24:46Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>陈天昱 2012011348</p>\n<p>李心田 2012011338</p>\n<p></p>\n<p><a href=\"https://github.com/cty12/os_exercises/blob/master/src/05-2-spoc_coding/process-cpuio.py\" target=\"_blank\">https://github.com/cty12/os_exercises/blob/master/src/05-2-spoc_coding/process-cpuio.py</a></p>", "created": "2015-04-08T15:30:54Z", "bucket_order": 265, "bucket_name": "Week 4/5 - 4/11", "type": "followup", "tag_good": [], "uid": "i6utvrywozd2vd", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>杨皓 2012013320</p>", "created": "2015-04-08T15:59:48Z", "bucket_order": 265, "bucket_name": "Week 4/5 - 4/11", "type": "feedback", "tag_good": [], "uid": "i6ugdh143r52f9", "children": [], "tag_good_arr": [], "id": "i88x8zosg4p1k1", "updated": "2015-04-08T15:59:48Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "i88w7tccdj93b6", "updated": "2015-04-08T15:30:54Z", "config": {}}], "tag_good_arr": [], "id": "i88bruqqbj84ez", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 28, "num_favorites": 0, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643167539386, "default_anonymity": "no"}, "error": null, "aid": "kyuzizsqold1hc"}