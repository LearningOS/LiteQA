{"result": {"folders": ["lab6", "课堂问答"], "nr": 358, "data": {"embed_links": []}, "created": "2015-04-27T07:04:19Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"uid": "hdjonbiyfs62ie", "anon": "no", "when": "2015-04-27T07:04:19Z", "data": "i8zjhji37b614t", "type": "create"}, {"to": "i8zjhji0gdc14s", "uid": "i6s09f3xHOf", "anon": "no", "when": "2015-04-27T16:06:14Z", "type": "followup"}, {"to": "i8zjhji0gdc14s", "uid": "i6uunp7jxDb", "anon": "no", "when": "2015-04-28T04:51:21Z", "type": "followup"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "第9周第1次课堂练习", "created": "2015-04-27T07:04:19Z", "content": "<p>跟踪内核调度器在执行时的进程在就绪队列和等待队列等队列的入队和出队信息。</p>\n<p></p>\n<p><a href=\"https://github.com/xuyongjiande/os_exercises/blob/master/all/06-2-lab6-spoc-discussion.md#1spoc-%E7%90%86%E8%A7%A3%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E6%94%AF%E6%92%91%E6%A1%86%E6%9E%B6%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B\">https://github.com/xuyongjiande/os_exercises/blob/master/all/06-2-lab6-spoc-discussion.md#1spoc-%E7%90%86%E8%A7%A3%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E6%94%AF%E6%92%91%E6%A1%86%E6%9E%B6%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B</a></p>\n<p></p>\n<p>请参与课堂讨论的同学在此回答你的结果和代码。</p>"}], "type": "note", "tags": ["instructor-note", "lab6", "课堂问答"], "tag_good": [], "unique_views": 128, "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>sched_class定义如下&#xff1a;<br />&#96;&#96;&#96;<br />struct sched_class {<br /> // the name of sched_class<br /> const char *name;<br /> // Init the run queue<br /> void (*init)(struct run_queue *rq);<br /> // put the proc into runqueue, and this function must be called with rq_lock<br /> void (*enqueue)(struct run_queue *rq, struct proc_struct *proc);<br /> // get the proc out runqueue, and this function must be called with rq_lock<br /> void (*dequeue)(struct run_queue *rq, struct proc_struct *proc);<br /> // choose the next runnable task<br /> struct proc_struct *(*pick_next)(struct run_queue *rq);<br /> // dealer of the time-tick<br /> void (*proc_tick)(struct run_queue *rq, struct proc_struct *proc);<br />};<br />&#96;&#96;&#96;<br />其中init用于初始化各个结构及变量</p>\n<p>enqueue和dequeue分别用于向run_queue中添加或删除一个runnable进程</p>\n<p>pick_next用于从run_queue中选出下一个被执行的进程</p>\n<p>proc_tick用于时钟相关的算法中&#xff0c;使调度器感知进程时钟的变化</p>\n<p>Round Robin算法是一个跟时钟密切相关的算法。</p>\n<p>sched_init中对相关的数据结构初始化&#xff0c;并指定调度类&#xff0c;调用调度类的init函数。</p>\n<p>在时钟中断的时候回调用sched_class_proc_tick()&#xff0c;让调度类感知时钟&#xff0c;如果时间片结束则调用schedule进行调度。</p>\n<p>在schedule中&#xff0c;如果当前进程状态为PROC_RUNNABLE&#xff0c;则调用sched_class_enqueue将其加入run_queue&#xff0c;然后调用sched_class_pick_next选择下一个执行进程。若不为NULL&#xff0c;则调用sched_class_dequeue将其出队&#xff0c;切换至该进程&#xff0c;否则切换至idleproc。</p>\n<p><br />至此调度完成。</p>\n<p>在do_exit、do_wait、lock、cpu_idle以及init_main等内核抢占点中均有调用schedule。</p>", "created": "2015-04-27T16:06:14Z", "bucket_order": 260, "bucket_name": "Week 4/26 - 5/2", "type": "followup", "tag_good": [], "uid": "i6s09f3xHOf", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "i902ug0jt7n2ls", "updated": "2015-04-27T16:06:14Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>加了一堆cprintf之后&#xff0c;输出如下&#xff1a;</p>\n<pre>&#43;&#43; setup timer interrupts\n --------------schedule in cpu_idle , from pid: 0 \n --------------schedule in do_wait , from pid: 1 \n kernel_execve: pid = 2, name = &#34;exit&#34;.\nI am the parent. Forking the child...\nI am parent, fork a child pid 3\nI am the parent, waiting now..\n --------------schedule in do_wait , from pid: 2 \n I am the child.\n --------------schedule in trap , from pid: 3 \n --------------to pid: 3 ------------------\n --------------schedule in trap , from pid: 3 \n --------------to pid: 3 ------------------\n --------------schedule in trap , from pid: 3 \n --------------to pid: 3 ------------------\n --------------schedule in trap , from pid: 3 \n --------------to pid: 3 ------------------\n --------------schedule in trap , from pid: 3 \n --------------to pid: 3 ------------------\n --------------schedule in trap , from pid: 3 \n --------------to pid: 3 ------------------\n --------------schedule in trap , from pid: 3 \n --------------to pid: 3 ------------------\n --------------schedule in do_exit , from pid: 3 \n --------------to pid: 2 ------------------\nwaitpid 3 ok.\nexit pass.\n --------------schedule in do_exit , from pid: 2 \n --------------to pid: 1 ------------------\n --------------schedule in init_main , from pid: 1 \n --------------to pid: 1 ------------------\nall user-mode processes have quit.\ninit check memory pass.\nkernel panic at kern/process/proc.c:460:\n    initproc exit.</pre>\n<p>https://github.com/sunlightsgy/ucore_lab/tree/master/labcodes_answer/lab6_result</p>", "created": "2015-04-28T04:51:21Z", "bucket_order": 260, "bucket_name": "Week 4/26 - 5/2", "type": "followup", "tag_good": [], "uid": "i6uunp7jxDb", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "i90u6eg9dah3tf", "updated": "2015-04-28T04:51:21Z", "config": {}}], "tag_good_arr": [], "id": "i8zjhji0gdc14s", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 4, "num_favorites": 1, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643167674791, "default_anonymity": "no"}, "error": null, "aid": "kyuzlw9zdcv5qp"}