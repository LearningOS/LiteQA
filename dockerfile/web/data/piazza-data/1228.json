{"result": {"folders": ["other"], "nr": 1228, "data": {"embed_links": []}, "created": "2018-05-17T03:25:26Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "isx6w631skc7on", "data": "jh9z2pn6r4q172", "type": "create", "when": "2018-05-17T03:25:26Z"}, {"anon": "no", "uid": "isu0wqaoff5125", "to": "jh9z2pn45r3171", "type": "followup", "when": "2018-05-18T05:45:36Z"}, {"anon": "no", "uid": "isx6w631skc7on", "to": "jh9z2pn45r3171", "type": "feedback", "when": "2018-05-18T09:10:40Z"}, {"anon": "no", "uid": "hcrrjuyequh4bt", "to": "jh9z2pn45r3171", "type": "followup", "when": "2018-05-21T07:09:48Z"}, {"anon": "no", "uid": "isx6w631skc7on", "to": "jh9z2pn45r3171", "type": "feedback", "when": "2018-05-21T09:45:12Z"}, {"anon": "no", "uid": "isu0wqaoff5125", "to": "jh9z2pn45r3171", "type": "feedback", "when": "2018-05-22T03:09:12Z"}, {"anon": "no", "uid": "isx6w631skc7on", "to": "jh9z2pn45r3171", "type": "feedback", "when": "2018-05-22T03:11:51Z"}, {"anon": "no", "uid": "isu0wqaoff5125", "to": "jh9z2pn45r3171", "type": "feedback", "when": "2018-05-22T03:16:28Z"}, {"anon": "no", "uid": "isu0wqaoff5125", "to": "jh9z2pn45r3171", "type": "feedback", "when": "2018-05-22T03:17:00Z"}, {"anon": "no", "uid": "isx6w631skc7on", "to": "jh9z2pn45r3171", "type": "feedback", "when": "2018-05-22T03:20:57Z"}, {"anon": "no", "uid": "isu0wqaoff5125", "to": "jh9z2pn45r3171", "type": "feedback", "when": "2018-05-22T04:03:59Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "jh9z2pn45r3171", "type": "feedback", "when": "2018-05-22T07:57:47Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "isx6w631skc7on", "subject": "在用户态直接响应中断", "created": "2018-05-17T03:25:26Z", "content": "<p>应陈老师要求&#xff0c;以下实现了μCore中在用户态对中断的直接响应。改动如下&#xff1a;<br /><br />1. 在&#96;trap.c&#96;中增加函数&#96;user_set_idt(int int_id, uintptr_t handler)&#96;&#xff0c;将IDT中编号为&#96;int_id&#96;的中断的处理向量设置为&#96;handler&#96;&#xff0c;并对特权级做相应设置&#xff0c;IDT的其他项不变&#xff1b;<br />2. 新增系统调用&#96;sys_setvec(int int_id, uintptr_t handler)&#96;&#xff0c;用于在用户态调用上述&#96;user_set_idt&#96;函数&#xff1b;</p>\n<p>3. 新增用户程序&#96;setvec&#96;&#xff0c;将程序中函数&#96;handler&#96;设为中断255的处理向量&#xff0c;调用&#96;sys_setvec&#96;设置之&#xff0c;然后执行&#96;ini $255&#96;触发。实验结果为&#96;handler&#96;可以被成功执行。</p>\n<p></p>\n<p>为了降低实现难度&#xff0c;本实现有如下两点缺陷&#xff0c;但这两点缺陷是可以避免的&#xff1a;</p>\n<p>1. 只能设置一个用户态处理向量&#xff0c;并且设置完后不能恢复原来的处理向量&#xff1b;</p>\n<p>2. 没有实现从中断处理向量的返回。</p>\n<p></p>\n<p>由于修改是基于Lab 8的&#xff0c;而Lab 8还没有截止&#xff0c;所以此处不公开完整代码。改动的git diff如下&#xff1a;</p>\n<p></p>\n<p>diff --git a/labcodes/lab8/kern/syscall/syscall.c b/labcodes/lab8/kern/syscall/syscall.c<br />index be23ab9..4b16f31 100644<br />--- a/labcodes/lab8/kern/syscall/syscall.c<br />&#43;&#43;&#43; b/labcodes/lab8/kern/syscall/syscall.c<br />&#64;&#64; -157,6 &#43;157,12 &#64;&#64; sys_dup(uint32_t arg[]) {<br /> return sysfile_dup(fd1, fd2);<br /> }<br /> <br />&#43;static int<br />&#43;sys_setvec(uint32_t arg[]) {<br />&#43; user_set_idt((int)arg[0], (uintptr_t)arg[1]);<br />&#43; return 0;<br />&#43;}<br />&#43;<br /> static int (*syscalls[])(uint32_t arg[]) = {<br /> [SYS_exit] sys_exit,<br /> [SYS_fork] sys_fork,<br />&#64;&#64; -180,6 &#43;186,7 &#64;&#64; static int (*syscalls[])(uint32_t arg[]) = {<br /> [SYS_getcwd] sys_getcwd,<br /> [SYS_getdirentry] sys_getdirentry,<br /> [SYS_dup] sys_dup,<br />&#43; [SYS_setvec] sys_setvec,<br /> };<br /> <br /> #define NUM_SYSCALLS ((sizeof(syscalls)) / (sizeof(syscalls[0])))<br />diff --git a/labcodes/lab8/kern/trap/trap.c b/labcodes/lab8/kern/trap/trap.c<br />index 7ecd1ab..c270805 100644<br />--- a/labcodes/lab8/kern/trap/trap.c<br />&#43;&#43;&#43; b/labcodes/lab8/kern/trap/trap.c<br />&#64;&#64; -39,6 &#43;39,20 &#64;&#64; static struct pseudodesc idt_pd = {<br /> sizeof(idt) - 1, (uintptr_t)idt<br /> };<br /> <br />&#43;void<br />&#43;user_set_idt(int int_id, uintptr_t handler) {<br />&#43; extern uintptr_t __vectors[];<br />&#43; int i;<br />&#43; for (i = 0; i &lt; 256; i&#43;&#43;)<br />&#43; if (i == int_id) {<br />&#43; SETGATE(idt[i], i &lt; IRQ_OFFSET || i == T_SYSCALL, GD_UTEXT, handler, DPL_USER);<br />&#43; } else {<br />&#43; SETGATE(idt[i], i &lt; IRQ_OFFSET || i == T_SYSCALL, GD_KTEXT, __vectors[i], i == T_SYSCALL ? DPL_USER : DPL_KERNEL);<br />&#43; }<br />&#43; lidt(&amp;idt_pd);<br />&#43; cprintf(&#34;New IDT loaded\\n&#34;);<br />&#43;}<br />&#43;<br /> /* idt_init - initialize IDT to each of the entry points in kern/trap/vectors.S */<br /> void<br /> idt_init(void) {<br />diff --git a/labcodes/lab8/kern/trap/trap.h b/labcodes/lab8/kern/trap/trap.h<br />index e870a6f..395465f 100644<br />--- a/labcodes/lab8/kern/trap/trap.h<br />&#43;&#43;&#43; b/labcodes/lab8/kern/trap/trap.h<br />&#64;&#64; -80,6 &#43;80,7 &#64;&#64; struct trapframe {<br /> uint16_t tf_padding5;<br /> } __attribute__((packed));<br /> <br />&#43;void user_set_idt(int int_id, uintptr_t handler);<br /> void idt_init(void);<br /> void print_trapframe(struct trapframe *tf);<br /> void print_regs(struct pushregs *regs);<br />diff --git a/labcodes/lab8/libs/unistd.h b/labcodes/lab8/libs/unistd.h<br />index 8599be6..035306c 100644<br />--- a/labcodes/lab8/libs/unistd.h<br />&#43;&#43;&#43; b/labcodes/lab8/libs/unistd.h<br />&#64;&#64; -31,6 &#43;31,8 &#64;&#64;<br /> #define SYS_dup 130<br /> /* OLNY FOR LAB6 */<br /> #define SYS_lab6_set_priority 255<br />&#43;/* User interrupt experiment */<br />&#43;#define SYS_setvec 254<br /> <br /> /* SYS_fork flags */<br /> #define CLONE_VM 0x00000100 // set if VM shared between processes<br />diff --git a/labcodes/lab8/user/libs/syscall.c b/labcodes/lab8/user/libs/syscall.c<br />index 5c5d978..c2755ba 100644<br />--- a/labcodes/lab8/user/libs/syscall.c<br />&#43;&#43;&#43; b/labcodes/lab8/user/libs/syscall.c<br />&#64;&#64; -143,3 &#43;143,9 &#64;&#64; int<br /> sys_dup(int fd1, int fd2) {<br /> return syscall(SYS_dup, fd1, fd2);<br /> }<br />&#43;<br />&#43;int<br />&#43;sys_setvec(int int_id, uintptr_t handler) {<br />&#43; return syscall(SYS_setvec, int_id, handler);<br />&#43;}<br />&#43;<br />diff --git a/labcodes/lab8/user/libs/syscall.h b/labcodes/lab8/user/libs/syscall.h<br />index 0238fa7..8d0abfc 100644<br />--- a/labcodes/lab8/user/libs/syscall.h<br />&#43;&#43;&#43; b/labcodes/lab8/user/libs/syscall.h<br />&#64;&#64; -26,6 &#43;26,7 &#64;&#64; int sys_fsync(int fd);<br /> int sys_getcwd(char *buffer, size_t len);<br /> int sys_getdirentry(int fd, struct dirent *dirent);<br /> int sys_dup(int fd1, int fd2);<br />&#43;int sys_setvec(int int_id, uintptr_t handler);<br /> void sys_lab6_set_priority(uint32_t priority); //only for lab6<br /> <br /> <br />diff --git a/labcodes/lab8/user/setvec.c b/labcodes/lab8/user/setvec.c<br />new file mode 100644<br />index 0000000..b6702ed<br />--- /dev/null<br />&#43;&#43;&#43; b/labcodes/lab8/user/setvec.c<br />&#64;&#64; -0,0 &#43;1,17 &#64;&#64;<br />&#43;#include &lt;stdio.h&gt;<br />&#43;#include &lt;ulib.h&gt;<br />&#43;#include &lt;syscall.h&gt;<br />&#43;<br />&#43;void handler() {<br />&#43; cprintf(&#34;Triggered\\n&#34;);<br />&#43; exit(0);<br />&#43;}<br />&#43;<br />&#43;int<br />&#43;main(void) {<br />&#43; sys_setvec(255, (uintptr_t)handler);<br />&#43; cprintf(&#34;Handler set\\n&#34;);<br />&#43; asm volatile (&#34;int $255&#34;);<br />&#43; return 0;<br />&#43;}<br />&#43;</p>"}], "type": "question", "tags": ["other", "student", "unanswered"], "tag_good": [{"role": "instructor", "name": "Yu Chen", "endorser": {}, "admin": true, "photo": "1378950179_35.png", "id": "hcrrjuyequh4bt", "photo_url": "https://d1b10bmlvqabco.cloudfront.net/photos/hcrrjuyequh4bt/1378950179_35.png", "us": false, "class_sections": ["课程设计_i5j09fnsl7k5x0", "清华学生_i5j09fnsl7k5x0", "所有老师和助教_i5j09fnsl7k5x0", "os2018spring_i5j09fnsl7k5x0"], "facebook_id": null}, {"role": "student", "name": "Wende Tan", "endorser": {}, "admin": false, "photo": null, "id": "isu0wqaoff5125", "photo_url": null, "published": true, "us": false, "class_sections": ["os2018spring_i5j09fnsl7k5x0"], "facebook_id": null}, {"role": "", "name": "Jason Yu", "endorser": {}, "admin": false, "photo": null, "id": "iswk6782g923e6", "photo_url": null, "published": true, "us": false, "class_sections": ["os2018spring_i5j09fnsl7k5x0"], "facebook_id": null}], "unique_views": 216, "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>好像还需要写一份在用户态的保存现场的代码。</p>\n<p></p>\n<p>从中断处理函数返回&#xff0c;由于没有换栈&#xff0c;直接用iret似乎就可以了&#xff08;注意errorcode&#xff09;&#xff0c;当然之前需要恢复现场。</p>", "created": "2018-05-18T05:45:36Z", "bucket_order": 97, "bucket_name": "Week 5/13 - 5/19", "type": "followup", "tag_good": [], "uid": "isu0wqaoff5125", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>是的&#xff0c;这可以在用户态库实现</p>", "created": "2018-05-18T09:10:40Z", "bucket_order": 97, "bucket_name": "Week 5/13 - 5/19", "type": "feedback", "tag_good": [], "uid": "isx6w631skc7on", "children": [], "tag_good_arr": [], "id": "jhbquji55pr4fj", "updated": "2018-05-18T09:10:40Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "jhbjite8bh71b9", "updated": "2018-05-18T05:45:36Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>我还有点疑问&#xff0c;&#xff08;假定OS限制了用户程序可以处理的中断类型&#xff0c;比如串口&#xff09;</p>\n<p>1 如果一个用户进程A申请了一个串口中断服务例程&#xff0c;那么一个串口中断来了&#xff0c;当这个用户进程不处于running态情况&#xff0c;如何处理&#xff1f;</p>\n<p></p>\n<p>2 如果其他用户进程B在running态&#xff0c;那么B也不得不处理本不属于它串口中断&#xff1f;</p>\n<p></p>\n<p>3 串口是一个设备&#xff0c;如果A申请了一个串口中断服务例程&#xff0c;那么其他进程如何共享这个设备&#xff1f;</p>\n<p></p>\n<p>4 其他进程能否搞破坏&#xff0c;让串口无法正常工作&#xff1f;</p>\n<p></p>\n<p>5 有哪些用户态中断服务潜在的安全风险&#xff1f;有哪些安全防范措施&#xff0c;可以避免这些用户态中断服务潜在的安全风险&#xff1f;</p>\n<p></p>\n<p>6 在哪种场景下&#xff0c;采用用户态中断服务有哪些好处&#xff1f;</p>\n<p></p>\n<p>7 有没有哪些应用已经采用了这样的方案&#xff1f;</p>\n<p></p>\n<p>请&#64;唐适之 有空时看看。</p>\n<p><a href=\"/class/i5j09fnsl7k5x0?cid=1228\"></a></p>", "created": "2018-05-21T07:09:48Z", "bucket_order": 96, "bucket_name": "Week 5/20 - 5/26", "type": "followup", "tag_good": [], "uid": "hcrrjuyequh4bt", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>1. a. 假设进程A不占有时间片时&#xff0c;相关中断可被忽略&#xff08;例如中断来自键盘&#xff09;&#xff0c;那么有如下解决办法&#xff1a;当进程A用完当前时间片时&#xff0c;在进程调度器中可用中断屏蔽字将特定中断屏蔽&#xff0c;待进程A重新进入running态时再取消屏蔽。b. 若进程A不占有时间片时&#xff0c;相关中断不可被忽略&#xff0c;则此中断不宜直接由用户态处理&#xff08;例如串口在每个字符到达时发出终端&#xff0c;程序需及时将该字符记入buffer中&#xff09;&#xff1b;</p>\n<p></p>\n<p>2. 解决办法同1&#xff1b;</p>\n<p></p>\n<p>3. 对于在进程间共享的设备&#xff0c;不适合直接在用户态处理中断&#xff1b;</p>\n<p></p>\n<p>4. 同3&#xff1b;</p>\n<p></p>\n<p>5. 用户态不能强行处理上述不适合由用户态处理的中断。用户程序申请处理某中断时&#xff0c;操作系统应做出相应判断&#xff0c;包括&#xff1a;a. 某些已知中断不能由用户程序处理&#xff0c;例如时钟中断&#xff1b;b. 同一时间&#xff0c;一个中断最多只能注册在一个用户进程中&#xff1b;</p>\n<p></p>\n<p>6. 采用用户态中断服务的好处是提升中断响应速度&#xff0c;可能可以用于实时操作系统中&#xff0c;或用于处理某进程独享的通信信道&#xff08;例如RDMA&#xff1f;&#xff09;&#xff1b;</p>\n<p></p>\n<p>7. 这点我不清楚。陈老师说RISC-V已对用户态处理中断做出了支持&#xff0c;请问RISC-V下有这样的应用吗&#xff1f;</p>", "created": "2018-05-21T09:45:12Z", "bucket_order": 96, "bucket_name": "Week 5/20 - 5/26", "type": "feedback", "tag_good": [], "uid": "isx6w631skc7on", "children": [], "tag_good_arr": [], "id": "jhg2eincnl666", "updated": "2018-05-21T09:45:12Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>所以&#xff0c;哪些中断适合直接在用户态处理&#xff1f;</p>", "created": "2018-05-22T03:09:12Z", "bucket_order": 96, "bucket_name": "Week 5/20 - 5/26", "type": "feedback", "tag_good": [], "uid": "isu0wqaoff5125", "children": [], "tag_good_arr": [], "id": "jhh3p3zfyg07iy", "updated": "2018-05-22T03:09:12Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>由某进程独享的、需要低响应延迟的中断&#xff0c;适合直接在用户态处理。</p>", "created": "2018-05-22T03:11:51Z", "bucket_order": 96, "bucket_name": "Week 5/20 - 5/26", "type": "feedback", "tag_good": [], "uid": "isx6w631skc7on", "children": [], "tag_good_arr": [], "id": "jhh3sih08j530s", "updated": "2018-05-22T03:11:51Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>请您举例</p>", "created": "2018-05-22T03:16:28Z", "bucket_order": 96, "bucket_name": "Week 5/20 - 5/26", "type": "feedback", "tag_good": [], "uid": "isu0wqaoff5125", "children": [], "tag_good_arr": [], "id": "jhh3yfxsbov1ev", "updated": "2018-05-22T03:16:28Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>假设进程不占有时间片时&#xff0c;相关中断可被忽略&#xff0c;那么不能够做到低延迟。</p>", "created": "2018-05-22T03:17:00Z", "bucket_order": 96, "bucket_name": "Week 5/20 - 5/26", "type": "feedback", "tag_good": [], "uid": "isu0wqaoff5125", "children": [], "tag_good_arr": [], "id": "jhh3z51aler1n7", "updated": "2018-05-22T03:17:00Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>陈老师说RISC-V支持&#xff0c;RISC-V是怎么实现的&#xff1f;</p>", "created": "2018-05-22T03:20:57Z", "bucket_order": 96, "bucket_name": "Week 5/20 - 5/26", "type": "feedback", "tag_good": [], "uid": "isx6w631skc7on", "children": [], "tag_good_arr": [], "id": "jhh447qurwz50x", "updated": "2018-05-22T03:20:57Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>根据我的理解&#xff0c;也是只是running态的进程才能处理它的中断。</p>", "created": "2018-05-22T04:03:59Z", "bucket_order": 96, "bucket_name": "Week 5/20 - 5/26", "type": "feedback", "tag_good": [], "uid": "isu0wqaoff5125", "children": [], "tag_good_arr": [], "id": "jhh5nk04mtn1y8", "updated": "2018-05-22T04:03:59Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>我认为&#xff0c;用户态中断只适合固定由某个进程处理的中断&#xff0c;不适合需要动态变动响应进程的中断。</p>\n<p></p>\n<p>在微内核架构下&#xff0c;网卡中断的处理就是一个很大的麻烦。网络包的处理需要有一定的处理后才能知道是给哪个进程的&#xff0c;不能直接让当前进程来处理网络中断。这时才有了BPF的做法&#xff0c;由用户动态注入代码到内核&#xff0c;对包进行分类&#xff0c;确定正确的接收进程后&#xff0c;才把包给相应的进程处理。</p>\n<p></p>\n<p>用一个专用的用户进程来响应指定的中断&#xff08;用户态驱动&#xff09;的目的&#xff0c;主要是减少内核的工作。</p>", "created": "2018-05-22T07:57:47Z", "bucket_order": 96, "bucket_name": "Week 5/20 - 5/26", "type": "feedback", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [], "tag_good_arr": [], "id": "jhhe07nto5h101", "updated": "2018-05-22T07:57:47Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "jhfwunhm9cu38a", "updated": "2018-05-21T07:09:48Z", "config": {}}], "tag_good_arr": ["hcrrjuyequh4bt", "isu0wqaoff5125", "iswk6782g923e6"], "no_answer": 1, "id": "jh9z2pn45r3171", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 6, "num_favorites": 2, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169458479, "default_anonymity": "no"}, "error": null, "aid": "kyv0o4kvfs157y"}