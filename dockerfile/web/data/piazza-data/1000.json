{"result": {"folders": ["lecture5"], "nr": 1000, "data": {"embed_links": []}, "created": "2017-03-07T08:00:39Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "ie7xy8gtpwk1t5", "data": "izz8x8u6ez47gn", "type": "create", "when": "2017-03-07T08:00:39Z"}, {"anon": "no", "uid": "ie7xy5sipx51qz", "data": "j00zgbqka512wn", "type": "update", "when": "2017-03-08T13:11:06Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "ie7xy5sipx51qz", "subject": "第五讲 伙伴系统总结", "created": "2017-03-08T13:11:06Z", "content": "<p>题外话&#xff1a;为什么叫“伙伴”&#xff1f;因为每块只能和特定的另一块合并。</p>\n<p></p>\n<p>参考了wiki上伙伴系统实现的<a href=\"http://coolshell.cn/articles/10427.html\">链接</a>&#xff0c;在此做一简单总结</p>\n<p>这里采用二叉树管理内存单元&#xff0c;分配和释放的搜索时间复杂度O(logN)&#xff0c;在这一点上优于最先匹配、最佳匹配和最差匹配。</p>\n<p> </p>\n<p>每个节点标记对应的<strong>可用</strong>内存块大小</p>\n<p>分配&#xff1a;</p>\n<ol><li>传入size&#xff0c;将size调整到2的幂大小&#xff0c;检查是否超过根节点的标记。</li><li>深度优先搜索&#xff0c;找到恰为<strong>size大小</strong>的空闲内存块&#xff08;标记等于size且该层每个节点对应内存块大小为size&#xff09;&#xff0c;修改标记为0。根据size和该节点对应二叉树中的序号以及总大小&#xff0c;可以计算出内存块索引offset。</li><li>之后回溯&#xff0c;更新祖先节点的标记&#xff0c;取左右子树较大值&#xff0c;完成分割。</li></ol>\n<p> </p>\n<p>释放&#xff1a;</p>\n<p>传入offset。从最底层节点向上回溯&#xff0c;遇到标记为0的节点即对应当初分配的内存块&#xff0c;恢复标记为块大小&#xff0c;继续回溯&#xff0c;如果左右子树标记相加等于父节点对应的块大小&#xff0c;则恢复父节点标记为块大小。</p>\n<p></p>"}, {"anon": "no", "uid": "ie7xy8gtpwk1t5", "subject": "第五讲 伙伴系统总结", "created": "2017-03-07T08:00:39Z", "content": "<p>题外话&#xff1a;为什么叫“伙伴”&#xff1f;因为每块只能和特定的另一块合并。</p>\n<p></p>\n<p>参考了wiki上伙伴系统实现的<a href=\"http://coolshell.cn/articles/10427.html\">链接</a>&#xff0c;在此做一简单总结</p>\n<p>这里采用二叉树管理内存单元&#xff0c;分配和释放的搜索时间复杂度O(logN)&#xff0c;在这一点上优于最先匹配、最佳匹配和最差匹配。</p>\n<p> </p>\n<p>每个节点标记对应的<strong>可用</strong>内存块大小</p>\n<p>分配&#xff1a;</p>\n<ol><li>传入size&#xff0c;将size调整到2的幂大小&#xff0c;检查是否超过根节点的标记。</li><li>深度优先搜索&#xff0c;找到恰为<strong>size大小</strong>的空闲内存块&#xff08;标记等于size且该层每个节点对应内存块大小为size&#xff09;&#xff0c;修改标记为0。根据size和该节点对应二叉树中的序号以及总大小&#xff0c;可以计算出内存块索引offset。</li><li>之后回溯&#xff0c;更新祖先节点的标记&#xff0c;取左右子树较大值&#xff0c;完成分割。</li></ol>\n<p> </p>\n<p>释放&#xff1a;</p>\n<p>传入offset。从最底层节点向上回溯&#xff0c;遇到标记为0的节点即对应当初分配的内存块&#xff0c;恢复标记为块大小&#xff0c;继续回溯&#xff0c;如果左右子树标记相加等于父节点对应的块大小&#xff0c;则恢复父节点标记为块大小。</p>\n<p></p>"}], "type": "note", "tags": ["lecture5", "student", "unanswered"], "tag_good": [], "unique_views": 103, "children": [], "tag_good_arr": [], "id": "izz8x8u25qk7gm", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 6, "num_favorites": 1, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643168957593, "default_anonymity": "no"}, "error": null, "aid": "kyv0de3df9q5nk"}