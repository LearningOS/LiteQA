{"result": {"folders": ["lecture4"], "nr": 1405, "data": {"embed_links": []}, "created": "2020-02-28T13:56:54Z", "bucket_order": 3, "no_answer_followup": 1, "change_log": [{"anon": "stud", "data": "k768q71pip77ob", "type": "create", "when": "2020-02-28T13:56:54Z", "uid_a": "a_0"}, {"anon": "stud", "data": "k768sxb9en22vj", "type": "update", "when": "2020-02-28T13:59:01Z", "uid_a": "a_0"}, {"anon": "no", "uid": "k6psv9yi7iv4pa", "data": "k772ygfh44p2yl", "to": "k768q71lw0h7oa", "type": "s_answer", "when": "2020-02-29T04:03:08Z"}, {"anon": "no", "uid": "k6psv9yi7iv4pa", "data": "k7730injapy4ul", "type": "s_answer_update", "when": "2020-02-29T04:04:44Z"}, {"anon": "stud", "to": "k768q71lw0h7oa", "type": "followup", "when": "2020-02-29T04:14:00Z", "uid_a": "a_0"}, {"anon": "no", "uid": "k6psv9yi7iv4pa", "to": "k768q71lw0h7oa", "type": "feedback", "when": "2020-02-29T04:32:39Z"}, {"anon": "stud", "to": "k768q71lw0h7oa", "uid_a": "a_0", "type": "feedback", "when": "2020-02-29T04:49:19Z"}], "bucket_name": "Today", "history": [{"anon": "stud", "uid_a": "a_0", "subject": "对2.27课后练习的ostep3-malloc.py脚本的疑问", "created": "2020-02-28T13:59:01Z", "content": "<p>脚本中的实现似乎和课上讲的有些地方不太一样&#xff1f;</p>\n<p>1.课上说最佳匹配和最差匹配是把freelist按照size升序或降序排好序&#xff0c;然后找的时候最佳匹配只需要找到第一个比自己大的&#xff0c;最差匹配只需要用第一个作比较。但脚本里是全都把列表遍历了一遍。</p>\n<p>2.课上说的最佳匹配和最差匹配的释放内存后合并的方法&#xff0c;是遍历查找与释放掉的内存地址相邻的内存区域。但脚本里是遍历列表&#xff0c;当且仅当列表顺序的第i&#43;1个区域紧挨在第i个区域的后边时才合并。而且合并完也没有什么调整顺序的过程。</p>\n<p>也就是说这两种方式在数据结构维护上各自的优缺点基本上在脚本中都没有体现出来&#xff0c;不知道课后练习可以怎么根据脚本给出的例子进行分析呢&#xff1f;</p>"}, {"anon": "stud", "uid_a": "a_0", "subject": "对2.27课后练习的ostep3-malloc.py脚本的疑问", "created": "2020-02-28T13:56:54Z", "content": "<p>脚本中的实现似乎和课上讲的有些地方不太一样&#xff1f;</p>\n<p>1.课上说最佳匹配和最差匹配是把freelist按照size升序或降序排好序&#xff0c;然后找的时候最佳匹配只需要找到第一个比自己大的&#xff0c;最差匹配只需要用第一个作比较。但脚本里是全都把列表遍历了一遍。</p>\n<p>2.课上说的最佳匹配和最差匹配的释放内存后合并的方法&#xff0c;是遍历查找地址相邻的内存区域。但脚本里是遍历列表&#xff0c;当且仅当第i&#43;1个区域紧挨在第i个区域的后边时才合并。而且合并完也没有什么调整顺序的过程。</p>\n<p>也就是说这两种方式在数据结构维护上各自的优缺点基本上在脚本中都没有体现出来&#xff0c;不知道课后练习可以怎么根据脚本给出的例子进行分析呢&#xff1f;</p>"}], "type": "question", "tags": ["lecture4", "student"], "tag_good": [], "unique_views": 104, "children": [{"folders": [], "data": {"embed_links": []}, "children": [], "created": "2020-02-29T04:03:08Z", "bucket_order": 3, "tag_endorse": [], "bucket_name": "Today", "id": "k772ygfdb5f2yk", "history": [{"anon": "no", "uid": "k6psv9yi7iv4pa", "subject": "", "created": "2020-02-29T04:04:44Z", "content": "<p>找第一个比自己大的是最先匹配吧。最佳匹配是当需要分配n字节分区的时候&#xff0c;找不小于n的最小空闲分区&#xff0c;所以要遍历吧。</p>"}, {"anon": "no", "uid": "k6psv9yi7iv4pa", "subject": "", "created": "2020-02-29T04:03:08Z", "content": "<p>找第一个比自己大的是最先匹配吧</p>"}], "type": "s_answer", "tag_endorse_arr": [], "config": {}, "is_tag_endorse": false}, {"anon": "stud", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>不是&#xff0c;我的意思是&#xff0c;课件上说最佳匹配的空闲列表应该按size大小排序&#xff0c;这样在分配的时候就能从小到大找到第一个比自己大的即可</p>", "created": "2020-02-29T04:14:00Z", "bucket_order": 3, "bucket_name": "Today", "type": "followup", "tag_good": [], "uid_a": "a_0", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>嗯&#xff0c;我觉得你说的没错。但脚本好像可以通过ADDRSORT SIZESORT&#43;等来设置freelist是地址排序还是大小排序&#xff0c;所以是不是遍历那一段是为了处理地址排序的情况。</p>", "created": "2020-02-29T04:32:39Z", "bucket_order": 3, "bucket_name": "Today", "type": "feedback", "tag_good": [], "uid": "k6psv9yi7iv4pa", "children": [], "tag_good_arr": [], "id": "k7740esdtdb37b", "updated": "2020-02-29T04:32:39Z", "config": {}}, {"anon": "stud", "folders": [], "data": {"embed_links": null}, "subject": "<p>不是的&#xff0c;我之前看过脚本的代码&#xff0c;设置排序方式只是在释放完之后把freelist排个序&#xff0c;在结果中显示给你看&#xff0c;而实际上在算法中并没有用到这个顺序的特性。也就是遍历的时候并不会管这个列表是怎么排序的&#xff0c;除了最先匹配以外都会把整个列表遍历一遍。</p>", "created": "2020-02-29T04:49:19Z", "bucket_order": 3, "bucket_name": "Today", "type": "feedback", "tag_good": [], "uid_a": "a_0", "children": [], "tag_good_arr": [], "id": "k774lunmzxw1", "updated": "2020-02-29T04:49:19Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "k773cfi5bwyy4", "updated": "2020-02-29T04:14:00Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "k768q71lw0h7oa", "config": {"seen": {"33": 1, "762": 4, "930": 2, "656": 6, "1166": 9, "835": 5, "1074": 3, "607": 7, "97": 0, "263": 8}}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 3, "num_favorites": 0, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169964245, "default_anonymity": "no"}, "error": null, "aid": "kyv0yytxy2x3t0"}