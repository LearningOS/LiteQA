{"result": {"folders": ["exam", "课堂问答"], "nr": 343, "data": {"embed_links": []}, "created": "2015-04-22T06:44:33Z", "bucket_order": 3, "no_answer_followup": 15, "change_log": [{"uid": "hcrrjuyequh4bt", "anon": "no", "when": "2015-04-22T06:44:33Z", "data": "i8sdkutlgzx1k0", "type": "create"}, {"to": "i8sdkutfd481jz", "uid": "i6vi7mt1I4G", "anon": "no", "when": "2015-04-22T06:44:41Z", "type": "followup"}, {"to": "i8sdkutfd481jz", "uid": "i6vi7mt1I4G", "anon": "no", "when": "2015-04-22T06:45:00Z", "type": "feedback"}, {"to": "i8sdkutfd481jz", "uid": "i6t1byqz5dE", "anon": "no", "when": "2015-04-22T06:45:01Z", "type": "followup"}, {"to": "i8sdkutfd481jz", "uid": "i7bg4v1keqE", "anon": "no", "when": "2015-04-22T06:45:07Z", "type": "followup"}, {"to": "i8sdkutfd481jz", "uid": "i6uak1ivjzr1i0", "anon": "no", "when": "2015-04-22T06:45:12Z", "type": "followup"}, {"to": "i8sdkutfd481jz", "uid": "i6uji18l8j51ob", "anon": "no", "when": "2015-04-22T06:45:21Z", "type": "followup"}, {"to": "i8sdkutfd481jz", "uid": "i7bg4v1keqE", "anon": "no", "when": "2015-04-22T06:46:18Z", "type": "feedback"}, {"to": "i8sdkutfd481jz", "uid": "i6t76fg9sEh", "anon": "no", "when": "2015-04-22T06:46:33Z", "type": "followup"}, {"to": "i8sdkutfd481jz", "uid": "i7013x05eSl", "anon": "no", "when": "2015-04-22T06:46:52Z", "type": "followup"}, {"to": "i8sdkutfd481jz", "uid": "i6uak1ivjzr1i0", "anon": "no", "when": "2015-04-22T06:47:17Z", "type": "feedback"}, {"to": "i8sdkutfd481jz", "uid": "i6sl02qfUgI", "anon": "no", "when": "2015-04-22T06:47:47Z", "type": "feedback"}, {"to": "i8sdkutfd481jz", "uid": "i7bq1v7feay2z9", "anon": "no", "when": "2015-04-22T06:48:19Z", "type": "followup"}, {"to": "i8sdkutfd481jz", "uid": "i7oaxkxhxjo3ui", "anon": "no", "when": "2015-04-22T06:48:56Z", "type": "followup"}, {"to": "i8sdkutfd481jz", "uid": "i6tezdpdQbq", "anon": "no", "when": "2015-04-22T06:49:13Z", "type": "feedback"}, {"to": "i8sdkutfd481jz", "uid": "i6t7mzhbhwF", "anon": "no", "when": "2015-04-22T06:49:38Z", "type": "followup"}, {"to": "i8sdkutfd481jz", "uid": "i7bq1v7feay2z9", "anon": "no", "when": "2015-04-22T06:50:09Z", "type": "feedback"}, {"to": "i8sdkutfd481jz", "uid": "i718mp903qx", "anon": "no", "when": "2015-04-22T06:50:18Z", "type": "feedback"}, {"to": "i8sdkutfd481jz", "uid": "i6vuv0mi6uU", "anon": "no", "when": "2015-04-22T06:57:39Z", "type": "feedback"}, {"to": "i8sdkutfd481jz", "uid": "i6xgf2t8N7w", "anon": "no", "when": "2015-04-22T07:01:15Z", "type": "followup"}, {"to": "i8sdkutfd481jz", "uid": "i718aanx0OS", "anon": "no", "when": "2015-04-22T07:05:04Z", "type": "followup"}, {"to": "i8sdkutfd481jz", "uid": "i6uswob7jl4242", "anon": "no", "when": "2015-04-22T07:06:33Z", "type": "followup"}, {"to": "i8sdkutfd481jz", "uid": "i6urm1j1ynv6sm", "anon": "no", "when": "2015-04-22T07:07:36Z", "type": "followup"}, {"to": "i8sdkutfd481jz", "uid": "i71fykcui1h2je", "anon": "no", "when": "2015-04-22T07:08:45Z", "type": "followup"}, {"to": "i8sdkutfd481jz", "uid": "i6unpz8nUza", "anon": "no", "when": "2015-04-22T08:03:06Z", "type": "feedback"}, {"to": "i8sdkutfd481jz", "uid": "i71fykcui1h2je", "anon": "no", "when": "2015-04-22T08:29:37Z", "type": "feedback"}, {"to": "i8sdkutfd481jz", "uid": "i6tawpo5Fm8", "anon": "no", "when": "2015-04-22T09:44:05Z", "type": "feedback"}, {"to": "i8sdkutfd481jz", "uid": "i6t7bfshA1d", "anon": "no", "when": "2015-04-22T13:42:32Z", "type": "feedback"}, {"to": "i8sdkutfd481jz", "uid": "i6uji18l8j51ob", "anon": "no", "when": "2015-04-22T13:58:23Z", "type": "feedback"}, {"uid": "hcrrjuyequh4bt", "anon": "no", "when": "2015-04-22T15:54:13Z", "data": "i8sx7q7p2ei4il", "type": "update"}, {"uid": "hcrrjuyequh4bt", "anon": "no", "when": "2015-04-23T06:40:24Z", "data": "i8tsvd6ipe77i0", "type": "update"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hcrrjuyequh4bt", "subject": "lec15 scheduling", "created": "2015-04-23T06:40:24Z", "content": "<p>练习&#xff11;优胜者</p>\n<p>小组</p>\n<p>黄杰 2012011272</p>\n<p>杜鹃 2012011354</p>\n<p>袁源 2012011294</p>\n<p></p>\n<p>小组</p>\n<p>裴中煜<br />李若愚</p>\n<p></p>\n<p>小组</p>\n<p>石伟男2012011367</p>\n<p>王轩  2012011369</p>\n<p>荣禹  2012011358</p>\n<p>李浩达2012011382</p>\n<p></p>\n<p>小组</p>\n<p>计22 覃伟 2012011278<br />计22 徐天宇 2012011275</p>\n<p>计22 杨博文 2012011288</p>\n<p>计22 韩慧阳 2012011276</p>"}, {"anon": "no", "uid": "hcrrjuyequh4bt", "subject": "lec15 scheduling", "created": "2015-04-22T15:54:13Z", "content": "<p>练习&#xff11;优胜者</p>\n<p>小组</p>\n<p>黄杰 2012011272</p>\n<p>杜鹃 2012011354</p>\n<p>袁源 2012011294</p>\n<p></p>\n<p>小组</p>\n<p>石伟男2012011367</p>\n<p>王轩  2012011369</p>\n<p>荣禹  2012011358</p>\n<p>李浩达2012011382</p>\n<p></p>\n<p>小组</p>\n<p>计22 覃伟 2012011278<br />计22 徐天宇 2012011275</p>\n<p>计22 杨博文 2012011288</p>\n<p>计22 韩慧阳 2012011276</p>"}, {"anon": "no", "uid": "hcrrjuyequh4bt", "subject": "lec15 scheduling", "created": "2015-04-22T06:44:33Z", "content": "<p></p>"}], "type": "note", "tags": ["exam", "instructor-note", "课堂问答"], "tag_good": [], "unique_views": 137, "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>黄杰 2012011272</p>\n<p>杜鹃 2012011354</p>\n<p>袁源 2012011294</p>", "created": "2015-04-22T06:44:41Z", "bucket_order": 264, "bucket_name": "Week 4/19 - 4/25", "type": "followup", "tag_good": [], "uid": "i6vi7mt1I4G", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>完成了 FIFO RR SJF MLFQ stride</p>", "created": "2015-04-22T06:45:00Z", "bucket_order": 264, "bucket_name": "Week 4/19 - 4/25", "type": "feedback", "tag_good": [], "uid": "i6vi7mt1I4G", "children": [], "tag_good_arr": [], "id": "i8sdlfw5l7f2eq", "updated": "2015-04-22T06:45:00Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>https://github.com/THUHJ/os_exercises/blob/master/all/schedule_with_stride_FIFO_RR_SJF.py</p>", "created": "2015-04-22T06:47:47Z", "bucket_order": 264, "bucket_name": "Week 4/19 - 4/25", "type": "feedback", "tag_good": [], "uid": "i6sl02qfUgI", "children": [], "tag_good_arr": [], "id": "i8sdp0k445e6mh", "updated": "2015-04-22T06:47:47Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "i8sdl108oo847p", "updated": "2015-04-22T06:44:41Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>石伟男2012011367</p>\n<p>王轩  2012011369</p>\n<p>荣禹  2012011358</p>\n<p>李浩达2012011382</p>\n<p>https://github.com/swnhieian/os_exercises/blob/master/all/scheduler-homework.py</p>", "created": "2015-04-22T06:45:01Z", "bucket_order": 264, "bucket_name": "Week 4/19 - 4/25", "type": "followup", "tag_good": [], "uid": "i6t1byqz5dE", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i8sdlg8lk5451w", "updated": "2015-04-22T06:45:01Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p><span style=\"font-family:&#34;Helvetica Neue&#34;,&#34;Helvetica&#34;,&#34;Segoe UI&#34;,&#34;Arial&#34;,&#34;freesans&#34;,sans-serif;text-align:start;font-weight:normal;font-size:16px;font-style:normal;background-color:#ffffff;color:#333333\">https://github.com/yanwang9411/os_exercises/blob/master/all/schedule.py<br /></span></p>", "created": "2015-04-22T06:45:07Z", "bucket_order": 264, "bucket_name": "Week 4/19 - 4/25", "type": "followup", "tag_good": [], "uid": "i7bg4v1keqE", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p><a href=\"https://github.com/yanwang9411/os_exercises/blob/master/all/schedule.py\">https://github.com/yanwang9411/os_exercises/blob/master/all/schedule.py</a></p>\n<p></p>\n<p>计24  王妍  2012011352</p>", "created": "2015-04-22T06:46:18Z", "bucket_order": 264, "bucket_name": "Week 4/19 - 4/25", "type": "feedback", "tag_good": [], "uid": "i7bg4v1keqE", "children": [], "tag_good_arr": [], "id": "i8sdn433x5351h", "updated": "2015-04-22T06:46:18Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "i8sdllc6zqd53c", "updated": "2015-04-22T06:45:07Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p><br />计22 覃伟 2012011278<br />计22 徐天宇 2012011275</p>\n<p>计22 杨博文 2012011288</p>\n<p>计22 韩慧阳 2012011276</p>\n<pre>#! /usr/bin/env python<br />import sys\nfrom optparse import OptionParser\nimport random\nimport operator\nparser = OptionParser()\nparser.add_option(&#34;-s&#34;, &#34;--seed&#34;, default=0, help=&#34;the random seed&#34;, \naction=&#34;store&#34;, type=&#34;int&#34;, dest=&#34;seed&#34;)\nparser.add_option(&#34;-j&#34;, &#34;--jobs&#34;, default=3, help=&#34;number of jobs in the system&#34;,\naction=&#34;store&#34;, type=&#34;int&#34;, dest=&#34;jobs&#34;)\nparser.add_option(&#34;-l&#34;, &#34;--jlist&#34;, default=&#34;&#34;, help=&#34;instead of random jobs, provide a comma-separated list of run times&#34;,\naction=&#34;store&#34;, type=&#34;string&#34;, dest=&#34;jlist&#34;)\nparser.add_option(&#34;-m&#34;, &#34;--maxlen&#34;, default=10, help=&#34;max length of job&#34;,\naction=&#34;store&#34;, type=&#34;int&#34;, dest=&#34;maxlen&#34;)\nparser.add_option(&#34;-p&#34;, &#34;--policy&#34;, default=&#34;FIFO&#34;, help=&#34;sched policy to use: SJF, FIFO, RR&#34;,\naction=&#34;store&#34;, type=&#34;string&#34;, dest=&#34;policy&#34;)\nparser.add_option(&#34;-q&#34;, &#34;--quantum&#34;, help=&#34;length of time slice for RR policy&#34;, default=1, \naction=&#34;store&#34;, type=&#34;int&#34;, dest=&#34;quantum&#34;)\nparser.add_option(&#34;-c&#34;, help=&#34;compute answers for me&#34;, action=&#34;store_true&#34;, default=True, dest=&#34;solve&#34;)\n(options, args) = parser.parse_args()\nrandom.seed(options.seed)\nprint &#39;ARG policy&#39;, options.policy\nif options.jlist == &#39;&#39;:\nprint &#39;ARG jobs&#39;, options.jobs\nprint &#39;ARG maxlen&#39;, options.maxlen\nprint &#39;ARG seed&#39;, options.seed\nelse:\nprint &#39;ARG jlist&#39;, options.jlist\nprint &#39;&#39;\nprint &#39;Here is the job list, with the run time of each job: &#39;\nimport operator\njoblist = []\nif options.jlist == &#39;&#39;:\nfor jobnum in range(0,options.jobs):\nruntime = int(options.maxlen * random.random()) &#43; 1\njoblist.append([jobnum, runtime])\nprint &#39; Job&#39;, jobnum, &#39;( length = &#39; &#43; str(runtime) &#43; &#39; )&#39;\nelse:\njobnum = 0\nfor runtime in options.jlist.split(&#39;,&#39;):\njoblist.append([jobnum, float(runtime)])\njobnum &#43;= 1\nfor job in joblist:\nprint &#39; Job&#39;, job[0], &#39;( length = &#39; &#43; str(job[1]) &#43; &#39; )&#39;\nprint &#39;\\n&#39;\nif options.solve == True:\nprint &#39;** Solutions **\\n&#39;\nif options.policy == &#39;SJF&#39;:\n#YOUR CODE\njoblist.sort(key=operator.itemgetter(1))\nqwtime = 0 \nfor job in joblist:\nprint &#39; [ time %3d ] Run job %3d for %3.2f secs ( DONE at %3.2f )&#39; % (qwtime,job[0],job[1],qwtime&#43;job[1])\nqwtime &#43;= job[1]\nprint &#39;\\nFinal statistics:&#39;\nt = 0.0\ncount = 0\nturnaroundSum = 0.0\nwaitSum = 0.0\nresponseSum = 0.0\nfor tmp in joblist:\njobnum = tmp[0]\nruntime = tmp[1]\n\nresponse = t\nturnaround = t &#43; runtime\nwait = t\nprint &#39; Job %3d -- Response: %3.2f Turnaround %3.2f Wait %3.2f&#39; % (jobnum, response, turnaround, wait)\nresponseSum &#43;= response\nturnaroundSum &#43;= turnaround\nwaitSum &#43;= wait\nt &#43;= runtime\ncount = count &#43; 1\nprint &#39;\\n Average -- Response: %3.2f Turnaround %3.2f Wait %3.2f\\n&#39; % (responseSum/count, turnaroundSum/count, waitSum/count)\n\nif options.policy == &#39;FIFO&#39;:\nthetime = 0\nprint &#39;Execution trace:&#39;\n#YOUR CODE\nqwtime = 0 \nfor job in joblist:\nprint &#39; [ time %3d ] Run job %3d for %3.2f secs ( DONE at %3.2f )&#39; % (qwtime,job[0],job[1],qwtime&#43;job[1])\nqwtime &#43;= job[1]\n\nprint &#39;\\nFinal statistics:&#39;\nt = 0.0\ncount = 0\nturnaroundSum = 0.0\nwaitSum = 0.0\nresponseSum = 0.0\nfor tmp in joblist:\njobnum = tmp[0]\nruntime = tmp[1]\n\nresponse = t\nturnaround = t &#43; runtime\nwait = t\nprint &#39; Job %3d -- Response: %3.2f Turnaround %3.2f Wait %3.2f&#39; % (jobnum, response, turnaround, wait)\nresponseSum &#43;= response\nturnaroundSum &#43;= turnaround\nwaitSum &#43;= wait\nt &#43;= runtime\ncount = count &#43; 1\nprint &#39;\\n Average -- Response: %3.2f Turnaround %3.2f Wait %3.2f\\n&#39; % (responseSum/count, turnaroundSum/count, waitSum/count)\n\nif options.policy == &#39;RR&#39;:\nprint &#39;Execution trace:&#39;\nturnaround = {}\nresponse = {}\nlastran = {}\nwait = {}\nquantum = float(options.quantum)\njobcount = len(joblist)\nfor i in range(0,jobcount):\nlastran[i] = 0.0\nwait[i] = 0.0\nturnaround[i] = 0.0\nresponse[i] = -1\nrunlist = []\nfor e in joblist:\nrunlist.append(e)\nthetime = 0.0\nwhile jobcount &gt; 0:\n# print &#39;%d jobs remaining&#39; % jobcount\njob = runlist.pop(0)\njobnum = job[0]\nruntime = float(job[1])\nif response[jobnum] == -1:\nresponse[jobnum] = thetime\ncurrwait = thetime - lastran[jobnum]\nwait[jobnum] &#43;= currwait\nranfor = 0\nif runtime &gt; quantum:\n#YOUR CODE\nruntime -= quantum\nranfor = quantum\nprint &#39; [ time %3d ] Run job %3d for %.2f secs&#39; % (thetime, jobnum, ranfor)\nrunlist.append([jobnum, runtime])\nelse:\n#YOUR CODE\nranfor = runtime\nprint &#39; [ time %3d ] Run job %3d for %.2f secs ( DONE at %.2f )&#39; % (thetime, jobnum, ranfor, thetime &#43; ranfor)\nturnaround[jobnum] = thetime &#43; ranfor\njobcount -= 1\nthetime &#43;= ranfor\nlastran[jobnum] = thetime\nprint &#39;\\nFinal statistics:&#39;\nturnaroundSum = 0.0\nwaitSum = 0.0\nresponseSum = 0.0\nfor i in range(0,len(joblist)):\nturnaroundSum &#43;= turnaround[i]\nresponseSum &#43;= response[i]\nwaitSum &#43;= wait[i]\nprint &#39; Job %3d -- Response: %3.2f Turnaround %3.2f Wait %3.2f&#39; % (i, response[i], turnaround[i], wait[i])\ncount = len(joblist)\n\nprint &#39;\\n Average -- Response: %3.2f Turnaround %3.2f Wait %3.2f\\n&#39; % (responseSum/count, turnaroundSum/count, waitSum/count)\nif options.policy != &#39;FIFO&#39; and options.policy != &#39;SJF&#39; and options.policy != &#39;RR&#39;: \nprint &#39;Error: Policy&#39;, options.policy, &#39;is not available.&#39;\nsys.exit(0)\nelse:\nprint &#39;Compute the turnaround time, response time, and wait time for each job.&#39;\nprint &#39;When you are done, run this program again, with the same arguments,&#39;\nprint &#39;but with -c, which will thus provide you with the answers. You can use&#39;\nprint &#39;-s &lt;somenumber&gt; or your own job list (-l 10,15,20 for example)&#39;\nprint &#39;to generate different problems for yourself.&#39;\nprint &#39;&#39;\n</pre>\n<p></p>", "created": "2015-04-22T06:45:12Z", "bucket_order": 264, "bucket_name": "Week 4/19 - 4/25", "type": "followup", "tag_good": [], "uid": "i6uak1ivjzr1i0", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>", "created": "2015-04-22T06:47:17Z", "bucket_order": 264, "bucket_name": "Week 4/19 - 4/25", "type": "feedback", "tag_good": [], "uid": "i6uak1ivjzr1i0", "children": [], "tag_good_arr": [], "id": "i8sdodjsgac2w5", "updated": "2015-04-22T06:47:17Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "i8sdlonacso2kz", "updated": "2015-04-22T06:45:12Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>裴中煜 2012010685</p>\n<p>李若愚 2012011353</p>\n<p></p>\n<p>python 2.7</p>\n<p>实现SJF FIFO RR stride调度算法</p>\n<p></p>\n<p>C&#43;&#43; 运行环境&#xff1a;VS2008</p>\n<p>实现MLFQ算法</p>\n<p></p>\n<p></p>\n<p>代码参见github链接</p>", "created": "2015-04-22T06:45:21Z", "bucket_order": 264, "bucket_name": "Week 4/19 - 4/25", "type": "followup", "tag_good": [], "uid": "i6uji18l8j51ob", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>裴中煜 2012010685</p>\n<p>李若愚 2012011353</p>\n<p></p>\n<p>FIFO RR SJF Stride</p>\n<p><a href=\"https://github.com/BrieflyX/ucore_lab/blob/master/related_info/lab6/scheduler-homework.py\" target=\"_blank\">Github Link</a></p>", "created": "2015-04-22T13:42:32Z", "bucket_order": 264, "bucket_name": "Week 4/19 - 4/25", "type": "feedback", "tag_good": [], "uid": "i6t7bfshA1d", "children": [], "tag_good_arr": [], "id": "i8ssidpa4us513", "updated": "2015-04-22T13:42:32Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>MLFQ</p>\n<p></p>\n<p>https://github.com/badpoem/MLFQ</p>", "created": "2015-04-22T13:58:23Z", "bucket_order": 264, "bucket_name": "Week 4/19 - 4/25", "type": "feedback", "tag_good": [], "uid": "i6uji18l8j51ob", "children": [], "tag_good_arr": [], "id": "i8st2rgufpw5m8", "updated": "2015-04-22T13:58:23Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "i8sdlvr6k4w2mp", "updated": "2015-04-22T06:45:21Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p></p>", "created": "2015-04-22T06:46:33Z", "bucket_order": 264, "bucket_name": "Week 4/19 - 4/25", "type": "followup", "tag_good": [], "uid": "i6t76fg9sEh", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i8sdnfugp8k35t", "updated": "2015-04-22T06:46:33Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>鲁逸沁 2012011314</p>\n<p>谢晓晖 2012011315</p>\n<p>李国豪 2012011303</p>\n<p></p>\n<p></p>\n<p>占坑&#xff01;</p>", "created": "2015-04-22T06:46:52Z", "bucket_order": 264, "bucket_name": "Week 4/19 - 4/25", "type": "followup", "tag_good": [], "uid": "i7013x05eSl", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p><pre>#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\n\nparser = OptionParser()\nparser.add_option(&#34;-s&#34;, &#34;--seed&#34;, default=0, help=&#34;the random seed&#34;, \n                  action=&#34;store&#34;, type=&#34;int&#34;, dest=&#34;seed&#34;)\nparser.add_option(&#34;-j&#34;, &#34;--jobs&#34;, default=3, help=&#34;number of jobs in the system&#34;,\n                  action=&#34;store&#34;, type=&#34;int&#34;, dest=&#34;jobs&#34;)\nparser.add_option(&#34;-l&#34;, &#34;--jlist&#34;, default=&#34;&#34;, help=&#34;instead of random jobs, provide a comma-separated list of run times&#34;,\n                  action=&#34;store&#34;, type=&#34;string&#34;, dest=&#34;jlist&#34;)\nparser.add_option(&#34;-m&#34;, &#34;--maxlen&#34;, default=10, help=&#34;max length of job&#34;,\n                  action=&#34;store&#34;, type=&#34;int&#34;, dest=&#34;maxlen&#34;)\nparser.add_option(&#34;-p&#34;, &#34;--policy&#34;, default=&#34;FIFO&#34;, help=&#34;sched policy to use: SJF, FIFO, RR&#34;,\n                  action=&#34;store&#34;, type=&#34;string&#34;, dest=&#34;policy&#34;)\nparser.add_option(&#34;-q&#34;, &#34;--quantum&#34;, help=&#34;length of time slice for RR policy&#34;, default=1, \n                  action=&#34;store&#34;, type=&#34;int&#34;, dest=&#34;quantum&#34;)\nparser.add_option(&#34;-c&#34;, help=&#34;compute answers for me&#34;, action=&#34;store_true&#34;, default=True, dest=&#34;solve&#34;)\n\n(options, args) = parser.parse_args()\n\nrandom.seed(options.seed)\n\nprint &#39;ARG policy&#39;, options.policy\nif options.jlist == &#39;&#39;:\n    print &#39;ARG jobs&#39;, options.jobs\n    print &#39;ARG maxlen&#39;, options.maxlen\n    print &#39;ARG seed&#39;, options.seed\nelse:\n    print &#39;ARG jlist&#39;, options.jlist\n\nprint &#39;&#39;\n\nprint &#39;Here is the job list, with the run time of each job: &#39;\n\nimport operator\n\njoblist = []\nif options.jlist == &#39;&#39;:\n    for jobnum in range(0,options.jobs):\n        runtime = int(options.maxlen * random.random()) &#43; 1\n        joblist.append([jobnum, runtime])\n        print &#39;  Job&#39;, jobnum, &#39;( length = &#39; &#43; str(runtime) &#43; &#39; )&#39;\nelse:\n    jobnum = 0\n    for runtime in options.jlist.split(&#39;,&#39;):\n        joblist.append([jobnum, float(runtime)])\n        jobnum &#43;= 1\n    for job in joblist:\n        print &#39;  Job&#39;, job[0], &#39;( length = &#39; &#43; str(job[1]) &#43; &#39; )&#39;\nprint &#39;\\n&#39;\n\nif options.solve == True:\n    print &#39;** Solutions **\\n&#39;\n    if options.policy == &#39;FIFO&#39; or options.policy == &#39;SJF&#39;:\n        if options.policy == &#39;SJF&#39;:\n\t\t#YOUR CODE\n            joblist.sort(lambda x, y : cmp(x[1], y[1]))\n        thetime = 0\n        print &#39;Execution trace:&#39;\n            #YOUR CODE\n        for tmp in joblist:\n            jobnum = tmp[0]\n            ranfor = tmp[1]\n            print &#39;  [ time %3d ] Run job %3d for %.2f secs ( DONE at %.2f )&#39; % (thetime, jobnum, ranfor, thetime &#43; ranfor)\n            thetime &#43;= ranfor\n         \n        print &#39;\\nFinal statistics:&#39;\n        t     = 0.0\n        count = 0\n        turnaroundSum = 0.0\n        waitSum       = 0.0\n        responseSum   = 0.0\n        for tmp in joblist:\n            jobnum  = tmp[0]\n            runtime = tmp[1]\n            \n            response   = t\n            turnaround = t &#43; runtime\n            wait       = t\n            print &#39;  Job %3d -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f&#39; % (jobnum, response, turnaround, wait)\n            responseSum   &#43;= response\n            turnaroundSum &#43;= turnaround\n            waitSum       &#43;= wait\n            t &#43;= runtime\n            count = count &#43; 1\n        print &#39;\\n  Average -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f\\n&#39; % (responseSum/count, turnaroundSum/count, waitSum/count)\n                     \n    if options.policy == &#39;RR&#39;:\n        print &#39;Execution trace:&#39;\n        turnaround = {}\n        response = {}\n        lastran = {}\n        wait = {}\n        quantum  = float(options.quantum)\n        jobcount = len(joblist)\n        for i in range(0,jobcount):\n            lastran[i] = 0.0\n            wait[i] = 0.0\n            turnaround[i] = 0.0\n            response[i] = -1\n\n        runlist = []\n        for e in joblist:\n            runlist.append(e)\n\n        thetime  = 0.0\n        while jobcount &gt; 0:\n            # print &#39;%d jobs remaining&#39; % jobcount\n            job = runlist.pop(0)\n            jobnum  = job[0]\n            runtime = float(job[1])\n            if response[jobnum] == -1:\n                response[jobnum] = thetime\n            currwait = thetime - lastran[jobnum]\n            wait[jobnum] &#43;= currwait\n            ranfor = 1.0\n            if runtime &gt; quantum:\n\t\t\t\t#YOUR CODE\n                runtime = runtime - ranfor\n                print &#39;  [ time %3d ] Run job %3d for %.2f secs&#39; % (thetime, jobnum, ranfor)\n                runlist.append([jobnum, runtime])\n            else:\n                #YOUR CODE\n                print &#39;  [ time %3d ] Run job %3d for %.2f secs ( DONE at %.2f )&#39; % (thetime, jobnum, ranfor, thetime &#43; ranfor)\n                turnaround[jobnum] = thetime &#43; ranfor\n                jobcount -= 1\n            thetime &#43;= ranfor\n            lastran[jobnum] = thetime\n\n        print &#39;\\nFinal statistics:&#39;\n        turnaroundSum = 0.0\n        waitSum       = 0.0\n        responseSum   = 0.0\n        for i in range(0,len(joblist)):\n            turnaroundSum &#43;= turnaround[i]\n            responseSum &#43;= response[i]\n            waitSum &#43;= wait[i]\n            print &#39;  Job %3d -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f&#39; % (i, response[i], turnaround[i], wait[i])\n        count = len(joblist)\n        \n        print &#39;\\n  Average -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f\\n&#39; % (responseSum/count, turnaroundSum/count, waitSum/count)\n\n    if options.policy != &#39;FIFO&#39; and options.policy != &#39;SJF&#39; and options.policy != &#39;RR&#39;: \n        print &#39;Error: Policy&#39;, options.policy, &#39;is not available.&#39;\n        sys.exit(0)\nelse:\n    print &#39;Compute the turnaround time, response time, and wait time for each job.&#39;\n    print &#39;When you are done, run this program again, with the same arguments,&#39;\n    print &#39;but with -c, which will thus provide you with the answers. You can use&#39;\n    print &#39;-s &lt;somenumber&gt; or your own job list (-l 10,15,20 for example)&#39;\n    print &#39;to generate different problems for yourself.&#39;\n    print &#39;&#39;\n\n\n</pre>\n<p></p>", "created": "2015-04-22T08:03:06Z", "bucket_order": 264, "bucket_name": "Week 4/19 - 4/25", "type": "feedback", "tag_good": [], "uid": "i6unpz8nUza", "children": [], "tag_good_arr": [], "id": "i8sgdvo42cy1jh", "updated": "2015-04-22T08:03:06Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "i8sdnu1ynyx2qg", "updated": "2015-04-22T06:46:52Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>楼华哲 2012011327</p>\n<p>周昊 2012011326</p>\n<p>李日灵 2012011332</p>\n<p></p>\n<p>占坑</p>", "created": "2015-04-22T06:48:19Z", "bucket_order": 264, "bucket_name": "Week 4/19 - 4/25", "type": "followup", "tag_good": [], "uid": "i7bq1v7feay2z9", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>周昊</p>\n<p>FIFO</p>\n<pre>if options.policy == &#39;FIFO&#39;:\n        thetime = 0\n        print &#39;Execution trace:&#39;\n\t\t#YOUR CODE\n\n        jobcount = len(joblist)\n        thetime  = 0.0\n        runlist = []\n        for i in joblist:\n            runlist.append(i)\n        while jobcount &gt; 0:\n            job = runlist.pop(0)\n            jobnum = job[0]\n            ranfor = job[1]\n            print &#39;  [ time %3d ] Run job %3d for %.2f secs ( DONE at %.2f )&#39; % (thetime, jobnum, ranfor, thetime &#43; ranfor)\n            thetime &#43;= ranfor\n            jobcount -= 1\n</pre>\n<p></p>", "created": "2015-04-22T06:49:13Z", "bucket_order": 264, "bucket_name": "Week 4/19 - 4/25", "type": "feedback", "tag_good": [], "uid": "i6tezdpdQbq", "children": [], "tag_good_arr": [], "id": "i8sdquvmwk16cp", "updated": "2015-04-22T06:49:13Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>RR&#xff1a;</p>\n<p>if runtime &gt; quantum:<br />                runtime -= quantum<br />                print &#39;  [ time %3d ] Run job %3d for %.2f secs&#39; % (thetime, jobnum, ranfor)<br />                runlist.append([jobnum, runtime])<br />            else:<br />                ranfor = runtime<br />                print &#39;  [ time %3d ] Run job %3d for %.2f secs ( DONE at %.2f )&#39; % (thetime, jobnum, runtime, thetime &#43; ranfor)<br />                turnaround[jobnum] = thetime &#43; ranfor<br />                jobcount -= 1</p>", "created": "2015-04-22T06:50:09Z", "bucket_order": 264, "bucket_name": "Week 4/19 - 4/25", "type": "feedback", "tag_good": [], "uid": "i7bq1v7feay2z9", "children": [], "tag_good_arr": [], "id": "i8sds26v4xb7bq", "updated": "2015-04-22T06:50:09Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>SJR改动代码部分&#xff1a;</p>\n<pre>if options.policy == &#39;SJF&#39;:\n        lnum = jobnum&#43;1\n        yy = []\n        aa = []\n        #print jobnum\n        for i in range(0,jobnum&#43;1):\n            yy.append(1)\n        #print yy\n        print &#39;Execution trace:&#39;\n        total = 0\n        while True:\n            kk = 11\n            t = jobnum&#43;1\n            for job in joblist:\n                if (yy[job[0]] == 1):\n                    if job[1]&lt;kk:\n                        kk = job[1]\n                        t = job[0]\n            aa.append([t,kk])\n            print &#39;  [ time %3d ] Run job %3d for %.2f secs ( DONE at %.2f )&#39; % (total, t, kk, total&#43;kk)\n            total = total &#43; kk\n            yy[t] = 0\n            lnum = lnum - 1\n            if lnum == 0:\n                break\n        print &#39;&#39;\n        total = 0\n        print &#39;Final statistics:&#39;\n        for e in aa:\n            print &#39;  Job %3d -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f&#39; % (e[0], total, total&#43;e[1], total)\n            total = total &#43; e[1]\n    \tpass</pre>\n<p></p>", "created": "2015-04-22T06:50:18Z", "bucket_order": 264, "bucket_name": "Week 4/19 - 4/25", "type": "feedback", "tag_good": [], "uid": "i718mp903qx", "children": [], "tag_good_arr": [], "id": "i8sds93savl6q5", "updated": "2015-04-22T06:50:18Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "i8sdppfbn3848j", "updated": "2015-04-22T06:48:19Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>罗鸿胤 2012011319</p>\n<p>杨元 2012011331</p>\n<p></p>\n<pre>#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\n\nparser = OptionParser()\nparser.add_option(&#34;-s&#34;, &#34;--seed&#34;, default=0, help=&#34;the random seed&#34;,\n                  action=&#34;store&#34;, type=&#34;int&#34;, dest=&#34;seed&#34;)\nparser.add_option(&#34;-j&#34;, &#34;--jobs&#34;, default=3, help=&#34;number of jobs in the system&#34;,\n                  action=&#34;store&#34;, type=&#34;int&#34;, dest=&#34;jobs&#34;)\nparser.add_option(&#34;-l&#34;, &#34;--jlist&#34;, default=&#34;&#34;, help=&#34;instead of random jobs, provide a comma-separated list of run times&#34;,\n                  action=&#34;store&#34;, type=&#34;string&#34;, dest=&#34;jlist&#34;)\nparser.add_option(&#34;-m&#34;, &#34;--maxlen&#34;, default=10, help=&#34;max length of job&#34;,\n                  action=&#34;store&#34;, type=&#34;int&#34;, dest=&#34;maxlen&#34;)\nparser.add_option(&#34;-p&#34;, &#34;--policy&#34;, default=&#34;FIFO&#34;, help=&#34;sched policy to use: SJF, FIFO, RR&#34;,\n                  action=&#34;store&#34;, type=&#34;string&#34;, dest=&#34;policy&#34;)\nparser.add_option(&#34;-q&#34;, &#34;--quantum&#34;, help=&#34;length of time slice for RR policy&#34;, default=1,\n                  action=&#34;store&#34;, type=&#34;int&#34;, dest=&#34;quantum&#34;)\nparser.add_option(&#34;-c&#34;, help=&#34;compute answers for me&#34;, action=&#34;store_true&#34;, default=True, dest=&#34;solve&#34;)\n\n(options, args) = parser.parse_args()\n\nrandom.seed(options.seed)\n\nprint &#39;ARG policy&#39;, options.policy\nif options.jlist == &#39;&#39;:\n    print &#39;ARG jobs&#39;, options.jobs\n    print &#39;ARG maxlen&#39;, options.maxlen\n    print &#39;ARG seed&#39;, options.seed\nelse:\n    print &#39;ARG jlist&#39;, options.jlist\n\nprint &#39;&#39;\n\nprint &#39;Here is the job list, with the run time of each job: &#39;\n\nimport operator\n\njoblist = []\nif options.jlist == &#39;&#39;:\n    for jobnum in range(0,options.jobs):\n        runtime = int(options.maxlen * random.random()) &#43; 1\n        joblist.append([jobnum, runtime])\n        print &#39;  Job&#39;, jobnum, &#39;( length = &#39; &#43; str(runtime) &#43; &#39; )&#39;\nelse:\n    jobnum = 0\n    for runtime in options.jlist.split(&#39;,&#39;):\n        joblist.append([jobnum, float(runtime)])\n        jobnum &#43;= 1\n    for job in joblist:\n        print &#39;  Job&#39;, job[0], &#39;( length = &#39; &#43; str(job[1]) &#43; &#39; )&#39;\nprint &#39;\\n&#39;\n\nif options.solve == True:\n    print &#39;** Solutions **\\n&#39;\n    if options.policy == &#39;SJF&#39;:\n        #YOUR CODE\n        joblist.sort(key=lambda x:x[1], reverse=False)\n        thetime = 0\n        print &#39;Execution trace:&#39;\n        #YOUR CODE\n        t = 0.0\n        for tmp in joblist:\n            jobnum = tmp[0]\n            runtime = tmp[1]\n            \n            print &#39;[ time   %3d ] Run job %3d for %3.2f secs ( DONE at %3.2f )&#39; % (t, jobnum, runtime, t &#43; runtime)\n            t &#43;= runtime\n        \n        print &#39;\\nFinal statistics:&#39;\n        t     = 0.0\n        count = 0\n        turnaroundSum = 0.0\n        waitSum       = 0.0\n        responseSum   = 0.0\n        for tmp in joblist:\n            jobnum  = tmp[0]\n            runtime = tmp[1]\n            \n            response   = t\n            turnaround = t &#43; runtime\n            wait       = t\n            print &#39;  Job %3d -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f&#39; % (jobnum, response, turnaround, wait)\n            responseSum   &#43;= response\n            turnaroundSum &#43;= turnaround\n            waitSum       &#43;= wait\n            t &#43;= runtime\n            count = count &#43; 1\n        print &#39;\\n  Average -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f\\n&#39; % (responseSum/count, turnaroundSum/count, waitSum/count)\n\n    if options.policy == &#39;FIFO&#39;:\n        thetime = 0\n        print &#39;Execution trace:&#39;\n        #YOUR CODE\n        \n        print &#39;\\nFinal statistics:&#39;\n        t     = 0.0\n        count = 0\n        turnaroundSum = 0.0\n        waitSum       = 0.0\n        responseSum   = 0.0\n        for tmp in joblist:\n            jobnum  = tmp[0]\n            runtime = tmp[1]\n            \n            response   = t\n            turnaround = t &#43; runtime\n            wait       = t\n            print &#39;  Job %3d -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f&#39; % (jobnum, response, turnaround, wait)\n            responseSum   &#43;= response\n            turnaroundSum &#43;= turnaround\n            waitSum       &#43;= wait\n            t &#43;= runtime\n            count = count &#43; 1\n        print &#39;\\n  Average -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f\\n&#39; % (responseSum/count, turnaroundSum/count, waitSum/count)\n\nif options.policy == &#39;RR&#39;:\n    print &#39;Execution trace:&#39;\n        turnaround = {}\n        response = {}\n        lastran = {}\n        wait = {}\n        quantum  = float(options.quantum)\n        jobcount = len(joblist)\n        for i in range(0,jobcount):\n            lastran[i] = 0.0\n            wait[i] = 0.0\n            turnaround[i] = 0.0\n            response[i] = -1\n\n    runlist = []\n        for e in joblist:\n            runlist.append(e)\n\nthetime  = 0.0\n    while jobcount &gt; 0:\n        # print &#39;%d jobs remaining&#39; % jobcount\n        job = runlist.pop(0)\n            jobnum  = job[0]\n            runtime = float(job[1])\n            if response[jobnum] == -1:\n                response[jobnum] = thetime\n        currwait = thetime - lastran[jobnum]\n            wait[jobnum] &#43;= currwait\n            ranfor = 0\n            if runtime &gt; quantum:\n                #YOUR CODE\n                ranfor = quantum\n                runtime = runtime - quantum\n                print &#39;  [ time %3d ] Run job %3d for %.2f secs&#39; % (thetime, jobnum, ranfor)\n                runlist.append([jobnum, runtime])\n            else:\n                #YOUR CODE\n                ranfor = runtime\n                print &#39;  [ time %3d ] Run job %3d for %.2f secs ( DONE at %.2f )&#39; % (thetime, jobnum, ranfor, thetime &#43; ranfor)\n                turnaround[jobnum] = thetime &#43; ranfor\n                jobcount -= 1\n        thetime &#43;= ranfor\n            lastran[jobnum] = thetime\n        \n        print &#39;\\nFinal statistics:&#39;\n        turnaroundSum = 0.0\n        waitSum       = 0.0\n        responseSum   = 0.0\n        for i in range(0,len(joblist)):\n            turnaroundSum &#43;= turnaround[i]\n            responseSum &#43;= response[i]\n            waitSum &#43;= wait[i]\n            print &#39;  Job %3d -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f&#39; % (i, response[i], turnaround[i], wait[i])\n        count = len(joblist)\n        \n                    print &#39;\\n  Average -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f\\n&#39; % (responseSum/count, turnaroundSum/count, waitSum/count)\n\nif options.policy != &#39;FIFO&#39; and options.policy != &#39;SJF&#39; and options.policy != &#39;RR&#39;:\n    print &#39;Error: Policy&#39;, options.policy, &#39;is not available.&#39;\n        sys.exit(0)\nelse:\n    print &#39;Compute the turnaround time, response time, and wait time for each job.&#39;\n    print &#39;When you are done, run this program again, with the same arguments,&#39;\n    print &#39;but with -c, which will thus provide you with the answers. You can use&#39;\n    print &#39;-s &lt;somenumber&gt; or your own job list (-l 10,15,20 for example)&#39;\n    print &#39;to generate different problems for yourself.&#39;\n    print &#39;&#39;\n\n\n</pre>\n<p></p>", "created": "2015-04-22T06:48:56Z", "bucket_order": 264, "bucket_name": "Week 4/19 - 4/25", "type": "followup", "tag_good": [], "uid": "i7oaxkxhxjo3ui", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i8sdqi4q3vh696", "updated": "2015-04-22T06:48:56Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>周界 2012011394</p>\n<p>陈刚 2012011389</p>\n<p></p>\n<pre>#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\n\nparser = OptionParser()\nparser.add_option(&#34;-s&#34;, &#34;--seed&#34;, default=0, help=&#34;the random seed&#34;, \n                  action=&#34;store&#34;, type=&#34;int&#34;, dest=&#34;seed&#34;)\nparser.add_option(&#34;-j&#34;, &#34;--jobs&#34;, default=3, help=&#34;number of jobs in the system&#34;,\n                  action=&#34;store&#34;, type=&#34;int&#34;, dest=&#34;jobs&#34;)\nparser.add_option(&#34;-l&#34;, &#34;--jlist&#34;, default=&#34;&#34;, help=&#34;instead of random jobs, provide a comma-separated list of run times&#34;,\n                  action=&#34;store&#34;, type=&#34;string&#34;, dest=&#34;jlist&#34;)\nparser.add_option(&#34;-m&#34;, &#34;--maxlen&#34;, default=10, help=&#34;max length of job&#34;,\n                  action=&#34;store&#34;, type=&#34;int&#34;, dest=&#34;maxlen&#34;)\nparser.add_option(&#34;-p&#34;, &#34;--policy&#34;, default=&#34;FIFO&#34;, help=&#34;sched policy to use: SJF, FIFO, RR&#34;,\n                  action=&#34;store&#34;, type=&#34;string&#34;, dest=&#34;policy&#34;)\nparser.add_option(&#34;-q&#34;, &#34;--quantum&#34;, help=&#34;length of time slice for RR policy&#34;, default=1, \n                  action=&#34;store&#34;, type=&#34;int&#34;, dest=&#34;quantum&#34;)\nparser.add_option(&#34;-c&#34;, help=&#34;compute answers for me&#34;, action=&#34;store_true&#34;, default=True, dest=&#34;solve&#34;)\n\n(options, args) = parser.parse_args()\n\nrandom.seed(options.seed)\n\nprint &#39;ARG policy&#39;, options.policy\nif options.jlist == &#39;&#39;:\n    print &#39;ARG jobs&#39;, options.jobs\n    print &#39;ARG maxlen&#39;, options.maxlen\n    print &#39;ARG seed&#39;, options.seed\nelse:\n    print &#39;ARG jlist&#39;, options.jlist\n\nprint &#39;&#39;\n\nprint &#39;Here is the job list, with the run time of each job: &#39;\n\nimport operator\n\njoblist = []\nif options.jlist == &#39;&#39;:\n    for jobnum in range(0,options.jobs):\n        runtime = int(options.maxlen * random.random()) &#43; 1\n        joblist.append([jobnum, runtime])\n        print &#39;  Job&#39;, jobnum, &#39;( length = &#39; &#43; str(runtime) &#43; &#39; )&#39;\nelse:\n    jobnum = 0\n    for runtime in options.jlist.split(&#39;,&#39;):\n        joblist.append([jobnum, float(runtime)])\n        jobnum &#43;= 1\n    for job in joblist:\n        print &#39;  Job&#39;, job[0], &#39;( length = &#39; &#43; str(job[1]) &#43; &#39; )&#39;\nprint &#39;\\n&#39;\n\nif options.solve == True:\n    print &#39;** Solutions **\\n&#39;\n    if options.policy == &#39;SJF&#39;:\n        \n        joblist.sort(key=lambda x:x[1], reverse=False)\n        \n        thetime = 0\n        print &#39;Execution trace:&#39;\n        #YOUR CODE\n        t = 0.0\n        for tmp in joblist:\n            jobnum = tmp[0]\n            runtime = tmp[1]\n            \n            print &#39;[ time   %3d ] Run job %3d for %3.2f secs ( DONE at %3.2f )&#39; % (t, jobnum, runtime, t &#43; runtime)\n            t &#43;= runtime\n        \n        print &#39;\\nFinal statistics:&#39;\n        t     = 0.0\n        count = 0\n        turnaroundSum = 0.0\n        waitSum       = 0.0\n        responseSum   = 0.0\n        for tmp in joblist:\n            jobnum  = tmp[0]\n            runtime = tmp[1]\n            \n            response   = t\n            turnaround = t &#43; runtime\n            wait       = t\n            print &#39;  Job %3d -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f&#39; % (jobnum, response, turnaround, wait)\n            responseSum   &#43;= response\n            turnaroundSum &#43;= turnaround\n            waitSum       &#43;= wait\n            t &#43;= runtime\n            count = count &#43; 1\n        print &#39;\\n  Average -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f\\n&#39; % (responseSum/count, turnaroundSum/count, waitSum/count)\n    \t\n    if options.policy == &#39;FIFO&#39;:\n        thetime = 0\n        print &#39;Execution trace:&#39;\n\t\t#YOUR CODE\n        t = 0.0\n        for tmp in joblist:\n            jobnum = tmp[0]\n            runtime = tmp[1]\n        \n            print &#39;[ time   %3d ] Run job %3d for %3.2f secs ( DONE at %3.2f )&#39; % (t, jobnum, runtime, t &#43; runtime)\n            t &#43;= runtime\n        \n        print &#39;\\nFinal statistics:&#39;\n        t     = 0.0\n        count = 0\n        turnaroundSum = 0.0\n        waitSum       = 0.0\n        responseSum   = 0.0\n        for tmp in joblist:\n            jobnum  = tmp[0]\n            runtime = tmp[1]\n            \n            response   = t\n            turnaround = t &#43; runtime\n            wait       = t\n            print &#39;  Job %3d -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f&#39; % (jobnum, response, turnaround, wait)\n            responseSum   &#43;= response\n            turnaroundSum &#43;= turnaround\n            waitSum       &#43;= wait\n            t &#43;= runtime\n            count = count &#43; 1\n        print &#39;\\n  Average -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f\\n&#39; % (responseSum/count, turnaroundSum/count, waitSum/count)\n                     \n    if options.policy == &#39;RR&#39;:\n        print &#39;Execution trace:&#39;\n        turnaround = {}\n        response = {}\n        lastran = {}\n        wait = {}\n        quantum  = float(options.quantum)\n        jobcount = len(joblist)\n        for i in range(0,jobcount):\n            lastran[i] = 0.0\n            wait[i] = 0.0\n            turnaround[i] = 0.0\n            response[i] = -1\n\n        runlist = []\n        for e in joblist:\n            runlist.append(e)\n\n        thetime  = 0.0\n        while jobcount &gt; 0:\n            # print &#39;%d jobs remaining&#39; % jobcount\n            job = runlist.pop(0)\n            jobnum  = job[0]\n            runtime = float(job[1])\n            if response[jobnum] == -1:\n                response[jobnum] = thetime\n            currwait = thetime - lastran[jobnum]\n            wait[jobnum] &#43;= currwait\n            ranfor = 0\n            if runtime &gt; quantum:\n\t\t\t\t#YOUR CODE\n                ranfor = quantum\n                runtime = runtime - quantum\n                print &#39;  [ time %3d ] Run job %3d for %.2f secs&#39; % (thetime, jobnum, ranfor)\n                runlist.append([jobnum, runtime])\n            else:\n                #YOUR CODE\n                ranfor = runtime\n                print &#39;  [ time %3d ] Run job %3d for %.2f secs ( DONE at %.2f )&#39; % (thetime, jobnum, ranfor, thetime &#43; ranfor)\n                turnaround[jobnum] = thetime &#43; ranfor\n                jobcount -= 1\n            thetime &#43;= ranfor\n            lastran[jobnum] = thetime\n\n        print &#39;\\nFinal statistics:&#39;\n        turnaroundSum = 0.0\n        waitSum       = 0.0\n        responseSum   = 0.0\n        for i in range(0,len(joblist)):\n            turnaroundSum &#43;= turnaround[i]\n            responseSum &#43;= response[i]\n            waitSum &#43;= wait[i]\n            print &#39;  Job %3d -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f&#39; % (i, response[i], turnaround[i], wait[i])\n        count = len(joblist)\n        \n        print &#39;\\n  Average -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f\\n&#39; % (responseSum/count, turnaroundSum/count, waitSum/count)\n\n    if options.policy != &#39;FIFO&#39; and options.policy != &#39;SJF&#39; and options.policy != &#39;RR&#39;: \n        print &#39;Error: Policy&#39;, options.policy, &#39;is not available.&#39;\n        sys.exit(0)\nelse:\n    print &#39;Compute the turnaround time, response time, and wait time for each job.&#39;\n    print &#39;When you are done, run this program again, with the same arguments,&#39;\n    print &#39;but with -c, which will thus provide you with the answers. You can use&#39;\n    print &#39;-s &lt;somenumber&gt; or your own job list (-l 10,15,20 for example)&#39;\n    print &#39;to generate different problems for yourself.&#39;\n    print &#39;&#39;</pre>\n<p></p>", "created": "2015-04-22T06:49:38Z", "bucket_order": 264, "bucket_name": "Week 4/19 - 4/25", "type": "followup", "tag_good": [], "uid": "i6t7mzhbhwF", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>2012011322 林子钏</p>\n<p>2012011299 史佳欣</p>\n<pre>#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\n\nparser = OptionParser()\nparser.add_option(&#34;-s&#34;, &#34;--seed&#34;, default=0, help=&#34;the random seed&#34;,\n                  action=&#34;store&#34;, type=&#34;int&#34;, dest=&#34;seed&#34;)\nparser.add_option(&#34;-j&#34;, &#34;--jobs&#34;, default=3, help=&#34;number of jobs in the system&#34;,\n                  action=&#34;store&#34;, type=&#34;int&#34;, dest=&#34;jobs&#34;)\nparser.add_option(&#34;-l&#34;, &#34;--jlist&#34;, default=&#34;&#34;, help=&#34;instead of random jobs, provide a comma-separated list of run times&#34;,\n                  action=&#34;store&#34;, type=&#34;string&#34;, dest=&#34;jlist&#34;)\nparser.add_option(&#34;-m&#34;, &#34;--maxlen&#34;, default=10, help=&#34;max length of job&#34;,\n                  action=&#34;store&#34;, type=&#34;int&#34;, dest=&#34;maxlen&#34;)\nparser.add_option(&#34;-p&#34;, &#34;--policy&#34;, default=&#34;FIFO&#34;, help=&#34;sched policy to use: SJF, FIFO, RR&#34;,\n                  action=&#34;store&#34;, type=&#34;string&#34;, dest=&#34;policy&#34;)\nparser.add_option(&#34;-q&#34;, &#34;--quantum&#34;, help=&#34;length of time slice for RR policy&#34;, default=1,\n                  action=&#34;store&#34;, type=&#34;int&#34;, dest=&#34;quantum&#34;)\nparser.add_option(&#34;-c&#34;, help=&#34;compute answers for me&#34;, action=&#34;store_true&#34;, default=True, dest=&#34;solve&#34;)\n\n(options, args) = parser.parse_args()\n\nrandom.seed(options.seed)\n\nprint &#39;ARG policy&#39;, options.policy\nif options.jlist == &#39;&#39;:\n    print &#39;ARG jobs&#39;, options.jobs\n    print &#39;ARG maxlen&#39;, options.maxlen\n    print &#39;ARG seed&#39;, options.seed\nelse:\n    print &#39;ARG jlist&#39;, options.jlist\n\nprint &#39;&#39;\n\nprint &#39;Here is the job list, with the run time of each job: &#39;\n\nimport operator\n\njoblist = []\nif options.jlist == &#39;&#39;:\n    for jobnum in range(0,options.jobs):\n        runtime = int(options.maxlen * random.random()) &#43; 1\n        joblist.append([jobnum, runtime])\n        print &#39;  Job&#39;, jobnum, &#39;( length = &#39; &#43; str(runtime) &#43; &#39; )&#39;\nelse:\n    jobnum = 0\n    for runtime in options.jlist.split(&#39;,&#39;):\n        joblist.append([jobnum, float(runtime)])\n        jobnum &#43;= 1\n    for job in joblist:\n        print &#39;  Job&#39;, job[0], &#39;( length = &#39; &#43; str(job[1]) &#43; &#39; )&#39;\nprint &#39;\\n&#39;\n\nif options.solve == True:\n    print &#39;** Solutions **\\n&#39;\n    if options.policy == &#39;SJF&#39;:\n        #YOUR CODE\n        joblist.sort(key=lambda x:x[1], reverse=False)\n        thetime = 0\n        print &#39;Execution trace:&#39;\n        #YOUR CODE\n        t = 0.0\n        for tmp in joblist:\n            jobnum = tmp[0]\n            runtime = tmp[1]\n            \n            print &#39;[ time   %3d ] Run job %3d for %3.2f secs ( DONE at %3.2f )&#39; % (t, jobnum, runtime, t &#43; runtime)\n            t &#43;= runtime\n        \n        print &#39;\\nFinal statistics:&#39;\n        t     = 0.0\n        count = 0\n        turnaroundSum = 0.0\n        waitSum       = 0.0\n        responseSum   = 0.0\n        for tmp in joblist:\n            jobnum  = tmp[0]\n            runtime = tmp[1]\n            \n            response   = t\n            turnaround = t &#43; runtime\n            wait       = t\n            print &#39;  Job %3d -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f&#39; % (jobnum, response, turnaround, wait)\n            responseSum   &#43;= response\n            turnaroundSum &#43;= turnaround\n            waitSum       &#43;= wait\n            t &#43;= runtime\n            count = count &#43; 1\n        print &#39;\\n  Average -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f\\n&#39; % (responseSum/count, turnaroundSum/count, waitSum/count)\n\n    if options.policy == &#39;FIFO&#39;:\n        thetime = 0\n        print &#39;Execution trace:&#39;\n        #YOUR CODE\n        \n        print &#39;\\nFinal statistics:&#39;\n        t     = 0.0\n        count = 0\n        turnaroundSum = 0.0\n        waitSum       = 0.0\n        responseSum   = 0.0\n        for tmp in joblist:\n            jobnum  = tmp[0]\n            runtime = tmp[1]\n            \n            response   = t\n            turnaround = t &#43; runtime\n            wait       = t\n            print &#39;  Job %3d -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f&#39; % (jobnum, response, turnaround, wait)\n            responseSum   &#43;= response\n            turnaroundSum &#43;= turnaround\n            waitSum       &#43;= wait\n            t &#43;= runtime\n            count = count &#43; 1\n        print &#39;\\n  Average -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f\\n&#39; % (responseSum/count, turnaroundSum/count, waitSum/count)\n\nif options.policy == &#39;RR&#39;:\n    print &#39;Execution trace:&#39;\n        turnaround = {}\n        response = {}\n        lastran = {}\n        wait = {}\n        quantum  = float(options.quantum)\n        jobcount = len(joblist)\n        for i in range(0,jobcount):\n            lastran[i] = 0.0\n            wait[i] = 0.0\n            turnaround[i] = 0.0\n            response[i] = -1\n\n    runlist = []\n        for e in joblist:\n            runlist.append(e)\n\nthetime  = 0.0\n    while jobcount &gt; 0:\n        # print &#39;%d jobs remaining&#39; % jobcount\n        job = runlist.pop(0)\n            jobnum  = job[0]\n            runtime = float(job[1])\n            if response[jobnum] == -1:\n                response[jobnum] = thetime\n        currwait = thetime - lastran[jobnum]\n            wait[jobnum] &#43;= currwait\n            ranfor = 0\n            if runtime &gt; quantum:\n                #YOUR CODE\n                ranfor = quantum\n                runtime = runtime - quantum\n                print &#39;  [ time %3d ] Run job %3d for %.2f secs&#39; % (thetime, jobnum, ranfor)\n                runlist.append([jobnum, runtime])\n            else:\n                #YOUR CODE\n                ranfor = runtime\n                print &#39;  [ time %3d ] Run job %3d for %.2f secs ( DONE at %.2f )&#39; % (thetime, jobnum, ranfor, thetime &#43; ranfor)\n                turnaround[jobnum] = thetime &#43; ranfor\n                jobcount -= 1\n        thetime &#43;= ranfor\n            lastran[jobnum] = thetime\n        \n        print &#39;\\nFinal statistics:&#39;\n        turnaroundSum = 0.0\n        waitSum       = 0.0\n        responseSum   = 0.0\n        for i in range(0,len(joblist)):\n            turnaroundSum &#43;= turnaround[i]\n            responseSum &#43;= response[i]\n            waitSum &#43;= wait[i]\n            print &#39;  Job %3d -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f&#39; % (i, response[i], turnaround[i], wait[i])\n        count = len(joblist)\n        \n                    print &#39;\\n  Average -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f\\n&#39; % (responseSum/count, turnaroundSum/count, waitSum/count)\n\nif options.policy != &#39;FIFO&#39; and options.policy != &#39;SJF&#39; and options.policy != &#39;RR&#39;:\n    print &#39;Error: Policy&#39;, options.policy, &#39;is not available.&#39;\n        sys.exit(0)\nelse:\n    print &#39;Compute the turnaround time, response time, and wait time for each job.&#39;\n    print &#39;When you are done, run this program again, with the same arguments,&#39;\n    print &#39;but with -c, which will thus provide you with the answers. You can use&#39;\n    print &#39;-s &lt;somenumber&gt; or your own job list (-l 10,15,20 for example)&#39;\n    print &#39;to generate different problems for yourself.&#39;\n    print &#39;&#39;</pre>\n<p></p>", "created": "2015-04-22T06:57:39Z", "bucket_order": 264, "bucket_name": "Week 4/19 - 4/25", "type": "feedback", "tag_good": [], "uid": "i6vuv0mi6uU", "children": [], "tag_good_arr": [], "id": "i8se1pbkznu5ti", "updated": "2015-04-22T06:57:39Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "i8sdre1d3qi76i", "updated": "2015-04-22T06:49:38Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "战裕隆 2012011388\n杨俊 2012011400\nhttps://github.com/zhanyl12/os_exercises/blob/master/all/06-1-spoc-discussion.md", "created": "2015-04-22T07:01:15Z", "bucket_order": 264, "bucket_name": "Week 4/19 - 4/25", "type": "followup", "tag_good": [], "uid": "i6xgf2t8N7w", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i8se6brs9jb2w", "updated": "2015-04-22T07:01:15Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>路云飞 2012011359</p>\n<p>https://github.com/december/os_data/blob/master/scheduler.py</p>", "created": "2015-04-22T07:05:04Z", "bucket_order": 264, "bucket_name": "Week 4/19 - 4/25", "type": "followup", "tag_good": [], "uid": "i718aanx0OS", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i8seb8s0ewp176", "updated": "2015-04-22T07:05:04Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>马晓彬 2012011402 张梦豪 2012011401</p>\n<p>完成三个基本任务和MLFQ调度Stride调度</p>\n<pre>#! /usr/bin/env python\nimport sys\nfrom optparse import OptionParser\nimport random\n\nparser = OptionParser()\nparser.add_option(&#34;-s&#34;, &#34;--seed&#34;, default=0, help=&#34;the random seed&#34;, \n                  action=&#34;store&#34;, type=&#34;int&#34;, dest=&#34;seed&#34;)\nparser.add_option(&#34;-j&#34;, &#34;--jobs&#34;, default=3, help=&#34;number of jobs in the system&#34;,\n                  action=&#34;store&#34;, type=&#34;int&#34;, dest=&#34;jobs&#34;)\nparser.add_option(&#34;-l&#34;, &#34;--jlist&#34;, default=&#34;&#34;, help=&#34;instead of random jobs, provide a comma-separated list of run times&#34;,\n                  action=&#34;store&#34;, type=&#34;string&#34;, dest=&#34;jlist&#34;)\nparser.add_option(&#34;-m&#34;, &#34;--maxlen&#34;, default=10, help=&#34;max length of job&#34;,\n                  action=&#34;store&#34;, type=&#34;int&#34;, dest=&#34;maxlen&#34;)\nparser.add_option(&#34;-p&#34;, &#34;--policy&#34;, default=&#34;FIFO&#34;, help=&#34;sched policy to use: SJF, FIFO, RR&#34;,\n                  action=&#34;store&#34;, type=&#34;string&#34;, dest=&#34;policy&#34;)\nparser.add_option(&#34;-q&#34;, &#34;--quantum&#34;, help=&#34;length of time slice for RR policy&#34;, default=1, \n                  action=&#34;store&#34;, type=&#34;int&#34;, dest=&#34;quantum&#34;)\nparser.add_option(&#34;-c&#34;, help=&#34;compute answers for me&#34;, action=&#34;store_true&#34;, default=True, dest=&#34;solve&#34;)\n\n(options, args) = parser.parse_args()\n\nrandom.seed(options.seed)\n\nprint &#39;ARG policy&#39;, options.policy\nif options.jlist == &#39;&#39;:\n    print &#39;ARG jobs&#39;, options.jobs\n    print &#39;ARG maxlen&#39;, options.maxlen\n    print &#39;ARG seed&#39;, options.seed\nelse:\n    print &#39;ARG jlist&#39;, options.jlist\n\nprint &#39;&#39;\n\nprint &#39;Here is the job list, with the run time of each job: &#39;\n\nimport operator\n\nqueuenum = 3;\njoblist = []\njobqueue = []\njobqueuepiece = [3,2,1]\nif options.policy == &#39;MLFQ&#39;:\n    if options.jobs &lt; queuenum:\n        options.jobs = queuenum;\n\nif options.jlist == &#39;&#39;: \n    for jobnum in range(0,options.jobs):\n        runtime = int(options.maxlen * random.random()) &#43; 1\n        if options.policy == &#39;STRIDE&#39;:\n            runtime = options.maxlen\n        prio = int(3 * random.random()) &#43; 1\n        stride = 0\n        passnum = 6/prio\n        joblist.append([jobnum, runtime, prio,stride,passnum])\n        print &#39;  Job&#39;, jobnum, &#39;( length = &#39; &#43; str(runtime) &#43; &#39; prior = &#39;&#43;str(prio)&#43;&#39; stride = &#39;&#43;str(stride)&#43;&#39; passnum = &#39;&#43;str(passnum)&#43;&#39;)&#39;\nelse:\n    jobnum = 0\n    for runtime in options.jlist.split(&#39;,&#39;):\n        joblist.append([jobnum, float(runtime)])\n        jobnum &#43;= 1\n    for job in joblist:\n        print &#39;  Job&#39;, job[0], &#39;( length = &#39; &#43; str(job[1]) &#43; &#39; )&#39;\nprint &#39;\\n&#39;\n\n\nif options.policy == &#39;MLFQ&#39;:\n    for i in range(0,queuenum):\n        jobqueue.append([])\n    for i in range(0,options.jobs):\n        jobqueue[i%queuenum].append(joblist[i]) \n\nif options.solve == True:\n    print &#39;** Solutions **\\n&#39;\n    if options.policy == &#39;SJF&#39;:\n        #YOUR CODE\n        thetime = 0\n        print &#39;Execution trace:&#39;\n        #YOUR CODE\n        time = 0;\n        jobnum = 0;\n        joblist.sort(lambda x,y:cmp(x[1],y[1]))\n        for jobs in joblist:\n            print &#39;  [ time %3d ] Run job %d for %3.2f secs ( DONE at %3.2f )&#39; % (time, jobs[0], jobs[1], time&#43;jobs[1]);\n            time = time &#43; jobs[1];\n        \n        print &#39;\\nFinal statistics:&#39;\n        t     = 0.0\n        count = 0\n        turnaroundSum = 0.0\n        waitSum       = 0.0\n        responseSum   = 0.0\n        for tmp in joblist:\n            jobnum  = tmp[0]\n            runtime = tmp[1]\n            \n            response   = t\n            turnaround = t &#43; runtime\n            wait       = t\n            print &#39;  Job %3d -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f&#39; % (jobnum, response, turnaround, wait)\n            responseSum   &#43;= response\n            turnaroundSum &#43;= turnaround\n            waitSum       &#43;= wait\n            t &#43;= runtime\n            count = count &#43; 1\n        print &#39;\\n  Average -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f\\n&#39; % (responseSum/count, turnaroundSum/count, waitSum/count)\n        \n    if options.policy == &#39;FIFO&#39;:\n        thetime = 0\n        print &#39;Execution trace:&#39;\n        #YOUR CODE\n        time = 0;\n        jobnum = 0;\n        for jobs in joblist:\n            print &#39;  [ time %3d ] Run job %d for %3.2f secs ( DONE at %3.2f )&#39; % (time, jobs[0], jobs[1], time&#43;jobs[1]);\n            time = time &#43; jobs[1];\n        print &#39;\\nFinal statistics:&#39;\n        t     = 0.0\n        count = 0\n        turnaroundSum = 0.0\n        waitSum       = 0.0\n        responseSum   = 0.0\n        for tmp in joblist:\n            jobnum  = tmp[0]\n            runtime = tmp[1]\n            \n            response   = t\n            turnaround = t &#43; runtime\n            wait       = t\n            print &#39;  Job %3d -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f&#39; % (jobnum, response, turnaround, wait)\n            responseSum   &#43;= response\n            turnaroundSum &#43;= turnaround\n            waitSum       &#43;= wait\n            t &#43;= runtime\n            count = count &#43; 1\n        print &#39;\\n  Average -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f\\n&#39; % (responseSum/count, turnaroundSum/count, waitSum/count)\n                     \n    if options.policy == &#39;RR&#39;:\n        print &#39;Execution trace:&#39;\n        turnaround = {}\n        response = {}\n        lastran = {}\n        wait = {}\n        quantum  = float(options.quantum)\n        jobcount = len(joblist)\n        for i in range(0,jobcount):\n            lastran[i] = 0.0\n            wait[i] = 0.0\n            turnaround[i] = 0.0\n            response[i] = -1\n\n        runlist = []\n        for e in joblist:\n            runlist.append(e)\n\n        thetime  = 0.0\n        while jobcount &gt; 0:\n            # print &#39;%d jobs remaining&#39; % jobcount\n            job = runlist.pop(0)\n            jobnum  = job[0]\n            runtime = float(job[1])\n            if response[jobnum] == -1:\n                response[jobnum] = thetime\n            currwait = thetime - lastran[jobnum]\n            wait[jobnum] &#43;= currwait\n            ranfor = 1\n            if runtime &gt; quantum:\n                #YOUR CODE\n                print &#39;  [ time %3d ] Run job %3d for %.2f secs&#39; % (thetime, jobnum, ranfor)\n                runtime = runtime - ranfor\n                runlist.append([jobnum, runtime])\n            else:\n                #YOUR CODE\n\n                print &#39;  [ time %3d ] Run job %3d for %.2f secs ( DONE at %.2f )&#39; % (thetime, jobnum, ranfor, thetime &#43; ranfor)\n                turnaround[jobnum] = thetime &#43; ranfor\n                jobcount -= 1\n            thetime &#43;= ranfor\n            lastran[jobnum] = thetime\n        \n        print &#39;\\nFinal statistics:&#39;\n        turnaroundSum = 0.0\n        waitSum       = 0.0\n        responseSum   = 0.0\n        for i in range(0,len(joblist)):\n            turnaroundSum &#43;= turnaround[i]\n            responseSum &#43;= response[i]\n            waitSum &#43;= wait[i]\n            print &#39;  Job %3d -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f&#39; % (i, response[i], turnaround[i], wait[i])\n        count = len(joblist)\n        \n        print &#39;\\n  Average -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f\\n&#39; % (responseSum/count, turnaroundSum/count, waitSum/count)\n    if options.policy == &#39;MLFQ&#39;:\n            print &#39;Execution trace:&#39;\n            freequeue = 0;\n            turnaround = {}\n            response = {}\n            lastran = {}\n            wait = {}\n            thetime  = 0.0\n            jobcount = len(joblist)\n            for i in range(0,jobcount):\n                lastran[i] = 0.0\n                wait[i] = 0.0\n                turnaround[i] = 0.0\n                response[i] = -1\n\n            quantum  = float(options.quantum)\n            while freequeue &lt; queuenum:\n                nowjoblist = jobqueue[freequeue]\n                jobcount = len(nowjoblist)\n\n                runlist = []\n                for e in nowjoblist:\n                    runlist.append(e)\n\n                while jobcount &gt; 0:\n                    # print &#39;%d jobs remaining&#39; % jobcount\n                    job = runlist.pop(0)\n                    jobnum  = job[0]\n                    runtime = float(job[1])\n                    if response[jobnum] == -1:\n                        response[jobnum] = thetime\n                    currwait = thetime - lastran[jobnum]\n                    wait[jobnum] &#43;= currwait\n                    ranfor = jobqueuepiece[freequeue]\n                    if runtime &gt; quantum:\n                        #YOUR CODE\n                        print &#39;  [ time %3d ] Run job %3d for %.2f secs&#39; % (thetime, jobnum, ranfor)\n                        runtime = runtime - ranfor\n                        runlist.append([jobnum, runtime])\n                    else:\n                        #YOUR CODE\n<br />                        print &#39;  [ time %3d ] Run job %3d for %.2f secs ( DONE at %.2f )&#39; % (thetime, jobnum, ranfor, thetime &#43; ranfor)<br />                        turnaround[jobnum] = thetime &#43; ranfor<br />                        jobcount -= 1<br />                    thetime &#43;= ranfor<br />                    lastran[jobnum] = thetime<br />                freequeue &#43;= 1<br />            print &#39;\\nFinal statistics:&#39;<br />            turnaroundSum = 0.0<br />            waitSum       = 0.0<br />            responseSum   = 0.0<br />            for i in range(0,len(joblist)):<br />                turnaroundSum &#43;= turnaround[i]<br />                responseSum &#43;= response[i]<br />                waitSum &#43;= wait[i]<br />                print &#39;  Job %3d -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f&#39; % (i, response[i], turnaround[i], wait[i])<br />            count = len(nowjoblist)<br />            <br />            print &#39;\\n  Average -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f\\n&#39; % (responseSum/count, turnaroundSum/count, waitSum/count)<br /><br />    if options.policy == &#39;STRIDE&#39;:<br />        print &#39;Execution trace:&#39;<br />        <br />        <br />        turnaround = {}<br />        response = {}<br />        lastran = {}<br />        wait = {}<br />        quantum  = float(options.quantum)<br />        jobcount = len(joblist)<br />        for i in range(0,jobcount):<br />   </pre>", "created": "2015-04-22T07:06:33Z", "bucket_order": 264, "bucket_name": "Week 4/19 - 4/25", "type": "followup", "tag_good": [], "uid": "i6uswob7jl4242", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "另外&#xff0c;又完成了stride调度算法&#xff0c;详见https://github.com/ZhangMenghao/os_exercises/blob/master/all/06-1-spoc-discussion.py", "created": "2015-04-22T09:44:05Z", "bucket_order": 264, "bucket_name": "Week 4/19 - 4/25", "type": "feedback", "tag_good": [], "uid": "i6tawpo5Fm8", "children": [], "tag_good_arr": [], "id": "i8sjzqcl7ll5ww", "updated": "2015-04-22T09:44:05Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "i8sed5hphrt3s4", "updated": "2015-04-22T07:06:33Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>陆喆 2012011308</p>\n<p><a href=\"https://github.com/lbx6z/ucore_lab/blob/master/related_info/lab6/scheduler-homework.py\" target=\"_blank\">https://github.com/lbx6z/ucore_lab/blob/master/related_info/lab6/scheduler-homework.py</a></p>", "created": "2015-04-22T07:07:36Z", "bucket_order": 264, "bucket_name": "Week 4/19 - 4/25", "type": "followup", "tag_good": [], "uid": "i6urm1j1ynv6sm", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i8seehr8key410", "updated": "2015-04-22T07:07:36Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>章浚源</p>\n<p>杨皓</p>\n<p><a href=\"https://github.com/Socyrus/os_exercises/blob/master/all/scheduler-homework.py\">https://github.com/Socyrus/os_exercises/blob/master/all/scheduler-homework.py</a><a href=\"https://github.com/Socyrus/os_exercises/blob/master/all/scheduler-homework.py\"></a></p>\n<p><a href=\"https://github.com/Socyrus/os_exercises/blob/master/all/mlfq.py\">https://github.com/Socyrus/os_exercises/blob/master/all/mlfq.py</a></p>", "created": "2015-04-22T07:08:45Z", "bucket_order": 264, "bucket_name": "Week 4/19 - 4/25", "type": "followup", "tag_good": [], "uid": "i71fykcui1h2je", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>", "created": "2015-04-22T08:29:37Z", "bucket_order": 264, "bucket_name": "Week 4/19 - 4/25", "type": "feedback", "tag_good": [], "uid": "i71fykcui1h2je", "children": [], "tag_good_arr": [], "id": "i8shbz0h7hkjz", "updated": "2015-04-22T08:29:37Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "i8sefzgw9ti6a4", "updated": "2015-04-22T07:08:45Z", "config": {}}], "tag_good_arr": [], "id": "i8sdkutfd481jz", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 24, "num_favorites": 0, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643167655426, "default_anonymity": "no"}, "error": null, "aid": "kyuzlhc2496420"}