{"result": {"folders": ["lab3"], "nr": 1331, "data": {"embed_links": []}, "created": "2019-05-12T09:12:06Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "j166z5vyA7y", "data": "jvkpz7awp2e5xb", "type": "create", "when": "2019-05-12T09:12:06Z"}, {"anon": "no", "uid": "j166z5vyA7y", "data": "jvlqhzwbsk858z", "type": "update", "when": "2019-05-13T02:14:29Z"}, {"anon": "no", "uid": "j166z5vyA7y", "data": "jvp4qkm5cr57bz", "type": "update", "when": "2019-05-15T11:16:22Z"}, {"anon": "no", "uid": "j166z5vyA7y", "data": "jvp5jk2jh8k1gx", "type": "update", "when": "2019-05-15T11:38:55Z"}, {"anon": "no", "uid": "j166z5vyA7y", "data": "jvrgwpqk4og7a7", "type": "update", "when": "2019-05-17T02:32:37Z"}, {"anon": "no", "uid": "jshne0q7ovz4n3", "data": "jvt1e0v25yp7fv", "to": "jvkpz7autx45xa", "type": "s_answer", "when": "2019-05-18T04:53:43Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "j166z5vyA7y", "subject": "lab3 相关问题汇总", "created": "2019-05-17T02:32:37Z", "content": "<p>1&#xff0c;<a href=\"https://github.com/chyyuu/ucore_os_lab/blob/master/labcodes_answer/lab3_result/kern/mm/pmm.c#L472\" target=\"_blank\">pmm.c#L472</a> 应该是删除以前在这里的物理地址映射的意思&#xff0c;但是为什么能保证这里的数据是不再被使用的了呢&#xff1f;&#xff1f;</p>\n<p></p>\n<p>2&#xff0c;<a href=\"https://github.com/chyyuu/ucore_os_lab/blob/master/labcodes_answer/lab3_result/kern/mm/memlayout.h#L106\" target=\"_blank\">memlayout.h#L106</a> pra_vaddr成员表示的是该页对应的虚拟地址。当然也可以理解为在页换出时候方便的找到pte对他进行。但是就算没有pra&#xff0c;page数据结构不需要一个成员来表明他对应分虚拟地址吗&#xff1f;如果没有pra_vaddr成员&#xff0c;请问如何高效的得到该页对应的虚拟地址&#xff1f;</p>\n<p></p>\n<p>3&#xff0c;在哪儿指定了进程最大页数</p>"}, {"anon": "no", "uid": "j166z5vyA7y", "subject": "lab3 相关问题汇总", "created": "2019-05-15T11:38:55Z", "content": "<p>1&#xff0c;<a href=\"https://github.com/chyyuu/ucore_os_lab/blob/master/labcodes_answer/lab3_result/kern/mm/pmm.c#L472\" target=\"_blank\">pmm.c#L472</a> 应该是删除以前在这里的物理地址映射的意思&#xff0c;但是为什么能保证这里的数据是不再被使用的了呢&#xff1f;&#xff1f;</p>\n<p></p>\n<p>2&#xff0c;<a href=\"https://github.com/chyyuu/ucore_os_lab/blob/master/labcodes_answer/lab3_result/kern/mm/memlayout.h#L106\" target=\"_blank\">memlayout.h#L106</a> pra_vaddr成员表示的是该页对应的虚拟地址。当然也可以理解为在页换出时候方便的找到pte对他进行。但是就算没有pra&#xff0c;page数据结构不需要一个成员来表明他对应分虚拟地址吗&#xff1f;如果没有pra_vaddr成员&#xff0c;请问如何高效的得到该页对应的虚拟地址&#xff1f;</p>"}, {"anon": "no", "uid": "j166z5vyA7y", "subject": "lab3 相关问题汇总", "created": "2019-05-15T11:16:22Z", "content": "<p>1&#xff0c;<a href=\"https://github.com/chyyuu/ucore_os_lab/blob/master/labcodes_answer/lab3_result/kern/mm/pmm.c#L472\" target=\"_blank\">pmm.c#L472</a> 应该是删除以前在这里的物理地址映射的意思&#xff0c;但是为什么能保证这里的数据是不再被使用的了呢&#xff1f;&#xff1f;</p>\n<p></p>"}, {"anon": "no", "uid": "j166z5vyA7y", "subject": "lab3 相关问题汇总", "created": "2019-05-13T02:14:29Z", "content": "<p>1&#xff0c;<a href=\"https://github.com/chyyuu/ucore_os_lab/blob/master/labcodes_answer/lab3_result/kern/mm/pmm.c#L472\" target=\"_blank\">pmm.c#L472</a> 应该是删除以前在这里的物理地址映射的意思&#xff0c;但是为什么能保证这里的数据是不再被使用的了呢&#xff1f;&#xff1f;</p>\n<p></p>\n<p>2&#xff0c;<a href=\"https://github.com/chyyuu/ucore_os_lab/blob/master/labcodes_answer/lab3_result/kern/mm/swap.c#L120\" target=\"_blank\">swap.c#L120</a> 第三个参数ptr_result为什么设计成二级指针&#xff1f;感觉没什么意义啊。。。。</p>"}, {"anon": "no", "uid": "j166z5vyA7y", "subject": "lab3 相关问题汇总", "created": "2019-05-12T09:12:06Z", "content": "<p>1&#xff0c;<a href=\"https://github.com/chyyuu/ucore_os_lab/blob/master/labcodes_answer/lab3_result/kern/mm/pmm.c#L472\" target=\"_blank\">pmm.c#L472</a> 应该是删除以前在这里的物理地址映射的意思&#xff0c;但是为什么能保证这里的数据是不再被使用的了呢&#xff1f;&#xff1f;</p>"}], "type": "question", "tags": ["lab3", "student"], "tag_good": [], "unique_views": 148, "children": [{"folders": [], "data": {"embed_links": []}, "children": [], "created": "2019-05-18T04:53:43Z", "bucket_order": 3, "tag_endorse": [], "bucket_name": "Today", "id": "jvt1e0uymzy7fu", "history": [{"anon": "no", "uid": "jshne0q7ovz4n3", "subject": "", "created": "2019-05-18T04:53:43Z", "content": "<p>1. 删除地址映射的对象是<strong>页表</strong>&#xff0c;page有没有被使用是由它的reference count来决定的&#xff0c;这和您之前提出的 lab2 的一个问题是类似的&#xff0c;表明您没有理解 page_remove_pte 的功能是删除页表中的地址映射&#xff08;而页表操作是不干涉页本身的&#xff09;&#xff0c;只在发现一个页不被任何页表reference的时候才<strong>顺便做GC</strong>。</p>\n<p></p>\n<p>2. 我想您在 lab 2 写 get_pte 时也一定写过利用 page2pa 和 KADDR 从 page 得到 kernel va 的代码。ucore 里这么做似乎是可行的&#xff0c;但是我也没有仔细想过它在 lab 3 中是不是就失效了。</p>\n<p></p>\n<p>3. &#xff08;不保证正确&#xff09;截止到 lab 3 我们都还不知道什么是进程。另外也没有最大页数限制&#xff0c;如果你尝试一直申请新页&#xff0c;会一直成功直到 ENOMEM。</p>"}], "type": "s_answer", "tag_endorse_arr": [], "config": {}, "is_tag_endorse": false}], "tag_good_arr": [], "no_answer": 0, "id": "jvkpz7autx45xa", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 2, "num_favorites": 0, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169781215, "default_anonymity": "no"}, "error": null, "aid": "kyv0v1lrxm92q2"}