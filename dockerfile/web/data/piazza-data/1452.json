{"result": {"history_size": 1, "folders": ["lab1"], "nr": 1452, "data": {"embed_links": []}, "created": "2020-04-15T10:58:23Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "k27mp5ixxdk3u7", "data": "k9181nm73eq4zh", "v": "all", "type": "create", "when": "2020-04-15T10:58:23Z"}, {"anon": "stud", "data": "k9axprhu8vd87", "to": "k9181nm3ndy4zg", "type": "s_answer", "when": "2020-04-22T06:06:54Z", "uid_a": "a_0"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "k27mp5ixxdk3u7", "subject": "关于课程里提到的各种地址的疑惑", "created": "2020-04-15T10:58:23Z", "content": "<p>课程里提到了3种地址&#xff0c;逻辑地址、线性地址和物理地址。请问下面关于这三个地址的理解对吗&#xff1f;</p>\n<p>1、对于经过编译、汇编但是还没有链接的.o文件&#xff0c;用objdump -d显示出的最左边那列是逻辑地址&#xff1b;</p>\n<p>2、经过链接之后的ELF文件&#xff0c;用objdump -d显示出的最左边那列是线性地址&#xff0c;比如32为linux默认.text起始的这个地址0x08048000&#xff1b;</p>\n<p>3、线性地址经过分页机制转换后的地址。</p>\n<p>还有就是在链接生成bootbolck.o和kernel时&#xff0c;分别指定了程序入口点为0x7C00和0x100000&#xff0c;这个是这两段程序实际运行时的在内存中的物理地址吗&#xff1f;</p>\n<p>下面这张图里的地址是物理地址还是线性地址&#xff1f;</p>\n<p><img src=\"/img/1452-eb6b2f64f8b95807.jpg\" alt=\"\" /></p>"}], "type": "question", "tags": ["lab1", "student"], "tag_good": [], "unique_views": 130, "children": [{"history_size": 1, "folders": [], "data": {"embed_links": []}, "created": "2020-04-22T06:06:54Z", "bucket_order": 3, "tag_endorse": [{"role": "student", "name": "Shao Jiale", "endorser": {}, "admin": false, "photo": null, "id": "ky2q30oe6thki", "photo_url": null, "published": true, "us": false, "facebook_id": null}], "bucket_name": "Today", "history": [{"anon": "stud", "uid_a": "a_0", "subject": "", "created": "2020-04-22T06:06:54Z", "content": "<md>\n在x86里，逻辑地址是`segment selector : offset`，比如指令地址是`%cs:%eip`；线性地址是`base + offset`，其中`base`是segment selector对应到GDT里的段描述符指定的`base`字段；物理地址是物理内存中存储单位 (Byte) 的地址，在只有分段没有分页时等于线性地址，在开启分页后等于线性地址通过页表映射得到的地址。\n\n所以`objdump`得到的地址（虚拟地址）其实是逻辑地址的`offset`，比如`%cs`对应的段的`base`是`-0xC0000000`，虚拟地址`0xC0000010`对应的逻辑地址是`%cs : 0xC0000010`，通过分段机制转化成的线性地址是 `-0xC0000000+0xC0000010=0x00000010`，再通过分页机制查询页表中`0x00000010`映射的地址就得到了物理地址。当segment selector对应的`base`是0时，虚拟地址等于线性地址。\n\n但是在BIOS加载结束准备跳转到bootloader时还处在实模式，`base`并不是从GDT表中的段描述符得到的，而是segment selector直接左移4位，所以`0x7C00`这个地址其实是“虚拟地址”也即`offset`，对应到线性地址是`base + offset = 0x7C00`，其中`base`是0（被BIOS的`ljmp`设置），offset是`0x7C00`，因此也可以把它看作是线性地址。当然这时没有开启分页，这个线性地址也就是物理地址，所以`0x7C00`可以同时看作虚拟地址、线性地址、物理地址。\n\n至于图中uCore的`0x100000`，这张图其实就是线性地址空间，所以这个地址就是线性地址。如果对应的段基址是0，那么恰好这个地址也是物理地址。\n</md>"}], "type": "s_answer", "tag_endorse_arr": ["ky2q30oe6thki"], "children": [], "id": "k9axprhr1ii86", "config": {}, "is_tag_endorse": false}], "tag_good_arr": [], "no_answer": 0, "id": "k9181nm3ndy4zg", "config": {"seen": {"1248": 9, "1303": 6, "169": 4, "215": 5, "743": 8, "746": 1, "172": 7, "507": 3, "274": 2, "939": 0}}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 3, "num_favorites": 2, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643170091332, "default_anonymity": "no"}, "error": null, "aid": "kyv11ow4mecf7"}