{"result": {"history_size": 1, "folders": ["quiz7", "quiz5"], "nr": 352, "data": {"embed_links": []}, "created": "2015-04-26T07:40:20Z", "bucket_order": 3, "no_answer_followup": 1, "change_log": [{"uid": "i6sl02qfUgI", "anon": "no", "when": "2015-04-26T07:40:20Z", "data": "i8y5c061x0z7h5", "type": "create"}, {"to": "i8y5c05wdhb7h4", "uid": "hdjonbiyfs62ie", "anon": "no", "when": "2015-04-26T16:18:16Z", "data": "i8ynu25ko0w20q", "type": "i_answer"}, {"to": "i8y5c05wdhb7h4", "uid": "hdjonbiyfs62ie", "anon": "no", "when": "2015-04-26T16:19:38Z", "type": "followup"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "i6sl02qfUgI", "subject": "关于视频后选择题的几处疑问~", "created": "2015-04-26T07:40:20Z", "content": "<p>操作系统来维护一组队列&#xff0c;表示系统中所有进程的当前状态&#xff0c;有关管理进程的描述正确的是&#xff08;1,2&#xff09;<br />就绪态进程维护在进程就绪队列中<br />等待态进程维护在进程等待队列中<br />运行态进程维护在进程运行队列中<br />zombie态进程不在任何队列</p>\n<p>疑问&#xff1a;在ucore的实现中&#xff0c;似乎不区分就绪和运行&#xff0c;统一叫做runnable。只有一个proc_list&#xff0c;并没有维护等待列表&#xff0c;和zombile列表&#xff08;不知道是不是我代码看的不够仔细……&#xff09;。</p>\n<p>另外&#xff0c;这可能是不同操作系统不同带来的&#xff0c;所以想请问对于这些不同状态&#xff0c;哪些需要有队列&#xff0c;以及维护这些队列的目的是什么呢&#xff1f;<br /><br /><br />关于创建新进程的描述正确的是&#xff08;1,2,3,4&#xff09;<br />fork() 创建子进程中&#xff0c;会复制父进程的所有变量和内存<br />子进程的fork()返回0<br />父进程的fork()在创建子进程成功后&#xff0c;返回子进程标识符<br />fork() 创建子进程中&#xff0c;会复制父进程的页表 </p>\n<p>疑问&#xff1a;第四个选项&#xff0c;对于子进程和父进程来说&#xff0c;它具体的物理页是要复制的&#xff0c;是不同的。所以他们的页表项应该是不同的&#xff0c;那么为什么需要复制呢&#xff1f;</p>\n<p>是不是只应该为子进程新建页表&#xff1f;</p>"}], "type": "question", "tags": ["quiz5", "quiz7", "student"], "tag_good": [{"role": "instructor", "name": "Yong XIANG", "endorser": {}, "admin": true, "photo": null, "id": "hdjonbiyfs62ie", "photo_url": null, "us": false, "class_sections": ["课程设计_i5j09fnsl7k5x0", "清华学生_i5j09fnsl7k5x0", "所有老师和助教_i5j09fnsl7k5x0", "os2018spring_i5j09fnsl7k5x0"], "facebook_id": null}], "unique_views": 103, "children": [{"history_size": 1, "folders": [], "data": {"embed_links": []}, "created": "2015-04-26T16:18:16Z", "bucket_order": 3, "tag_endorse": [], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "", "created": "2015-04-26T16:18:16Z", "content": "<p>等待事件是一定要有自己的队列的。你可以看一下&#xff0c;进程的状态改为等待时的相关函数。</p>\n<p></p>\n<p>不同操作系统的队列会有所不同&#xff0c;但基本的原理是相同的。队列的多少与操作系统的进程状态划分是相关的。这个题目说的是&#xff0c;三状态进程模型的情况。ucore只分了两种状态&#xff0c;它的队列相对也简单一些。</p>\n<p></p>\n<p>fork的复制时页表的处理是比较复杂的。你的这个问题很好。由于使用不同的物理页面&#xff0c;用户地址空间的复制&#xff0c;页表肯定是要改的。对于内核空间&#xff0c;由于不同进程的共享的&#xff0c;这时只复制页表项&#xff0c;其他的内核空间是不用复制的。对x86-32系统的4KB页大小时&#xff0c;内核空间对应的二级页表项也是共享的&#xff0c;不用复制。</p>\n<p></p>\n<p>对这个问题的深入讨论有利于fork的内存空间复制理解。</p>"}], "type": "i_answer", "tag_endorse_arr": [], "children": [], "id": "i8ynu25gae320p", "config": {}, "is_tag_endorse": false}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>建议有兴趣的同学&#xff0c;在此详细地回复&#xff0c;ucore中到底哪些内容在fork时进行了复制&#xff1f;</p>", "created": "2015-04-26T16:19:38Z", "bucket_order": 335, "bucket_name": "Week 4/26 - 5/2", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i8ynvtivc6i2ht", "updated": "2015-04-26T16:19:38Z", "config": {}}], "tag_good_arr": ["hdjonbiyfs62ie"], "no_answer": 0, "id": "i8y5c05wdhb7h4", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 4, "num_favorites": 1, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643167665838, "default_anonymity": "no"}, "error": null, "aid": "kyuzlpda3im4zt"}