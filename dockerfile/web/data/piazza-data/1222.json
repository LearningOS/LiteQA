{"result": {"folders": ["lab7", "lecture19", "2018"], "nr": 1222, "data": {"embed_links": []}, "created": "2018-05-14T03:05:26Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "isycnlmpuv26l6", "data": "jh5o1g39zj61lg", "type": "create", "when": "2018-05-14T03:05:26Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "data": "jh5ojhcti6a1zk", "to": "jh5o1g36dog1lf", "type": "i_answer", "when": "2018-05-14T03:19:28Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "data": "jh5ojo4e8ic22f", "type": "update", "when": "2018-05-14T03:19:36Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "关于ucore中管程的next信号量问题", "created": "2018-05-14T03:19:36Z", "content": "<p>lab7中的管程monitor实现有一个信号量next&#xff0c;实际运行时&#xff0c;调用cond_signal函数的进程需要将自己睡眠在next信号量上&#xff0c;等待其他进程从管程中退出或调用cond_wait来唤醒next信号量&#xff0c;才能继续执行。</p>\n<p>mooc上的解释是管程中同时只能有一个进程运行&#xff0c;signal函数想要唤醒其他进程就必须让自己进入睡眠。但是信号量的up操作调用的是wakeup_proc来唤醒进程&#xff0c;这只会让proc-&gt;state = PROC_RUNNABLE;&#xff08;见sched.c&#xff09;&#xff0c;也就是说修改相关进程的状态为可运行&#xff0c;等待下一次调度。这也就是说&#xff0c;signal函数在唤醒等待条件变量的进程时并不会马上被调度&#xff0c;而是在下一次时钟中断引发的调度前仍然可以继续执行下面的内容。</p>\n<p>按照理论上管程与信号量的实现&#xff1a;</p>\n<p>wait(lock){</p>\n<p>    numWaiting&#43;&#43;;</p>\n<p>    add current thread t to q;</p>\n<p>    lock.unlock();</p>\n<p>    schedule();</p>\n<p>    lock.lock();</p>\n<p>}</p>\n<p></p>\n<p>signal(lock){</p>\n<p>    if (numWaiting &gt; 0){</p>\n<p>        remove first thread t from q;</p>\n<p>        wakeup(t);</p>\n<p>        numWaiting--;</p>\n<p>    }</p>\n<p>}</p>\n<p>假设进程A先调用cond_wait&#xff0c;进程B再调用cond_signal&#xff0c;此时虽然进程B唤醒了进程A&#xff0c;但A仅仅是处于RUNNABLE状态&#xff0c;并没有取得CPU使用权&#xff0c;B仍然可以从容地运行剩余代码。即使因为时钟中断调度到了A&#xff0c;由于此时管程的锁lock仍然被B持有&#xff0c;A的schedule的下一行lock.lock()对应的锁无法获得&#xff0c;依然不会引发互斥访问问题。</p>\n<p>综上&#xff0c;monitor中的next信号量似乎没有使用的必要&#xff0c;我猜测其最大的作用也许是为了让等待变量的进程第一时间被唤醒&#xff0c;而非经过一些时间后由正常调度唤醒&#xff1f;还烦请老师解释一下。</p>"}, {"anon": "no", "uid": "isycnlmpuv26l6", "subject": "关于ucore中管程的next信号量问题", "created": "2018-05-14T03:05:26Z", "content": "<p>lab7中的管程monitor实现有一个信号量next&#xff0c;实际运行时&#xff0c;调用cond_signal函数的进程需要将自己睡眠在next信号量上&#xff0c;等待其他进程从管程中退出或调用cond_wait来唤醒next信号量&#xff0c;才能继续执行。</p>\n<p>mooc上的解释是管程中同时只能有一个进程运行&#xff0c;signal函数想要唤醒其他进程就必须让自己进入睡眠。但是信号量的up操作调用的是wakeup_proc来唤醒进程&#xff0c;这只会让proc-&gt;state = PROC_RUNNABLE;&#xff08;见sched.c&#xff09;&#xff0c;也就是说修改相关进程的状态为可运行&#xff0c;等待下一次调度。这也就是说&#xff0c;signal函数在唤醒等待条件变量的进程时并不会马上被调度&#xff0c;而是在下一次时钟中断引发的调度前仍然可以继续执行下面的内容。</p>\n<p>按照理论上管程与信号量的实现&#xff1a;</p>\n<p>wait(lock){</p>\n<p>    numWaiting&#43;&#43;;</p>\n<p>    add current thread t to q;</p>\n<p>    lock.unlock();</p>\n<p>    schedule();</p>\n<p>    lock.lock();</p>\n<p>}</p>\n<p></p>\n<p>signal(lock){</p>\n<p>    if (numWaiting &gt; 0){</p>\n<p>        remove first thread t from q;</p>\n<p>        wakeup(t);</p>\n<p>        numWaiting--;</p>\n<p>    }</p>\n<p>}</p>\n<p>假设进程A先调用cond_wait&#xff0c;进程B再调用cond_signal&#xff0c;此时虽然进程B唤醒了进程A&#xff0c;但A仅仅是处于RUNNABLE状态&#xff0c;并没有取得CPU使用权&#xff0c;B仍然可以从容地运行剩余代码。即使因为时钟中断调度到了A&#xff0c;由于此时管程的锁lock仍然被B持有&#xff0c;A的schedule的下一行lock.lock()对应的锁无法获得&#xff0c;依然不会引发互斥访问问题。</p>\n<p>综上&#xff0c;monitor中的next信号量似乎没有使用的必要&#xff0c;我猜测其最大的作用也许是为了让等待变量的进程第一时间被唤醒&#xff0c;而非经过一些时间后由正常调度唤醒&#xff1f;还烦请老师解释一下。</p>"}], "type": "question", "tags": ["2018", "lab7", "lecture19", "student"], "tag_good": [], "unique_views": 152, "children": [{"folders": [], "data": {"embed_links": []}, "children": [], "created": "2018-05-14T03:19:28Z", "bucket_order": 3, "tag_endorse": [], "bucket_name": "Today", "id": "jh5ojhcmzgq1zj", "history": [{"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "", "created": "2018-05-14T03:19:28Z", "content": "<p>按hoare管程的定义&#xff0c;next的作用是优先于入口等待队列调度从条件变量的等待中唤醒的进程进入管程执行。你的描述“next的最大作用是为了让等待变量的进程第一时间被唤醒&#xff0c;而非经过一些时间后由正常调度唤醒”是对的。</p>\n<p></p>\n<p>下列与管程中next相关的贴子也可参考。</p>\n<p></p>\n<p><a href=\"https://www.piazza.com/class/i5j09fnsl7k5x0?cid=894\">https://piazza.com/class/i5j09fnsl7k5x0?cid=894</a></p>\n<p>管程的相关讨论</p>\n<p></p>\n<p><a href=\"https://www.piazza.com/class/i5j09fnsl7k5x0?cid=866\">https://piazza.com/class/i5j09fnsl7k5x0?cid=866</a></p>\n<p>关于ucore管程实现中next_count的想法</p>\n<p></p>"}], "type": "i_answer", "tag_endorse_arr": [], "config": {}, "is_tag_endorse": false}], "tag_good_arr": [], "no_answer": 0, "id": "jh5o1g36dog1lf", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 2, "num_favorites": 2, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169449414, "default_anonymity": "no"}, "error": null, "aid": "kyv0nxl2azw3oj"}