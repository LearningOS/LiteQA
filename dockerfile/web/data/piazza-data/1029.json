{"result": {"folders": ["2017", "lecture12"], "nr": 1029, "data": {"embed_links": []}, "created": "2017-04-01T02:50:18Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "ie7xxyhe7dp1jr", "data": "j0ynufcf57p3t9", "type": "create", "when": "2017-04-01T02:50:18Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "ie7xxyhe7dp1jr", "subject": "switch_to 是否有必要保存 eip", "created": "2017-04-01T02:50:18Z", "content": "<p></p><pre>// proc_run - make process &#34;proc&#34; running on cpu\n// NOTE: before call switch_to, should load  base addr of &#34;proc&#34;&#39;s new PDT\nvoid\nproc_run(struct proc_struct *proc) {\n    if (proc != current) {\n        bool intr_flag;\n        struct proc_struct *prev = current, *next = proc;\n        local_intr_save(intr_flag);\n        {\n            current = proc;\n            load_esp0(next-&gt;kstack &#43; KSTACKSIZE);<br />            // (1)\n            lcr3(next-&gt;cr3);\n            switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context));<br />            // (2)\n        }\n        local_intr_restore(intr_flag);\n    }\n}</pre>\n<p>在没仔细分析的情况下&#xff0c;粗略一看&#xff1a;似乎在进程切换的切换的时候&#xff0c;好像是永远会从上一个进程的 (1) 处进入上下文切换的过程 switch_to&#xff0c;切换完后&#xff0c;好像总会回下一个进程的 (2) 处&#xff0c;继续执行&#xff0c;因此似乎没有必要 eip。</p>\n<p></p>\n<p>但上面的分析是<strong>不对</strong>的&#xff0c;对于 fork 后的生成子进程</p>\n<p></p>\n<pre>// copy_thread - setup the trapframe on the  process&#39;s kernel stack top and\n//             - setup the kernel entry point and stack of process\nstatic void\ncopy_thread(struct proc_struct *proc, uintptr_t esp, struct trapframe *tf) {\n    proc-&gt;tf = (struct trapframe *)(proc-&gt;kstack &#43; KSTACKSIZE) - 1;\n    *(proc-&gt;tf) = *tf;\n    proc-&gt;tf-&gt;tf_regs.reg_eax = 0;\n    proc-&gt;tf-&gt;tf_esp = esp;\n    proc-&gt;tf-&gt;tf_eflags |= FL_IF;\n\n    proc-&gt;context.eip = (uintptr_t)forkret;\n    proc-&gt;context.esp = (uintptr_t)(proc-&gt;tf);\n}</pre>\n<p><br />会将其 context.eip 设置到 forkret。当从别的进程 A 切入刚 fork 好但还没跑过的子进程 B 时&#xff0c;会从前面的 A 进程的 (1) 处进入&#xff0c;随后不会返回 B 进程的 (2)&#xff0c;而是直接飞到 B 进程的 forkret&#xff0c;forkret 调用 forkrets&#xff0c;forkrets 假装是从中断中返回。根据 trap 帧的内容从中断返回后&#xff0c;就设置好了 fork 好的子进程的上下文&#xff0c;并开始执行了。<br /><br /><strong>可见&#xff0c;context.eip 对于 fork 后的新线程意义重大&#xff0c;不得不保存。</strong></p>\n<p></p>\n<p></p>"}], "type": "note", "tags": ["2017", "lecture12", "student"], "tag_good": [{"role": "student", "name": "Zhu Qi", "endorser": {}, "admin": false, "photo": null, "id": "ie7xy8gtpwk1t5", "photo_url": null, "published": true, "us": false, "facebook_id": null}, {"role": "student", "name": "王纪开", "endorser": {}, "admin": false, "photo": null, "id": "k6t2yt49jyo348", "photo_url": null, "us": false, "facebook_id": null}], "unique_views": 137, "children": [], "tag_good_arr": ["ie7xy8gtpwk1t5", "k6t2yt49jyo348"], "id": "j0ynufbkrxv3t8", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 4, "num_favorites": 0, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169001112, "default_anonymity": "no"}, "error": null, "aid": "kyv0ebo8f2p24o"}