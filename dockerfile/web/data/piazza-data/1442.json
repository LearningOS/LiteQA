{"result": {"folders": ["lecture12"], "nr": 1442, "data": {"embed_links": []}, "created": "2020-03-31T17:02:43Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "je2ib27z6a7691", "data": "k8g5gf4ro4o7kd", "type": "create", "when": "2020-03-31T17:02:43Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "je2ib27z6a7691", "subject": "第十二讲课后练习参考解答", "created": "2020-03-31T17:02:43Z", "content": "<md>## 题目描述\n\n在理解基于 python 的多处理机调度模拟器框架的基础上&#xff0c;选择并实现 O(1)、CFS 或 BFS 三种调度算法中的一个。可 &#xff12; 个人一组。\n\n* [框架代码](http://pages.cs.wisc.edu/~remzi/OSTEP/Homework/HW-Sched-MultiCPU.tgz)\n\n## 框架分析\n\n&gt; 2017011456\n\n### 执行流程&#xff1a;\n- &#96;handle_interrupts()&#96;: 产生时钟中断。如果当前执行时间是时间片的整数倍&#xff0c;那么需要对每个CPU进行中断处理&#xff0c;调用函数 &#96;handle_one_interrupt()&#96;。在&#96;handle_one_interrupt()&#96;函数中判断当前CPU是否在执行进程&#xff0c;如果是的话暂停当前进程的执行并把当前进程加入该CPU的待执行进程列表&#96;per_cpu_sched_queue&#96;的末尾。\n- &#96;steal_jobs()&#96;: 如果存在某个CPU的待执行进程列表为空&#xff0c;为了负载均衡&#xff0c;随机选择一个其它CPU&#xff0c;把它的某些待执行进程加入这个CPU中。这些进程需要满足的要求是未设置“亲和CPU(&#96;affinity&#96;)”或者“亲和CPU”中存在这个CPU。\n- &#96;assign_jobs()&#96;: 对所有CPU&#xff0c;如果处于等待状态 (&#96;STATE_IDLE&#96;)&#xff0c;那么调用&#96;get_job()&#96;函数分配一个进程。&#96;get_job()&#96;通过算法获取该CPU的待执行进程队列&#xff0c;框架中实现的算法为FIFO&#xff0c;因此在待执行进程队列中选取第一个进程&#xff0c;让该CPU的状态变为执行(&#96;STATE_RUNNIGN&#96;)&#xff0c;然后把所选进程移出待执行进程队列&#xff0c;执行该进程。\n- &#96;run_jobs()&#96;: 对于所有处于执行(&#96;STATE_RUNNIGN&#96;)状态的CPU&#xff0c;调用&#96;run_one_tick()&#96;函数执行一个时钟周期。执行过程中需要调用与cache相关的函数&#xff0c;还要判断是否进程是否被执行完。需要注意的是&#xff0c;如果判断进程执行完了&#xff0c;那么意味着进程在当前tick过后被执行完。对于执行完进程的CPU&#xff0c;切换其状态为等待。\n- 判断是否所有进程都被执行完了&#xff0c;如果是的话结束循环。循环期间可以控制一些参数来打印信息。\n\n### 多队列算法的初始化\n\n遍历所有进程和CPU&#xff0c;主要是进行亲和力的判断。如果不设置亲和力&#xff0c;有可能所有进程一开始都集中在某个CPU上。\n\n&#96;&#96;&#96;python\nfor cpu in range(num_cpus):\n    self.per_cpu_sched_queue[cpu] = []\n    # now assign jobs to these queues \n    jobs_not_assigned = list(self.job_name_list)\n    while len(jobs_not_assigned) &gt; 0:\n        for cpu in range(num_cpus):\n            assigned = False\n            for job_name in jobs_not_assigned:\n                if len(self.jobs[job_name].affinity) == 0 or cpu in self.jobs[job_name].affinity:\n                    self.per_cpu_sched_queue[cpu].append(job_name)\n                    jobs_not_assigned.remove(job_name)\n                    assigned = True\n                if assigned:\n                    break\n&#96;&#96;&#96;\n\n### 单队列和不同CPU多队列的实现\n框架中通过参数&#96;per_cpu_queues&#96;来选择是使用统一的单队列还是不同CPU多队列。如果选择前者&#xff0c;只需要使用Scheduler类的一个成员变量&#96;single_sched_queue&#96;&#xff0c;把所有进程加入其中&#xff0c;然后把它赋值给各个CPU的队列&#xff0c;即&#xff1a;\n&#96;&#96;&#96;Python\nself.single_sched_queue = []\nfor job_name in self.job_name_list:\n    self.single_sched_queue.append(job_name)\nfor cpu in range(num_cpus):\n    self.per_cpu_sched_queue[cpu] = self.single_sched_queue\n&#96;&#96;&#96;\n这样就能够使用统一的函数来实现这两种算法了。一些实现细节&#xff1a;\n- &#96;steal_jobs()&#96;中&#xff0c;如果使用单队列&#xff0c;则不作任何操作。\n- &#96;get_job()&#96;中&#xff0c;仍然对进程进行“亲和力”判断&#xff0c;这样就能防止单队列中一些进程不能够被放入某些CPU中。\n\n## O(1) 调度\n\n&gt; 2017013588\n&gt; https://git.tsinghua.edu.cn/wei10/os-course/tree/master/lec12-homework\n\n### 主要实现思路\n\n在原来的代码上&#xff0c;主要需要改以下几个地方&#xff1a;\n\n#### 优先级属性\n\n&#96;Job&#96;以及&#96;Scheduler&#96;的&#96;init&#96;中都需要增加新的一个&#96;priority&#96;属性&#xff0c;且由于&#96;priority&#96;应该能够变动&#xff0c;但由于Job为一个tuple无法修改数值&#xff0c;因此参考&#96;time_left&#96;&#xff0c;将其设置为一个list&#xff0c;每次改变的时候pop出原有的值&#xff0c;再append新的值\n\n#### queue队列、expired队列、bit array\n\n由于O(1)调度算法要求每一个cpu都有一个对应的bit array来标记&#96;sched_queue&#96;中是否有对应优先级的任务&#xff0c;因此需要增加一个bit array &#96;per_cpu_sched_queue_flag&#96;&#xff0c;为一个整数。\n\n&#96;sched_queue&#96;队列也要做出对应的更改&#xff0c;原先每个CPU都对应一个队列&#xff0c;但现在每个CPU的每个优先级都有一个队列。\n\n添加一个&#96;expired_queue&#96;&#xff0c;存放运行过的程序&#xff0c;并在全部CPU的&#96;sched_queue&#96;为空时进行交换。\n\n#### 中断处理\n\n原先的中断处理只需要将当前进程重新加入到队列中即可&#xff0c;但现在需要重新计算优先级&#xff08;具体实现中直接重新random了一个数值&#xff09;&#xff0c;然后将其加到对应优先级的&#96;expired_queue&#96;中。\n\n#### 获取任务\n\n先获得当前CPU所有任务中优先级最高的数值&#xff0c;然后到对应队列中拿一个任务出来执行&#xff0c;如果此时不再有该优先级的任务&#xff0c;则应该更新bit array对应位为0。\n\n#### 窃取任务\n\n整体思路和原代码没有太大差别&#xff0c;只不过针对由于队列结构的修改做出对应的访问修改而已。\n\n### 核心代码\n\n&#96;&#96;&#96;python\ndef handle_one_interrupt(self, interrupt, cpu):\n    # HANDLE: interrupts here, so jobs don&#39;t run an extra tick\n    if interrupt and self.sched_state[cpu] == self.STATE_RUNNING:\n        self.sched_state[cpu] = self.STATE_IDLE\n        job_name = self.sched_current[cpu]\n        job = self.jobs[job_name]\n        self.sched_current[cpu] = &#39;&#39;\n        # print_cpu(cpu, &#39;tick done for job %s&#39; % job_name)\n        if self.o1:\n            job.priority.pop()\n            job.priority.append(random.randint(0, PRIORITY_LEVELS - 1))\n            self.per_cpu_expired_queue[cpu][job.priority[0]].append(job_name)\n        else:\n            self.per_cpu_sched_queue[cpu].append(job_name)\n    return\n\ndef get_job(self, cpu, sched_queue):\n    # get next job?\n    if self.o1:\n        if self.per_cpu_sched_queue_flag[cpu] != 0:\n            prior = ffs(self.per_cpu_sched_queue_flag[cpu])\n            sched_queue = sched_queue[prior]\n            for job_index in range(len(sched_queue)):\n                job_name = sched_queue[job_index]\n                # len(affinity) == 0 is special case, which means ANY cpu is fine\n                if len(self.jobs[job_name].affinity) == 0 or cpu in self.jobs[job_name].affinity:\n                    # extract job from runqueue, put in CPU local structures\n                    sched_queue.pop(job_index)\n                    if len(sched_queue) == 0:\n                        self.per_cpu_sched_queue_flag[cpu] &amp;= ~(1 &lt;&lt; prior)\n                    self.sched_state[cpu] = self.STATE_RUNNING\n                    self.sched_current[cpu] = job_name\n                    self.caches[cpu].new_job(job_name)\n                    # print(&#39;got job %s&#39; % job_name)\n                    return\n        else:\n            flag = True\n            for cpu in range(self.num_cpus):\n                if self.per_cpu_sched_queue_flag[cpu] != 0:\n                    flag = False\n                    break\n            if flag:\n                self.per_cpu_expired_queue, self.per_cpu_sched_queue = self.per_cpu_sched_queue, self.per_cpu_expired_queue\n                for cpu in range(self.num_cpus):\n                    for i, q in enumerate(self.per_cpu_sched_queue[cpu]):\n                        if len(q) &gt; 0:\n                            self.per_cpu_sched_queue_flag[cpu] |= (1 &lt;&lt; i)\n\ndef steal_jobs(self):\n    if not self.per_cpu_queues or self.peek_interval &lt;= 0:\n        return\n\n    # if it is time to steal\n    if self.system_time &gt; 0 and self.system_time % self.peek_interval == 0:\n        for cpu in range(self.num_cpus):\n            if self.o1:\n                if self.per_cpu_sched_queue_flag[cpu] == 0:\n                    other_cpu_list = list(range(self.num_cpus))\n                    other_cpu_list.remove(cpu)\n                    other_cpu = random.choice(other_cpu_list)\n                    # print(&#39;cpu %d is idle&#39; % cpu)\n                    # print(&#39;-&gt; look at %d&#39; % other_cpu)\n\n                    for i, q in enumerate(self.per_cpu_sched_queue[other_cpu]):\n                        for job_name in q:\n                            # print(&#39;---&gt; examine job %s&#39; % job_name)\n                            if len(self.jobs[job_name].affinity) == 0 or cpu in self.jobs[job_name]:\n                                q.remove(job_name)\n                                self.per_cpu_sched_queue[cpu][i].append(job_name)\n                                self.per_cpu_sched_queue_flag[cpu] |= (1 &lt;&lt; i)\n                                # print(&#39;stole job %s from %d to %d&#39; % (job_name, other_cpu, cpu))\n                                return\n&#96;&#96;&#96;\n\n### 评价 \n\n基本与课件中的一致。\n\n## CFS 调度\n\n&gt; 2016011624\n&gt; https://git.tsinghua.edu.cn/longxm16/exercise\n\n### CFS 调度算法的实现\n\n首先为每一个 job 记录一个参数 vruntime&#xff0c;初始化为 0\n\n&#96;&#96;&#96;python\nself.jobs_vruntime = {}\nfor entry in job_list.split(&#39;,&#39;):\n    tmp = entry.split(&#39;:&#39;)\n    job_name, run_time, working_set_size = tmp[0], int(tmp[1]), int(tmp[2])\n    self.jobs_vruntime[job_name] = 0\n&#96;&#96;&#96;\n\n然后在每一个 tick 结束的时候&#xff0c;将对应 job 的 vruntime 加 1\n\n&#96;&#96;&#96;python\ndef run_one_tick(self, cpu):\n    job_name = self.sched_current[cpu]\n    job = self.jobs[job_name]\n    # change vruntime\n    job.vruntime &#43;= 1\n&#96;&#96;&#96;\n\n对应的&#xff0c;在 assign_jobs 时选择 vruntime 最小的 job 来执行\n这里仅仅作为算法的演示&#xff0c;就没有写红黑树来进行数据结构的维护&#xff0c;在每一次查找时直接使用 sort 来进行\n\n&#96;&#96;&#96;python\ndef get_job(self, cpu, sched_queue):\n    # 排序\n    sched_queue.sort(key=lambda x:(self.jobs_vruntime[x]))\n&#96;&#96;&#96;\n\n在每一次负载均衡处理时&#xff0c;按理说需要根据两边队列中 vruntime 最小值来修改被移动的进程的 vruntime 以适应新的队列。\n但是在本模拟器中&#xff0c;由于只有在队列为空的时候才会进行进程的移动&#xff0c;所以不需要进行该操作。\n此外&#xff0c;包括新进程的加入和进程的睡眠都不涉及&#xff0c;所以都不需要进行修改。\n\n### 评价 \n\n* 实现非常简洁&#xff0c;只需增加 4 行代码。\n* 未考虑优先级。\n\n## BFS 调度\n\n&gt; 2017011474\n&gt; 2016010103\n&gt; https://git.tsinghua.edu.cn/zhenglj17/operating-system-homework\n\n在多处理机调度模拟器框架的基础上&#xff0c;实现BFS调度算法。\n\n首先对框架进行了部分改动&#xff0c;&#96;Job&#96; 类増加了 &#96;prior_atio&#96;&#xff08;优先级&#xff09;和 &#96;deadline&#96;&#xff08;虚拟截止时间&#xff09;共两个参数。\n\n新建了一个 &#96;BFS&#96; 类&#xff0c;其中 &#96;flags&#96; 为标志位&#xff0c;&#96;lists&#96; 为每个优先级所对应的任务列表&#xff08;这里为了方便实现直接采用了 Python 内置的 List&#xff09;\n\n&#96;&#96;&#96;python\nclass BFS:\n    def __init__(self):\n        self.flags = 0\n        self.lists = []\n        for _ in range(103):\n            self.lists.append([])\n\n    def append(self, job_name, prior_atio):\n        self.flags |= 2 ** prior_atio\n        self.lists[prior_atio].append(job_name)\n\n    def remove(self, job_name, prior_atio):\n        self.lists[prior_atio].remove(job_name)\n        if len(self.lists[prior_atio]) == 0:\n            self.flags -= 2 ** prior_atio\n\n    def find_lsb(self):\n        if self.flags == 0:\n            return -1\n        return int(math.log(self.flags &amp; -self.flags) / math.log(2))\n&#96;&#96;&#96;\n\n对原框架中的 &#96;get_job&#96; 进行改动&#xff0c;改成多个 CPU 共享一排调度队列。首先查看 &#96;flags&#96; 是否有置位的比特&#xff0c;如果有多个则取最低位。选定了相应的 bit 位之后&#xff0c;便需要遍历其相应的子队列。假如是一个 Realtime 进程的子队列&#xff0c;则选取其中的第一个进程&#xff1b;如果是其他的队列&#xff0c;那么就采用 EEVDF(Earliest Eligible Virtual Deadline First) 算法来选取合适的进程&#xff0c;即比较队列中的每一个进程的 Virtual Deadline 值&#xff0c;并找到最小的那个&#xff0c;倘若在过程中发现某个进程的 Virtual Deadline 小于当前系统时间&#xff0c;则直接选中该进程并跳出遍历。\n\n### 核心代码\n\n&#96;&#96;&#96;python\ndef handle_one_interrupt(self, interrupt, cpu):\n    # HANDLE: interrupts here, so jobs don&#39;t run an extra tick\n    if interrupt and self.sched_state[cpu] == self.STATE_RUNNING:\n        self.sched_state[cpu] = self.STATE_IDLE\n        job_name = self.sched_current[cpu]\n        self.sched_current[cpu] = &#39;&#39;\n        # print_cpu(cpu, &#39;tick done for job %s&#39; % job_name)\n        self.jobs[job_name] = self.jobs[job_name]._replace(deadline = self.system_time &#43; (g[self.jobs[job_name].prior_atio] * self.time_slice))\n        # print(self.jobs[job_name])\n        # print(&#39;[CHECK: {} {}]&#39;.format(job_name, self.jobs[job_name].deadline))\n        self.single_sched_queue.append(job_name, self.jobs[job_name].prior_atio)\n    return\n\ndef get_job(self, cpu, sched_queue):\n    # get next job?\n\n    prior_atio = sched_queue.find_lsb()\n    if prior_atio == -1:\n        return\n    elif prior_atio &gt;= 100:\n        min_job_name = &#39;&#39;\n        for job_name in sched_queue.lists[prior_atio]:\n            if min_job_name == &#39;&#39; or self.jobs[job_name].deadline &lt; self.jobs[min_job_name].deadline:\n                min_job_name = job_name\n                if self.jobs[job_name].deadline &lt; self.system_time:\n                    break\n        if len(self.jobs[min_job_name].affinity) == 0 or cpu in self.jobs[min_job_name].affinity:\n            # extract job from runqueue, put in CPU local structures\n            sched_queue.remove(min_job_name, prior_atio)\n            self.sched_state[cpu] = self.STATE_RUNNING\n            self.sched_current[cpu] = min_job_name\n            self.caches[cpu].new_job(min_job_name)\n            # print(&#39;got job %s&#39; % min_job_name)\n            return\n    else:\n        job_name = sched_queue.lists[prior_atio][0]\n        if len(self.jobs[job_name].affinity) == 0 or cpu in self.jobs[job_name].affinity:\n            # extract job from runqueue, put in CPU local structures\n            sched_queue.remove(job_name, prior_atio)\n            self.sched_state[cpu] = self.STATE_RUNNING\n            self.sched_current[cpu] = job_name\n            self.caches[cpu].new_job(job_name)\n            # print(&#39;got job %s&#39; % job_name)\n            return\n    return\n&#96;&#96;&#96;\n\n### 评价\n\n* 实现了基于虚拟截止时间的调度&#xff0c;即 BFS 算法的核心思想。\n* 对 100 个实时优先级和 3 个 Isochronous、Normal、Idle 优先级进行了不同的处理。\n</md>"}], "type": "note", "tags": ["lecture12", "student"], "tag_good": [], "unique_views": 112, "children": [], "tag_good_arr": [], "id": "k8g5gf4oam37kc", "config": {"seen": {"33": 5, "1202": 7, "468": 1, "1230": 8, "1030": 0, "1074": 4, "1308": 2, "97": 9, "1071": 3, "1093": 6}}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 1, "num_favorites": 0, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643170054682, "default_anonymity": "no"}, "error": null, "aid": "kyv10wm2jeg3zq"}