{"result": {"history_size": 2, "folders": ["lecture18", "lecture19", "课堂问答"], "nr": 391, "data": {"embed_links": []}, "created": "2015-05-06T06:13:35Z", "bucket_order": 3, "no_answer_followup": 26, "change_log": [{"uid": "hdjonbiyfs62ie", "anon": "no", "when": "2015-05-06T06:13:35Z", "data": "i9ccmyc78dd3r3", "type": "create"}, {"to": "i9ccmyc49aa3r2", "uid": "i71i9b92nrr7n4", "anon": "no", "when": "2015-05-06T06:15:47Z", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "uid": "i6uunp7jxDb", "anon": "no", "when": "2015-05-06T06:17:51Z", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "uid": "i6rgda76fc66q4", "anon": "no", "when": "2015-05-06T06:20:04Z", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "uid": "i6uayov5SAo", "anon": "no", "when": "2015-05-06T06:20:08Z", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "uid": "i6ub691ffHe", "anon": "no", "when": "2015-05-06T06:20:37Z", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "uid": "i6t1w87gRBD", "anon": "no", "when": "2015-05-06T06:20:57Z", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "uid": "i6roqnlkmtw", "anon": "no", "when": "2015-05-06T06:22:03Z", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "uid": "hs2sszu8rbz6jj", "anon": "no", "when": "2015-05-06T06:22:21Z", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "uid": "i6s09f3xHOf", "anon": "no", "when": "2015-05-06T06:23:07Z", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "uid": "i6t6y9snjx2", "anon": "no", "when": "2015-05-06T06:23:33Z", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "uid": "i6rgda76fc66q4", "anon": "no", "when": "2015-05-06T06:24:18Z", "type": "feedback"}, {"to": "i9ccmyc49aa3r2", "uid": "i6vkh2uqu3V", "anon": "no", "when": "2015-05-06T06:34:28Z", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "uid": "i6uaz13iyeM", "anon": "no", "when": "2015-05-06T06:35:59Z", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "uid": "i7oaxkxhxjo3ui", "anon": "no", "when": "2015-05-06T06:48:39Z", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "uid": "i6tezdpdQbq", "anon": "no", "when": "2015-05-06T06:57:47Z", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "uid": "i71fykcui1h2je", "anon": "no", "when": "2015-05-06T07:00:58Z", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "uid": "i6un4iacNGX", "anon": "no", "when": "2015-05-06T07:03:28Z", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "uid": "i7bg4v1keqE", "anon": "no", "when": "2015-05-06T07:04:09Z", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "uid": "i71i9b92nrr7n4", "anon": "no", "when": "2015-05-06T07:04:17Z", "type": "feedback"}, {"to": "i9ccmyc49aa3r2", "uid": "i6uayl3vEOz", "anon": "no", "when": "2015-05-06T07:06:44Z", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "uid": "i6ut6cjo5lj4aa", "anon": "no", "when": "2015-05-06T07:07:23Z", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "uid": "i6roqnlkmtw", "anon": "no", "when": "2015-05-06T07:07:57Z", "type": "feedback"}, {"to": "i9ccmyc49aa3r2", "uid": "i718mp903qx", "anon": "no", "when": "2015-05-06T07:10:41Z", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "uid": "i6t76fg9sEh", "anon": "no", "when": "2015-05-06T07:19:04Z", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "uid": "i6sl02qfUgI", "anon": "no", "when": "2015-05-06T07:28:50Z", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "uid": "i6rtbanwzcm5t6", "anon": "no", "when": "2015-05-06T08:27:33Z", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "uid": "i6uteptdP5U", "anon": "no", "when": "2015-05-06T08:38:33Z", "type": "feedback"}, {"to": "i9ccmyc49aa3r2", "uid": "i6un4iacNGX", "anon": "no", "when": "2015-05-06T08:57:10Z", "type": "feedback"}, {"to": "i9ccmyc49aa3r2", "uid": "i6vkh2uqu3V", "anon": "no", "when": "2015-05-06T09:47:58Z", "type": "feedback"}, {"to": "i9ccmyc49aa3r2", "uid": "i6rgfjo5j1r6c", "anon": "no", "when": "2015-05-06T11:11:13Z", "type": "followup"}, {"to": "i9ccmyc49aa3r2", "uid": "i6t1w87gRBD", "anon": "no", "when": "2015-05-06T14:29:28Z", "type": "feedback"}, {"to": "i9ccmyc49aa3r2", "uid": "i6t6y9snjx2", "anon": "no", "when": "2015-05-06T14:58:50Z", "type": "feedback"}, {"to": "i9ccmyc49aa3r2", "uid": "i6t6y9snjx2", "anon": "no", "when": "2015-05-06T14:59:51Z", "type": "feedback"}, {"to": "i9ccmyc49aa3r2", "uid": "i6t6y9snjx2", "anon": "no", "when": "2015-05-06T15:00:22Z", "type": "feedback"}, {"to": "i9ccmyc49aa3r2", "uid": "i6vkh2uqu3V", "anon": "no", "when": "2015-05-11T05:41:19Z", "type": "feedback"}, {"to": "i9ccmyc49aa3r2", "uid": "hdjonbiyfs62ie", "anon": "no", "when": "2015-05-13T16:16:23Z", "type": "feedback"}, {"to": "i9ccmyc49aa3r2", "uid": "hdjonbiyfs62ie", "anon": "no", "when": "2015-05-13T16:19:14Z", "type": "feedback"}, {"to": "i9ccmyc49aa3r2", "uid": "i6t6y9snjx2", "anon": "no", "when": "2015-05-15T08:20:02Z", "type": "feedback"}, {"to": "i9ccmyc49aa3r2", "uid": "hdjonbiyfs62ie", "anon": "no", "when": "2015-05-15T15:06:11Z", "type": "feedback"}, {"uid": "hdjonbiyfs62ie", "anon": "no", "when": "2016-04-27T02:44:58Z", "data": "ini9dsn2yjb1xr", "type": "update"}, {"anon": "no", "uid": "izb0cbqbyzd6wf", "to": "i9ccmyc49aa3r2", "type": "followup", "when": "2017-04-28T07:39:03Z"}, {"anon": "no", "uid": "izb0cbkdd5s6w9", "to": "i9ccmyc49aa3r2", "type": "followup", "when": "2017-05-07T00:01:50Z"}, {"anon": "no", "uid": "izb0cbqbyzd6wf", "to": "i9ccmyc49aa3r2", "type": "feedback", "when": "2017-05-07T01:00:48Z"}, {"anon": "no", "uid": "isvxeq6bspf1vn", "to": "i9ccmyc49aa3r2", "type": "feedback", "when": "2018-05-08T00:55:18Z"}, {"anon": "no", "uid": "isvxeq6bspf1vn", "to": "i9ccmyc49aa3r2", "type": "feedback", "when": "2018-05-10T07:07:23Z"}, {"anon": "no", "uid": "isvxeq6bspf1vn", "to": "i9ccmyc49aa3r2", "type": "feedback", "when": "2018-05-10T09:28:04Z"}, {"anon": "no", "uid": "isvxeq6bspf1vn", "to": "i9ccmyc49aa3r2", "type": "feedback", "when": "2018-05-10T13:48:25Z"}, {"anon": "no", "uid": "isvxeq6bspf1vn", "to": "i9ccmyc49aa3r2", "type": "feedback", "when": "2018-05-10T16:07:38Z"}, {"anon": "no", "uid": "je2ib5nk89v6ca", "to": "i9ccmyc49aa3r2", "type": "feedback", "when": "2018-05-14T18:36:15Z"}, {"anon": "no", "uid": "isvxeq6bspf1vn", "to": "i9ccmyc49aa3r2", "type": "feedback", "when": "2018-05-15T00:31:33Z"}, {"anon": "no", "uid": "je2ib5nk89v6ca", "to": "i9ccmyc49aa3r2", "type": "feedback", "when": "2018-05-15T17:28:32Z"}, {"anon": "no", "uid": "je2ib5nk89v6ca", "to": "i9ccmyc49aa3r2", "type": "feedback", "when": "2018-05-15T17:34:58Z"}, {"anon": "no", "uid": "isvxeq6bspf1vn", "to": "i9ccmyc49aa3r2", "type": "feedback", "when": "2018-05-20T11:33:20Z"}, {"anon": "no", "uid": "isvxeq6bspf1vn", "to": "i9ccmyc49aa3r2", "type": "feedback", "when": "2018-05-20T12:27:56Z"}, {"anon": "no", "uid": "isvxeq6bspf1vn", "to": "i9ccmyc49aa3r2", "type": "feedback", "when": "2018-05-20T13:19:23Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "i9ccmyc49aa3r2", "type": "feedback", "when": "2018-05-21T02:30:50Z"}, {"anon": "no", "uid": "jsk4iwnsAnmZ", "to": "i9ccmyc49aa3r2", "type": "feedback", "when": "2019-05-05T15:50:18Z"}, {"anon": "no", "uid": "jsk4iwnsAnmZ", "to": "i9ccmyc49aa3r2", "type": "followup", "when": "2019-05-08T15:32:09Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "第18和19讲的课堂练习回答", "created": "2016-04-27T02:44:58Z", "content": "<p>下面链接列出了47个同步互斥问题。请每个同学在此回复自己的回答。</p>\n<p><a href=\"http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7\">http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7</a></p>\n<p></p>\n<p>题目要求见下面链接。</p>\n<p><a href=\"https://github.com/xuyongjiande/os_exercises/blob/master/all/07-3-lab7-spoc-discussion.md#%E5%B0%8F%E7%BB%84%E6%80%9D%E8%80%83%E9%A2%98\">https://github.com/xuyongjiande/os_exercises/blob/master/all/07-3-lab7-spoc-discussion.md#%E5%B0%8F%E7%BB%84%E6%80%9D%E8%80%83%E9%A2%98</a></p>\n<p></p>"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "第18和19讲的课堂练习回答", "created": "2015-05-06T06:13:35Z", "content": "<p>下面链接列出了47个同步互斥问题。请每个同学在此回复自己的回答。</p>\n<p><a href=\"http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7\">http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7</a></p>\n<p></p>\n<p>题目要求见下面链接。</p>\n<p><a href=\"https://github.com/xuyongjiande/os_exercises/blob/master/all/07-3-lab7-spoc-discussion.md#%E5%B0%8F%E7%BB%84%E6%80%9D%E8%80%83%E9%A2%98\">https://github.com/xuyongjiande/os_exercises/blob/master/all/07-3-lab7-spoc-discussion.md#%E5%B0%8F%E7%BB%84%E6%80%9D%E8%80%83%E9%A2%98</a></p>\n<p></p>"}], "type": "note", "tags": ["instructor-note", "lecture18", "lecture19", "课堂问答"], "tag_good": [], "unique_views": 489, "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>1. </p>\n<p>第一章(一)生产者一消费者问题(producer-consumerproblem)</p>\n<p>http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync0<br /><br />計22 梁锡豪　2012011290</p>", "created": "2015-05-06T06:15:47Z", "bucket_order": 351, "bucket_name": "Week 5/3 - 5/9", "type": "followup", "tag_good": [], "uid": "i71i9b92nrr7n4", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>Source Code</p>\n<p></p>\n<pre>#include &lt;stdio.h&gt;\n#include &lt;pthread.h&gt;\n#include &lt;semaphore.h&gt;\n#include &lt;cstring&gt;\n#include &lt;unistd.h&gt;\n#include &lt;string&gt;\n#include &lt;cstdlib&gt;\n\nusing namespace std;\n\n#define BUFFER_SIZE 2\n#define SLEEP_SPAN 5\n#define WORK_SPAN 4\n\nint iflag = 0;\nint oflag = 0;\nsem_t empty, full, mutex;\nint empty_count, full_count;\nint data_num = 0;\nint num = 0;\n\nint buffer[BUFFER_SIZE] = {};\n\nint p_task_done = -1;\nint c_task_done = -1;\t\n\nstruct arg_struct{\n\targ_struct(int _id, int _start, int _work, string _indent): id(_id), start(_start), work(_work), indent(_indent){}\n\targ_struct(int _id): id(_id), start(0), work(0), indent(string(&#34;&#34;)){}\n\tint id;\n\tint start;\n\tint work;\n\tstring indent;\t\n};\n\nvoid* producer(void* argv){\n\targ_struct arg = *(arg_struct*)argv;\n\tint id = arg.id;\n\tconst char* indent = arg.indent.c_str();\n\n\tsleep(arg.start);\n\n\t//printf(&#34;Producer %d waiting for EMPTY: %d\\n&#34;, id, empty_count);\n\tprintf(&#34;%sSTART\\n&#34;, indent);\n\n\tsem_wait(&amp;empty);\n\t//printf(&#34;Producer %d Waiting for MUTEX\\n&#34;, id);\n\tprintf(&#34;%saEMPTY\\n&#34;, indent);\n\n\tsem_wait(&amp;mutex);\n\t//printf(&#34;Producer %d entered Critical\\n&#34;, id);\n\tprintf(&#34;%saMUTEX\\n&#34;, indent);\n\n\tprintf(&#34;%sENTER\\n&#34;, indent);\t\n\t\n\tint time = rand()%SLEEP_SPAN;\n\t//sleep(time);\n\tsleep(arg.work);\n\n\tp_task_done&#43;&#43;;\n\t//printf(&#34;Producer %d Produced: %d\\n&#34;, id, p_task_done);\n\tprintf(&#34;%sProd %d\\n&#34;, indent, p_task_done);\n\n\tbuffer[iflag] = p_task_done;\n\n\tif (empty_count == 0) printf(&#34;Error: Produce while no empty\\n&#34;);\n\tiflag = (iflag &#43; 1) % BUFFER_SIZE;\n\tempty_count--;\n\tfull_count&#43;&#43;;\n\n\t//printf(&#34;Producer %d exited Critical\\n&#34;, id);\n\tprintf(&#34;%sEXIT\\n&#34;, indent);\n\t\n\tsem_post(&amp;mutex);\n\tprintf(&#34;%srMUTEX\\n&#34;, indent);\t\n\t//printf(&#34;Producer %d released MUTEX\\n&#34;, id);\n\n\tsem_post(&amp;full);\n\tprintf(&#34;%srFULL\\n&#34;, indent);\n\t//printf(&#34;Producer %d released FULL: %d\\n&#34;, id, full_count);\n\n\treturn NULL;\n}\n\nvoid* consumer(void* argv){\n\targ_struct arg = *(arg_struct*)argv;\n\tint id = arg.id;\n\tconst char* indent = arg.indent.c_str();\n\n\tsleep(arg.start);\n\n\t//printf(&#34;Consumer %d Waiting for FULL: %d\\n&#34;, id, full_count);\n\tprintf(&#34;%sSTART\\n&#34;, indent);\n\n\tsem_wait(&amp;full);\n\t//printf(&#34;Consumer %d Waiting for MUTEX\\n&#34;, id);\n\tprintf(&#34;%saFULL\\n&#34;, indent);\n\n\tsem_wait(&amp;mutex);\n\tprintf(&#34;%saMUTEX\\n&#34;, indent);\n\n\t//printf(&#34;Consumer %d entered Critical\\n&#34;, id);\n\tprintf(&#34;%sENTER\\n&#34;, indent);\t\n\n\tsleep(arg.work);\n\t\t\n\t&#43;&#43;c_task_done;\n\tif (full_count == 0) printf(&#34;Error: Consume while no full\\n&#34;);\n\n\tint tmp = buffer[oflag];\n\t//printf(&#34;Consumer %d consumed: %d\\n&#34;, id, tmp);\n\tprintf(&#34;%sCons %d\\n&#34;, indent, tmp);\t\n\n\toflag = (oflag &#43; 1) % BUFFER_SIZE;\n\tif (c_task_done != tmp) printf(&#34;Error: Consume data wrong\\n&#34;);\n\tif (c_task_done &gt; p_task_done) printf(&#34;Error: Over-consume!\\n&#34;);\n\n\tfull_count--;\n\tempty_count&#43;&#43;;\n\t\t\n\t//printf(&#34;Consumer %d exited Critical\\n&#34;, id);\n\tprintf(&#34;%sEXIT\\n&#34;, indent);\n\t\n\tsem_post(&amp;mutex);\n\t//printf(&#34;Consumer %d released MUTEX\\n&#34;, id);\n\tprintf(&#34;%srMUTEX\\n&#34;, indent);\n\n\tsem_post(&amp;empty);\n\t//printf(&#34;Consumer %d released EMPTY: %d\\n&#34;, id, empty_count);\n\tprintf(&#34;%srEMPTY\\n&#34;, indent);\n\n\treturn NULL;\n}\n\nint main(int argc, char** argv) {\n\tsrand((unsigned)time(NULL));\n\n\tmemset(buffer, 0, sizeof(int) * BUFFER_SIZE);\n\n\tsem_init(&amp;mutex, 0, 1);\n\tsem_init(&amp;empty, 0, BUFFER_SIZE);\n\tsem_init(&amp;full, 0, 0);\n\n\tempty_count = BUFFER_SIZE;\n\tfull_count = 0;\n\n\t#define N 3\n\tpthread_t p_consumer[2 * N], p_producer[2 * N];\n\n\tint c_count = 0, p_count = 0;\n\n\t#define PRODUCER 0\n\t#define CONSUMER 1\n\n\t/* For managed creation of 2 * N threads */\n\n\t#define TEST1\n\n\t#ifdef TEST1\n\tint st_time = 0;\n\tint inst[2 * N][3] = {\n\t\t/* { Consumer or Producer to be create?, \n\t\t     When does it start to work after being created?, st_stime &#43;= N means it starts N seconcds later than the previous P/C\n\t\t     How long does it work after it enters critical zone? } */\n\t\t{CONSUMER, st_time &#43;= 0, rand()%WORK_SPAN}, \n\t\t{CONSUMER, st_time &#43;= 1, rand()%WORK_SPAN}, \n\t\t{CONSUMER, st_time &#43;= 0, rand()%WORK_SPAN}, \n\t\t{PRODUCER, st_time &#43;= 4, rand()%WORK_SPAN}, \n\t\t{PRODUCER, st_time &#43;= 0, rand()%WORK_SPAN}, \n\t\t{PRODUCER, st_time &#43;= 0, rand()%WORK_SPAN}\n\t};\n\t#else\n\tint inst[2 * N][3] = {\n\t\t{PRODUCER, st_time &#43;= 0, rand()%WORK_SPAN}, \n\t\t{PRODUCER, st_time &#43;= 1, rand()%WORK_SPAN}, \n\t\t{PRODUCER, st_time &#43;= 0, rand()%WORK_SPAN}, \n\t\t{CONSUMER, st_time &#43;= 4, rand()%WORK_SPAN}, \n\t\t{CONSUMER, st_time &#43;= 0, rand()%WORK_SPAN}, \n\t\t{CONSUMER, st_time &#43;= 0, rand()%WORK_SPAN}\n\t};\n\t#endif\n\n\t/* Print the first line */\n\tint tmp_c = 0, tmp_p = 0;\n\tfor (int i = 0; i &lt; 2 * N; i&#43;&#43;){\n\t\tif (inst[i][0] == PRODUCER){\n\t\t\tprintf(&#34;P%d\\t&#34;, tmp_p&#43;&#43;);\n\t\t} else if (inst[i][0] == CONSUMER){\n\t\t\tprintf(&#34;C%d\\t&#34;, tmp_c&#43;&#43;);\n\t\t}\n\t}\n\tprintf(&#34;\\n&#34;);\n\n\t/* Create Producers and Consumers according to $inst*/\n\tint rc;\n\tstring indent(&#34;&#34;);\n\tfor (int i = 0; i &lt; 2 * N; i&#43;&#43;){\n\t\tif (inst[i][0] == PRODUCER){\n\t\t\t//printf(&#34;Main: Producer %d created\\n&#34;, p_count);\n\t\t\trc = pthread_create(p_producer &#43; p_count, NULL, producer, new arg_struct(p_count, inst[i][1], inst[i][2], indent));\n\t\t\tif (rc) printf(&#34;ERROR\\n&#34;);\n\t\t\tp_count&#43;&#43;;\n\t\t} else if (inst[i][0] == CONSUMER){\n\t\t\t//printf(&#34;Main: Consumer %d created\\n&#34;, c_count);\n\t\t\trc = pthread_create(p_consumer &#43; c_count, NULL, consumer, new arg_struct(c_count, inst[i][1], inst[i][2], indent));\n\t\t\tif (rc) printf(&#34;ERROR\\n&#34;);\n\t\t\tc_count&#43;&#43;;\n\t\t}\n\t\tindent &#43;= &#39;\\t&#39;;\n\t}\n\n\t/* wait until every thread finishes*/\n\tfor (int i = 0; i &lt; p_count; i&#43;&#43;){\n\t\tpthread_join(p_producer[i], NULL);\n\t}\n\tfor (int i = 0; i &lt; c_count; i&#43;&#43;){\n\t\tpthread_join(p_consumer[i], NULL);\t\n\t}\n\n\treturn 0;\n}</pre>\n<p></p>\n<p>Output</p>\n<p></p>\n<pre>C0\tC1\tC2\tP0\tP1\tP2\t\nSTART\n\t\tSTART\n\tSTART\n\t\t\tSTART\n\t\t\taEMPTY\n\t\t\taMUTEX\n\t\t\tENTER\n\t\t\t\tSTART\n\t\t\t\taEMPTY\n\t\t\t\t\tSTART\n\t\t\tProd 0\n\t\t\tEXIT\n\t\t\trMUTEX\n\t\t\trFULL\n\t\t\t\taMUTEX\n\t\t\t\tENTER\naFULL\n\t\t\t\tProd 1\n\t\t\t\tEXIT\n\t\t\t\trMUTEX\n\t\t\t\trFULL\naMUTEX\nENTER\n\t\taFULL\nCons 0\nEXIT\nrMUTEX\nrEMPTY\n\t\taMUTEX\n\t\tENTER\n\t\t\t\t\taEMPTY\n\t\tCons 1\n\t\tEXIT\n\t\trMUTEX\n\t\trEMPTY\n\t\t\t\t\taMUTEX\n\t\t\t\t\tENTER\n\t\t\t\t\tProd 2\n\t\t\t\t\tEXIT\n\t\t\t\t\trMUTEX\n\t\t\t\t\trFULL\n\taFULL\n\taMUTEX\n\tENTER\n\tCons 2\n\tEXIT\n\trMUTEX\n\trEMPTY</pre>\n<p></p>", "created": "2015-05-06T07:04:17Z", "bucket_order": 351, "bucket_name": "Week 5/3 - 5/9", "type": "feedback", "tag_good": [], "uid": "i71i9b92nrr7n4", "children": [], "tag_good_arr": [], "id": "i9ceg5ptdnh6ml", "updated": "2015-05-06T07:04:17Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p><p>在 2015年5月14日&#xff0c;上午12:15&#xff0c;xyong &lt;xyong&#64;mail.tsinghua.edu.cn&gt; 写道&#xff1a;</p>\n<p>梁锡豪&#xff0c;你好&#xff01;</p>\n<p></p>\n<p>你的邮件中没有附件。我认为目前的代码与我的期望是一致的。如果能再加点儿注释就更好了。</p>\n<p></p>\n<p>请把你的输出放在piazza上&#xff0c;并更新代码&#xff08;我在piazza上的代码中没有看到TEST相关的代码&#xff09;。</p>\n<p></p>\n<p><a href=\"https://www.piazza.com/class/i5j09fnsl7k5x0?cid=391\">https://piazza.com/class/i5j09fnsl7k5x0?cid=391</a></p>\n<p></p>\n<p>--向勇</p>\n<p></p>\n<p>在 2015年5月13日&#xff0c;下午4:25&#xff0c;Sek Hou Leong &lt;<a href=\"mailto:sekhou64&#64;hotmail.com\">sekhou64&#64;hotmail.com</a>&gt; 写道&#xff1a;</p>\n<p>向老师你好, </p>\n<p></p>\n<p>我是操作系统课上的学生梁锡豪, 附件是生产者-消费者问题的测试代码(main.cpp), 可执得档案(main) [linux下生成], 以及输出样例(out.txt).</p>\n<p><br /></p>\n<p>1) 代码已经修改, 更方便人为设置各进程的运行参数(开始时间, 临界区停留时间)</p>\n<p>2) 输出格式已经修改, 形如表格, 各进程进度的时间关系更一目了然</p>\n<p>3) 预设两组测试样例, 分别使得 i)消费者等待生产者, ii)生产者等待空BUFFER, 透过对#define TEST1控制</p>\n<p><br /></p>\n<p>在ubuntu bash下的编译/执行命令为</p>\n<p>g&#43;&#43; main.cpp -o main -pthread</p>\n<p>./main</p>\n<p></p>\n<p>未知是否需要进一步修改, 请查收.<br /></p>\n<p></p>\n<p></p>\n<p></p>\n<p>祝<br /></p>\n<p>工作顺利</p>\n<p><br /></p>\n<p>学生</p>\n<p>梁锡豪</p>", "created": "2015-05-13T16:16:23Z", "bucket_order": 350, "bucket_name": "Week 5/10 - 5/16", "type": "feedback", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [], "tag_good_arr": [], "id": "i9my94xkhfqu4", "updated": "2015-05-13T16:16:23Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>一些同学的进程同步算法没有很好地进行测试。建议这些同学参考一下梁锡豪同学的算法实现和测试用例设计。对检查同步算法的正确很有必要。</p>", "created": "2015-05-13T16:19:14Z", "bucket_order": 350, "bucket_name": "Week 5/10 - 5/16", "type": "feedback", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [], "tag_good_arr": [], "id": "i9mycspv3l4v4", "updated": "2015-05-13T16:19:14Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>认真拜读了梁学长的代码&#xff0c;非常佩服&#xff0c;不过由于时间久远&#xff0c;梁学长当年使用的信号量机制 semaphore.h 库已经弃用了&#xff0c;在此给出最近比较流行的基于GCD的ios同步机制&#xff0c;以及运行结果</p>\n<pre>#include &lt;stdio.h&gt;\n#include &lt;pthread.h&gt;\n#include &lt;semaphore.h&gt;\n#include &lt;cstring&gt;\n#include &lt;unistd.h&gt;\n#include &lt;string&gt;\n#include &lt;cstdlib&gt;\n#include &lt;dispatch/dispatch.h&gt;\n\nusing namespace std;\n\n#define BUFFER_SIZE 2\n#define SLEEP_SPAN 5\n#define WORK_SPAN 4\n\nint iflag = 0;\nint oflag = 0;\n//sem_t empty, full, mutex;\ndispatch_semaphore_t mutex,empty,full;\nint empty_count, full_count;\nint data_num = 0;\nint num = 0;\n\nint buffer[BUFFER_SIZE] = {};\n\nint p_task_done = -1;\nint c_task_done = -1;\t\n\nstruct arg_struct{\n\targ_struct(int _id, int _start, int _work, string _indent): id(_id), start(_start), work(_work), indent(_indent){}\n\targ_struct(int _id): id(_id), start(0), work(0), indent(string(&#34;&#34;)){}\n\tint id;\n\tint start;\n\tint work;\n\tstring indent;\t\n};\n\nvoid* producer(void* argv){\n\targ_struct arg = *(arg_struct*)argv;\n\tint id = arg.id;\n\tconst char* indent = arg.indent.c_str();\n\n\tsleep(arg.start);\n\n\t//printf(&#34;Producer %d waiting for EMPTY: %d\\n&#34;, id, empty_count);\n\tprintf(&#34;%sSTART\\n&#34;, indent);\n    \n    //sem_wait(&amp;empty);\n    dispatch_semaphore_wait(empty, DISPATCH_TIME_FOREVER);\n\t\n    //printf(&#34;Producer %d Waiting for MUTEX\\n&#34;, id);\n\tprintf(&#34;%saEMPTY\\n&#34;, indent);\n\n\t//sem_wait(&amp;mutex);\n    dispatch_semaphore_wait(mutex, DISPATCH_TIME_FOREVER);\n\t//printf(&#34;Producer %d entered Critical\\n&#34;, id);\n\tprintf(&#34;%saMUTEX\\n&#34;, indent);\n\n\tprintf(&#34;%sENTER\\n&#34;, indent);\n\t\n\tint time = rand()%SLEEP_SPAN;\n\t//sleep(time);\n\tsleep(arg.work);\n\n\tp_task_done&#43;&#43;;\n\t//printf(&#34;Producer %d Produced: %d\\n&#34;, id, p_task_done);\n\tprintf(&#34;%sProd %d\\n&#34;, indent, p_task_done);\n\n\tbuffer[iflag] = p_task_done;\n\n\tif (empty_count == 0) printf(&#34;Error: Produce while no empty\\n&#34;);\n\tiflag = (iflag &#43; 1) % BUFFER_SIZE;\n\tempty_count--;\n\tfull_count&#43;&#43;;\n\n\t//printf(&#34;Producer %d exited Critical\\n&#34;, id);\n\tprintf(&#34;%sEXIT\\n&#34;, indent);\n\t\n    //sem_post(&amp;mutex);\n    dispatch_semaphore_signal(mutex);\n\tprintf(&#34;%srMUTEX\\n&#34;, indent);\t\n\t//printf(&#34;Producer %d released MUTEX\\n&#34;, id);\n\n    //sem_post(&amp;full);\n\tdispatch_semaphore_signal(full);\n\tprintf(&#34;%srFULL\\n&#34;, indent);\n\t//printf(&#34;Producer %d released FULL: %d\\n&#34;, id, full_count);\n\n\treturn NULL;\n}\n\nvoid* consumer(void* argv){\n\targ_struct arg = *(arg_struct*)argv;\n\tint id = arg.id;\n\tconst char* indent = arg.indent.c_str();\n\n\tsleep(arg.start);\n    \n\t//printf(&#34;Consumer %d Waiting for FULL: %d\\n&#34;, id, full_count);\n\tprintf(&#34;%sSTART\\n&#34;, indent);\n\n\t//sem_wait(&amp;full);\n\tdispatch_semaphore_wait(full, DISPATCH_TIME_FOREVER);\n    \n    //printf(&#34;Consumer %d Waiting for MUTEX\\n&#34;, id);\n\tprintf(&#34;%saFULL\\n&#34;, indent);\n\n\t//sem_wait(&amp;mutex);\n\tdispatch_semaphore_wait(mutex, DISPATCH_TIME_FOREVER);\n    \n    printf(&#34;%saMUTEX\\n&#34;, indent);\n\n\t//printf(&#34;Consumer %d entered Critical\\n&#34;, id);\n\tprintf(&#34;%sENTER\\n&#34;, indent);\t\n\n\tsleep(arg.work);\n\t\t\n\t&#43;&#43;c_task_done;\n\tif (full_count == 0) printf(&#34;Error: Consume while no full\\n&#34;);\n\n\tint tmp = buffer[oflag];\n\t//printf(&#34;Consumer %d consumed: %d\\n&#34;, id, tmp);\n\tprintf(&#34;%sCons %d\\n&#34;, indent, tmp);\t\n\n\toflag = (oflag &#43; 1) % BUFFER_SIZE;\n\tif (c_task_done != tmp) printf(&#34;Error: Consume data wrong\\n&#34;);\n\tif (c_task_done &gt; p_task_done) printf(&#34;Error: Over-consume!\\n&#34;);\n\n\tfull_count--;\n\tempty_count&#43;&#43;;\n\t\t\n\t//printf(&#34;Consumer %d exited Critical\\n&#34;, id);\n\tprintf(&#34;%sEXIT\\n&#34;, indent);\n\t\n\t//sem_post(&amp;mutex);\n\tdispatch_semaphore_signal(mutex);\n    \n    //printf(&#34;Consumer %d released MUTEX\\n&#34;, id);\n\tprintf(&#34;%srMUTEX\\n&#34;, indent);\n\n\t//sem_post(&amp;empty);\n\tdispatch_semaphore_signal(empty);\n    \n    //printf(&#34;Consumer %d released EMPTY: %d\\n&#34;, id, empty_count);\n\tprintf(&#34;%srEMPTY\\n&#34;, indent);\n\n\treturn NULL;\n}\n\nint main(int argc, char** argv) {\n\tsrand((unsigned)time(NULL));\n\n\tmemset(buffer, 0, sizeof(int) * BUFFER_SIZE);\n\n//\tsem_open(&amp;mutex, 0, 1);\n//\tsem_open(&amp;empty, 0, BUFFER_SIZE);\n//\tsem_open(&amp;full, 0, 0);\n    \n    mutex = dispatch_semaphore_create(1);\n    empty = dispatch_semaphore_create(BUFFER_SIZE);\n    full  = dispatch_semaphore_create(0);\n    \n\tempty_count = BUFFER_SIZE;\n\tfull_count = 0;\n\n\t#define N 3\n\tpthread_t p_consumer[2 * N], p_producer[2 * N];\n\n\tint c_count = 0, p_count = 0;\n\n\t#define PRODUCER 0\n\t#define CONSUMER 1\n\n\t/* For managed creation of 2 * N threads */\n\n\t#define TEST1\n\n\t#ifdef TEST1\n\tint st_time = 0;\n\tint inst[2 * N][3] = {\n\t\t/* { Consumer or Producer to be create?, \n\t\t     When does it start to work after being created?, st_stime &#43;= N means it starts N seconcds later than the previous P/C\n\t\t     How long does it work after it enters critical zone? } */\n\t\t{CONSUMER, st_time &#43;= 0, rand()%WORK_SPAN}, \n\t\t{CONSUMER, st_time &#43;= 1, rand()%WORK_SPAN}, \n\t\t{CONSUMER, st_time &#43;= 0, rand()%WORK_SPAN}, \n\t\t{PRODUCER, st_time &#43;= 4, rand()%WORK_SPAN}, \n\t\t{PRODUCER, st_time &#43;= 0, rand()%WORK_SPAN}, \n\t\t{PRODUCER, st_time &#43;= 0, rand()%WORK_SPAN}\n\t};\n\t#else\n\tint inst[2 * N][3] = {\n\t\t{PRODUCER, st_time &#43;= 0, rand()%WORK_SPAN}, \n\t\t{PRODUCER, st_time &#43;= 1, rand()%WORK_SPAN}, \n\t\t{PRODUCER, st_time &#43;= 0, rand()%WORK_SPAN}, \n\t\t{CONSUMER, st_time &#43;= 4, rand()%WORK_SPAN}, \n\t\t{CONSUMER, st_time &#43;= 0, rand()%WORK_SPAN}, \n\t\t{CONSUMER, st_time &#43;= 0, rand()%WORK_SPAN}\n\t};\n\t#endif\n\n\t/* Print the first line */\n\tint tmp_c = 0, tmp_p = 0;\n\tfor (int i = 0; i &lt; 2 * N; i&#43;&#43;){\n\t\tif (inst[i][0] == PRODUCER){\n\t\t\tprintf(&#34;P%d\\t&#34;, tmp_p&#43;&#43;);\n\t\t} else if (inst[i][0] == CONSUMER){\n\t\t\tprintf(&#34;C%d\\t&#34;, tmp_c&#43;&#43;);\n\t\t}\n\t}\n\tprintf(&#34;\\n&#34;);\n\n\t/* Create Producers and Consumers according to $inst*/\n\tint rc;\n\tstring indent(&#34;&#34;);\n\tfor (int i = 0; i &lt; 2 * N; i&#43;&#43;){\n\t\tif (inst[i][0] == PRODUCER){\n\t\t\t//printf(&#34;Main: Producer %d created\\n&#34;, p_count);\n\t\t\trc = pthread_create(p_producer &#43; p_count, NULL, producer, new arg_struct(p_count, inst[i][1], inst[i][2], indent));\n\t\t\tif (rc) printf(&#34;ERROR\\n&#34;);\n\t\t\tp_count&#43;&#43;;\n\t\t} else if (inst[i][0] == CONSUMER){\n\t\t\t//printf(&#34;Main: Consumer %d created\\n&#34;, c_count);\n\t\t\trc = pthread_create(p_consumer &#43; c_count, NULL, consumer, new arg_struct(c_count, inst[i][1], inst[i][2], indent));\n\t\t\tif (rc) printf(&#34;ERROR\\n&#34;);\n\t\t\tc_count&#43;&#43;;\n\t\t}\n\t\tindent &#43;= &#39;\\t&#39;;\n\t}\n\n\t/* wait until every thread finishes*/\n\tfor (int i = 0; i &lt; p_count; i&#43;&#43;){\n\t\tpthread_join(p_producer[i], NULL);\n\t}\n\tfor (int i = 0; i &lt; c_count; i&#43;&#43;){\n\t\tpthread_join(p_consumer[i], NULL);\t\n\t}\n\n\treturn 0;\n}</pre>\n<p>在mac上的运行结果如下&#xff1a;</p>\n<p><img src=\"/img/391-e5c644857bac6e44.png\" alt=\"\" /></p>", "created": "2018-05-10T07:07:23Z", "bucket_order": 194, "bucket_name": "Week 5/6 - 5/12", "type": "feedback", "tag_good": [], "uid": "isvxeq6bspf1vn", "children": [], "tag_good_arr": [], "id": "jh06x6ajlnu1y4", "updated": "2018-05-10T07:07:23Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>下面是该问题的管程实现&#xff1a;</p>\n<pre>#include &lt;stdio.h&gt;\n#include &lt;pthread.h&gt;\n#include &lt;semaphore.h&gt;\n#include &lt;cstring&gt;\n#include &lt;unistd.h&gt;\n#include &lt;string&gt;\n#include &lt;cstdlib&gt;\n#include &lt;dispatch/dispatch.h&gt;\n\n\nusing namespace std;\n\n#define BUFFER_SIZE 2\n#define SLEEP_SPAN 5\n#define WORK_SPAN 4\n\n\n\nint buffer[BUFFER_SIZE] = {};\nint g_write_index = 0;\nint g_read_index = 0;\n\npthread_mutex_t lock;\npthread_cond_t consume_cond, produce_cond;\n\nint p_task_done = -1;\nint c_task_done = 1;\nint empty_count, full_count;\nint data_num = 0;\nint num = 0;\n\nstruct arg_struct{\n    arg_struct(int _id, int _start, int _work, string _indent): id(_id), start(_start), work(_work), indent(_indent){}\n    arg_struct(int _id): id(_id), start(0), work(0), indent(string(&#34;&#34;)){}\n    int id;\n    int start;\n    int work;\n    string indent;\n};\n\n\nvoid * produce(void * argv){\n    arg_struct arg = *(arg_struct*) argv;\n    int id = arg.id;\n    const char* indent = arg.indent.c_str();\n    \n    sleep(arg.start);\n    \n    printf(&#34;%sSTART\\n&#34;, indent);\n    \n    pthread_mutex_lock(&amp;lock);\n    printf(&#34;%saMUTEX\\n&#34;, indent);\n    bool first = true;\n    while((g_write_index &#43; 1) % BUFFER_SIZE == g_read_index){\n        if (first){\n            printf(&#34;%sWAIT\\n&#34;,indent);\n            first = false;\n        }\n        pthread_cond_wait(&amp;produce_cond, &amp;lock);\n    }\n    \n    printf(&#34;%ssPRO%d\\n&#34;, indent, g_write_index);\n    \n    sleep(arg.work);\n    p_task_done&#43;&#43;;\n    buffer[g_write_index] = p_task_done;\n    empty_count--;\n    full_count&#43;&#43;;\n    printf(&#34;%sePRO%d\\n&#34;,indent, g_write_index);\n    g_write_index = (g_write_index &#43; 1) % BUFFER_SIZE;\n    \n    pthread_cond_signal(&amp;consume_cond);\n    \n    pthread_mutex_unlock(&amp;lock);\n    printf(&#34;%srMUTEX\\n&#34;,indent);\n    return NULL;\n}\n\nvoid * consume(void * argv){\n    arg_struct arg = *(arg_struct*) argv;\n    int id = arg.id;\n    const char* indent = arg.indent.c_str();\n    \n    sleep(arg.start);\n    \n    printf(&#34;%sSTART\\n&#34;, indent);\n    \n    pthread_mutex_lock(&amp;lock);\n    printf(&#34;%saMUTEX\\n&#34;, indent);\n    bool first = true;\n    while(g_read_index == g_write_index){\n        if (first){\n            printf(&#34;%sWAIT\\n&#34;,indent);\n            first = false;\n        }\n        pthread_cond_wait(&amp;consume_cond, &amp;lock);\n    }\n    \n    printf(&#34;%ssCON%d\\n&#34;, indent, g_read_index);\n    sleep(arg.work);\n    c_task_done&#43;&#43;;\n    buffer[g_read_index] = c_task_done;\n    printf(&#34;%seCON%d\\n&#34;,indent, g_read_index);\n    g_read_index = (g_read_index &#43; 1) % BUFFER_SIZE;\n    empty_count--;\n    full_count&#43;&#43;;\n    \n    pthread_cond_signal(&amp;produce_cond);\n    pthread_mutex_unlock(&amp;lock);\n    printf(&#34;%srMUTEX\\n&#34;,indent);\n    return NULL;\n}\n\nint main(int argc, char** argv) {\n    srand((unsigned)time(NULL));\n    \n    memset(buffer, 0, sizeof(int) * BUFFER_SIZE);\n    \n    //    sem_open(&amp;mutex, 0, 1);\n    //    sem_open(&amp;empty, 0, BUFFER_SIZE);\n    //    sem_open(&amp;full, 0, 0);\n    \n    //mutex = dispatch_semaphore_create(1);\n    //empty = dispatch_semaphore_create(BUFFER_SIZE);\n    //full  = dispatch_semaphore_create(0);\n    \n    pthread_cond_init(&amp;consume_cond, 0);\n    pthread_cond_init(&amp;produce_cond, 0);\n    pthread_mutex_init(&amp;lock, 0);\n    \n    empty_count = BUFFER_SIZE;\n    full_count = 0;\n    \n#define N 3\n    pthread_t p_consumer[2 * N], p_producer[2 * N];\n    \n    int c_count = 0, p_count = 0;\n    \n#define PRODUCER 0\n#define CONSUMER 1\n    \n    /* For managed creation of 2 * N threads */\n    \n#define TEST1\n    \n#ifdef TEST1\n    int st_time = 0;\n    int inst[2 * N][3] = {\n        /* { Consumer or Producer to be create?,\n         When does it start to work after being created?, st_stime &#43;= N means it starts N seconcds later than the previous P/C\n         How long does it work after it enters critical zone? } */\n        {CONSUMER, st_time &#43;= 0, rand()%WORK_SPAN},\n        {CONSUMER, st_time &#43;= 1, rand()%WORK_SPAN},\n        {CONSUMER, st_time &#43;= 0, rand()%WORK_SPAN},\n        {PRODUCER, st_time &#43;= 4, rand()%WORK_SPAN},\n        {PRODUCER, st_time &#43;= 0, rand()%WORK_SPAN},\n        {PRODUCER, st_time &#43;= 0, rand()%WORK_SPAN}\n    };\n#else\n    int inst[2 * N][3] = {\n        {PRODUCER, st_time &#43;= 0, rand()%WORK_SPAN},\n        {PRODUCER, st_time &#43;= 1, rand()%WORK_SPAN},\n        {PRODUCER, st_time &#43;= 0, rand()%WORK_SPAN},\n        {CONSUMER, st_time &#43;= 4, rand()%WORK_SPAN},\n        {CONSUMER, st_time &#43;= 0, rand()%WORK_SPAN},\n        {CONSUMER, st_time &#43;= 0, rand()%WORK_SPAN}\n    };\n#endif\n    \n    /* Print the first line */\n    int tmp_c = 0, tmp_p = 0;\n    for (int i = 0; i &lt; 2 * N; i&#43;&#43;){\n        if (inst[i][0] == PRODUCER){\n            printf(&#34;P%d\\t&#34;, tmp_p&#43;&#43;);\n        } else if (inst[i][0] == CONSUMER){\n            printf(&#34;C%d\\t&#34;, tmp_c&#43;&#43;);\n        }\n    }\n    printf(&#34;\\n&#34;);\n    \n    /* Create Producers and Consumers according to $inst*/\n    int rc;\n    string indent(&#34;&#34;);\n    for (int i = 0; i &lt; 2 * N; i&#43;&#43;){\n        if (inst[i][0] == PRODUCER){\n            //printf(&#34;Main: Producer %d created\\n&#34;, p_count);\n            rc = pthread_create(p_producer &#43; p_count, NULL, produce, new arg_struct(p_count, inst[i][1], inst[i][2], indent));\n            if (rc) printf(&#34;ERROR\\n&#34;);\n            p_count&#43;&#43;;\n        } else if (inst[i][0] == CONSUMER){\n            //printf(&#34;Main: Consumer %d created\\n&#34;, c_count);\n            rc = pthread_create(p_consumer &#43; c_count, NULL, consume, new arg_struct(c_count, inst[i][1], inst[i][2], indent));\n            if (rc) printf(&#34;ERROR\\n&#34;);\n            c_count&#43;&#43;;\n        }\n        indent &#43;= &#39;\\t&#39;;\n    }\n    \n    /* wait until every thread finishes*/\n    for (int i = 0; i &lt; p_count; i&#43;&#43;){\n        pthread_join(p_producer[i], NULL);\n    }\n    for (int i = 0; i &lt; c_count; i&#43;&#43;){\n        pthread_join(p_consumer[i], NULL);\n    }\n    \n    return 0;\n}</pre>\n<p>在mac上的运行结果如下&#xff1a;</p>\n<p><img src=\"/img/391-38381680c510ca59.png\" alt=\"\" /></p>", "created": "2018-05-10T09:28:04Z", "bucket_order": 194, "bucket_name": "Week 5/6 - 5/12", "type": "feedback", "tag_good": [], "uid": "isvxeq6bspf1vn", "children": [], "tag_good_arr": [], "id": "jh0by3r2vg719d", "updated": "2018-05-10T09:28:04Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "i9ccpsb2ul3562", "updated": "2015-05-06T06:15:47Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>2.</p>\n<p>读者-写者问题</p>\n<p><a href=\"http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync02\">http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync02</a></p>\n<p></p>\n<p>计22 沈光耀 2012011273</p>\n<p></p>\n<p>读者优先</p>\n<pre>#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;pthread.h&gt;\n#include &lt;semaphore.h&gt;\n#include &lt;unistd.h&gt;\n\nconst int n = 5;\nsem_t write_mutex, count_mutex;\nint readcount = 0;\nconst int SLEEP_TIME = 1;\n\nvoid * read(void* arg)\n{\n        int i = *(int*)(arg);\n        sem_wait(&amp;count_mutex);\n        if(readcount ==0){\n                sem_wait(&amp;write_mutex);\n        }\n        readcount&#43;&#43;;\n        printf(&#34;read count is %d\\n&#34;, readcount);\n        sem_post(&amp;count_mutex);\n\n        printf(&#34;No.%d Reader Now Reading\\n&#34;, i);\n        sleep(SLEEP_TIME);\n        printf(&#34;No.%d Reader Now Finished\\n&#34;, i);\n\n        sem_wait(&amp;count_mutex);\n        readcount--;\n        if(readcount == 0)\n                sem_post(&amp;write_mutex);\n        sem_post(&amp;count_mutex);\n        printf(&#34;No.%d Reader Now Quit\\n&#34;, i);\n\n        return NULL;\n}\n\nvoid * write(void* arg)\n{\n        sleep(SLEEP_TIME);\n        int i = *(int*)(arg);\n        sem_wait(&amp;write_mutex);\n        printf(&#34;No.%d Writer Now Writting\\n&#34;, i);\n        sleep(SLEEP_TIME);\n        printf(&#34;No.%d Writer Now Finished\\n&#34;, i);\n        printf(&#34;No.%d Writer Now Quit\\n&#34;, i);\n\n        sem_post(&amp;write_mutex);\n        return NULL;\n}\n\nint main()\n{\n        sem_init(&amp;write_mutex, 0, 1);\n        sem_init(&amp;count_mutex, 0, 1);\n\n        pthread_t id[n];\n\n        for (int i = 0; i &lt; n/2; &#43;&#43;i) pthread_create(id&#43;i, 0, read, new int(i));\n\n        for (int i = n/2; i &lt; n; &#43;&#43;i)\n        {\n                pthread_create(id&#43;i, 0, write, new int(i));\n        }\n\n\n        for (int i = 0; i &lt; n; &#43;&#43;i) pthread_join(id[i], 0);\n\n    return 0;\n}</pre>\n<p>写者优先</p>\n<pre>#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;pthread.h&gt;\n#include &lt;semaphore.h&gt;\n#include &lt;unistd.h&gt;\n\nconst int n = 5;\nsem_t count_mutex, write_mutex,read_mutex, write_count_mutex, first_reader_mutex;\nint readcount = 0, writecount = 0;\nconst int SLEEP_TIME = 1;\n\nvoid * read(void * args)\n{\n\tint i = *(int*)(args);\n\tsem_wait(&amp;read_mutex);\n\tsem_wait(&amp;first_reader_mutex);\n\tsem_wait(&amp;count_mutex);\n\tif(readcount ==0){\n        sem_wait(&amp;write_mutex);\n    }\n\treadcount&#43;&#43;;\n\n    printf(&#34;read count is %d\\n&#34;, readcount);\n    sem_post(&amp;count_mutex);\n    sem_post(&amp;first_reader_mutex);\n    sem_post(&amp;read_mutex);\n    \n    printf(&#34;No.%d Reader Now Reading\\n&#34;, i);\n    sleep(SLEEP_TIME);\n    printf(&#34;No.%d Reader Now Finished\\n&#34;, i);\n    sem_wait(&amp;count_mutex);\n    readcount--;\n    if(readcount == 0)\n    {\n    \tsem_post(&amp;write_mutex);\n    }\n    sem_post(&amp;count_mutex);\n}\n\nvoid * write(void * args)\n{\n\tint i = *(int*)(args);\n\tsem_wait(&amp;write_count_mutex);\n\tif(writecount == 0) sem_wait(&amp;first_reader_mutex);\n\twritecount &#43;&#43;;\n\tsem_post(&amp;write_count_mutex);\n\tsem_wait(&amp;write_mutex);\n\n\tprintf(&#34;No.%d Writer Now Writting\\n&#34;, i);\n    sleep(SLEEP_TIME);\n    printf(&#34;No.%d Writer Now Finished\\n&#34;, i);\n    printf(&#34;No.%d Writer Now Quit\\n&#34;, i);\n\tsem_post(&amp;write_mutex);\n\tsem_wait(&amp;write_count_mutex);\n\twritecount--;\n\tif(writecount == 0) sem_post(&amp;first_reader_mutex);\n\tsem_post(&amp;write_count_mutex);\n}\n\n\nint main()\n{\n\tsem_init(&amp;write_mutex, 0, 1);\n    sem_init(&amp;count_mutex, 0, 1);\n    sem_init(&amp;read_mutex, 0, 1);\n    sem_init(&amp;write_count_mutex, 0, 1);\n    sem_init(&amp;first_reader_mutex, 0, 1);\n    \n    pthread_t id[n];\n\n    for (int i = 0; i &lt; n; &#43;&#43;i) {\n    \tif(i % 2 == 0)\n    \t\tpthread_create(id&#43;i, 0, read, new int(i));\n    \telse\n    \t\tpthread_create(id&#43;i, 0, write, new int(i));\n    }\n    for (int i = 0; i &lt; n; &#43;&#43;i) pthread_join(id[i], 0);\n}</pre>\n<p></p>", "created": "2015-05-06T06:17:51Z", "bucket_order": 351, "bucket_name": "Week 5/3 - 5/9", "type": "followup", "tag_good": [], "uid": "i6uunp7jxDb", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>使用信号量机制实现了读者优先的情况&#xff1a;</p>\n<pre>#include &lt;stdio.h&gt;\n#include &lt;pthread.h&gt;\n#include &lt;semaphore.h&gt;\n#include &lt;cstring&gt;\n#include &lt;unistd.h&gt;\n#include &lt;string&gt;\n#include &lt;cstdlib&gt;\n#include &lt;dispatch/dispatch.h&gt;\n\nusing namespace std;\n\n#define N 3\n#define SLEEP_SPAN 5\n#define WORK_SPAN 4\n\ndispatch_semaphore_t write_mutex, counter_mutex;\nint readcount = 0;\nint data = 0;\n\n\nstruct arg_struct{\n    arg_struct(int _id, int _start, int _work, string _indent): id(_id), start(_start), work(_work), indent(_indent){}\n    arg_struct(int _id): id(_id), start(0), work(0), indent(string(&#34;&#34;)){}\n    int id;\n    int start;\n    int work;\n    string indent;\n};\n\nvoid* reader(void* argv){\n    arg_struct arg = *(arg_struct*)argv;\n    int id = arg.id;\n    const char* indent = arg.indent.c_str();\n    \n    sleep(arg.start);\n    \n    printf(&#34;%sSTART\\n&#34;, indent);\n    \n    dispatch_semaphore_wait(counter_mutex, DISPATCH_TIME_FOREVER);\n    printf(&#34;%saCOUNT\\n&#34;, indent);\n    if (readcount == 0){\n        dispatch_semaphore_wait(write_mutex, DISPATCH_TIME_FOREVER);\n    }\n    readcount&#43;&#43;;\n    dispatch_semaphore_signal(counter_mutex);\n    printf(&#34;%srCOUNT\\n&#34;, indent);\n    \n    printf(&#34;%ssREAD%d\\n&#34;, indent, data);\n    sleep(SLEEP_SPAN);\n    printf(&#34;%sfREAD%d\\n&#34;, indent, data);\n    \n    dispatch_semaphore_wait(counter_mutex, DISPATCH_TIME_FOREVER);\n    printf(&#34;%saCOUNT\\n&#34;, indent);\n    readcount--;\n    if (readcount == 0){\n        dispatch_semaphore_signal(write_mutex);\n    }\n    dispatch_semaphore_signal(counter_mutex);\n    printf(&#34;%srCOUNT\\n&#34;, indent);\n    \n    return NULL;\n}\n\nvoid* writer(void* argv){\n    arg_struct arg = *(arg_struct*)argv;\n    int id = arg.id;\n    const char* indent = arg.indent.c_str();\n    \n    sleep(arg.start);\n    \n    //printf(&#34;Consumer %d Waiting for FULL: %d\\n&#34;, id, full_count);\n    printf(&#34;%sSTART\\n&#34;, indent);\n    \n    dispatch_semaphore_wait(write_mutex, DISPATCH_TIME_FOREVER);\n    printf(&#34;%saWRITE\\n&#34;,indent);\n    sleep(SLEEP_SPAN);\n    data&#43;&#43;;\n    printf(&#34;%sWRITE%d\\n&#34;,indent, data);\n    dispatch_semaphore_signal(write_mutex);\n    printf(&#34;%srWRITE\\n&#34;,indent);\n    \n    return NULL;\n}\n\nint main(int argc, char** argv) {\n    srand((unsigned)time(NULL));\n    \n    write_mutex = dispatch_semaphore_create(1);\n    counter_mutex = dispatch_semaphore_create(1);\n    \n    pthread_t p_reader[2 * N], p_writer[2 * N];\n    \n    int r_count = 0, w_count = 0;\n    \n#define WRITER 0\n#define READER 1\n    \n    /* For managed creation of 2 * N threads */\n    \n    int st_time = 0;\n    int inst[2 * N][3] = {\n        {READER, st_time &#43;= 0, rand()%WORK_SPAN},\n        {READER, st_time &#43;= 1, rand()%WORK_SPAN},\n        {READER, st_time &#43;= 0, rand()%WORK_SPAN},\n        {READER, st_time &#43;= 4, rand()%WORK_SPAN},\n        {READER, st_time &#43;= 0, rand()%WORK_SPAN},\n        {WRITER, st_time &#43;= 0, rand()%WORK_SPAN}\n    };\n    \n    /* Print the first line */\n    int tmp_r = 0, tmp_w = 0;\n    for (int i = 0; i &lt; 2 * N; i&#43;&#43;){\n        if (inst[i][0] == READER){\n            printf(&#34;R%d\\t&#34;, tmp_r&#43;&#43;);\n        } else if (inst[i][0] == WRITER){\n            printf(&#34;W%d\\t&#34;, tmp_w&#43;&#43;);\n        }\n    }\n    printf(&#34;\\n&#34;);\n    \n    /* Create Readers and Writers according to $inst*/\n    int rc;\n    string indent(&#34;&#34;);\n    for (int i = 0; i &lt; 2 * N; i&#43;&#43;){\n        if (inst[i][0] == READER){\n            //printf(&#34;Main: Producer %d created\\n&#34;, p_count);\n            rc = pthread_create(p_reader &#43; r_count, NULL, reader, new arg_struct(r_count, inst[i][1], inst[i][2], indent));\n            if (rc) printf(&#34;ERROR\\n&#34;);\n            r_count&#43;&#43;;\n        } else if (inst[i][0] == WRITER){\n            //printf(&#34;Main: Consumer %d created\\n&#34;, c_count);\n            rc = pthread_create(p_writer &#43; w_count, NULL, writer, new arg_struct(w_count, inst[i][1], inst[i][2], indent));\n            if (rc) printf(&#34;ERROR\\n&#34;);\n            w_count&#43;&#43;;\n        }\n        indent &#43;= &#39;\\t&#39;;\n    }\n    \n    /* wait until every thread finishes*/\n    for (int i = 0; i &lt; r_count; i&#43;&#43;){\n        pthread_join(p_reader[i], NULL);\n    }\n    for (int i = 0; i &lt; w_count; i&#43;&#43;){\n        pthread_join(p_writer[i], NULL);\n    }\n    \n    return 0;\n}</pre>\n<p>在mac上运行得到如下结果&#xff1a;</p>\n<p><img src=\"/img/391-b31fd27c077c3513.png\" alt=\"\" /></p>", "created": "2018-05-10T13:48:25Z", "bucket_order": 194, "bucket_name": "Week 5/6 - 5/12", "type": "feedback", "tag_good": [], "uid": "isvxeq6bspf1vn", "children": [], "tag_good_arr": [], "id": "jh0l8wtrmqp2ho", "updated": "2018-05-10T13:48:25Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>写者优先的管程实现</p>\n<pre>#include &lt;stdio.h&gt;\n#include &lt;pthread.h&gt;\n#include &lt;semaphore.h&gt;\n#include &lt;cstring&gt;\n#include &lt;unistd.h&gt;\n#include &lt;string&gt;\n#include &lt;cstdlib&gt;\n#include &lt;dispatch/dispatch.h&gt;\n\n\nusing namespace std;\n\n#define BUFFER_SIZE 2\n#define SLEEP_SPAN 5\n#define WORK_SPAN 4\n#define N 5\n\n\nint buffer[BUFFER_SIZE] = {};\nint g_write_index = 0;\nint g_read_index = 0;\n\npthread_mutex_t lock;\npthread_cond_t okToRead, okToWrite;\n\nint AR = 0; // active readers\nint AW = 0; // active writers\nint WR = 0; // waiting readers\nint WW = 0; // waiting writers\n\nint data = 0;\n\nstruct arg_struct{\n    arg_struct(int _id, int _start, int _work, string _indent): id(_id), start(_start), work(_work), indent(_indent){}\n    arg_struct(int _id): id(_id), start(0), work(0), indent(string(&#34;&#34;)){}\n    int id;\n    int start;\n    int work;\n    string indent;\n};\n\n\nvoid * reader(void * argv){\n    arg_struct arg = *(arg_struct*) argv;\n    int id = arg.id;\n    const char* indent = arg.indent.c_str();\n    \n    sleep(arg.start);\n    \n    printf(&#34;%sSTART\\n&#34;, indent);\n    \n    //Start Read\n    pthread_mutex_lock(&amp;lock); //Acquire the lock\n    printf(&#34;%saMUTEX\\n&#34;, indent);\n    bool first = true;\n    while((AW &#43; WW) &gt; 0){\n        WR&#43;&#43;;\n        if (first){\n            printf(&#34;%sWAIT\\n&#34;, indent);\n            first = false;\n        }\n        pthread_cond_wait(&amp;okToRead, &amp;lock);\n        WR--;\n    }\n    AR&#43;&#43;;\n    \n    pthread_mutex_unlock(&amp;lock); //Release the lock\n    printf(&#34;%srMUTEX\\n&#34;, indent);\n  \n    //Read\n    printf(&#34;%ssRead:%d\\n&#34;, indent, data);\n    sleep(arg.work);\n    printf(&#34;%seRead:%d\\n&#34;, indent, data);\n    \n    //End Read\n    pthread_mutex_lock(&amp;lock); // Acquire the lock\n    printf(&#34;%saMUTEX\\n&#34;, indent);\n    AR--;\n    if (AR == 0 &amp;&amp; WW &gt; 0){\n        pthread_cond_signal(&amp;okToWrite);\n    }\n    pthread_mutex_unlock(&amp;lock); //Release the lock\n    printf(&#34;%srMUTEX\\n&#34;, indent);\n    \n    return NULL;\n}\n\nvoid * writer(void * argv){\n    arg_struct arg = *(arg_struct*) argv;\n    int id = arg.id;\n    const char* indent = arg.indent.c_str();\n    \n    sleep(arg.start);\n    \n    printf(&#34;%sSTART\\n&#34;, indent);\n    \n    //Start Write\n    pthread_mutex_lock(&amp;lock);\n    printf(&#34;%saMUTEX\\n&#34;, indent);\n    bool first = true;\n    while((AW &#43; AR) &gt; 0){\n        WW&#43;&#43;;\n        if (first){\n            printf(&#34;%sWAIT\\n&#34;, indent);\n            first = false;\n        }\n        pthread_cond_wait(&amp;okToWrite, &amp;lock);\n        WW--;\n    }\n    AW&#43;&#43;;\n    \n    pthread_mutex_unlock(&amp;lock);\n    printf(&#34;%srMUTEX\\n&#34;, indent);\n    \n    //Write\n    printf(&#34;%ssWrite:%d\\n&#34;, indent, data);\n    data&#43;&#43;;\n    sleep(arg.work);\n    printf(&#34;%seWrite:%d\\n&#34;, indent, data);\n    \n    //End Write\n    pthread_mutex_lock(&amp;lock);\n    printf(&#34;%saMUTEX\\n&#34;, indent);\n    AW--;\n    if (WW &gt; 0){\n        pthread_cond_signal(&amp;okToWrite);\n    }else if (WR &gt; 0){\n        pthread_cond_broadcast(&amp;okToRead);\n    }\n    pthread_mutex_unlock(&amp;lock);\n    printf(&#34;%srMUTEX\\n&#34;, indent);\n    \n    return NULL;\n}\n\nint main(int argc, char** argv) {\n    srand((unsigned)time(NULL));\n    \n    pthread_mutex_init(&amp;lock,0);\n    pthread_cond_init(&amp;okToWrite,0);\n    pthread_cond_init(&amp;okToRead,0);\n    \n    pthread_t p_reader[2 * N], p_writer[2 * N];\n    \n    int r_count = 0, w_count = 0;\n    \n#define WRITER 0\n#define READER 1\n    \n    /* For managed creation of 2 * N threads */\n    \n    int st_time = 0;\n    int inst[2 * N][3] = {\n        {READER, st_time &#43;= 0, rand()%WORK_SPAN},\n        {READER, st_time &#43;= 1, rand()%WORK_SPAN},\n        {READER, st_time &#43;= 0, rand()%WORK_SPAN},\n        {WRITER, st_time &#43;= 4, rand()%WORK_SPAN},\n        {READER, st_time &#43;= 0, rand()%WORK_SPAN},\n        {WRITER, st_time &#43;= 1, rand()%WORK_SPAN},\n        {READER, st_time &#43;= 0, rand()%WORK_SPAN},\n        {READER, st_time &#43;= 0, rand()%WORK_SPAN},\n        {WRITER, st_time &#43;= 1, rand()%WORK_SPAN},\n        {READER, st_time &#43;= 0, rand()%WORK_SPAN}\n    };\n    \n    /* Print the first line */\n    int tmp_r = 0, tmp_w = 0;\n    for (int i = 0; i &lt; 2 * N; i&#43;&#43;){\n        if (inst[i][0] == READER){\n            printf(&#34;R%d\\t&#34;, tmp_r&#43;&#43;);\n        } else if (inst[i][0] == WRITER){\n            printf(&#34;W%d\\t&#34;, tmp_w&#43;&#43;);\n        }\n    }\n    printf(&#34;\\n&#34;);\n    \n    /* Create Readers and Writers according to $inst*/\n    int rc;\n    string indent(&#34;&#34;);\n    for (int i = 0; i &lt; 2 * N; i&#43;&#43;){\n        if (inst[i][0] == READER){\n            rc = pthread_create(p_reader &#43; r_count, NULL, reader, new arg_struct(r_count, inst[i][1], inst[i][2], indent));\n            if (rc) printf(&#34;ERROR\\n&#34;);\n            r_count&#43;&#43;;\n        } else if (inst[i][0] == WRITER){\n            rc = pthread_create(p_writer &#43; w_count, NULL, writer, new arg_struct(w_count, inst[i][1], inst[i][2], indent));\n            if (rc) printf(&#34;ERROR\\n&#34;);\n            w_count&#43;&#43;;\n        }\n        indent &#43;= &#39;\\t&#39;;\n    }\n    \n    /* wait until every thread finishes*/\n    for (int i = 0; i &lt; r_count; i&#43;&#43;){\n        pthread_join(p_reader[i], NULL);\n    }\n    for (int i = 0; i &lt; w_count; i&#43;&#43;){\n        pthread_join(p_writer[i], NULL);\n    }\n    \n    return 0;\n}</pre>\n<p>在mac上的运行结果如下&#xff1a;</p>\n<p><img src=\"/img/391-49ba31d07cda9aed.png\" alt=\"\" /></p>", "created": "2018-05-10T16:07:38Z", "bucket_order": 194, "bucket_name": "Week 5/6 - 5/12", "type": "feedback", "tag_good": [], "uid": "isvxeq6bspf1vn", "children": [], "tag_good_arr": [], "id": "jh0q7yi8upk4r3", "updated": "2018-05-10T16:07:38Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>李凯文 2014011756</p>\n<p>上节课老师要求我给出完整的测试用例&#xff0c;由于周二的课我还在成都出差&#xff0c;所以下面的分类可能与周二课上的不同&#xff0c;下面是分析&#xff1a;</p>\n<p>在读者写者问题中&#xff0c;有四种状态&#xff0c;AR(active reader) AW(active writer) WR(waiting reader) WW(waiting writer)&#xff0c;由于三条规则限制&#xff0c;只有部分取值是可行的&#xff0c;而WW和WR在分类中只需要分为有和无即可&#xff0c;简化处理为0和1个&#xff0c;AW上限为1&#xff0c;AR可以为0,1,n&#xff08;n&gt;1&#xff09;&#xff0c;AW&amp;AR=0&#xff0c;因此&#xff0c;有以下取值方式&#xff1a;&#xff08;AR AW WR WW&#xff09;</p>\n<p>0000 0001 0010 0011</p>\n<p>0100 0101 0110 0111</p>\n<p>1000 1001 1010 1011</p>\n<p>n000 n001 n010 n011</p>\n<p>其中后两位为0的可以不进行考虑&#xff0c;因为这时没有进程等待&#xff0c;这样&#xff0c;还剩下12种状态&#xff0c;其中后两位为11的0011 0111 1011涉及到读者优先还是写者优先&#xff0c;而n011的下一个状态一定不会涉及到读者还是写者优先&#xff08;n个读者同时释放可以看做一个个地释放&#xff09;&#xff0c;于是&#xff0c;符合条件的应该有如下状态转换&#xff1a;</p>\n<p>                 R     W</p>\n<p>0001 -&gt; 0100 0100 不稳定</p>\n<p>0010 -&gt; 1000 1000 不稳定</p>\n<p>0011 -&gt; 1001 0110 不稳定</p>\n<p>以下三个&#xff0c;writer退出后</p>\n<p>0101 -&gt; 0100 0100 中间0001</p>\n<p>0110 -&gt; 1000 1000 中间0010</p>\n<p>0111 -&gt; 1001 0110 中间0011  *</p>\n<p>以下三个&#xff0c;reader退出后</p>\n<p>1001 -&gt; 0100 0100 中间0001</p>\n<p>1010 -&gt; &#xff08;不稳定&#xff09;n000</p>\n<p>1011 -&gt; (读者优先不稳定) 0110 中间0011 *</p>\n<p>以下三个&#xff0c;reader退出一个后</p>\n<p>n001 -&gt; n001/1001 n001/1001</p>\n<p>n010 -&gt; (不稳定&#xff0c;变为n000)   </p>\n<p>n011 -&gt; (读者优先不稳定&#xff0c;变为n001) n011/1011   *</p>\n<p>其他&#xff1a;</p>\n<p>0100 -&gt; 0000 1000 -&gt;0000 n000-&gt;n000/1000</p>\n<p>由于代码中每一步输出结果不会出现不稳定状态&#xff0c;所以实际上需要分析的状态数更少&#xff0c;只要保证上面的稳定的状态转换在测试中都存在&#xff0c;并且与上面的结果相同&#xff0c;就可以说明代码的正确性和读写者优先的特性。</p>\n<p>读者优先的稳定状态有0000 1000 0100 n000 &#43;  0101 0110 1001 n001 0111 </p>\n<p>写者优先的稳定状态有0000 1000 0100 n000 &#43;  0101 0110 1001 n001 0111   &#43;  1011 n011</p>\n<p>对于读者优先设计如下&#xff1a;</p>\n<p>1. 统一测试&#xff1a;</p>\n<p>0000-&gt;1000-&gt;1001-&gt;0100-&gt;0110-&gt;1000-&gt;2000-&gt;3000-&gt;3001-&gt;2001-&gt;1001-&gt;0100-&gt;0000</p>\n<p>(通过了读者有先和写者优先共同的除0111外所有稳定状态&#xff0c;测试了1010 0010 n010的不稳定性&#xff0c;还需要测试0001的不稳定性&#xff0c;而0011在0001和0010不稳定的情况下不会出现&#xff09;</p>\n<p></p>\n<p>实现&#xff1a;</p>\n<p>a 读  -- DDDDDD</p>\n<p>b 写  --            XXXXX</p>\n<p>c 读  --                    DDDDDDDDD</p>\n<p>d 读  --                            DDDDDDD</p>\n<p>e 读  --                                  DDDDDD</p>\n<p>f  写  --                                       XXXXXXX</p>\n<p>具体数据取</p>\n<p>a读&#xff0c;起始0&#xff0c;时长2&#xff0c;等待0~0&#xff0c;运行0~2</p>\n<p>b写&#xff0c;起始1&#xff0c;时长2&#xff0c;等待1~2&#xff0c;运行2~4</p>\n<p>c读&#xff0c;起始3&#xff0c;时长6&#xff0c;等待3~4&#xff0c;运行4~10</p>\n<p>d读&#xff0c;起始5&#xff0c;时长6&#xff0c;等待5~5&#xff0c;运行5~11</p>\n<p>e读&#xff0c;起始6&#xff0c;时长6&#xff0c;等待6~6&#xff0c;运行6~12</p>\n<p>f 写&#xff0c;起始8&#xff0c;时长2&#xff0c;等待8~12&#xff0c;运行12~14</p>\n<p>int inst[2 * N][3]=</p>\n<p>{{READER, 0, 2},</p>\n<p>{WRITER, 1, 2},</p>\n<p>{READER, 3, 6},</p>\n<p>{READER, 5, 6},</p>\n<p>{READER, 6, 6},</p>\n<p>{WRITER, 8, 2}}</p>\n<p></p>\n<p>2. 优先测试&#xff1a;</p>\n<p> 1011 n011是否稳定是读者优先和写者优先的一个区别&#xff0c;对于0111写者退出后的处理也是两者的差异</p>\n<p>读者优先&#xff1a;</p>\n<p>0000-&gt;0100-&gt;0110-&gt;0111-&gt;1001-&gt;2001-&gt;3001-&gt;2001-&gt;1001-&gt;0100-&gt;0000</p>\n<p>&#xff08;测试了0111的状态转换和1011 n011的不稳定性&#xff09;</p>\n<p>实现&#xff1a;</p>\n<p>a 写  -- XXXXXXXXX</p>\n<p>b 读  --          DDDDDDDDDD</p>\n<p>c 写  --                XXXXXXXXXXXXXX</p>\n<p>d 读  --                       DDDDDDD</p>\n<p>e 读  --                            DDDDDD</p>\n<p>具体数据取</p>\n<p>a写&#xff0c;起始0&#xff0c;时长4&#xff0c;等待0~0&#xff0c;运行0~4</p>\n<p>b读&#xff0c;起始1&#xff0c;时长4&#xff0c;等待1~4&#xff0c;运行4~8</p>\n<p>c写&#xff0c;起始2&#xff0c;时长2&#xff0c;等待2~10&#xff0c;运行10~12</p>\n<p>d读&#xff0c;起始5&#xff0c;时长4&#xff0c;等待5~5&#xff0c;运行5~9</p>\n<p>e读&#xff0c;起始6&#xff0c;时长4&#xff0c;等待6~6&#xff0c;运行6~10</p>\n<p>int inst[2 * N][3]=</p>\n<p>{{WRITER, 0, 4},</p>\n<p>{READER, 1, 4},</p>\n<p>{WRITER, 2, 2},</p>\n<p>{READER, 5, 4},</p>\n<p>{READER, 6, 4},&#xff08;补一个随意的时间靠后的&#xff09;}</p>\n<p></p>\n<p>写者优先&#xff1a;</p>\n<p>0000-&gt;1000-&gt;2000-&gt;2001-&gt;2011-&gt;1011-&gt;0110-&gt;0111-&gt;0110-&gt;1000-&gt;0000</p>\n<p>&#xff08;测试了0111的状态转换和1011 n011的稳定性&#xff09;</p>\n<p>a 读  -- DDDDDDDDDDD</p>\n<p>b 读  --       DDDDDDDDDDDD</p>\n<p>c 写  --                  XXXXXXXXXXXXX</p>\n<p>d 读  --                       DDDDDDDDDDDDDDDD</p>\n<p>e 写  --                                         XXXXXXX</p>\n<p>具体数据取</p>\n<p>a读&#xff0c;起始0&#xff0c;时长6&#xff0c;等待0~0&#xff0c;运行0~6</p>\n<p>b读&#xff0c;起始1&#xff0c;时长6&#xff0c;等待1~1&#xff0c;运行1~7</p>\n<p>c写&#xff0c;起始2&#xff0c;时长2&#xff0c;等待2~7&#xff0c;运行7~9</p>\n<p>d读&#xff0c;起始3&#xff0c;时长2&#xff0c;等待3~11&#xff0c;运行11~13</p>\n<p>e写&#xff0c;起始8&#xff0c;时长2&#xff0c;等待8~9&#xff0c;运行9~11</p>\n<p>int inst[2 * N][3]=</p>\n<p>{{READER, 0, 6},</p>\n<p>{READER, 1, 6},</p>\n<p>{WRITER, 2, 2},</p>\n<p>{READER, 3, 2},</p>\n<p>{WRITER, 8, 2},&#xff08;补一个随意的时间靠后的&#xff09;}</p>\n<p></p>\n<p>由于dispatch/dispatch.h在linux上不知道为啥加载不上&#xff0c;而且没有mac环境&#xff0c;所以没法编译测试……</p>", "created": "2018-05-14T18:36:15Z", "bucket_order": 193, "bucket_name": "Week 5/13 - 5/19", "type": "feedback", "tag_good": [], "uid": "je2ib5nk89v6ca", "children": [], "tag_good_arr": [], "id": "jh6lah4h7o42kc", "updated": "2018-05-14T18:36:15Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>李凯文同学的统一测试的测试结果如下</p>\n<p></p>\n<p><img src=\"/img/391-5aac2c7f4b612514.png\" alt=\"\" /></p>", "created": "2018-05-15T00:31:33Z", "bucket_order": 193, "bucket_name": "Week 5/13 - 5/19", "type": "feedback", "tag_good": [], "uid": "isvxeq6bspf1vn", "children": [], "tag_good_arr": [], "id": "jh6xze38snt16d", "updated": "2018-05-15T00:31:33Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>李凯文 2014011756</p>\n<p></p>\n<p>实际上信号量和管程实现中都是有AR AW WR WW四个量&#xff0c;所以两者的分析实际上是可以统一起来的&#xff0c;然后&#xff0c;读者写者问题的三条规则如下&#xff1a;</p>\n<p>1. 允许多个读者同时读</p>\n<p>2. 读者读时写者不能写&#xff0c;写者写时读者不能读</p>\n<p>3. 多个写者不能同时写</p>\n<p>可见&#xff0c;后面两条规则都是只与AR AW相关的&#xff0c;而第一条是1010 n010不稳定&#xff0c;这在后面分析。</p>\n<p>那么&#xff0c;只需要保证AR AW符合条件即可&#xff0c;两者的取值都有三种&#xff1a;0 1 n(n&gt;1)&#xff0c;这样共有9种组合</p>\n<p><img src=\"/img/391-e20fee34cdf33eae.png\" alt=\"\" /></p>\n<p>当然这些组合有不符合上面三条规则的&#xff0c;其中蓝色的四个是符合的&#xff0c;而剩下的五个都是不符合的&#xff0c;如果不考虑同时进入临界区的情况&#xff0c;那么想要进入非蓝色的五个&#xff0c;只有上面四条路径&#xff0c;只需要保证上面四条路径都不能通过&#xff08;测试用例组1&#xff09;&#xff0c;就保证了第二三条要求&#xff0c;而第一条要求是尝试构造0010 1010和n010但发现出现不了&#xff08;测试用例组2&#xff09;&#xff0c;当然&#xff0c;还有测试用例组0,即0001 0010 0011不会出现。</p>\n<p></p>\n<p>不可行测试&#xff0c;即为尝试所有可能达到该状态的转换过程&#xff0c;发现转换结果不是该状态</p>\n<p></p>\n<p>测试用例组0&#xff1a;AR AW WR WW取值0001 0010 0011 不可行测试&#xff09;</p>\n<p>0.1 0000-&gt;0001 1000-&gt;0001 0100-&gt;0001</p>\n<p>0.2 0000-&gt;0010 1000-&gt;0010 0100-&gt;0010</p>\n<p>0.3 1011-&gt;0011  0111-&gt;0011                       (0010-&gt;0011 0001-&gt;0011)</p>\n<p>注意&#xff0c;1011是否稳定是与优先性有关的&#xff0c;在读者优先等一些算法中这种情形无法构造&#xff0c;所以这个测试需要与优先性测试结合。</p>\n<p></p>\n<p>测试用例组1&#xff1a;(AR AW取值0n 11 1n n1 nn 不可行测试)</p>\n<p>1.1  01 -&gt; 0n 先构造有一个写者在写</p>\n<p>1.2  01 -&gt; 11 先构造有一个写者在写</p>\n<p>1.3  10 -&gt; 11 先构造有一个读者在读</p>\n<p>1.4  n0 -&gt; n1先构造有多个读者在读</p>\n<p></p>\n<p>测试用例组2&#xff1a;&#xff08;AR AW WR WW取值0010 1010 n010 不可行测试&#xff09;</p>\n<p>2.1 0000-&gt;0010   1010-&gt;0010   0110-&gt;0010              (0010-&gt;0010)</p>\n<p>2.2 1000-&gt;1010                                                          (n010-&gt;1010 1010-&gt;1010)</p>\n<p>2.3 n000-&gt;n010                                                          (1010-&gt;n010 n010-&gt;n010)</p>\n<p>其中括号里面的左状态实际上是不能实现的&#xff0c;所以只需要让状态变为括号外的左状态&#xff0c;然后尝试向右转换&#xff0c;发现转换失败&#xff0c;所有括号外的转换失败&#xff0c;括号里的就无法出现&#xff0c;从而完成该组测试。</p>\n<p>注意测试用例组2要基于测试用例组1通过&#xff0c;进而说明AR AW的有效取值问题&#xff0c;而测试用例组1的具体测试用例分析在下面。</p>\n<p></p>\n<p>想要完成具体的测试用例组1,需要对WR WW的取值进行分析&#xff0c;这里的1 0仍然是有或无的含义&#xff0c;为了分析优先问题&#xff0c;需要考虑第一个WR和第一个WW的顺序问题&#xff0c;所以实际上WR WW一共有5种取值&#xff1a;</p>\n<p>0 R W RW WR</p>\n<p>其中RW为第一个读者先到&#xff0c;WR为第一个写者先到&#xff0c;测试用例组2中的只涉及到R一种&#xff0c;而测试用例组1中每种情况都需要对这5种情况进行确认&#xff0c;</p>\n<p>1. 首先0的显然不需要测试&#xff0c;让读者/写者退出即可</p>\n<p>2. R&#xff0c;测试用例组1的左状态准备好后&#xff0c;进一个读者</p>\n<p>3. W&#xff0c;测试用例组1的左状态准备好后&#xff0c;进一个写者</p>\n<p>4.RW&#xff0c;测试用例组1的左状态准备好后&#xff0c;进一个读者&#xff0c;再进一个写者</p>\n<p>5.WR&#xff0c;测试用例组1的左状态准备好后&#xff0c;进一个写者&#xff0c;再进一个读者</p>\n<p>总体上测试用例组1的测试用例数目为3*5=15个&#xff08;1.1和1.2的左状态相同&#xff09;</p>\n<p></p>\n<p>以上完成了读者/写者问题三条规则的确认&#xff0c;前提条件是&#xff0c;不需要区别等待读者1个还是多个&#xff0c;等待写者1个还是多个; 同时进入和同时退出可以看作是有先后顺序的两个基本操作的组合&#xff0c;即不存在同时进入&#xff0c;同时退出。</p>\n<p></p>\n<p>上面分析了AR AW的取值有效的只有10 n0 01三种&#xff08;实际上00只有0000这样一个稳定状态&#xff0c;所以可以认为只有这三种取值&#xff09;&#xff0c;而WR WW有效有5种&#xff0c;总有效状态数为不超过3*5=15种&#xff0c;状态转移种类数小于15*15=225种&#xff0c;对于各种优先性&#xff0c;只需要对这不超过225种进行分析分析&#xff0c;即可。</p>\n<p></p>\n<p>测例的构造方式&#xff1a;</p>\n<p>第一步&#xff1a;构造AR AW&#xff0c;参考测试用例组1的实现</p>\n<p>第二步&#xff1a;构造WR WW&#xff0c;为了保证所有的转换方式都存在&#xff0c;需要对0 R W RW WR进行细分为</p>\n<p>0&#xff1a;不进入等待者&#xff0c;活跃者依次退出即可</p>\n<p></p>\n<p>R&#xff1a;仅有读者等待</p>\n<p>R      1个  只进入一个读者&#xff0c;然后活跃者依次退出</p>\n<p>RR   n个  进入两个读者之后&#xff0c;活跃者才开始退出</p>\n<p></p>\n<p>W&#xff1a;仅有写者等待</p>\n<p>W     1个  只进入一个写者&#xff0c;然后活跃者依次退出</p>\n<p>WW  n个  进入两个写者之后&#xff0c;活跃者才开始退出</p>\n<p></p>\n<p>RW&#xff1a;既有读者又有写者等待&#xff0c;而且第一个读者到的早</p>\n<p>RW</p>\n<p>RRW</p>\n<p>RWR</p>\n<p>RWW</p>\n<p>以上均表示进入顺序和总数&#xff0c;进入等待之后活跃者才开始退出</p>\n<p></p>\n<p>WR&#xff1a;既有读者又有写者等待&#xff0c;而且第一个写者到的早</p>\n<p>WR</p>\n<p>WRW</p>\n<p>WWR</p>\n<p>WRR</p>\n<p>以上均表示进入顺序和总数&#xff0c;进入等待之后活跃者才开始退出</p>\n<p></p>\n<p>由此可以构造出所有测例&#xff0c;而参考解应该参考优先特征很容易给出&#xff0c;因为太多这里就不列了。</p>\n<p></p>\n<p>目前想到的问题&#xff1a;</p>\n<p>如果算法是等待队列后来者可以先进入&#xff0c;那么上面的测试关于RW和WR的还需要进一步细分&#xff0c;情况变得相当复杂&#xff0c;但仍然可以找到所有需要表示的状态&#xff0c;从中找到有效的状态和状态转换&#xff0c;进而测试无效状态无法到达和状态转换按照优先要求进行&#xff0c;即可完成测试。</p>", "created": "2018-05-15T17:28:32Z", "bucket_order": 193, "bucket_name": "Week 5/13 - 5/19", "type": "feedback", "tag_good": [], "uid": "je2ib5nk89v6ca", "children": [], "tag_good_arr": [], "id": "jh7yb91rryn4qg", "updated": "2018-05-15T17:28:32Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>另外&#xff0c;关于课上提到的dispatch.h在linux上的问题&#xff0c;魏钧宇同学的管程实现实际上并没有使用dispatch.h&#xff0c;而信号量实现只需要改用semaphore.h的函数替换掉一部分函数即可&#xff0c;修改后的魏钧宇同学的读者优先信号量实现如下&#xff1a;&#xff08;换了测试用例&#xff09;</p>\n<p></p>\n<pre>#include &lt;stdio.h&gt;\n#include &lt;pthread.h&gt;\n#include &lt;semaphore.h&gt;\n#include &lt;cstring&gt;\n#include &lt;unistd.h&gt;\n#include &lt;string&gt;\n#include &lt;cstdlib&gt;\n\nusing namespace std;\n\n#define N 3\n#define SLEEP_SPAN 5\n#define WORK_SPAN 4\n\nsem_t write_mutex, counter_mutex;\nint readcount = 0;\nint data = 0;\n\n\nstruct arg_struct{\n    arg_struct(int _id, int _start, int _work, string _indent): id(_id), start(_start), work(_work), indent(_indent){}\n    arg_struct(int _id): id(_id), start(0), work(0), indent(string(&#34;&#34;)){}\n    int id;\n    int start;\n    int work;\n    string indent;\n};\n\nvoid* reader(void* argv){\n    arg_struct arg = *(arg_struct*)argv;\n    int id = arg.id;\n    const char* indent = arg.indent.c_str();\n    \n    sleep(arg.start);\n    \n    printf(&#34;%sSTART\\n&#34;, indent);\n    \n    sem_wait(&amp;counter_mutex);\n    printf(&#34;%saCOUNT\\n&#34;, indent);\n    if (readcount == 0){\n        sem_wait(&amp;write_mutex);\n    }\n    readcount&#43;&#43;;\n    sem_post(&amp;counter_mutex);\n    printf(&#34;%srCOUNT\\n&#34;, indent);\n    \n    printf(&#34;%ssREAD%d\\n&#34;, indent, data);\n    sleep(arg.work);\n    printf(&#34;%sfREAD%d\\n&#34;, indent, data);\n    \n    sem_wait(&amp;counter_mutex);\n    printf(&#34;%saCOUNT\\n&#34;, indent);\n    readcount--;\n    if (readcount == 0){\n        sem_post(&amp;write_mutex);\n    }\n    sem_post(&amp;counter_mutex);\n    printf(&#34;%srCOUNT\\n&#34;, indent);\n    \n    return NULL;\n}\n\nvoid* writer(void* argv){\n    arg_struct arg = *(arg_struct*)argv;\n    int id = arg.id;\n    const char* indent = arg.indent.c_str();\n    \n    sleep(arg.start);\n    \n    //printf(&#34;Consumer %d Waiting for FULL: %d\\n&#34;, id, full_count);\n    printf(&#34;%sSTART\\n&#34;, indent);\n    \n    sem_wait(&amp;write_mutex);\n    printf(&#34;%saWRITE\\n&#34;,indent);\n    sleep(arg.work);\n    data&#43;&#43;;\n    printf(&#34;%sWRITE%d\\n&#34;,indent, data);\n    sem_post(&amp;write_mutex);\n    printf(&#34;%srWRITE\\n&#34;,indent);\n    \n    return NULL;\n}\n\nint main(int argc, char** argv) {\n    srand((unsigned)time(NULL));\n    \n    sem_init(&amp;write_mutex, 0, 1);\n    sem_init(&amp;counter_mutex, 0, 1);\n    // write_mutex = dispatch_semaphore_create(1);\n    // counter_mutex = dispatch_semaphore_create(1);\n    \n    pthread_t p_reader[2 * N], p_writer[2 * N];\n    \n    int r_count = 0, w_count = 0;\n    \n#define WRITER 0\n#define READER 1\n    \n    /* For managed creation of 2 * N threads */\n    \n    int st_time = 0;\n    // int inst[2 * N][3] = {\n    //     {READER, 0, 2},\n    //     {WRITER, 1, 2},\n    //     {READER, 3, 6},\n    //     {READER, 5, 6},\n    //     {READER, 6, 6},\n    //     {WRITER, 8, 2}\n    // };\n    int inst[2 * N][3] = {\n        {WRITER, 0, 4},\n        {READER, 1, 4},\n        {WRITER, 2, 2},\n        {READER, 5, 4},\n        {READER, 6, 4},\n        {WRITER, 13, 1}\n    };\n    \n    /* Print the first line */\n    int tmp_r = 0, tmp_w = 0;\n    for (int i = 0; i &lt; 2 * N; i&#43;&#43;){\n        if (inst[i][0] == READER){\n            printf(&#34;R%d\\t&#34;, tmp_r&#43;&#43;);\n        } else if (inst[i][0] == WRITER){\n            printf(&#34;W%d\\t&#34;, tmp_w&#43;&#43;);\n        }\n    }\n    printf(&#34;\\n&#34;);\n    \n    /* Create Readers and Writers according to $inst*/\n    int rc;\n    string indent(&#34;&#34;);\n    for (int i = 0; i &lt; 2 * N; i&#43;&#43;){\n        if (inst[i][0] == READER){\n            //printf(&#34;Main: Producer %d created\\n&#34;, p_count);\n            rc = pthread_create(p_reader &#43; r_count, NULL, reader, new arg_struct(r_count, inst[i][1], inst[i][2], indent));\n            if (rc) printf(&#34;ERROR\\n&#34;);\n            r_count&#43;&#43;;\n        } else if (inst[i][0] == WRITER){\n            //printf(&#34;Main: Consumer %d created\\n&#34;, c_count);\n            rc = pthread_create(p_writer &#43; w_count, NULL, writer, new arg_struct(w_count, inst[i][1], inst[i][2], indent));\n            if (rc) printf(&#34;ERROR\\n&#34;);\n            w_count&#43;&#43;;\n        }\n        indent &#43;= &#39;\\t&#39;;\n    }\n    \n    /* wait until every thread finishes*/\n    for (int i = 0; i &lt; r_count; i&#43;&#43;){\n        pthread_join(p_reader[i], NULL);\n    }\n    for (int i = 0; i &lt; w_count; i&#43;&#43;){\n        pthread_join(p_writer[i], NULL);\n    }\n    \n    return 0;\n}</pre>\n<p></p>", "created": "2018-05-15T17:34:58Z", "bucket_order": 193, "bucket_name": "Week 5/13 - 5/19", "type": "feedback", "tag_good": [], "uid": "je2ib5nk89v6ca", "children": [], "tag_good_arr": [], "id": "jh7yjipvwbyoj", "updated": "2018-05-15T17:34:58Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "i9ccsg2cck25hg", "updated": "2015-05-06T06:17:51Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>3.</p>\n<p>哲学家进餐问题</p>\n<p><a href=\"http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync03\">http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync03</a></p>\n<p></p>\n<p>计23 胡津铭 2012011301</p>", "created": "2015-05-06T06:20:04Z", "bucket_order": 351, "bucket_name": "Week 5/3 - 5/9", "type": "followup", "tag_good": [], "uid": "i6rgda76fc66q4", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<pre>#include &lt;iostream&gt;\n#include &lt;pthread.h&gt;\n#include &lt;semaphore.h&gt;\n\nconstexpr int n = 5;\nsem_t sem[n];\n\nvoid* func(void* arg) {\n    int i = *(int*)(arg);\n    \n    while (true) {\n        if (i % 2) {\n            sem_wait(sem &#43; i);\n            sem_wait(sem &#43; (i &#43; 1) % n);\n        } else {\n            sem_wait(sem &#43; (i &#43; 1) % n);\n            sem_wait(sem &#43; i);\n        }\n        std::cout &lt;&lt; i;\n        sem_post(sem &#43; i);\n        sem_post(sem &#43; (i &#43; 1) % n);\n    }   \n    return nullptr;\n}\n\nint main(int, char**) {\n\n    for (int i = 0; i &lt; n; &#43;&#43;i)\n        sem_init(sem &#43; i, 0, 1);\n\n    pthread_t id[n];\n\n    for (int i = 0; i &lt; n; &#43;&#43;i)\n        pthread_create(id &#43; i, 0, func, new int(i));\n    \n    for (int i = 0; i &lt; n; &#43;&#43;i)\n        pthread_join(id[i], 0);\n\n}</pre>\n<p></p>", "created": "2015-05-06T06:24:18Z", "bucket_order": 351, "bucket_name": "Week 5/3 - 5/9", "type": "feedback", "tag_good": [], "uid": "i6rgda76fc66q4", "children": [], "tag_good_arr": [], "id": "i9cd0qgxs07ap", "updated": "2015-05-06T06:24:18Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p><pre>#define N 5\nsemaphore fork[5];\nvoid philosopher(int i ){\n    while(TRUE){\n        think();\n        P(mutex);\n        P(fork[i]);\n        P(fork[i&#43;1] %N);\n        V(mutex);\n        eat();\n        V(fork[i]);\n        V(fork[(i&#43;1) %N]);\n    }\n}</pre>\n<p>这个方法可能会有死锁&#xff0c;但我暂时没有找到&#xff0c;希望老师同学给我提醒一下</p>", "created": "2018-05-08T00:55:18Z", "bucket_order": 194, "bucket_name": "Week 5/6 - 5/12", "type": "feedback", "tag_good": [], "uid": "isvxeq6bspf1vn", "children": [], "tag_good_arr": [], "id": "jgwyqzab4mq4zr", "updated": "2018-05-08T00:55:18Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>哲学家就餐问题的这种实现不会出现死锁&#xff0c;并且在一些情况下允许两个不相邻的哲学家同时就餐。</p>\n<p></p>\n<p>有兴趣的同学可以继续讨论一下&#xff0c;在什么情况允许两个不相邻的哲学同时就餐&#xff0c;在什么情况下不允许两个不相邻的哲学同时就餐。</p>", "created": "2018-05-21T02:30:50Z", "bucket_order": 192, "bucket_name": "Week 5/20 - 5/26", "type": "feedback", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [], "tag_good_arr": [], "id": "jhfmvwhlz111jf", "updated": "2018-05-21T02:30:50Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "i9ccvaovaey1w8", "updated": "2015-05-06T06:20:04Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>4.</p>\n<p>(四)理发师问题(BarberProblem)</p>\n<p><a href=\"http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync04\">http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync04<br /><br />计</a>23 李载隆 2012080061</p>", "created": "2015-05-06T06:20:08Z", "bucket_order": 351, "bucket_name": "Week 5/3 - 5/9", "type": "followup", "tag_good": [], "uid": "i6uayov5SAo", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>信号量实现&#xff1a;</p>\n<pre>#include &lt;stdio.h&gt;\n#include &lt;pthread.h&gt;\n#include &lt;semaphore.h&gt;\n#include &lt;cstring&gt;\n#include &lt;unistd.h&gt;\n#include &lt;string&gt;\n#include &lt;cstdlib&gt;\n#include &lt;dispatch/dispatch.h&gt;\n#include &lt;assert.h&gt;\nusing namespace std;\n\n#define BUFFER_SIZE 2\n#define SLEEP_SPAN 5\n#define WORK_SPAN 4\n#define WAITCHAIR 3\n\n//shared variable\nint waiting_chair;\nint idle_barber;\n\n//mutex\ndispatch_semaphore_t c_mutex, b_mutex;\n\n//Sync\ndispatch_semaphore_t barber, customer;\n\n\nstruct arg_struct{\n\targ_struct(int _id, int _start, int _work, string _indent): id(_id), start(_start), work(_work), indent(_indent){}\n\targ_struct(int _id): id(_id), start(0), work(0), indent(string(&#34;&#34;)){}\n\tint id;\n\tint start;\n\tint work;\n\tstring indent;\t\n};\n\n//First role\nvoid* Barber(void* argv){\n\targ_struct arg = *(arg_struct*)argv;\n\tint id = arg.id;\n\tconst char* indent = arg.indent.c_str();\n\tsleep(arg.start);\n    int worktime = arg.work;\n//start\n    printf(&#34;%sSTART\\n&#34;, indent);\n    while(1){\n        \n        dispatch_semaphore_wait(customer, DISPATCH_TIME_FOREVER); // Wait for customer\n        \n        printf(&#34;%ssCUT\\n&#34;, indent);\n        sleep(worktime);\n        printf(&#34;%seCUT\\n&#34;, indent);\n        \n        dispatch_semaphore_signal(barber);\n    }\n//end\n    \n\treturn NULL;\n}\n\n//Second role\nvoid* Consumer(void* argv){\n\targ_struct arg = *(arg_struct*)argv;\n\tint id = arg.id;\n\tconst char* indent = arg.indent.c_str();\n\tsleep(arg.start);\n\n//start\n    printf(&#34;%sSTART\\n&#34;, indent);\n    \n    dispatch_semaphore_wait(c_mutex, DISPATCH_TIME_FOREVER);\n    if (waiting_chair &lt;= 0){\n        printf(&#34;%sLEAVE\\n&#34;, indent);\n        dispatch_semaphore_signal(c_mutex);\n        return NULL;\n    }else{\n        waiting_chair--;\n        dispatch_semaphore_signal(customer);\n    }\n    dispatch_semaphore_signal(c_mutex);\n    \n    printf(&#34;%sWAIT\\n&#34;, indent);\n    dispatch_semaphore_wait(barber, DISPATCH_TIME_FOREVER);\n\n    dispatch_semaphore_wait(c_mutex, DISPATCH_TIME_FOREVER);\n    waiting_chair&#43;&#43;;\n    dispatch_semaphore_signal(c_mutex);\n\nBAR:\n    printf(&#34;%sBAR\\n&#34;, indent);\n//end\n    \n\treturn NULL;\n}\n\nint main(int argc, char** argv) {\n\tsrand((unsigned)time(NULL));\n    \n//init of shared variable\n    waiting_chair = WAITCHAIR;\n    idle_barber = 0;\n//init of mutex\n    c_mutex = dispatch_semaphore_create(1);\n    b_mutex = dispatch_semaphore_create(1);\n    barber = dispatch_semaphore_create(0);\n    customer = dispatch_semaphore_create(0);\n    \n//init of role name ( First is Barber, Second is Consumer )\n    #define First 0\n\t#define Second 1\n\n    //init of thread num\n    const int f_num = 2;\n    const int s_num = 10;\n    \n    int t_num = f_num&#43;s_num;\n    \n    int f_count = 0;\n    int s_count = 0;\n    \n    //init of thread array\n    pthread_t p_f[f_num], p_s[s_num];\n    \n    //init of role array\n    char role[] = {&#39;F&#39;,&#39;F&#39;,&#39;S&#39;,&#39;S&#39;,&#39;S&#39;,&#39;S&#39;,&#39;S&#39;,&#39;S&#39;,&#39;S&#39;,&#39;S&#39;,&#39;S&#39;,&#39;S&#39;};\n    int st_time[] = {0, 0, 1, 2, 3, 4, 5, 7, 8, 9, 10, 11};\n    \n\t/* For managed creation of t_num threads */\n    int inst[t_num][3];\n    for (int i = 0; i &lt; t_num; i&#43;&#43;){\n        bool finish = false;\n        if (role[i] == &#39;F&#39;){\n            inst[i][0] = First;\n            inst[i][1] = st_time[i];\n            inst[i][2] = WORK_SPAN;\n            finish = true;\n        }\n        if (role[i] == &#39;S&#39;){\n            inst[i][0] = Second;\n            inst[i][1] = st_time[i];\n            inst[i][2] = WORK_SPAN;\n            finish = true;\n         }\n        assert(finish == true);\n        \n    }\n\n\t/* Print the first line */\n\tint tmp_c = 0, tmp_p = 0;\n\tfor (int i = 0; i &lt; t_num; i&#43;&#43;){\n\t\tif (inst[i][0] == First){\n\t\t\tprintf(&#34;B%d\\t&#34;, tmp_p&#43;&#43;);\n\t\t} else if (inst[i][0] == Second){\n\t\t\tprintf(&#34;C%d\\t&#34;, tmp_c&#43;&#43;);\n\t\t}\n\t}\n\tprintf(&#34;\\n&#34;);\n\n\t/* Create Producers and Consumers according to $inst*/\n\tint rc;\n\tstring indent(&#34;&#34;);\n\tfor (int i = 0; i &lt; t_num; i&#43;&#43;){\n\t\tif (inst[i][0] == First){\n\t\t\t//printf(&#34;Main: Producer %d created\\n&#34;, p_count);\n\t\t\trc = pthread_create(p_f &#43; f_count, NULL, Barber, new arg_struct(f_count, inst[i][1], inst[i][2], indent));\n\t\t\tif (rc) printf(&#34;ERROR\\n&#34;);\n\t\t\tf_count&#43;&#43;;\n\t\t} else if (inst[i][0] == Second){\n\t\t\t//printf(&#34;Main: Consumer %d created\\n&#34;, c_count);\n\t\t\trc = pthread_create(p_s &#43; s_count, NULL, Consumer, new arg_struct(s_count, inst[i][1], inst[i][2], indent));\n\t\t\tif (rc) printf(&#34;ERROR\\n&#34;);\n\t\t\ts_count&#43;&#43;;\n\t\t}\n\t\tindent &#43;= &#39;\\t&#39;;\n\t}\n\n\t/* wait until every thread finishes*/\n\tfor (int i = 0; i &lt; f_count; i&#43;&#43;){\n\t\tpthread_join(p_f[i], NULL);\n\t}\n\tfor (int i = 0; i &lt; s_count; i&#43;&#43;){\n\t\tpthread_join(p_s[i], NULL);\n\t}\n\n\treturn 0;\n}</pre>\n<p>得到结果如下&#xff1a;</p>\n<p><img src=\"/img/391-58be3b79a3a4c03f.png\" alt=\"\" /></p>", "created": "2018-05-20T11:33:20Z", "bucket_order": 193, "bucket_name": "Week 5/13 - 5/19", "type": "feedback", "tag_good": [], "uid": "isvxeq6bspf1vn", "children": [], "tag_good_arr": [], "id": "jheqtpj6ctr30g", "updated": "2018-05-20T11:33:20Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "i9ccvdqzn1gip", "updated": "2015-05-06T06:20:08Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>5.吸烟者问题</p>\n<p>http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync05</p>", "created": "2015-05-06T06:20:37Z", "bucket_order": 351, "bucket_name": "Week 5/3 - 5/9", "type": "followup", "tag_good": [], "uid": "i6ub691ffHe", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>信号量实现</p>\n<pre>#include &lt;stdio.h&gt;\n#include &lt;pthread.h&gt;\n#include &lt;semaphore.h&gt;\n#include &lt;cstring&gt;\n#include &lt;unistd.h&gt;\n#include &lt;string&gt;\n#include &lt;cstdlib&gt;\n#include &lt;dispatch/dispatch.h&gt;\n#include &lt;assert.h&gt;\nusing namespace std;\n\n#define BUFFER_SIZE 2\n#define SLEEP_SPAN 5\n#define WORK_SPAN 2\n#define WAITCHAIR 3\n\n//shared variable\n\n//mutex\ndispatch_semaphore_t t_mutex;\n\n//Sync\ndispatch_semaphore_t smook, paper, match;\n\n\nstruct arg_struct{\n\targ_struct(int _id, int _start, int _work, string _indent): id(_id), start(_start), work(_work), indent(_indent){}\n\targ_struct(int _id): id(_id), start(0), work(0), indent(string(&#34;&#34;)){}\n\tint id;\n\tint start;\n\tint work;\n\tstring indent;\t\n};\n\n//First role\nvoid* Smooker(void* argv){\n\targ_struct arg = *(arg_struct*)argv;\n\tint id = arg.id;\n\tconst char* indent = arg.indent.c_str();\n\tsleep(arg.start);\n    int worktime = arg.work;\n    \n    printf(&#34;%sSTART\\n&#34;, indent);\n//start\n    while(1){\n        printf(&#34;%sWAIT\\n&#34;, indent);\n        switch(id){\n            case 0:{ //smook\n                dispatch_semaphore_wait(smook, DISPATCH_TIME_FOREVER);\n                break;\n            }\n            case 1:{ //paper\n                dispatch_semaphore_wait(paper, DISPATCH_TIME_FOREVER);\n                break;\n            }\n            case 2:{ //match\n                dispatch_semaphore_wait(match, DISPATCH_TIME_FOREVER);\n                break;\n            }\n        }\n        printf(&#34;%sDO\\n&#34;, indent);\n        sleep(arg.work);\n        dispatch_semaphore_signal(t_mutex);\n    }\n//end\n    \n\treturn NULL;\n}\n\n//Second role\n\nvoid* Producer(void* argv){\n\targ_struct arg = *(arg_struct*)argv;\n\tint id = arg.id;\n\tconst char* indent = arg.indent.c_str();\n\tsleep(arg.start);\n    printf(&#34;%sSTART\\n&#34;, indent);\n\n//start\n    while(1){\n        printf(&#34;%sWAIT\\n&#34;, indent);\n        dispatch_semaphore_wait(t_mutex, DISPATCH_TIME_FOREVER);\n        int bitmap[] = {0,0,0};\n        bitmap[rand() % 3] = 1;\n        while(true){\n            int temp = rand() % 3;\n            if (bitmap[temp] != 1){\n                bitmap[temp] = 1;\n                break;\n            }\n        }\n        \n        //sleep(arg.work);\n        if (bitmap[0] == 1 &amp;&amp; bitmap[1] == 1){ // SMOOK and PAPER\n            printf(&#34;%sSMOOK\\n&#34;, indent);\n            printf(&#34;%sPAPER\\n&#34;, indent);\n            dispatch_semaphore_signal(match);\n        }\n        if (bitmap[0] == 1 &amp;&amp; bitmap[2] == 1){ // SMOOK and MATCH\n            printf(&#34;%sSMOOK\\n&#34;, indent);\n            printf(&#34;%sMATCH\\n&#34;, indent);\n            dispatch_semaphore_signal(paper);\n        }\n        if (bitmap[1] == 1 &amp;&amp; bitmap[2] == 1){ // PAPER and MATCH\n            printf(&#34;%sPAPER\\n&#34;, indent);\n            printf(&#34;%sMATCH\\n&#34;, indent);\n            dispatch_semaphore_signal(smook);\n        }\n    }\n    \n//end\n    \n\treturn NULL;\n}\n\nint main(int argc, char** argv) {\n\tsrand((unsigned)time(NULL));\n    \n//init of shared variable\n\n//init of mutex\n    t_mutex = dispatch_semaphore_create(1);\n    smook = dispatch_semaphore_create(0);\n    paper = dispatch_semaphore_create(0);\n    match = dispatch_semaphore_create(0);\n    \n//init of role name ( First is Barber, Second is Consumer )\n    #define First 0\n\t#define Second 1\n\n    //init of thread num\n    const int f_num = 1;\n    const int s_num = 3;\n    \n    int t_num = f_num&#43;s_num;\n    \n    int f_count = 0;\n    int s_count = 0;\n    \n    //init of thread array\n    pthread_t p_f[f_num], p_s[s_num];\n    \n    //init of role array\n    char role[] = {&#39;F&#39;,&#39;S&#39;,&#39;S&#39;,&#39;S&#39;};\n    int st_time[] = { 0, 1, 1, 1 };\n    \n\t/* For managed creation of t_num threads */\n    int inst[t_num][3];\n    for (int i = 0; i &lt; t_num; i&#43;&#43;){\n        bool finish = false;\n        if (role[i] == &#39;F&#39;){\n            inst[i][0] = First;\n            inst[i][1] = st_time[i];\n            inst[i][2] = WORK_SPAN;\n            finish = true;\n        }\n        if (role[i] == &#39;S&#39;){\n            inst[i][0] = Second;\n            inst[i][1] = st_time[i];\n            inst[i][2] = WORK_SPAN;\n            finish = true;\n         }\n        assert(finish == true);\n        \n    }\n\n\t/* Print the first line */\n\tint tmp_c = 0, tmp_p = 0;\n\tfor (int i = 0; i &lt; t_num; i&#43;&#43;){\n\t\tif (inst[i][0] == First){\n\t\t\tprintf(&#34;P%d\\t&#34;, tmp_p&#43;&#43;);\n\t\t} else if (inst[i][0] == Second){\n\t\t\tprintf(&#34;S%d\\t&#34;, tmp_c&#43;&#43;);\n\t\t}\n\t}\n\tprintf(&#34;\\n&#34;);\n\n\t/* Create Producers and Consumers according to $inst*/\n\tint rc;\n\tstring indent(&#34;&#34;);\n\tfor (int i = 0; i &lt; t_num; i&#43;&#43;){\n\t\tif (inst[i][0] == First){\n\t\t\t//printf(&#34;Main: Producer %d created\\n&#34;, p_count);\n\t\t\trc = pthread_create(p_f &#43; f_count, NULL, Producer, new arg_struct(f_count, inst[i][1], inst[i][2], indent));\n\t\t\tif (rc) printf(&#34;ERROR\\n&#34;);\n\t\t\tf_count&#43;&#43;;\n\t\t} else if (inst[i][0] == Second){\n\t\t\t//printf(&#34;Main: Consumer %d created\\n&#34;, c_count);\n\t\t\trc = pthread_create(p_s &#43; s_count, NULL, Smooker, new arg_struct(s_count, inst[i][1], inst[i][2], indent));\n\t\t\tif (rc) printf(&#34;ERROR\\n&#34;);\n\t\t\ts_count&#43;&#43;;\n\t\t}\n\t\tindent &#43;= &#39;\\t&#39;;\n\t}\n\n\t/* wait until every thread finishes*/\n\tfor (int i = 0; i &lt; f_count; i&#43;&#43;){\n\t\tpthread_join(p_f[i], NULL);\n\t}\n\tfor (int i = 0; i &lt; s_count; i&#43;&#43;){\n\t\tpthread_join(p_s[i], NULL);\n\t}\n\n\treturn 0;\n}</pre>\n<p>测试结果如下&#xff1a;</p>\n<p><img src=\"/img/391-dd6647829f37f268.png\" alt=\"\" /></p>", "created": "2018-05-20T12:27:56Z", "bucket_order": 192, "bucket_name": "Week 5/20 - 5/26", "type": "feedback", "tag_good": [], "uid": "isvxeq6bspf1vn", "children": [], "tag_good_arr": [], "id": "jhesrxtk7x435h", "updated": "2018-05-20T12:27:56Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "i9ccvzu0s3q28m", "updated": "2015-05-06T06:20:37Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>6.<a href=\"http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync06\">第二章生产者-消费者问题扩展(一)扩展一(北大1991)</a></p>\n<p><a href=\"http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync06\">http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync06</a></p>\n<p>计24 王昊 2012011341</p>", "created": "2015-05-06T06:20:57Z", "bucket_order": 351, "bucket_name": "Week 5/3 - 5/9", "type": "followup", "tag_good": [], "uid": "i6t1w87gRBD", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p><pre>#include &lt;iostream&gt;\n#include &lt;pthread.h&gt;\n#include &lt;semaphore.h&gt; \n#include &lt;cmath&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstdlib&gt;\n#include &lt;time.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;malloc.h&gt; \nusing namespace std;\n\n#define M 5\n#define N 4\n#define TIME 10\n\nsem_t AStore, BStore;\nstatic int ADecB;\n\nvoid *store(void* type)\n{\n\tint t = *((int*)type);\n\tint id = t/5;\n\tt = t%5;\n\tprintf(&#34;This thread is to store %c&#34;, &#39;A&#39;&#43;t);\n\tfor (int i = 0; i &lt; TIME; i&#43;&#43;)\n\t{\n\t\tsleep(rand()%10);\n\t\tif (t)  //B\n\t\t{\n\t\t\twhile (ADecB &gt; -M)\n\t\t\t{\n\t\t\t\tsem_wait(&amp;AStore);\n\t\t\t\tprintf(&#34;I am %c%d, now A-B = %d&#34;, &#39;B&#39;, id, ADecB);\n\t\t\t\tADecB--;\n\t\t\t\tsem_post(&amp;BStore);\n\t\t\t}\n\t\t}\n\t\telse  //A\n\t\t{\n\t\t\twhile (ADecB &lt; N)\n\t\t\t{\n\t\t\t\tsem_wait(&amp;AStore);\n\t\t\t\tprintf(&#34;I am %c%d, now A-B = %d&#34;, &#39;A&#39;, id, ADecB);\n\t\t\t\tADecB&#43;&#43;;\n\t\t\t\tsem_post(&amp;BStore);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tsem_init(&amp;AStore, 0, 1);\n\tsem_init(&amp;BStore, 0, 1);\n\tpthread_t AId[5], BId[5];\n\tsrand((unsigned)time(NULL));\n\tfor (int i = 0; i &lt; 5; i&#43;&#43;)\n\t{\n\t\tpthread_create(AId&#43;i, 0, store, new int(5*i));\n\t\tpthread_create(BId&#43;i, 0, store, new int(i*5&#43;1));\n\t}\n\tfor (int i = 0; i &lt; 5; i&#43;&#43;)\n\t{\n\t\tpthread_join(AId[i], 0);\n\t\tpthread_join(BId[i], 0);\n\t}\n\treturn 0;\n}\n\n</pre>\n<p></p>", "created": "2015-05-06T14:29:28Z", "bucket_order": 351, "bucket_name": "Week 5/3 - 5/9", "type": "feedback", "tag_good": [], "uid": "i6t1w87gRBD", "children": [], "tag_good_arr": [], "id": "i9cucnz3hbwwf", "updated": "2015-05-06T14:29:28Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>信号量实现&#xff1a;</p>\n<pre>#include &lt;stdio.h&gt;\n#include &lt;pthread.h&gt;\n#include &lt;semaphore.h&gt;\n#include &lt;cstring&gt;\n#include &lt;unistd.h&gt;\n#include &lt;string&gt;\n#include &lt;cstdlib&gt;\n#include &lt;dispatch/dispatch.h&gt;\n#include &lt;assert.h&gt;\nusing namespace std;\n\n#define BUFFER_SIZE 2\n#define SLEEP_SPAN 5\n#define WORK_SPAN 1\n#define WAITCHAIR 3\n\n#define M 5\n#define N 3\n//shared variable\nint A_num = 0;\nint B_num = 0;\n\n//mutex\ndispatch_semaphore_t mutex;\n\n//Sync\ndispatch_semaphore_t A_ok, B_ok;\n\n\nstruct arg_struct{\n\targ_struct(int _id, int _start, int _work, string _indent): id(_id), start(_start), work(_work), indent(_indent){}\n\targ_struct(int _id): id(_id), start(0), work(0), indent(string(&#34;&#34;)){}\n\tint id;\n\tint start;\n\tint work;\n\tstring indent;\t\n};\nstring global(&#34;\\t\\t&#34;);\n//First role\nvoid* Producer(void* argv){\n\targ_struct arg = *(arg_struct*)argv;\n\tint id = arg.id;\n\tconst char* indent = arg.indent.c_str();\n\tsleep(arg.start);\n    int worktime = arg.work;\n//start\n    printf(&#34;%sSTART\\n&#34;, indent);\n    while(1){\n        int type = rand() % 2;\n        if (type == 0){ // Produce A\n            dispatch_semaphore_wait(A_ok, DISPATCH_TIME_FOREVER);\n            dispatch_semaphore_wait(mutex, DISPATCH_TIME_FOREVER);\n            printf(&#34;%ssProA:%d\\n&#34;, indent, A_num);\n            sleep(arg.work);\n            A_num&#43;&#43;;\n            printf(&#34;%seProA:%d\\n&#34;, indent, A_num);\n            printf(&#34;%sA-B:%d\\n&#34;, global.c_str(), A_num-B_num);\n            dispatch_semaphore_signal(mutex);\n            dispatch_semaphore_signal(B_ok);\n        }else{ //Produce B\n            dispatch_semaphore_wait(B_ok, DISPATCH_TIME_FOREVER);\n            dispatch_semaphore_wait(mutex, DISPATCH_TIME_FOREVER);\n            printf(&#34;%ssProB:%d\\n&#34;, indent, B_num);\n            sleep(arg.work);\n            B_num&#43;&#43;;\n            printf(&#34;%seProB:%d\\n&#34;, indent, B_num);\n            printf(&#34;%sA-B:%d\\n&#34;, global.c_str(), A_num-B_num);\n            dispatch_semaphore_signal(mutex);\n            dispatch_semaphore_signal(A_ok);\n        }\n    }\n//end\n    \n\treturn NULL;\n}\n\n//Second role\nvoid* Consumer(void* argv){\n\targ_struct arg = *(arg_struct*)argv;\n\tint id = arg.id;\n\tconst char* indent = arg.indent.c_str();\n\tsleep(arg.start);\n    printf(&#34;%sSTART\\n&#34;, indent);\n//start\n    while(1){\n\n    }\n//end\n    \n\treturn NULL;\n}\n\nint main(int argc, char** argv) {\n\tsrand((unsigned)time(NULL));\n    \n//init of shared variable\n\n//init of mutex\n    mutex = dispatch_semaphore_create(1);\n    A_ok = dispatch_semaphore_create(M);\n    B_ok = dispatch_semaphore_create(N);\n    \n//init of role name ( First is Barber, Second is Consumer )\n    #define First 0\n\t#define Second 1\n\n    //init of thread num\n    const int f_num = 2;\n    const int s_num = 0;\n    \n    int t_num = f_num&#43;s_num;\n    \n    int f_count = 0;\n    int s_count = 0;\n    \n    //init of thread array\n    pthread_t p_f[f_num], p_s[s_num];\n    \n    //init of role array\n    char role[] = {&#39;F&#39;,&#39;F&#39;};\n    int st_time[] = {0, 1};\n    \n\t/* For managed creation of t_num threads */\n    int inst[t_num][3];\n    for (int i = 0; i &lt; t_num; i&#43;&#43;){\n        bool finish = false;\n        if (role[i] == &#39;F&#39;){\n            inst[i][0] = First;\n            inst[i][1] = st_time[i];\n            inst[i][2] = WORK_SPAN;\n            finish = true;\n        }\n        if (role[i] == &#39;S&#39;){\n            inst[i][0] = Second;\n            inst[i][1] = st_time[i];\n            inst[i][2] = WORK_SPAN;\n            finish = true;\n         }\n        assert(finish == true);\n        \n    }\n\n\t/* Print the first line */\n\tint tmp_c = 0, tmp_p = 0;\n\tfor (int i = 0; i &lt; t_num; i&#43;&#43;){\n\t\tif (inst[i][0] == First){\n\t\t\tprintf(&#34;P%d\\t&#34;, tmp_p&#43;&#43;);\n\t\t} else if (inst[i][0] == Second){\n\t\t\tprintf(&#34;C%d\\t&#34;, tmp_c&#43;&#43;);\n\t\t}\n\t}\n    printf(&#34;A-B\\t&#34;);\n\tprintf(&#34;\\n&#34;);\n\n\t/* Create Producers and Consumers according to $inst*/\n\tint rc;\n\tstring indent(&#34;&#34;);\n\tfor (int i = 0; i &lt; t_num; i&#43;&#43;){\n\t\tif (inst[i][0] == First){\n\t\t\t//printf(&#34;Main: Producer %d created\\n&#34;, p_count);\n\t\t\trc = pthread_create(p_f &#43; f_count, NULL, Producer, new arg_struct(f_count, inst[i][1], inst[i][2], indent));\n\t\t\tif (rc) printf(&#34;ERROR\\n&#34;);\n\t\t\tf_count&#43;&#43;;\n\t\t} else if (inst[i][0] == Second){\n\t\t\t//printf(&#34;Main: Consumer %d created\\n&#34;, c_count);\n\t\t\trc = pthread_create(p_s &#43; s_count, NULL, Consumer, new arg_struct(s_count, inst[i][1], inst[i][2], indent));\n\t\t\tif (rc) printf(&#34;ERROR\\n&#34;);\n\t\t\ts_count&#43;&#43;;\n\t\t}\n\t\tindent &#43;= &#39;\\t&#39;;\n\t}\n\n\t/* wait until every thread finishes*/\n\tfor (int i = 0; i &lt; f_count; i&#43;&#43;){\n\t\tpthread_join(p_f[i], NULL);\n\t}\n\tfor (int i = 0; i &lt; s_count; i&#43;&#43;){\n\t\tpthread_join(p_s[i], NULL);\n\t}\n\n\treturn 0;\n}</pre>\n<p>实验结果如下&#xff1a;</p>\n<p><img src=\"/img/391-727f79ebdc81d9ad.png\" alt=\"\" /></p>", "created": "2018-05-20T13:19:23Z", "bucket_order": 192, "bucket_name": "Week 5/20 - 5/26", "type": "feedback", "tag_good": [], "uid": "isvxeq6bspf1vn", "children": [], "tag_good_arr": [], "id": "jheum3m42jd2ny", "updated": "2018-05-20T13:19:23Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "i9ccwfhwe1v6l4", "updated": "2015-05-06T06:20:57Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>计23 李天润</p>\n<p><a href=\"http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync07\">(二)扩展二(北大1995)</a></p>\n<p><a href=\"http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync07\">http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync07</a></p>\n<p></p>", "created": "2015-05-06T06:22:03Z", "bucket_order": 351, "bucket_name": "Week 5/3 - 5/9", "type": "followup", "tag_good": [], "uid": "i6roqnlkmtw", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p><pre>#include &lt;iostream&gt;\n#include &lt;pthread.h&gt;\n#include &lt;semaphore.h&gt;\n\nusing namespace std;\n\nsem_t semA;\nsem_t semB;\n\nint numA = 2;\nint numB = 2;\n\nint M = 3;\nint N = 4;\n\nvoid init(){\n    sem_init(&amp;semA, 0, 1);\n    sem_init(&amp;semB, 0, 1);\n}\n\nvoid* funcA(void* arg){\n    for(int i=0; i&lt;100; i&#43;&#43;){\n        sem_wait(&amp;semA);\n        if(numA - numB == N || numA == N){\n            sem_post(&amp;semA);\n            continue;\n        }\n        cout&lt;&lt;&#34;A in&#34;&lt;&lt;endl;\n        numA&#43;&#43;;\n        sem_post(&amp;semA);\n    }\n    return NULL;\n}\n\nvoid* funcB(void* arg){\n    for(int i=0; i&lt;100; i&#43;&#43;){\n        sem_wait(&amp;semB);\n        if(numB - numA == M || numB == N){\n            sem_post(&amp;semB);\n            continue;\n        }\n        cout&lt;&lt;&#34;B in&#34;&lt;&lt;endl;\n        numB&#43;&#43;;\n        sem_post(&amp;semB);\n    }\n    return NULL;\n}\n\nvoid* funcC(void* arg){\n    for(int i=0; i&lt;50; i&#43;&#43;){\n        sem_wait(&amp;semA);\n        sem_wait(&amp;semB);\n        if(numA == 0 || numB == 0){\n            sem_post(&amp;semA);\n            sem_post(&amp;semB);\n            continue;\n        }\n        cout&lt;&lt;&#34;C out&#34;&lt;&lt;endl;\n        numA--;\n        numB--;\n        sem_post(&amp;semA);\n        sem_post(&amp;semB);\n    }\n    return NULL;\n}\n\nint main(int argc, char const *argv[])\n{\n    init();    \n    pthread_t thread[3];\n    pthread_create(&amp;thread[0], 0, funcA, NULL);\n    pthread_create(&amp;thread[1], 0, funcB, NULL);\n    pthread_create(&amp;thread[2], 0, funcC, NULL);\n\n    for (int i = 0; i &lt; 3; &#43;&#43;i)\n        pthread_join(thread[i], 0);\n\n    return 0;\n}</pre>\n<p></p>", "created": "2015-05-06T07:07:57Z", "bucket_order": 351, "bucket_name": "Week 5/3 - 5/9", "type": "feedback", "tag_good": [], "uid": "i6roqnlkmtw", "children": [], "tag_good_arr": [], "id": "i9cekva510244y", "updated": "2015-05-06T07:07:57Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "i9ccxuk4ean2lx", "updated": "2015-05-06T06:22:03Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>8. 进程同步问题&#xff1a;生产者-消费者-扩展三</p>\n<p><a href=\"http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync08\">http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync08</a></p>\n<p></p>\n<p>计13 张宏辉 2011011237</p>", "created": "2015-05-06T06:22:21Z", "bucket_order": 351, "bucket_name": "Week 5/3 - 5/9", "type": "followup", "tag_good": [], "uid": "hs2sszu8rbz6jj", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i9ccy8k0xj02ul", "updated": "2015-05-06T06:22:21Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>计24 李心成 2012012057</p>\n<p>10</p>\n<p><a href=\"http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync10\">http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync10</a></p>\n<p></p>\n<pre>import time\nimport threading\nimport Queue\nimport random\n\nqueue = Queue.Queue()\t\t#thread safe\nreadThreadNum = 0\nwaitWriteThreadNum = 0\ncountMutex = threading.Lock()\nwriteMutex = threading.Lock()\nreadMutex = threading.Lock()\nwaitWriteCountMutex = threading.Lock()\ncv = threading.Condition()\n\nclass WriteThread(threading.Thread):\n\tdef __init__(self, index):\n\t\tthreading.Thread.__init__(self)\n\t\tself.mode = &#39;WRITE&#39;\n\t\tself.index = index\n\n\tdef write(self):\n\t\tglobal readThreadNum\n\t\tglobal countMutex\n\t\tglobal writeMutex\n\t\tglobal queue\n\t\tglobal waitWriteThreadNum\n\t\tglobal waitWriteCountMutex\n\t\tglobal cv\n\n\t\tisLastWriteThread = False\n\t\t#queue.put(self, True)\n\n\t\twaitWriteCountMutex.acquire()\n\t\twaitWriteThreadNum &#43;= 1\n\t\twaitWriteCountMutex.release()\n\n\t\twriteMutex.acquire()\n\n\t\twaitWriteCountMutex.acquire()\n\t\twaitWriteThreadNum -= 1\n\t\tif waitWriteThreadNum == 0:\n\t\t\tisLastWriteThread = True\n\t\twaitWriteCountMutex.release()\n\n\t\tprint &#39;thread &#39; &#43; str(self.index) &#43; &#39; writing...&#39;\n\t\ttime.sleep(random.random())\n\t\tprint &#39;thread &#39; &#43; str(self.index) &#43; &#39; quit&#39;\n\n\t\t#queue.get(True)\n\n\t\tif isLastWriteThread:\n\t\t\tcv.acquire()\n\t\t\tcv.notifyAll()\n\t\t\tcv.release()\n\t\telse:\n\t\t\twriteMutex.release()\n\n\tdef run(self):\n\t\tself.write()\n\nclass ReadThread(threading.Thread):\n\tdef __init__(self, index):\n\t\tthreading.Thread.__init__(self)\n\t\tself.mode = &#39;READ&#39;\n\t\tself.index = index\n\n\tdef read(self):\n\t\tglobal readThreadNum\n\t\tglobal countMutex\n\t\tglobal writeMutex\n\t\tglobal queue\n\t\tglobal waitWriteThreadNum\n\t\tglobal waitWriteCountMutex\n\t\tglobal cv\n\n\t\t#queue.put(self, True)\n\n\t\tcountMutex.acquire()\n\t\tif readThreadNum == 0 and waitWriteThreadNum == 0:\n\t\t\twriteMutex.acquire()\n\t\telif waitWriteThreadNum != 0:\n\t\t\tprint &#39;thread &#39; &#43; str(self.index) &#43; &#39; wait after waitWriteThread&#39;\n\t\t\tcv.acquire()\n\t\t\tcv.wait()\n\t\t\tcv.release()\n\t\treadThreadNum &#43;= 1\n\t\tcountMutex.release()\n\n\t\tprint &#39;thread &#39; &#43; str(self.index) &#43; &#39; reading...&#39;\n\t\ttime.sleep(random.random())\n\t\tprint &#39;thread &#39; &#43; str(self.index) &#43; &#39; quit&#39;\n\n\t\t#queue.get(True)\n\t\tcountMutex.acquire()\n\t\treadThreadNum -= 1\n\t\tif readThreadNum == 0:\n\t\t\twriteMutex.release()\n\t\tcountMutex.release()\n\n\tdef run(self):\n\t\tself.read()\n\n#main test thread\ndef test():\n\tReadThread(0).start()\n\tWriteThread(1).start()\n\tWriteThread(2).start()\n\tReadThread(3).start()\n\tReadThread(4).start()\n\tReadThread(5).start()\n\n\nif __name__ == &#39;__main__&#39;:\n\ttest()</pre>\n<p>有bug&#xff0c;待修复。。。</p>", "created": "2015-05-06T06:23:07Z", "bucket_order": 351, "bucket_name": "Week 5/3 - 5/9", "type": "followup", "tag_good": [], "uid": "i6s09f3xHOf", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i9ccz7mv8cs388", "updated": "2015-05-06T06:23:07Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>9 读者写者问题扩展&#xff08;一&#xff09;</p>\n<p><a href=\"http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync09\">http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync09</a></p>\n<p></p>\n<p>计25 矣晓沅 2012011364</p>", "created": "2015-05-06T06:23:33Z", "bucket_order": 351, "bucket_name": "Week 5/3 - 5/9", "type": "followup", "tag_good": [], "uid": "i6t6y9snjx2", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>矣晓沅</p>\n<p>我做的是读写者问题的扩展一&#xff0c;这个问题在基本的读写者问题上新增了两个要求&#xff1a;一是要求平等第对待读者和写者&#xff0c;而是要求每个资源可以同时读取的线程数有限。</p>\n<p></p>\n<p>第二个要求比较简单&#xff0c;先说第二个要求吧。新增一个信号量threadReadSem&#xff0c;设置初始资源数为最大同时读取线程数。每个线程要读时&#xff0c;需要申请threadReadSem&#xff0c;读完后释放threadReadSem。当当前正在读的线程大于最大可读数时&#xff0c;新的读线程会在申请threadReadSem进入等待&#xff0c;这样就可以保证“每个资源可以同时读取的线程数有限”。</p>\n<p></p>\n<p>第二个问题稍微复杂一些。课上老师举的例子是读优先。即写需要获得WriteSemaphore。读的时候&#xff0c;第一个开始读的读者申请WriteSemaphore&#xff0c;最后一个读完的读者释放WriteSemaphore。所以写者只有等所有人读完后才能写。如何才叫“平等对待”呢&#xff1f;关于这点的理解&#xff0c;我和wiki上几个学长的观点类似&#xff0c;即&#xff1a;当前有k个读者正在读&#xff0c;若某个写着要写&#xff0c;那么写着等待这k个读者读完后开始写&#xff0c;在写着等待这k个读者的过程中&#xff0c;不再允许新的读者开始读。这样的话&#xff0c;每个写着不必等到所有读者读完&#xff0c;而只需 等已经开始读的读者读完。这种“平等”是比较合理的。</p>\n<p></p>\n<p>具体的实现上&#xff0c;和wiki上的学长有些区别。wiki上的学长是用了一个所以再设置一个排队信号量queue&#xff0c;每次读写进程要求访问文件都要在此信号量上排队&#xff0c;根据先来先得公平竟争。我的思路总体来说属于同一类&#xff0c;但是略有区别。我的思路如下&#xff1a;</p>\n<p></p>\n<p>设置一个读者增加信号量AddReadSemaphore&#xff0c;AddReadSemaphore为一个二值信号量。每个写者要写时&#xff0c;先申请AddReadSemaphore&#xff0c;写完后释放AddReadSemaphore。每个读者要读时&#xff0c;首先申请AddReadSemaphore。若申请失败&#xff0c;说明此时有写者准备要写了&#xff0c;不允许增加新的读者。只有等当前读者读完&#xff0c;等待的写者写完&#xff0c;新的读者才能获取AddReadSemaphore并开始写。若AddReadSemaphore申请成功&#xff0c;表示现在没有写者在等待写。由于AddReadSemaphore是二值信号量&#xff0c;所以不能等读完才释放&#xff0c;否则没办法同时多个读者读&#xff0c;所以读者应该在AddReadSemaphore申请成功&#xff0c;读者计数ReaderCount 加1成功后即释放&#xff0c;以便其他读者开始写。</p>\n<p></p>\n<p>具体来说&#xff0c;设计如下四个信号&#xff1a;</p>\n<p></p>\n<p>threadWriteSem 表示能否写&#xff0c;二值信号量</p>\n<p>threadCountSem 控制全局读者计数&#xff0c;二值信号量</p>\n<p>threadReadSem 表示能否度 初值为最大同时读取线程数</p>\n<p>threadAddReadSem 表示能否允许新的读者开始读&#xff0c;二值信号量</p>\n<p></p>\n<p>ReaderCount为当前正在读的线程计数</p>\n<p></p>\n<p>读写流程如下&#xff1a;</p>\n<p></p>\n<p>写者&#xff1a;</p>\n<p>申请threadAddReadSem&#xff0c;进入等待读状态&#xff0c;不再允许新的读者开始读</p>\n<p>申请threadWriteSem&#xff0c;不再允许其他读者或者写者读写</p>\n<p>临界区&#xff0c;进行写</p>\n<p>释放threadWriteSem</p>\n<p>释放threadAddReadSem</p>\n<p></p>\n<p>读者&#xff1a;</p>\n<p>申请threadAddReadSem&#xff0c;当没有写者等待写时可继续</p>\n<p>申请threadReadSem&#xff0c;当前读的线程不超最大限制数目时可继续</p>\n<p>申请threadCountSem</p>\n<p>如果ReaderCount为0&#xff0c;申请threadWriteSem&#xff0c;不允许写者再写</p>\n<p>ReaderCount加1</p>\n<p>释放threadCountSem</p>\n<p>释放threadAddReadSem</p>\n<p>临界区&#xff0c;进行读</p>\n<p>申请threadCountSem</p>\n<p>ReaderCount减1</p>\n<p>如果ReaderCount为0&#xff0c;说明当前正在读的读者都读完了&#xff0c;释放threadWriteSem&#xff0c;让等待写的写者写</p>\n<p>释放threadCountSem</p>\n<p>释放threadReadSem</p>\n<p></p>\n<p>测例如下&#xff0c;设置最大同时读线程数为2</p>\n<p></p>\n<p>threads.append(Writer(&#34;thread&#34;&#43;str(0),threadCountSem,threadWriteSem,threadAddReadSem))</p>\n<p>threads.append(Reader(&#34;thread&#34;&#43;str(1),threadCountSem,threadWriteSem,threadReadSem,threadAddReadSem))</p>\n<p>threads.append(Reader(&#34;thread&#34;&#43;str(2),threadCountSem,threadWriteSem,threadReadSem,threadAddReadSem))</p>\n<p>threads.append(Reader(&#34;thread&#34;&#43;str(3),threadCountSem,threadWriteSem,threadReadSem,threadAddReadSem))</p>\n<p></p>\n<p>threads.append(Writer(&#34;thread&#34;&#43;str(4),threadCountSem,threadWriteSem,threadAddReadSem))</p>\n<p>threads.append(Reader(&#34;thread&#34;&#43;str(5),threadCountSem,threadWriteSem,threadReadSem,threadAddReadSem))</p>\n<p></p>\n<p>for thread in threads:</p>\n<p>thread.start()</p>\n<p></p>\n<p>先让一个写者开始写&#xff0c;又让三个读者开始读&#xff0c;又当一个写者开始写&#xff0c;又让一个读者开始读。读写的临界区了做了1000*1000次的循环&#xff0c;确保下一个thread start时上一个start尚未执行完毕。打印输出结果如下&#xff1a;</p>\n<p></p>\n<p>Thread thread0 is waiting for writing!</p>\n<p>Thread thread0 is writing!</p>\n<p>Thread thread0 &#39;s writing finish!</p>\n<p>Thread thread1 is waiting for reading!</p>\n<p>Thread thread1 is reading! ReaderCount is 1 now</p>\n<p>Thread thread2 is waiting for reading!</p>\n<p>Thread thread2 is reading! ReaderCount is 2 now</p>\n<p>Thread thread3 is waiting for reading!</p>\n<p>Thread thread1 &#39;s reading finish! ReaderCount is 2 now</p>\n<p>Thread thread3 is reading! ReaderCount is 2 now</p>\n<p>Thread thread4 is waiting for writing!</p>\n<p>Thread thread2 &#39;s reading finish! ReaderCount is 2 now</p>\n<p>Thread thread3 &#39;s reading finish! ReaderCount is 1 now</p>\n<p>Thread thread4 is writing!</p>\n<p>Thread thread4 &#39;s writing finish!</p>\n<p>Thread thread5 is waiting for reading!</p>\n<p>Thread thread5 is reading! ReaderCount is 1 now</p>\n<p>Thread thread5 &#39;s reading finish! ReaderCount is 1 now</p>\n<p></p>\n<p>对上述结果做简要说明&#xff1a;线程0&#xff0c;4是写者&#xff0c;其余是读者&#xff0c; “is waiting for writing!”是在申请threadAddReadSem成功后打印的&#xff0c; “is waiting for reading”是在threadAddReadSem申请成功后打印的。从上述结果可看出&#xff0c;线程0写完&#xff0c;线程1开始写&#xff0c;进入临界区&#xff1b;线程二开始写&#xff0c;进入临界区&#xff1b;线程三申请threadAddReadSem成功&#xff0c;但是最大同时读线程为2&#xff0c;threadReadSem申请失败。等到1读完&#xff0c;3才进入临界区。此时4要写&#xff0c;申请threadAddReadSem成功&#xff0c;进入等待状态。5应该要开始写&#xff0c;但是4进入等待写&#xff0c;5申请threadAddReadSem失败&#xff0c;所以此时没有打印5的信息。而是看到&#xff0c;2和3都读完后&#xff0c;4进入写临界区。等4写完&#xff0c;5才开始读。</p>\n<p></p>\n<p>写者代码&#xff1a;</p>\n<p>#coding=utf-8<br />import threading  <br />import random  <br />import time  <br /><br />class Writer(threading.Thread):  <br />    &#34;&#34;&#34;class using semaphore&#34;&#34;&#34;  <br /><br />    def __init__(self,threadName,CountSem,WriteSem,AddRead):  <br />       <br />       &#34;&#34;&#34;initialize thread&#34;&#34;&#34;  <br /><br />       threading.Thread.__init__(self,name=threadName)  <br />       #self.sleepTime = random.randrange(1,6)  <br />       <br />       #set the semaphore as a data attribute of the class  <br />    &amp;nb</p>", "created": "2015-05-06T14:58:50Z", "bucket_order": 351, "bucket_name": "Week 5/3 - 5/9", "type": "feedback", "tag_good": [], "uid": "i6t6y9snjx2", "children": [], "tag_good_arr": [], "id": "i9cvefwctzu2au", "updated": "2015-05-06T14:58:50Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>self.CountSemaphore = CountSem<br />       self.WriteSemaphore = WriteSem<br />       self.AddReadSemaphore = AddRead<br /><br /><br />   <br />    def run(self):  <br />       &#34;&#34;&#34;Print message and release semaphore&#34;&#34;&#34;  <br /><br />       #acquire write mutex<br />       self.AddReadSemaphore.acquire()<br />       print &#34; Thread %s  is waiting for writing!&#34; % (self.getName()) <br />       self.WriteSemaphore.acquire() <br />       print &#34; Thread %s  is writing!&#34; % (self.getName()) <br />       for i in range(1,1000):<br />        for j in range(1,1000):<br />          (i&#43;j) % 23<br />       print &#34; Thread %s  &#39;s writing finish!&#34; % (self.getName()) <br />       <br />       #release the  write mutex  <br />       self.WriteSemaphore.release()  <br />       self.AddReadSemaphore.release()</p>", "created": "2015-05-06T14:59:51Z", "bucket_order": 351, "bucket_name": "Week 5/3 - 5/9", "type": "feedback", "tag_good": [], "uid": "i6t6y9snjx2", "children": [], "tag_good_arr": [], "id": "i9cvfqflw165t1", "updated": "2015-05-06T14:59:51Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>读者代码&#xff1a;</p>\n<p>class Reader(threading.Thread):  <br />    &#34;&#34;&#34;class using semaphore&#34;&#34;&#34;  <br /><br />    def __init__(self,threadName,CountSem,WriteSem,ReadSem,AddRead):  <br /><br />      &#34;&#34;&#34;initialize thread&#34;&#34;&#34;  <br /><br /><br />      threading.Thread.__init__(self,name=threadName)  <br />      #self.sleepTime=random.randrange(1,6) <br />      #self.sleepTime = random.randrange(1,6)  <br />       <br />      #set the semaphore as a data attribute of the class  <br />       <br />      self.CountSemaphore = CountSem<br />      self.WriteSemaphore = WriteSem<br />      self.ReadSemaphore = ReadSem<br />      self.AddReadSemaphore = AddRead<br /><br />    def run(self):<br />      #acquire write mutex<br />      global ReaderCount<br />      self.AddReadSemaphore.acquire()<br />      print &#34; Thread %s  is waiting for  reading!&#34; % (self.getName()) <br />      self.ReadSemaphore.acquire()<br />      <br />      self.CountSemaphore.acquire() <br />      if ReaderCount == 0:<br />        self.WriteSemaphore.acquire()<br />      <br />      ReaderCount = ReaderCount &#43; 1<br /><br />      self.CountSemaphore.release()<br />      self.AddReadSemaphore.release()<br /><br /><br /><br />      print &#34; Thread %s  is reading! ReaderCount is %d now&#34; % (self.getName(),ReaderCount)<br />      for i in range(1,1000):<br />        for j in range(1,1000):<br />          (i&#43;j) % 23<br />      print &#34; Thread %s  &#39;s reading finish! ReaderCount is %d now&#34; % (self.getName(),ReaderCount)<br /><br />      self.CountSemaphore.acquire()<br />      ReaderCount = ReaderCount - 1<br />      if (ReaderCount == 0):<br />          self.WriteSemaphore.release(); <br />      #release the  write mutex  <br />      self.CountSemaphore.release()  <br />      self.ReadSemaphore.release()</p>", "created": "2015-05-06T15:00:22Z", "bucket_order": 351, "bucket_name": "Week 5/3 - 5/9", "type": "feedback", "tag_good": [], "uid": "i6t6y9snjx2", "children": [], "tag_good_arr": [], "id": "i9cvgef83osyz", "updated": "2015-05-06T15:00:22Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>按向老师的建议&#xff0c;在Reader和Writer的构造函数里加入了读/写时间的参数设置&#xff0c;已控制读者写者的读写顺序。新的测试用例及结果说明如下&#xff1a;</p>\n<p>github的地址是&#xff1a;<a href=\"https://github.com/MtMoon/os_exercises/blob/master/all/ReaderWriteProblem/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E5%8F%8A%E7%BB%93%E6%9E%9C.md\">https://github.com/MtMoon/os_exercises/blob/master/all/ReaderWriteProblem/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E5%8F%8A%E7%BB%93%E6%9E%9C.md</a></p>\n<p></p>\n<p></p>\n<p>信号量说明&#xff1a;</p>\n<p></p>\n<p>threadWriteSem 表示能否写&#xff0c;二值信号量&#xff0c;用于读写互斥控制</p>\n<p>threadCountSem 控制全局读者计数&#xff0c;二值信号量</p>\n<p>threadReadSem 表示能否读 初值为最大同时读取线程数&#xff0c;用于最大同时读线程数目控制</p>\n<p>threadAddReadSem 表示能否允许新的读者开始读&#xff0c;二值信号量&#xff0c;用于写者等待是锁定</p>\n<p></p>\n<p></p>\n<p>*1.* 测试最大同时读者数限制</p>\n<p></p>\n<p>设定最大同时读者数为2&#xff0c;测例如下&#xff0c;其中&#xff0c;Reader构造函数的3是读时间设置&#xff0c;设为3秒</p>\n<p></p>\n<p>threads.append( Reader(&#34;thread&#34;&#43;str(1), threadCountSem, threadWriteSem, threadReadSem, threadAddReadSem, 3) )</p>\n<p>threads.append(Reader(&#34;thread&#34;&#43;str(2),threadCountSem,threadWriteSem,threadReadSem,threadAddReadSem,3 ))</p>\n<p>threads.append(Reader(&#34;thread&#34;&#43;str(3),threadCountSem,threadWriteSem,threadReadSem,threadAddReadSem,3))</p>\n<p></p>\n<p>运行结果如下&#xff1a;</p>\n<p></p>\n<p>Thread thread1 enters function run() and is waiting for AddReadSemaphore!</p>\n<p>Thread thread1 is waiting for ReadSemaphore!</p>\n<p>Thread thread2 enters function run() and is waiting for AddReadSemaphore!</p>\n<p>Thread thread3 enters function run() and is waiting for AddReadSemaphore!</p>\n<p>Thread thread1 is waiting for WriteSemaphore!</p>\n<p>Thread thread1 is reading! ReaderCount is 1 now</p>\n<p>Thread thread2 is waiting for ReadSemaphore!</p>\n<p>Thread thread2 is reading! ReaderCount is 2 now(1)</p>\n<p>Thread thread3 is waiting for ReadSemaphore!(2)</p>\n<p>Thread thread2 &#39;s reading finish!(3)</p>\n<p>Thread thread3 is reading! ReaderCount is 2 now(4)</p>\n<p>Thread thread1 &#39;s reading finish!</p>\n<p>Thread thread3 &#39;s reading finish!</p>\n<p></p>\n<p></p>\n<p>测试结果说明&#xff1a;从上述测试结果可以看到&#xff0c;线程1,2正在读时&#xff0c;(1)处可以看到ReadCount为2&#xff0c;表面现在有两个读者同时读&#xff0c;而(2)处的读者3只能等在ReadSemaphore信号量上&#xff0c;直到(3)处有一个读者读完&#xff0c;(4)处的读者三才能开始读</p>\n<p></p>\n<p>*2.* 测试写者互斥</p>\n<p></p>\n<p>测试用例如下&#xff1a;</p>\n<p></p>\n<p>threads.append(Writer(&#34;thread&#34;&#43;str(0),threadCountSem,threadWriteSem,threadAddReadSem,5))</p>\n<p>threads.append(Writer(&#34;thread&#34;&#43;str(1),threadCountSem,threadWriteSem,threadAddReadSem,5))</p>\n<p></p>\n<p>输出结果如下&#xff1a;</p>\n<p></p>\n<p>Thread thread0 is waiting for writing!</p>\n<p>Thread thread0 is writing!</p>\n<p>Thread thread0 &#39;s writing finish!</p>\n<p>Thread thread1 is waiting for writing!</p>\n<p>Thread thread1 is writing!</p>\n<p>Thread thread1 &#39;s writing finish!</p>\n<p></p>\n<p>可以看到两个写者不同同时进入临界区&#xff0c;只有前一个finish后一个才开始写。</p>\n<p></p>\n<p></p>\n<p>*3.* 测试写者写时读者不能读且写者不能被读者打断(读写互斥)</p>\n<p></p>\n<p>测试用例如下&#xff0c;先后启动一个读者和一个写者&#xff0c;写者写时间设定为5s</p>\n<p></p>\n<p>threads.append(Writer(&#34;thread&#34;&#43;str(0),threadCountSem,threadWriteSem,threadAddReadSem,5))</p>\n<p>threads.append( Reader(&#34;thread&#34;&#43;str(1), threadCountSem, threadWriteSem, threadReadSem, threadAddReadSem, 3) )</p>\n<p></p>\n<p>结果如下&#xff1a;</p>\n<p></p>\n<p>Thread thread0 is waiting for writing!</p>\n<p>Thread thread0 is writing!</p>\n<p>Thread thread1 enters function run() and is waiting for AddReadSemaphore!</p>\n<p>Thread thread0 &#39;s writing finish!</p>\n<p>Thread thread1 is waiting for ReadSemaphore!</p>\n<p>Thread thread1 is waiting for WriteSemaphore!</p>\n<p>Thread thread1 is reading! ReaderCount is 1 now</p>\n<p>Thread thread1 &#39;s reading finish!</p>\n<p></p>\n<p>测试结果说明&#xff1a;写者0开始写之后&#xff0c;读者1进入了run()函数&#xff0c;但是写者写时&#xff0c;锁定了AddReadSemaphore信号量&#xff0c;读者无法开始读&#xff0c;自导写者写完&#xff0c;读者才能相继获得其他信号量开始读。</p>\n<p></p>\n<p>*4.* 测试写者申请写时&#xff0c;新的读者不能再加入</p>\n<p></p>\n<p>测试用例如下&#xff1a;</p>\n<p></p>\n<p>threads.append( Reader(&#34;thread&#34;&#43;str(1), threadCountSem, threadWriteSem, threadReadSem, threadAddReadSem, 5) )</p>\n<p>threads.append(Writer(&#34;thread&#34;&#43;str(2),threadCountSem,threadWriteSem,threadAddReadSem,3))</p>\n<p>threads.append(Reader(&#34;thread&#34;&#43;str(3),threadCountSem,threadWriteSem,threadReadSem,threadAddReadSem,3 ))</p>\n<p></p>\n<p>先启动一个读者1&#xff0c;读者1正在读时启动一个写者2&#xff0c;写者2申请写&#xff0c;再启动一个读者3.输出结果如下&#xff1a;</p>\n<p></p>\n<p>Thread thread1 enters function run() and is waiting for AddReadSemaphore!</p>\n<p>Thread thread1 is waiting for ReadSemaphore!</p>\n<p>Thread thread1 is waiting for WriteSemaphore!</p>\n<p>Thread thread1 is reading! ReaderCount is 1</p>", "created": "2015-05-15T08:20:01Z", "bucket_order": 350, "bucket_name": "Week 5/10 - 5/16", "type": "feedback", "tag_good": [], "uid": "i6t6y9snjx2", "children": [], "tag_good_arr": [], "id": "i9pc48boob36qx", "updated": "2015-05-15T08:20:01Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>这个测试用例设计是很好的&#xff0c;可以发现算法的可能错误。建议其他同学仿照这里的做法&#xff0c;测试自己的同学算法。</p>", "created": "2015-05-15T15:06:11Z", "bucket_order": 350, "bucket_name": "Week 5/10 - 5/16", "type": "feedback", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [], "tag_good_arr": [], "id": "i9pqmjzgoah2f", "updated": "2015-05-15T15:06:11Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "i9cczrm0mvv2zx", "updated": "2015-05-06T06:23:33Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>11.进程同步问题&#xff1a;吸烟者问题拓展一 &#xff08;北大1999&#xff09;</p>\n<p><a href=\"http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync11\">http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync11</a></p>\n<p></p>\n<p>计22 滕爽 2012011270</p>", "created": "2015-05-06T06:34:28Z", "bucket_order": 351, "bucket_name": "Week 5/3 - 5/9", "type": "followup", "tag_good": [], "uid": "i6vkh2uqu3V", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p><pre>package test;\n\nimport java.util.Random;\nimport java.util.concurrent.Semaphore;\n\n\npublic class question11 {\n\t\n    public static void main(String[] args) {\n    \tSemaphore sem_seller = new Semaphore(1);\n    \tSemaphore sem_goods1 = new Semaphore(0);\n\t\tSemaphore sem_goods2 = new Semaphore(0);\n\t\tSemaphore sem_goods3 = new Semaphore(0);\n\n\t\tseller a = new seller(sem_seller, sem_goods1, sem_goods2, sem_goods3);\n    \tlistener listener1 = new listener(&#34;group one&#34;,0, sem_seller, sem_goods1);\n    \tlistener listener2 = new listener(&#34;group two&#34;,1, sem_seller, sem_goods2);\n    \tlistener listener3 = new listener(&#34;group three&#34;,2, sem_seller, sem_goods3);\n    \t\n    \ta.start();\n    \tlistener1.start();\n    \tlistener2.start();\n    \tlistener3.start();\n    \t\n    }\n}\nclass seller extends Thread{\n\tSemaphore sem_seller;\n\tSemaphore sem_goods1;\n\tSemaphore sem_goods2;\n\tSemaphore sem_goods3;\n\tseller(Semaphore sem_seller,Semaphore sem_goods1, Semaphore sem_goods2,Semaphore sem_goods3){\n\t\tthis.sem_seller = sem_seller;\n\t\tthis.sem_goods1 = sem_goods1;\n\t\tthis.sem_goods2 = sem_goods2;\n\t\tthis.sem_goods3 = sem_goods3;\n\t}\n\t\n\tpublic void run(){\n\t\twhile(true){\n\t\t\ttry {\n\t\t\t\tthis.sem_seller.acquire();\n\t\t\t\tint max=3;\n\t\t        int min=0;\n\t\t        Random random = new Random();\n\t\t        int s = random.nextInt(max)%(max-min&#43;1) &#43; min;\n\t\t        System.out.println(&#34;-------------Seller-------------&#34;);\n\t            if(s == 0){\n\t            \tSystem.out.println(&#34;Sell Tape, Battery&#34;);\n\t                this.sem_goods1.release();\n\t            }\n\t            if(s == 1){\n\t            \tSystem.out.println(&#34;Sell Walkman, Battery&#34;);\n\t                this.sem_goods2.release();\n\t            }\n\t            if(s == 2){\n\t            \tSystem.out.println(&#34;Sell Walkman, Tape&#34;);\n\t                this.sem_goods3.release();\n\t            }\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass listener extends Thread{\n\tint need;\n\tSemaphore sem_seller;\n\tSemaphore sem_goods;\n\tString name;\n\tlistener(String name,int need,Semaphore sem_seller,Semaphore sem_goods){\n\t\t this.need = need;\n\t\t this.sem_seller = sem_seller;\n\t\t this.name = name;\n\t     this.sem_goods = sem_goods;\n\t}\n\tpublic void run(){\n\t\twhile(true){\n            try {\n\t            this.sem_goods.acquire();\n\t\t    if (need == 0){\n\t\t\tSystem.out.println(&#34;-------------&#34; &#43; this.name &#43; &#34;-------------&#34;);\n\t\t\tSystem.out.println(&#34;Buy Tape, Battery.&#34;);\n\t\t    }\n\t            if(need == 1){\n\t            \tSystem.out.println(&#34;-------------&#34; &#43; this.name &#43; &#34;-------------&#34;);\n\t            \tSystem.out.println(&#34;Buy Walkman, Battery.&#34;);\n\t            }\n\t            if(need == 2){\n\t            \tSystem.out.println(&#34;-------------&#34; &#43; this.name &#43; &#34;-------------&#34;);\n\t            \tSystem.out.println(&#34;Buy Walkman, Tape.&#34;);\n\t            }\n\t            sleep(2);\n\t            this.sem_seller.release();\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n}</pre>\n<p></p>", "created": "2015-05-06T09:47:58Z", "bucket_order": 351, "bucket_name": "Week 5/3 - 5/9", "type": "feedback", "tag_good": [], "uid": "i6vkh2uqu3V", "children": [], "tag_good_arr": [], "id": "i9ckanzmlwb3fs", "updated": "2015-05-06T09:47:58Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>-------------Seller-------------<br />Sell Walkman, Tape<br />-------------group three-------------<br />Buy Walkman, Tape.<br />-------------Seller-------------<br />Sell Walkman, Battery<br />-------------group two-------------<br />Buy Walkman, Battery.<br />-------------Seller-------------<br />Sell Tape, Battery<br />-------------group one-------------<br />Buy Tape, Battery.<br />-------------Seller-------------<br />Sell Walkman, Tape<br />-------------group three-------------<br />Buy Walkman, Tape.<br />-------------Seller-------------<br />Sell Tape, Battery<br />-------------group one-------------<br />Buy Tape, Battery.<br />-------------Seller-------------<br />Sell Walkman, Tape<br />-------------group three-------------<br />Buy Walkman, Tape.</p>", "created": "2015-05-11T05:41:19Z", "bucket_order": 350, "bucket_name": "Week 5/10 - 5/16", "type": "feedback", "tag_good": [], "uid": "i6vkh2uqu3V", "children": [], "tag_good_arr": [], "id": "i9jgoqbg32w6tk", "updated": "2015-05-11T05:41:19Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "i9cddt2yxox6c9", "updated": "2015-05-06T06:34:28Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>12. 电影院问题&#xff08;吸烟者问题扩展2&#xff09;</p>\n<p><a href=\"http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync12\">http://os.cs.tsinghua.edu.cn/oscourse/OS2013/lab7/sync12</a></p>\n<p></p>\n<p>计25 董欣 2012011361</p>", "created": "2015-05-06T06:35:59Z", "bucket_order": 351, "bucket_name": "Week 5/3 - 5/9", "type": "followup", "tag_good": [], "uid": "i6uaz13iyeM", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i9cdfracelt7g6", "updated": "2015-05-06T06:35:59Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>罗鸿胤 2012011319</p>\n<p></p>\n<p>29. 阅览室问题 有一个阅览室&#xff0c;共有100个座位&#xff0c;读者进入时必须先在一张登记表上登记&#xff0c;该表为每一个座位列一表目&#xff0c;包括座号和读者姓名等&#xff0c;读者离开时要消掉登记的信息&#xff0c;试问&#xff1b;</p>\n<p></p>\n<p>(1)为描述读者的动作&#xff0c;应编写几个程序&#xff0c;设置几个进程&#xff1f;</p>\n<p>编写一个程序&#xff0c;用锁描述登记表&#xff0c;用线程描述人&#xff0c;因此一个程序&#xff0c;一个进程即可</p>\n<p></p>\n<p>(2)试用PV操作描述各个进程之间的同步互斥关系。</p>\n<p></p>\n<pre>#coding=utf-8\nimport threading\nimport random\nimport time\n\nmutex = threading.Lock()\n\nclass TableThread(threading.Thread):\n\n    availableTables = range(100)\n\n    def __init__(self,threadName,semaphore):\n        &#34;&#34;&#34;initialize thread&#34;&#34;&#34;\n        threading.Thread.__init__(self,name = threadName)\n        self.sleepTime=random.randrange(1,6)\n        #set the semaphore as a data attribute of the class\n        self.threadSemaphore = semaphore\n    def run(self):\n        &#34;&#34;&#34;Print message and release semaphore&#34;&#34;&#34;\n\n        #acquire the semaphore\n        if mutex.acquire():\n            print &#34;%s is using the check area&#34; %(self.getName())\n            print &#34;%s is leaving the check area&#34; %(self.getName())\n            mutex.release()\n            self.threadSemaphore.acquire()\n            #remove a table from the list\n            table = TableThread.availableTables.pop()\n            print &#34;%s entered;seated at table %s.&#34; %(self.getName(),table),\n            print len(TableThread.availableTables)\n            time.sleep(self.sleepTime)\n            if mutex.acquire():\n                #free a table\n                print &#34;%s is using the check area&#34; %(self.getName())\n                print &#34;%s exiting;freeing table %s.&#34; %(self.getName(),table),\n                TableThread.availableTables.append(table)\n                print len(TableThread.availableTables)\n                #release the semaphore after execution finishes\n                self.threadSemaphore.release()\n                print &#34;%s is leaving the check area&#34; %(self.getName())\n                mutex.release()\n\nthreads = [] #list of threads\n#semaphore allows five threads to enter critical section\n#checkSemaphore = threading.Semaphore(len(CheckThread.availableCheck))\ntableSemaphore = threading.Semaphore(len(TableThread.availableTables))\n#创建一个threading.Semaphore对象&#xff0c;他最多允许5个线程访问临界区。\n#Semaphore类的一个对象用计数器跟踪获取和释放信号量的线程数量。\n#create ten threads\nfor i in range(1,11):\n    #threads.append([CheckThread(&#34;thread&#34;&#43;str(i),checkSemaphore),TableThread(&#34;thread&#34; &#43; str(i),tableSemaphore)])\n    threads.append(TableThread(&#34;thread&#34; &#43; str(i),tableSemaphore))\n#创建一个列表&#xff0c;该列表由SemaphoreThread对象构成&#xff0c;start方法开始列表中的每个线程\n#start each thread\nfor thread in threads:\n    thread.start()</pre>\n<p></p>", "created": "2015-05-06T06:48:39Z", "bucket_order": 351, "bucket_name": "Week 5/3 - 5/9", "type": "followup", "tag_good": [], "uid": "i7oaxkxhxjo3ui", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i9cdw24pn323y5", "updated": "2015-05-06T06:48:39Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>周昊 2012011326</p>\n<p>11.在一间酒吧里有三个音乐爱好者队列&#xff0c;第一队的音乐爱好者只有随身听&#xff0c;第二队的只有音乐磁带&#xff0c;第三队只有电池。而要听音乐就必须随身听&#xff0c;音乐磁带和电池这三种物品俱全。酒吧老板依次出售这三种物品中的任意两种。当一名音乐爱好者得到这三种物品并听完一首乐曲后&#xff0c;酒吧老板才能再一次出售这三种物品中的任意两种。于是第二名音乐爱好者得到这三种物品&#xff0c;并开始听乐曲。全部买卖就这样进行下去。试用P&#xff0c;V操作正确解决这一买卖。</p>\n<p></p>\n<p>code-semaphore</p>\n<pre>#coding=utf-8\n#semaphore\nimport threading  \nimport random  \nimport time  \n\nclass Producer(threading.Thread):\n    goods = [1, 2, 3]\n\n    def __init__(self, threadName, semaphore0, semaphore1, semaphore2, semaphore3):\n        threading.Thread.__init__(self,name=threadName)  \n        self.semaphore0 = semaphore0\n        self.semaphore1 = semaphore1\n        self.semaphore2 = semaphore2\n        self.semaphore3 = semaphore3\n\n    def run(self):\n        while True:\n            self.semaphore0.acquire()\n            good = random.randrange(1, 4)\n            if good == 1:\n                print &#39;Produce Tape, Battery&#39;\n                self.semaphore1.release()\n            elif good == 2:\n                print &#39;Produce Walkman, Battery&#39;\n                self.semaphore2.release()\n            else:\n                print &#39;Produce Walkman, Tape&#39;\n                self.semaphore3.release()\n\nclass Listener(threading.Thread):\n    \n    def __init__(self, threadName, need, semaphore0, semaphore):\n        threading.Thread.__init__(self,name=threadName)  \n        self.need = need\n        self.semaphore0 = semaphore0\n        self.semaphore = semaphore\n        \n    def run(self):\n        while True:\n            self.semaphore.acquire()\n            if self.need == 1:\n                print self.getName()&#43;&#39;: Buy Tape, Battery. Listening&#39;\n            elif self.need == 2:\n                print self.getName()&#43;&#39;: Buy Walkman, Battery. Listening&#39;\n            else:\n                print self.getName()&#43;&#39;: Buy Walkman, Tape. Listening&#39;\n            time.sleep(2)\n            self.semaphore0.release()\n            \n\nthreads=[]\nsemaphore0 = threading.Semaphore(1)\nsemaphore1 = threading.Semaphore(0)\nsemaphore2 = threading.Semaphore(0)\nsemaphore3 = threading.Semaphore(0)\n\nthreads.append(Producer(&#34;Producer&#34;, semaphore0, semaphore1, semaphore2, semaphore3))\nthreads.append(Listener(&#34;Listener1&#34;, 1, semaphore0, semaphore1))\nthreads.append(Listener(&#34;Listener2&#34;, 2, semaphore0, semaphore2))\nthreads.append(Listener(&#34;Listener3&#34;, 3, semaphore0, semaphore3))\n\nfor thread in threads: \n   thread.start() </pre>\n<p>code-condition</p>\n<pre>#coding=utf-8<br />#condition<br />import threading  <br />import random  <br />import time  <br /><br />condition = threading.Condition()<br />product = 0<br />class Producer(threading.Thread):<br />    goods = [1, 2, 3]<br /><br />    def __init__(self, threadName):<br />        threading.Thread.__init__(self,name=threadName)  <br />        <br />    def run(self):<br />        global condition, product<br />        while True:<br />            if condition.acquire():<br />                if product == 0:<br />                    product = random.randrange(1, 4)<br />                    if product == 1:<br />                        print &#39;Produce Tape, Battery&#39;<br />                    elif product == 2:<br />                        print &#39;Produce Walkman, Battery&#39;<br />                    else:<br />                        print &#39;Produce Walkman, Tape&#39;<br />                    condition.notifyAll()<br />                else:<br />                    condition.wait()<br />                condition.release()<br />                <br />class Listener(threading.Thread):<br />    <br />    def __init__(self, threadName, need):<br />        threading.Thread.__init__(self,name=threadName)  <br />        self.need = need<br />               <br />    def run(self):<br />        global condition, product<br />        while True:<br />            if condition.acquire():<br />                if product == self.need:<br />                    if self.need == 1:<br />                        print self.getName()&#43;&#39;: Buy Tape, Battery. Listening&#39;<br />                    elif self.need == 2:<br />                        print self.getName()&#43;&#39;: Buy Walkman, Battery. Listening&#39;<br />                    else:<br />                        print self.getName()&#43;&#39;: Buy Walkman, Tape. Listening&#39;<br />                    product = 0<br />                    time.sleep(2)<br />                    condition.notifyAll()<br />                else:<br />                    condition.wait()<br />                condition.release()<br /><br />threads=[]<br />semaphore0 = threading.Semaphore(1)<br />semaphore1 = threading.Semaphore(0)<br />semaphore2 = threading.Semaphore(0)<br />semaphore3 = threading.Semaphore(0)<br /><br />threads.append(Producer(&#34;Producer&#34;))<br />threads.append(Listener(&#34;Listener1&#34;, 1))<br />threads.append(Listener(&#34;Listener2&#34;, 2))<br />threads.append(Listener(&#34;Listener3&#34;, 3))<br /><br />for thread in threads: <br />   thread.start() </pre>\n<p></p>", "created": "2015-05-06T06:57:47Z", "bucket_order": 351, "bucket_name": "Week 5/3 - 5/9", "type": "followup", "tag_good": [], "uid": "i6tezdpdQbq", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i9ce7stq2fwt9", "updated": "2015-05-06T06:57:47Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>章浚源 第7题</p>\n<p></p>\n<p>见github&#xff1a;</p>\n<p><a href=\"https://github.com/Socyrus/os_exercises/blob/master/all/warehouse-condition.py\">https://github.com/Socyrus/os_exercises/blob/master/all/warehouse-condition.py</a></p>\n<p><a href=\"https://github.com/Socyrus/os_exercises/blob/master/all/warehouse-semaphore.py\">https://github.com/Socyrus/os_exercises/blob/master/all/warehouse-semaphore.py</a></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>", "created": "2015-05-06T07:00:58Z", "bucket_order": 351, "bucket_name": "Week 5/3 - 5/9", "type": "followup", "tag_good": [], "uid": "i71fykcui1h2je", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i9cebw0pnu2538", "updated": "2015-05-06T07:00:58Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>生产流水线问题 设自行车生产线上有一只箱子&#xff0c;其中有N 个位置( N ≥3)&#xff0c;每个位置可存放一个车架或一个车轮; 又设有三个工人&#xff0c;其活动分别为: 工人1活动: do{ 加工一个车架; 车架放入箱中; }while(1) 工人2活动&#xff1a; do{ 加工一个车轮; 车轮放入箱中; }while(1) 工人1活动&#xff1a; do{ 箱中取一个车架; 箱中取两个车轮; 组装为一台车; }while(1) 试分别用信号灯与PV 操作实现三个工人的合作&#xff0c;要求解中不含死锁。</p>\n<p>杜鹃  2012011354 第39题</p>\n<p></p>\n<pre>#coding=utf-8\n#!/usr/bin/env python\n  \nimport threading  \nimport time  \n   \ncondition1 = threading.Condition()  \n\ncondition2 = threading.Condition()  \nproducts1 = 0  \nproducts2 = 0  \nN = 10\n\nclass Producer1(threading.Thread):  \n    def __init__(self):  \n        threading.Thread.__init__(self)  \n          \n    def run(self):  \n        global condition1, products1 \n        while True:  \n            if condition1.acquire():  \n                if products1 &lt; N - 1:  \n                    products1 &#43;= 1;  \n                    print &#34;Producer1(%s):deliver one1, now products:%s&#34; %(self.name, products1) \n                    print &#34;&#34; \n                    condition1.notify()  \n                else:  \n                    print &#34;Producer1(%s):already 9, stop deliver, now products:%s&#34; %(self.name, products1)  \n                    condition1.wait();  \n                condition1.release()  \n                time.sleep(2)  \n\nclass Producer2(threading.Thread):  \n    def __init__(self):  \n        threading.Thread.__init__(self)  \n          \n    def run(self):  \n        global condition2, products2  \n        while True:  \n            if condition2.acquire():  \n                if products2 &lt; N-2:  \n                    products2 &#43;= 1;  \n                    print &#34;Producer2(%s):deliver one2, now products:%s&#34; %(self.name, products2)  \n                    print &#34;&#34;\n                    condition2.notify()  \n                else:  \n                    print &#34;Producer2(%s):already 8, stop deliver, now products:%s&#34; %(self.name, products2)  \n                    condition2.wait();  \n                condition2.release()  \n                time.sleep(2)           \nclass Consumer(threading.Thread):  \n    def __init__(self):  \n        threading.Thread.__init__(self)  \n          \n    def run(self):  \n        global condition1, condition2, products1,products2\n        while True:  \n            if condition1.acquire():  \n                if products1 &gt; 1:  \n                    products1 -= 1 \n                    print &#34;Consumer(%s):consume frame, now products1:%s, products2:%s&#34; %(self.name, products1,products2)  \n                    condition1.notify()\n                else:\n                    print &#34;Consumer(%s): stop consume frame, products1:%s,products2:%s&#34; %(self.name, products1,products2)  \n                    condition1.wait();  \n                condition1.release()\n                time.sleep(2) \n            if condition2.acquire():\n                if products2 &gt; 2:\n                    products2-=2\n                    print &#34;Consumer(%s):consume wheels and create a car, now products1:%s, products2:%s&#34; %(self.name, products1,products2)  \n                    condition2.notify()\n                else:\n                    print &#34;Consumer(%s): stop consume wheels, products1:%s,products2:%s&#34; %(self.name, products1,products2)  \n                    condition2.wait();  \n                condition2.release() \n                time.sleep(2)  \n                  \nif __name__ == &#34;__main__&#34;:  \n    p1 = Producer1()\n    p1.start()\n    p2 = Producer2()\n    p2.start()\n    c = Consumer()\n    c.start()</pre>\n<p></p>", "created": "2015-05-06T07:03:28Z", "bucket_order": 351, "bucket_name": "Week 5/3 - 5/9", "type": "followup", "tag_good": [], "uid": "i6un4iacNGX", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>信号量方法&#xff1a; <a href=\"https://github.com/Azalea94/os_exercises/blob/master/all/related/samph.py\">https://github.com/Azalea94/os_exercises/blob/master/all/related/samph.py</a><a href=\"https://github.com/Azalea94/os_exercises/blob/master/all/related/samph.py\" target=\"_blank\"></a></p>\n<p>condition方法&#xff1a;<a href=\"https://github.com/Azalea94/os_exercises/blob/master/all/related/condition.py\" target=\"_blank\">https://github.com/Azalea94/os_exercises/blob/master/all/related/condition.py</a></p>", "created": "2015-05-06T08:57:10Z", "bucket_order": 351, "bucket_name": "Week 5/3 - 5/9", "type": "feedback", "tag_good": [], "uid": "i6un4iacNGX", "children": [], "tag_good_arr": [], "id": "i9cihbkkdyr6te", "updated": "2015-05-06T08:57:10Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "i9cef47uf316tr", "updated": "2015-05-06T07:03:28Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p></p>\n<ol><li>第20题</li><li>\n<p>两人公用一个账号&#xff0c;每次限存或取10元&#xff1b;</p>\n<pre>&lt;code&gt;begin\nvar mutex=1:semaphore;\namount =0:integer;\ncobegin\n  process save\n    m1: integer;\n    begin\n    repeat\n    p(mutex);\n    m1= amount ;\n    m1 = m1 &#43;10;\n    amout = m1;\n    v(mutex);\n    end\n  process take\n    m2: integer;\n    begin\n    repeat;\n    p(mutex);\n    m2= amount ;\n    m2 = m2 -10;\n    amout = m2;\n    v(mutex);\n    end\ncoend\n&lt;/code&gt;</pre>\n</li></ol>\n<p>output&#xff1a;</p>\n<p><a href=\"https://github.com/yanwang9411/os_exercises/blob/master/semaphone-output.txt\">https://github.com/yanwang9411/os_exercises/blob/master/semaphone-output.txt</a></p>\n<p></p>\n<p></p>\n<p>implemention&#xff1a;</p>\n<p><a href=\"https://github.com/yanwang9411/os_exercises/blob/master/condition.py\">https://github.com/yanwang9411/os_exercises/blob/master/condition.py</a></p>\n<p><a href=\"https://github.com/yanwang9411/os_exercises/blob/master/semaphore.py\">https://github.com/yanwang9411/os_exercises/blob/master/semaphore.py</a></p>\n<p></p>\n<p></p>\n<p>2012011352 计24 王妍</p>\n<p></p>", "created": "2015-05-06T07:04:09Z", "bucket_order": 351, "bucket_name": "Week 5/3 - 5/9", "type": "followup", "tag_good": [], "uid": "i7bg4v1keqE", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i9cefzrs4853e7", "updated": "2015-05-06T07:04:09Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>第15题</p>\n<p>在南开大学至天津大学间有一条弯曲的路&#xff0c;每次只允许一辆自行车通过&#xff0c;但中间有小的安全岛M&#xff08;同时允许两辆车&#xff09;&#xff0c;可供两辆车在已进入两端小车错车&#xff0c;设计算法并使用P&#xff0c;V实现。</p>\n<p></p>\n<p></p>\n<p>信号量</p>\n<pre>#coding=utf-8<br />import threading <br />import random <br />import time\ndef BikeT2N():<br /> name = threading.currentThread().getName()<br /> T2N.acquire()<br /> print &#34;%s get into road\\n&#34; % name<br /> L.acquire()<br /> print &#34;%s get into L&#34; % name<br /> M.acquire()<br /> print &#34;%s get into M&#34; % name<br /> L.release()<br /> K.acquire()<br /> print &#34;%s get into K&#34; % name<br /> M.release()<br /> print &#34;%s get out of M&#34; % name<br /> K.release()<br /> T2N.release()<br /> print &#34;%s get out of road\\n&#34; % name<br />def BikeN2T():<br /> name = threading.currentThread().getName()<br /> N2T.acquire()<br /> print &#34;%s get into road\\n&#34; % name<br /> K.acquire()<br /> print &#34;%s get into k&#34; % name<br /> M.acquire()<br /> print &#34;%s get into M&#34; % name<br /> K.release()<br /> L.acquire()<br /> M.release()<br /> print &#34;%s get out of M&#34; % name<br /> L.release()<br /> print &#34;%s get out of M&#34; % name<br /> N2T.release()<br /> print &#34;%s get out of road\\n&#34; % name\nif __name__ == &#39;__main__&#39;:<br /> threads = []<br /> T2N = threading.Semaphore(1)<br /> N2T = threading.Semaphore(1)<br /> L = threading.Semaphore(1)<br /> K = threading.Semaphore(1)<br /> M = threading.Semaphore(2)<br /> for i in xrange(10):<br /> if i%2 == 0:<br /> thread = threading.Thread(target = BikeT2N, name=&#34;bikeT2N&#34;&#43;str(i/2))<br /> thread.start()<br /> threads.append(thread)<br /> else:<br /> thread = threading.Thread(target = BikeN2T, name=&#34;bikeN2T&#34;&#43;str(i))<br /> thread.start()<br /> threads.append(thread)<br /> for item in threads:<br /> item.join()</pre>\n<p></p>\n<p>条件变量</p>\n<pre>import threading\nT2N_num = 0<br />N2T_num = 0<br />M_num = 0\ndef BikeT2N():<br /> global T2N_num,N2T_num,M_num<br /> name = threading.currentThread().getName()<br /> T2Ncond.acquire()<br /> if T2N_num == 1:<br /> T2Ncond.wait()<br /> T2N_num &#43;= 1<br /> print &#34;%s get into T\\n&#34; % name<br /> Mcond.acquire()<br /> if M_num == 2:<br /> Mcond.wait()<br /> M_num &#43;= 1<br /> print &#34;%s get into M\\n&#34; % name<br /> Mcond.release()<br /> T2N_num -= 1<br /> T2Ncond.notify()<br /> T2Ncond.release()<br /> print &#34;%s get out of T\\n&#34; % name<br /> Mcond.acquire()<br /> assert(M_num &gt;0)<br /> M_num -= 1<br /> Mcond.notify()<br /> Mcond.release()<br /> print &#34;%s get out of M\\n&#34; % name<br /> #print &#34;vars : %d %d %d&#34; % (T2N_num, N2T_num, M_num)<br /> N2Tcond.acquire()<br /> if N2T_num == 1:<br /> N2T_num.wait()<br /> N2T_num &#43;= 1\nprint &#34;%s get into N\\n&#34; % name<br /> N2T_num -= 1<br /> N2Tcond.notify()<br /> N2Tcond.release()<br /> print &#34;%s get out of N\\n&#34; % name\n<br />def BikeN2T():<br /> global T2N_num,N2T_num,M_num<br /> name = threading.currentThread().getName()<br /> N2Tcond.acquire()<br /> if N2T_num == 1:<br /> N2Tcond.wait()<br /> N2T_num &#43;= 1<br /> print &#34;%s get into N\\n&#34; % name<br /> Mcond.acquire()<br /> if M_num == 2:<br /> Mcond.wait()<br /> M_num &#43;= 1<br /> print &#34;%s get into M\\n&#34; % name<br /> Mcond.release()<br /> N2T_num -= 1<br /> N2Tcond.notify()<br /> N2Tcond.release()<br /> print &#34;%s get out of N\\n&#34; % name<br /> Mcond.acquire()<br /> assert(M_num&gt;0)<br /> M_num -= 1<br /> Mcond.notify()<br /> Mcond.release()<br /> print &#34;%s get into M\\n&#34; % name<br /> T2Ncond.acquire()<br /> if T2N_num == 1:<br /> T2N_num.wait()<br /> T2N_num &#43;= 1<br /> <br /> print &#34;%s get into T\\n&#34; % name<br /> T2N_num -= 1<br /> T2Ncond.notify()<br /> T2Ncond.release()<br /> print &#34;%s get out of T\\n&#34; % name\n<br />if __name__ == &#39;__main__&#39;:<br /> T2Ncond = threading.Condition()<br /> N2Tcond = threading.Condition()<br /> Mcond = threading.Condition()<br /> threads = []<br /> for i in xrange(10):<br /> if i%2 == 0:<br /> thread = threading.Thread(target=BikeT2N, name=&#34;thread&#34;&#43;str(i))<br /> thread.start()<br /> threads.append(thread)<br /> else:<br /> thread = threading.Thread(target=BikeN2T, name=&#34;thread&#34;&#43;str(i))<br /> thread.start()<br /> threads.append(thread)<br /> for item in threads:<br /> item.join()</pre>\n<p></p>", "created": "2015-05-06T07:06:44Z", "bucket_order": 351, "bucket_name": "Week 5/3 - 5/9", "type": "followup", "tag_good": [], "uid": "i6uayl3vEOz", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i9cejazzpo77mc", "updated": "2015-05-06T07:06:44Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>第36题  计21班   韦福超  2012011392</p>\n<pre><code>var\ns, Sa.Sb, mutexa, mutexb: semaphore;\ns: = mutexa &#xff1a;=mutexb: = 1;\nsa: = sb: = 0;\nbox: (PaPer, Pen);\ncobegin\n    process 保管员\n        begin\n            repeat\n            P(S);\n            take a material intobox ;\n            if (box)=Paper then V(Sa);\n            else V(Sb);\n            untile false ;\n        end\n\nProcess A组学生\n    begin\n        repeat\n        P(Sa);\n        P(mutexa);\n        take the pen from box ;\n        V(mutexa);\n        V(S);\n        write a letter;\n        untile false ;\n    end\n\nProcess B组学生\n    begin\n        repeat\n        P(Sb);\n        P(mutexb);\n        take the paper from box ;\n        V(mutexb);\n        V(S);\n        wnte a letter ;\n        untile false ;\n    end\nCoend.</code></pre>\n<p># coding=utf-8<br />import threading<br />import random<br />import time</p>\n<p>s = mutexa = mutexb = 1<br />sa = sb = 0<br />box = random.choice([0, 1])</p>\n<p><br />class processAdmin(threading.Thread):</p>\n<p>def __init__(self, threadName, semaphore):<br /> threading.Thread.__init__(self, name=threadName)<br /> self.sleepTime = random.randrange(1, 6)<br /> self.threadSemaphore = semaphore</p>\n<p>def run(self):<br /> self.threadSemaphore.acquire()<br /> # critical zone<br /> self.threadSemaphore.release()</p>", "created": "2015-05-06T07:07:23Z", "bucket_order": 351, "bucket_name": "Week 5/3 - 5/9", "type": "followup", "tag_good": [], "uid": "i6ut6cjo5lj4aa", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i9cek5imoppr9", "updated": "2015-05-06T07:07:23Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>李日灵 2012011332  第7题</p>\n<p>题目描述如下&#xff1a;(操作系统之PV金典)设有一个可以装A、B两种物品的仓库,其容量有限(分别为N),但要求仓库中A、B两种物品的数量满足下述不等式: -M≤A物品数量-B物品数量≤N 其中M和N为正整数。另外,还有一个进程消费A,B,一次取一个A,B组装成C。 试用信号量和PV操作描述A、B两种物品的入库过程。</p>\n<p>因为0&lt;=A,B&lt;=N,所以A-B&lt;=恒成立&#xff0c;所以可以去掉一个条件。另&#xff0c;原题所附的伪代码有误&#xff0c;修改后semaphore和lock两种方式的伪代码如下&#xff1a;</p>\n<p>1、semaphore</p>\n<p>semaphore mutex=1,diff=m,empty1=N,empty2=N,full1,full2=0;<br />cobegin<br /> process(A);<br /> process(B);<br /> process(C)<br />coend<br />// A物品入库<br />process A<br />begin<br /> while(TRUE)<br /> begin<br /> p(empty1);<br /> p(mutex);<br /> A物品入库;<br /> v(mutex);<br /> v(full1);</p>\n<p>v(diff);<br /> end<br />end<br />// B物品入库&#xff1a;<br />process B<br />begin<br /> while(TRUE)<br /> begin<br /> p(empty2);<br /> p(diff);<br /> <br /> p(mutex);<br /> B物品入库;<br /> v(mutex);<br /> v(full2);<br /> end<br />end<br />// process C<br />begin<br /> while(TRUE)<br /> begin<br /> p(full1);<br /> p(full2);<br /> p(mutex);<br /> 组装;<br /> v(mutex);<br /> v(empty1);<br /> v(empty2);<br /> end<br />end</p>\n<p></p>\n<p>2、lock伪代码</p>\n<p><br />procedure producerA() {<br /> lock-&gt;Acquire();<br /> while (countA == n)<br /> admit_A.Wait(&amp;lock);<br /> <br /> Add A to the buffer;<br /> countA&#43;&#43;;<br /> <br /> admit_B.Signal();<br /> admit_C.signal();<br /> lock-&gt;Release();<br /> }</p>\n<p><br />procedure producerB() {<br /> lock-&gt;Acquire();<br /> while (countB == n || countA-countB&lt;=-M)<br /> admit_B.Wait(&amp;lock);<br /> <br /> Add B to the buffer;<br /> countB&#43;&#43;;</p>\n<p>admit_A.Signal();<br /> admit_C.signal();<br /> lock-&gt;Release();<br />}</p>\n<p>procedure consumer() {<br /> lock-&gt;Acquire();<br /> while (countA==0 || countB == 0)<br /> admit_C.Signal();<br /> countA--;<br /> countB--;</p>\n<p>admit_A.Signal();<br /> admit_B.signal();<br /> lock-&gt;Release(); <br />}</p>\n<p></p>\n<p><em><strong>对应的python代码</strong></em></p>\n<p>semaphore方法&#xff1a;</p>\n<pre>import multiprocessing\nimport time\ndef producerA(mutex,empty1,full1,diff,i):\n    print(&#34;ready to produce A&#34;)\n    empty1.acquire()\n    mutex.acquire()\n    # print(multiprocessing.current_process().name &#43; &#34; acquire&#34;)\n    print(&#34;producing A succeed&#34;)\n    time.sleep(i)\n    # print(multiprocessing.current_process().name &#43; &#34; release&#34;)\n    mutex.release()\n    full1.release()\n\n    diff.release()\n\ndef producerB(mutex,empty2,full2,diff,i):\n    print(&#34;ready to produce B&#34;)\n    empty2.acquire()\n    diff.acquire()\n    mutex.acquire()\n\n    print(&#34;producing B succeed&#34;)\n    time.sleep(i)\n    \n    mutex.release()\n    full2.release()\n\ndef consumer(mutex,empty1,empty2,full1,full2,i):\n    print(&#34;ready to cosume&#34;)\n    full1.acquire()\n    full2.acquire()\n    mutex.acquire()\n    \n    print(&#34;cosuming suceed&#34;)\n    time.sleep(i)\n\n    mutex.release()\n    empty1.release()\n    empty2.release()\n    \nif __name__ == &#34;__main__&#34;:\n    N = 10\n    m = 5\n    full1 = multiprocessing.Semaphore(0)\n    full2 = multiprocessing.Semaphore(0)\n    empty1 = multiprocessing.Semaphore(N)\n    empty2 = multiprocessing.Semaphore(N)\n    \n    diff = multiprocessing.Semaphore(m)\n    mutex = multiprocessing.Semaphore(1)\n\n    for i in range(5):\n        pa = multiprocessing.Process(target=producerA, args=(mutex,empty1,full1,diff,i*2))\n        pa.start()\n        pb = multiprocessing.Process(target=producerB, args=(mutex,empty2,full2,diff,i*2))\n        pb.start()\n        c = multiprocessing.Process(target=consumer, args=(mutex,empty1,empty2,full1,full2,i*2))</pre>\n<p>condition代码&#xff1a;</p>\n<pre>import multiprocessing\nimport time\ndef producerA(mutex,empty1,full1,diff,i):\n    print(&#34;ready to produce A&#34;)\n    empty1.acquire()\n    mutex.acquire()\n    # print(multiprocessing.current_process().name &#43; &#34; acquire&#34;)\n    print(&#34;producing A succeed&#34;)\n    time.sleep(i)\n    # print(multiprocessing.current_process().name &#43; &#34; release&#34;)\n    mutex.release()\n    full1.release()\n\n    diff.release()\n\ndef producerB(mutex,empty2,full2,diff,i):\n    print(&#34;ready to produce B&#34;)\n    empty2.acquire()\n    diff.acquire()\n    mutex.acquire()\n\n    print(&#34;producing B succeed&#34;)\n    time.sleep(i)\n    \n    mutex.release()\n    full2.release()\n\ndef consumer(mutex,empty1,empty2,full1,full2,i):\n    print(&#34;ready to cosume&#34;)\n    full1.acquire()\n    full2.acquire()\n    mutex.acquire()\n    \n    print(&#34;cosuming suceed&#34;)\n    time.sleep(i)\n\n    mutex.release()\n    empty1.release()\n    empty2.release()\n    \nif __name__ == &#34;__main__&#34;:\n    N = 10\n    m = 5\n    full1 = multiprocessing.Semaphore(0)\n    full2 = multiprocessing.Semaphore(0)\n    empty1 = multiprocessing.Semaphore(N)\n    empty2 = multiprocessing.Semaphore(N)\n    \n    diff = multiprocessing.Semaphore(m)\n    mutex = multiprocessing.Semaphore(1)\n\n    for i in range(5):\n        pa = multiprocessing.Process(target=producerA, args=(mutex,empty1,full1,diff,i*2))\n        pa.start()\n        pb = multiprocessing.Process(target=producerB, args=(mutex,empty2,full2,diff,i*2))\n        pb.start()\n        c = multiprocessing.Process(target=consumer, args=(mutex,empty1,empty2,full1,full2,i*2))</pre>\n<p></p>", "created": "2015-05-06T07:10:41Z", "bucket_order": 351, "bucket_name": "Week 5/3 - 5/9", "type": "followup", "tag_good": [], "uid": "i718mp903qx", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i9ceoef1w7o5bv", "updated": "2015-05-06T07:10:41Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>28.有n&#43;1个进程A1&#xff0c;A2&#xff0c;... ,An和B&#xff1a; A1,A2,... ,An通过同一个缓冲池各自不断地向B发送消息&#xff0c;B不断地取消息&#xff0c;它必须取走 发来的每个消息&#xff0c;刚开始时缓冲区为空&#xff0c;使用P,V操作实现之。 若缓冲区个数增至M个&#xff0c;试用P,V实现正确通讯。</p>\n<p>semaphore</p>\n<pre>#coding = utf-8\n\nimport threading\nimport time\nimport random\n\nproducts = 0\nN = 5  #producer number\nM = 20  #buffer size\n\nclass Producer(threading.Thread):\n\tdef __init__(self, threadName, ifull, iempty, imutex):\n\t\tthreading.Thread.__init__(self, name=threadName)\n\t\tself.sleepTime = random.randrange(1,6)\n\t\tself.full = ifull\n\t\tself.empty = iempty\n\t\tself.mutex = imutex\n\n\tdef run(self):\n\t\tglobal products\n\t\twhile True:\n\t\t\tself.empty.acquire()\n\t\t\tself.mutex.acquire()\n\t\t\tproducts &#43;= 1\n\t\t\tprint &#34;Producer(%s):deliver one, now products:%s&#34; %(self.name, products)\n\t\t\tself.mutex.release()\n\t\t\tself.full.release()\n\t\t\t#print full._Semaphore__value\n\t\t\ttime.sleep(self.sleepTime)\n\nclass Comsumer(threading.Thread):\n\tdef __init__(self, threadName, ifull, iempty, imutex):\n\t\tthreading.Thread.__init__(self, name=threadName)\n\t\tself.sleepTime = random.randrange(1,6)\n\t\tself.full = ifull\n\t\tself.empty = iempty\n\t\tself.mutex = imutex\n\n\tdef run(self):\n\t\tglobal products\n\t\twhile True:\n\t\t\tself.full.acquire()\n\t\t\tself.mutex.acquire()\n\t\t\tproducts -= 1\n\t\t\tprint &#34;Comsumer(%s):comsume one, now products:%s&#34; %(self.name, products)\n\t\t\tself.mutex.release()\n\t\t\tself.empty.release()\n\t\t\ttime.sleep(self.sleepTime)\n\n\nfull = threading.Semaphore(0)\nempty = threading.Semaphore(M)\nmutex = threading.Semaphore(1)\n\nfor i in range(N):\n\tp = Producer(str(i&#43;1),full, empty, mutex)\n\tp.start()\n\nc = Comsumer(&#34;one&#34;, full, empty, mutex)\nc.start()\n\n\n</pre>\n<p>condition</p>\n<pre>#coding=utf-8\n#!/usr/bin/env python\n\nimport threading  \nimport time  \n\nM = 10\nN = 5\ncondition = threading.Condition()  \nproducts = 0  \n\nclass Producer(threading.Thread):  \n    def __init__(self):  \n        threading.Thread.__init__(self)  \n\n    def run(self):  \n        global condition, products , M\n        while True:  \n            if condition.acquire():  \n                if products &lt; M:  \n                    products &#43;= 1;  \n                    print &#34;Producer(%s):deliver one, now products:%s&#34; %(self.name, products)  \n                    condition.notify()  \n                else:  \n                    print &#34;Producer(%s):already %d, stop deliver, now products:%s&#34; %(self.name, M, products)  \n                    condition.wait();  \n                condition.release()  \n                time.sleep(1)  \n\nclass Consumer(threading.Thread):  \n    def __init__(self):  \n        threading.Thread.__init__(self)  \n\n    def run(self):  \n        global condition, products  \n        while True:  \n            if condition.acquire():  \n                if products &gt; 1:  \n                    products -= 1  \n                    print &#34;Consumer(%s):consume one, now products:%s&#34; %(self.name, products)  \n                    condition.notify()  \n                else:  \n                    print &#34;Consumer(%s):only 1, stop consume, products:%s&#34; %(self.name, products)  \n                    condition.wait();  \n                condition.release()  \n                time.sleep(2)  \n\nif __name__ == &#34;__main__&#34;:  \n    for p in range(0, N):  \n        p = Producer()  \n        p.start()  \n\n    for c in range(1):  \n        c = Consumer()  \n        c.start() </pre>\n<p></p>", "created": "2015-05-06T07:19:04Z", "bucket_order": 351, "bucket_name": "Week 5/3 - 5/9", "type": "followup", "tag_good": [], "uid": "i6t76fg9sEh", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i9cez61au753n1", "updated": "2015-05-06T07:19:04Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>计22 黄杰 2012011272</p>\n<p> 博物馆-公园问题 Jurassic公园有一个恐龙博物馆和一个花园&#xff0c;有m 个旅客租卫辆车&#xff0c;每辆车仅能乘 一个一旅客。旅客在博物馆逛了一会&#xff0c;然后&#xff0c;排队乘坐旅行车&#xff0c;挡一辆车可用喊飞它载 入一个旅客&#xff0c;再绕花园行驶任意长的时间。若n 辆车都己被旅客乘坐游玩&#xff0c;则想坐车的 旅客需要等待。如果一辆车己经空闲&#xff0c;但没有游玩的旅客了&#xff0c;那么&#xff0c;车辆要等待。试用 信号量和P 、V 操作同步m 个旅客和n 辆车子。<br /> <br /> 这是一个汇合机制&#xff0c;有两类进程&#xff1a;顾客进程和车辆进程&#xff0c;需要进行汇合、即顾客要坐进车辆后才能游玩&#xff0c;开始时让车辆进程进入等待状态<br /> <br /> 解答:</p>\n<p><a href=\"https://github.com/THUHJ/os_exercises/blob/master/all/07-2-spoc-discussion.md\" target=\"_blank\">https://github.com/THUHJ/os_exercises/blob/master/all/07-2-spoc-discussion.md</a></p>\n<p></p>", "created": "2015-05-06T07:28:50Z", "bucket_order": 351, "bucket_name": "Week 5/3 - 5/9", "type": "followup", "tag_good": [], "uid": "i6sl02qfUgI", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i9cfbqf9rdd290", "updated": "2015-05-06T07:28:50Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>陈振寰 2012012390</p>\n<p>24题&#xff0c;题目&#xff1a;设公共汽车上&#xff0c;司机和售票员的活动分别如下&#xff1a;司机的活动&#xff1a;启动车辆&#xff1a;正常行车&#xff1b;到站停车。售票员的活动&#xff1a;关车门&#xff1b;售票&#xff1b;开车门。在汽车不断地到站、停车、行驶过程中&#xff0c;这两个活动有什么同步关系&#xff1f;用信号量和P 、V 操作实现它们的同步。</p>\n<p></p>\n<p>解答&#xff1a;</p>\n<p>sem:</p>\n<pre>#coding=utf-8\nimport threading \nimport random\nimport time\n\nclass driverThread(threading.Thread):\n\tdef __init__(self,threadName,semaphore1,semaphore2):\n\t\tthreading.Thread.__init__(self,name=threadName)  \n\t\tself.sleepTime=random.randrange(1,6)  \n\t\t#set the semaphore as a data attribute of the class  \n\t\tself.threadSemaphore1 = semaphore1\n\t\tself.threadSemaphore2 = semaphore2\n\tdef run(self):\n\t\twhile True:\n\t\t\tself.threadSemaphore1.acquire() \n\t\t\tprint &#34;bus start running&#34;\n\t\t\ttime.sleep(self.sleepTime) \n\t\t\tprint &#34;bus is running&#34;\n\t\t\ttime.sleep(self.sleepTime) \n\t\t\tprint &#34;bus stop running&#34;\n\t\t\tself.threadSemaphore2.release()\n\n\nclass conductorThread(threading.Thread):\n\tdef __init__(self,threadName,semaphore1,semaphore2):\n\t\tthreading.Thread.__init__(self,name=threadName)  \n\t\tself.sleepTime=random.randrange(1,6)  \n\t\t#set the semaphore as a data attribute of the class  \n\t\tself.threadSemaphore1 = semaphore1\n\t\tself.threadSemaphore2 = semaphore2\n\tdef run(self):\n\t\twhile True:\n\t\t\tprint &#34;close the bus door&#34;\n\t\t\ttime.sleep(self.sleepTime) \n\t\t\tself.threadSemaphore1.release() \n\t\t\tprint &#34;sale ticket&#34;\n\t\t\ttime.sleep(self.sleepTime) \n\t\t\tself.threadSemaphore2.acquire()\n\t\t\ttime.sleep(self.sleepTime) \n\t\t\tprint &#34;open the bus door&#34;\n\t\t\ttime.sleep(self.sleepTime) \n\t\t\tprint &#34;passenger on and off&#34;\n<br />threadSemaphore1=threading.Semaphore(0)\nthreadSemaphore2=threading.Semaphore(0)\ndriver_thread = driverThread(&#34;driver&#34;,threadSemaphore1,threadSemaphore2)\nconductor_thread = conductorThread(&#34;conductor&#34;,threadSemaphore1,threadSemaphore2)\ndriver_thread.start()\nconductor_thread.start()</pre>\n<p>condition:</p>\n<pre>import threading\nimport random\nimport time\n\ncondition = threading.Condition()\nbusStatus = &#34;&#34;\n\nclass Driver(threading.Thread):\n    def __init__(self,threadName):\n        threading.Thread.__init__(self,name=threadName)\n        self.sleepTime = random.randrange(1,6)\n\n    def run(self):\n        global condition, busStatus\n        while True:\n            if condition.acquire():\n                if busStatus == &#34;Start&#34;:\n                    print &#34;Driver: bus start running&#34;\n                    busStatus = &#34;Running&#34;\n                    time.sleep(self.sleepTime)\n                    print &#34;Driver: bus stop&#34;\n                    busStatus = &#34;Stop&#34;\n                    time.sleep(self.sleepTime)\n                    condition.notify()\n                elif busStatus == &#34;doorOpened&#34;:\n                    time.sleep(self.sleepTime)\n                    print &#34;Driver: door not closed, waiting.&#34;\n                    condition.wait()\n                condition.release()\n\nclass Conductor(threading.Thread):\n    def __init__(self,threadName):\n        threading.Thread.__init__(self,name=threadName)\n        self.sleepTime = random.randrange(1,6)\n\n    def run(self):\n        global condition, busStatus\n        while True:\n            if condition.acquire():\n                if busStatus == &#34;Stop&#34;:\n                    print &#34;Conductor: Bus stopped, open the door,passenger on and off&#34;\n                    busStatus = &#34;doorOpened&#34;\n                    time.sleep(self.sleepTime)\n                    print &#34;Conductor: close the door,sell tickets&#34;\n                    busStatus = &#34;Start&#34;\n                    time.sleep(self.sleepTime)\n                    condition.notify()\n                elif busStatus == &#34;Running&#34;:\n                    time.sleep(self.sleepTime)\n                    print &#34;Condutor: bus not stopped, cannot open the door.&#34;\n                    condition.wait()\n                condition.release()\n\nif __name__ == &#39;__main__&#39;:\n    busStatus = &#34;Start&#34;  \n    Driver(&#34;driver&#34;).start()\n    Conductor(&#34;conductor&#34;).start()</pre>\n<p></p>", "created": "2015-05-06T08:27:33Z", "bucket_order": 351, "bucket_name": "Week 5/3 - 5/9", "type": "followup", "tag_good": [], "uid": "i6rtbanwzcm5t6", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>题目(第25题):</p>\n<p>把学生和监考老师都看做进程&#xff0c;学生有N个人&#xff0c;教师1人&#xff0c;考场门口每次只能进出一个人&#xff0c;进 考场原则是先来先进&#xff0c;当N个学生都进入考场后&#xff0c;教师才能发试卷。学生交卷后可以离开考 场&#xff0c;教师要等收上来全部试卷并封装试卷后才能离开考场。问共需设置几个进程&#xff1f;使用P&#xff0c;V 操作解决上述问题中的同步和互斥关系。</p>\n<p>需要开N&#43;1个进程&#xff1b;</p>\n<p>代码如下&#xff1a;</p>\n<pre>#信号量方法<br />#coding=utf-8\nimport threading  \n\nN = 10\nmutex = threading.Semaphore(1)\nBeginready = threading.Semaphore(0)\nTestready = threading.Semaphore(0)\nEndready = threading.Semaphore(0)\n\ndef thread_run(name):\n\tif(name == &#34;teacher&#34;):\n\t\tmutex.acquire()\n\t\tprint &#34;老师进教室!\\n&#34;\n\t\tmutex.release()\n\t\tfor i in range(N):\n\t\t\tBeginready.acquire()\n\t\tprint &#34;开始发卷!\\n&#34;\n\t\tTestready.release()\n\t\tfor i in range(N):\n\t\t\tEndready.acquire()\n\t\tprint &#34;老师离开!\\n&#34;\n\telse:\n\t\tmutex.acquire()\n\t\tprint &#34;学生进教室!\\n&#34;\n\t\tmutex.release()\n\t\tBeginready.release()\n\t\tTestready.acquire()\n\t\tTestready.release()\n\t\tprint &#34;答题\\n&#34;\n\t\tprint &#34;交卷\\n&#34;\n\t\tprint &#34;离开\\n&#34;\n\t\tEndready.release()\n\ndef main(thread_num):  \n    thread_list = list();  \n    # 先创建线程对象  \n    for i in range(0, thread_num):\n \t\tif(i == 0):\n \t\t\tthread_name = &#34;teacher&#34;\n \t\t\tthread_list.append(threading.Thread(target = thread_run, name = thread_name, args = (thread_name,)))\n \t\telse:\n \t\t\tthread_name = &#34;student&#34;\n \t\t\tthread_list.append(threading.Thread(target = thread_run, name = thread_name, args = (thread_name,)))\n      \n    # 启动所有线程     \n    for thread in thread_list:  \n        thread.start()  \n      \n    # 主线程中等待所有子线程退出  \n    for thread in thread_list:  \n        thread.join()  \n  \nif __name__ == &#34;__main__&#34;:  \n    main(N&#43;1)  \n#条件量方法<br />#coding=utf-8\nimport threading  \n\nN = 10#学生数量\nmutex = threading.Condition()\ncond = threading.Condition()\nend = threading.Condition()\nBeginready = -9\nTestready = 0\nEndready = -9\n\ndef thread_run(name):\n\tglobal Testready\n\tglobal Beginready\n\tglobal Endready\n\tif(name == &#34;teacher&#34;):\n\t\tmutex.acquire()\n\t\tprint &#34;老师进教室!\\n&#34;\n\t\tmutex.release()\n\t\tcond.acquire()\n\t\tif(Beginready &lt; 1):\n\t\t\tcond.wait()\n\t\tprint &#34;开始发卷!\\n&#34;\n\t\tTestready &#43;= 1\n\t\tcond.notify()\n\t\tcond.release()\n\t\tend.acquire()\n\t\tif(Endready != 1):\n\t\t\tend.wait()\n\t\tprint &#34;老师离开!\\n&#34;\n\t\tend.release()\n\telse:\n\t\tmutex.acquire()\n\t\tprint &#34;学生进教室!\\n&#34;\n\t\tBeginready &#43;= 1\n\t\tmutex.release()\n\t\tcond.acquire()\n\t\tcond.notifyAll()\n\t\tif(Testready != 1):\n\t\t\tcond.wait()\n\t\tprint &#34;答题\\n&#34;\n\t\tprint &#34;交卷\\n&#34;\n\t\tprint &#34;离开\\n&#34;\n\t\tcond.release()\n\t\tend.acquire()\n\t\tEndready &#43;= 1\n\t\tend.notify()\n\t\tend.release()\n\ndef main(thread_num):  \n    thread_list = list();  \n    # 先创建线程对象  \n    for i in range(0, thread_num):\n \t\tif(i == 0):\n \t\t\tthread_name = &#34;teacher&#34;\n \t\t\tthread_list.append(threading.Thread(target = thread_run, name = thread_name, args = (thread_name,)))\n \t\telse:\n \t\t\tthread_name = &#34;student&#34;\n \t\t\tthread_list.append(threading.Thread(target = thread_run, name = thread_name, args = (thread_name,)))\n      \n    # 启动所有线程     \n    for thread in thread_list:  \n        thread.start()  \n      \n    # 主线程中等待所有子线程退出  \n    for thread in thread_list:  \n        thread.join()  \n  \nif __name__ == &#34;__main__&#34;:  \n    main(N&#43;1)  </pre>\n<p></p>", "created": "2015-05-06T08:38:33Z", "bucket_order": 351, "bucket_name": "Week 5/3 - 5/9", "type": "feedback", "tag_good": [], "uid": "i6uteptdP5U", "children": [], "tag_good_arr": [], "id": "i9chtdpugsr28z", "updated": "2015-05-06T08:38:33Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "i9chf8s6vi51lp", "updated": "2015-05-06T08:27:33Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>2012011375 梁俊邦 第16题</p>\n<p></p>\n<p>16.在一个盒子里&#xff0c;混装了数量相等的黑白围棋子·现在用自动分拣系统把黑子、白子分开&#xff0c;设分拣系统有二个进程P1 和P2 &#xff0c;其中P1 拣白子&#xff1b;P2 拣黑子。规定每个进程每次拣一子&#xff1b;当一个进程在拣时&#xff0c;不允许另一个进程去拣&#xff1b;当一个进程拣了一子时&#xff0c;必须让另一个进程去拣&#xff0e;试写出两进程P1 和P2 能并发正确执行的程序。</p>\n<p></p>\n<p>信号量方法&#xff1a; <a href=\"https://github.com/williamljb/os_exercises/blob/master/all/semaphore.py\" target=\"_blank\">https://github.com/williamljb/os_exercises/blob/master/all/semaphore.py</a><a href=\"https://github.com/Azalea94/os_exercises/blob/master/all/related/samph.py\" target=\"_blank\"></a></p>\n<p>condition方法&#xff1a;<a href=\"https://github.com/williamljb/os_exercises/blob/master/all/condition.py\" target=\"_blank\">https://github.com/williamljb/os_exercises/blob/master/all/condition.py</a></p>", "created": "2015-05-06T11:11:13Z", "bucket_order": 351, "bucket_name": "Week 5/3 - 5/9", "type": "followup", "tag_good": [], "uid": "i6rgfjo5j1r6c", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i9cn9pshybv5zk", "updated": "2015-05-06T11:11:13Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>2016011279 何家傲 打印机问题:</p>\n<p></p>\n<p>问题概述: 有五台打印机, 请求有优先级, 保证优先级高的先得到打印机.</p>\n<p></p>\n<p>思路: 把队列换成优先队列就好了.</p>\n<p></p>\n<p>实现: 第一次用cpp的thread. 坑比较多, 比如最后要 join 否则会直接退出, 得不到各子线程的输出. 用 yield 和全局变量实现了一个差不多是轮询的等待和唤醒. 用8个进程(其实是线程模拟的) 和 5台打印机 可以比较好地体现出优先级的高低.</p>\n<p></p>\n<p>代码: <a href=\"https://gist.github.com/laekov/348a49b8894856622e902d49c4523631\" target=\"_blank\">https://gist.github.com/laekov/348a49b8894856622e902d49c4523631</a></p>", "created": "2017-04-28T07:39:03Z", "bucket_order": 248, "bucket_name": "Week 4/23 - 4/29", "type": "followup", "tag_good": [], "uid": "izb0cbqbyzd6wf", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>更新了一下输出方式. 做了一个比较好看的输出. 另外如果只有 3 个椅子的时候比较容易看出优先级的分配.</p>", "created": "2017-05-07T01:00:48Z", "bucket_order": 247, "bucket_name": "Week 4/30 - 5/6", "type": "feedback", "tag_good": [], "uid": "izb0cbqbyzd6wf", "children": [], "tag_good_arr": [], "id": "j2dzs9r673o4ii", "updated": "2017-05-07T01:00:48Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "j21j1qzx17x3rn", "updated": "2017-04-28T07:39:03Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>练习题4&#xff1a;理发师问题</p>\n<p>假设有5把椅子&#xff0c;20位顾客&#xff0c;在50s的时间内申请理发。每次理发的时间4s</p>\n<pre>#include&lt;pthread.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;semaphore.h&gt;\n#include &lt;sys/time.h&gt;\n#include &lt;math.h&gt;\n #define CHAIRS 5 //椅子数\n#define TOTALTIME 50\nsem_t customers; //等待服务的顾客信号量\nsem_t barbers; //等待顾客的理发师信号量\nsem_t mutex; //互斥变量\nint waiting = 0; //正在等待的顾客数\nvoid *barber(void);\nvoid *customer();\nvoid cut_hair(void);\n\nvoid *barber(void*) {\n\tint i;\n\twhile(1) {\n\tsem_wait(&amp;customers);//顾客信号量-1\n\tsem_wait(&amp;mutex);\n\twaiting = waiting -1;\n\tsem_post(&amp;barbers);\n\tsem_post(&amp;mutex);\n\tcut_hair();//理发\n\t}\n}\nvoid cut_hair(void) {\nprintf(&#34; Barber is busy now.\\n&#34;);\nsleep(4);//理发时间\nprintf(&#34; Haircut is over.\\n&#34;);\n}\nvoid *customer(void* arg) {\n\tsleep(rand()%TOTALTIME);\n\tsem_wait(&amp;mutex);\n\tif(waiting&lt;CHAIRS) {\n\t\tprintf(&#34;Customer %d starts waiting. Length of waiting line:%d\\n&#34;,*(int*)(arg),&#43;&#43;waiting);\n\t\tsem_post(&amp;customers);\n\t\tsem_post(&amp;mutex);\n\t\tsem_wait(&amp;barbers);\n\t\tprintf(&#34;Customer %d is having haircut. Length of waiting line:%d\\n&#34;,*(int*)(arg),waiting);\n\t\tsleep(5);\n\t}\n\telse {\n\t\tprintf(&#34;Customer %d:So much customers,not enough chairs.\\n&#34;,*(int*)(arg));\n\t\tsem_post(&amp;mutex);\n\t\tsleep(5);\n\t} //释放占用的资源\n}\nint main(int argc,char** argv ){\n\tsem_init(&amp;customers,0,0);\n\tsem_init(&amp;barbers,0,0);\n\tsem_init(&amp;mutex,0,1);\n\tpthread_t barber_t,customer_t[20];  //20个顾客线程\n\tpthread_create(&amp;barber_t,NULL,barber,NULL);\n\tfor(int i=0;i&lt;20;i&#43;&#43;){\n\t\tpthread_create(&amp;customer_t[i],NULL,customer,new int(i));\n\t}\n\tpthread_join(barber_t,NULL);\n\tfor(int i=0;i&lt;20;i&#43;&#43;){\n\t\tpthread_join(customer_t[i],NULL);\n\t}\n\treturn 0;\n}</pre>\n<p></p>", "created": "2017-05-07T00:01:50Z", "bucket_order": 247, "bucket_name": "Week 4/30 - 5/6", "type": "followup", "tag_good": [], "uid": "izb0cbkdd5s6w9", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>2018期末理发问题</p>\n<p>待编辑</p>\n<p></p>\n<p></p>", "created": "2019-05-05T15:50:18Z", "bucket_order": 142, "bucket_name": "Week 5/5 - 5/11", "type": "feedback", "tag_good": [], "uid": "jsk4iwnsAnmZ", "children": [], "tag_good_arr": [], "id": "jvb44bokh7u1vc", "updated": "2019-05-05T15:50:18Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "j2dxofyec4c22r", "updated": "2017-05-07T00:01:50Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>更新了代码&#xff0c;实现多个理发师工作</p>\n<pre>import java.util.Random;<br />import java.util.Vector;<br />import java.util.concurrent.Semaphore;<br /><br />import javax.swing.JOptionPane;<br /><br />/**主类**/<br />public class MainClassTest{<br />\t//主函数<br />\tpublic static void main(String[] args) throws InterruptedException {<br /><br />\t\tChair chair=new Chair(3);\t<br />\t\tSemaphore semp[] = new Semaphore[5];<br />\t\tsemp[0]=new Semaphore(1);<br />\t\tfor(int i=1;i&lt;semp.length;i&#43;&#43;){<br />\t\t\tsemp[i]=new Semaphore(0);<br />\t\t}<br />\t\t<br />\t\t/* 0对椅子的访问<br />\t\t * 1理发师休息和唤醒<br />\t\t * 2顾客等待理发<br />\t\t * 3顾客等待理发结束<br />\t\t * 4理发师等待给下一个理发<br />\t\t * <br />\t\t * */\t\t\t\t<br />\t\tint barberNum = 3;<br />\t\t<br />\t\tfor(int i=0;i&lt;barberNum;i&#43;&#43;)<br />\t\t{<br />          <br />\t\t\t//运行理发师线程<br />\t\t\tnew Barber(chair,semp, i).start();<br />\t\t}<br />\t\t<br />\t\t//创建随机函数类<br />\t\tRandom random=new Random();<br />\t\t<br />\t\tint customerNum =10;<br />\t\t<br />\t\tfor(int i=0;i&lt;customerNum;i&#43;&#43;)<br />\t\t{<br />            //产生[500,1000)之间的随机数<br />\t\t\tint time=random.nextInt(500&#43;100*random.nextInt(5));<br />\t\t\t//int time=1000;<br />\t\t\ttry {<br />\t\t\t\tThread.sleep(time);<br />\t\t\t} catch (InterruptedException e) {<br />\t\t\t\te.printStackTrace();<br />\t\t\t}<br />\t\t\t//运行顾客线程<br />\t\t\tnew Customer(chair,semp, i).start();<br />\t\t}<br />\t\t// try {<br />\t\t// \tbarber.join(100);<br />\t\t// } catch (InterruptedException e1) {\t<br />\t\t// \t/*打印出异常*/<br />\t\t// \te1.printStackTrace();<br />\t\t// }<br />\t\t<br />\t}<br />}<br /><br />//创建Barber线程类<br />class Barber extends Thread<br />{<br />\tprivate Semaphore semp[];<br />\tprivate Chair chair;<br />\tprivate  int  ID;<br />\tpublic Barber(Chair chair,Semaphore semp[], int ID)<br />\t{<br />\t\tthis.ID=ID;<br />\t\tthis.semp=semp;\t<br />\t\tthis.chair=chair;<br />\t}<br />\t/*定义理发函数*/<br />\tpublic void hairCut() throws InterruptedException<br />\t{<br />\t\tint CID=0;<br />\t\twhile(true){<br />\t\t\t<br />\t\t\tsemp[0].acquire();//获取对chair的读写权限。<br />\t\t\tif(chair.v.size()==0){<br />\t\t\t\tCID=-1;<br />\t\t\t}<br />\t\t\telse{<br />\t\t\t\tCID=chair.v.get(0);<br />\t\t\t}<br />\t\t\tsemp[0].release();<br />\t\t\t<br />\t\t\tif(CID==-1){<br />\t\t\t\tSystem.out.println(&#34;理发师&#34;&#43;ID&#43;&#34;&#xff1a;店里没人&#xff0c;开始休息&#34;);<br />\t\t\t\tsemp[1].acquire();//等待被唤醒<br />\t\t\t\t<br />\t\t\t\tSystem.out.println(&#34;理发师&#34;&#43;ID&#43;&#34;&#xff1a;被唤醒&#34;);<br />\t\t\t\tCID=chair.v.get(0);<br />\t\t\t\tSystem.out.println(&#34;---------------------------------&#34;);<br />\t\t\t}<br />\t\t\t<br />\t\t\tSystem.out.println(&#34;理发师&#34;&#43;ID&#43;&#34;&#xff1a;开始给Customer&#34;&#43;CID&#43;&#34;理发&#34;);<br />\t\t\tsemp[2].release();<br />\t\t\tThread.sleep(1000);//正在理发<br />\t\t\t<br />\t\t\tSystem.out.println(&#34;理发师&#34;&#43;ID&#43;&#34;&#xff1a;Customer&#34;&#43;CID&#43;&#34;理发结束&#34;);<br />\t\t\t<br />\t\t\tsemp[3].release();//理发结束&#xff0c;通知顾客可以走了<br />\t\t\t<br />\t\t\tsemp[4].acquire();//等待顾客走人。\t<br />\t\t}<br />\t\t<br />\t}<br />\t\t<br />\t\t<br />\t&#64;Override//重载hairCut()方法<br />\tpublic void run() {<br />\t\ttry {<br />\t\t\thairCut();<br />\t\t} catch (InterruptedException e) {<br />\t\t\t// TODO Auto-generated catch block<br />\t\t\te.printStackTrace();<br />\t\t}<br />\t}<br />}<br />//创建Customer线程类<br />class Customer extends Thread<br />{<br />\tprivate Chair chair;<br />\tprivate  int  ID;<br />\tprivate Semaphore semp[];<br />\tpublic Customer(Chair chair,Semaphore semp[], int ID)<br />\t{<br />\t\tthis.ID=ID;<br />\t\tthis.chair=chair;<br />\t\tthis.semp=semp;<br />\t}<br />\t//定义等待服务函数<br />\tpublic void waitAndService() throws InterruptedException<br />\t{<br />\t\tSystem.out.println(&#34;Customer&#34;&#43;ID&#43;&#34;到达&#34;);<br />\t\t<br />\t\tsemp[0].acquire();//获取对chair的读写权限。<br />\t\tif(chair.v.size()&gt;=chair.size){<br />\t\t\tSystem.out.println(&#34;Customer&#34;&#43;ID&#43;&#34;没有座位离开&#34;);<br />\t\t\tsemp[0].release();<br />\t\t\treturn;<br />\t\t}<br />\t\telse{<br />\t\t\tSystem.out.println(&#34;Customer&#34;&#43;ID&#43;&#34;坐下&#34;);<br />\t\t\tchair.v.add(ID);<br />\t\t\tif(chair.v.size()==1){<br />\t\t\t\tsemp[1].release();//唤醒理发师<br />\t\t\t\tSystem.out.println(&#34;Customer&#34;&#43;ID&#43;&#34;唤醒理发师&#34;);<br />\t\t\t}<br />\t\t}<br />\t\tsemp[0].release();<br />\t\t<br />\t\tSystem.out.println(&#34;Customer&#34;&#43;ID&#43;&#34;等待理发&#34;);<br />\t\tsemp[2].acquire();//等待理发师<br />\t\t<br />\t\tSystem.out.println(&#34;Customer&#34;&#43;ID&#43;&#34;开始理发&#34;);<br />\t\tsemp[3].acquire();//等待理发结束<br />\t\tSystem.out.println(&#34;Customer&#34;&#43;ID&#43;&#34;理发结束&#34;);<br />\t\t<br />\t\t\t\t<br />\t\tSystem.out.println(&#34;Customer&#34;&#43;ID&#43;&#34;离开座位&#34;);<br />\t\tSystem.out.println(&#34;---------------------------------&#34;);<br />\t\tchair.v.remove(0);<br /><br />\t<br />\t\tsemp[4].release();//理发师可以给下一个人理发了<br />\t\t<br />\t}<br />\t<br />\tpublic void run()<br />\t{<br />\t\ttry {<br />\t\t\twaitAndService();<br />\t\t} catch (InterruptedException e) {<br />\t\t\t// TODO Auto-generated catch block<br />\t\t\te.printStackTrace();<br />\t\t}<br />\t}<br />}<br /><br />class Chair{<br />\tpublic Vector&lt;Integer&gt; v; <br />\tpublic int size;<br />\tpublic Chair(int size){<br />\t\tthis.size=size;<br />\t\tv=new Vector&lt;Integer&gt;(size);<br />\t}<br />}</pre>\n<p>以2个等待座位&#xff0c;4位顾客为例的测试结果&#xff1a;</p>\n<pre>理发师&#xff1a;店里没人&#xff0c;开始休息\nCustomer0到达\nCustomer0坐下\nCustomer0唤醒理发师\nCustomer0等待理发\n理发师&#xff1a;被唤醒\n---------------------------------\n理发师&#xff1a;开始给Customer0理发\nCustomer0开始理发\nCustomer1到达\nCustomer1坐下\nCustomer1等待理发\nCustomer2到达\nCustomer2没有座位离开\n理发师&#xff1a;Customer0理发结束\nCustomer0理发结束\nCustomer0离开座位\n---------------------------------\n理发师&#xff1a;开始给Customer1理发\nCustomer1开始理发\nCustomer3到达\nCustomer3坐下\nCustomer3等待理发\n理发师&#xff1a;Customer1理发结束\nCustomer1理发结束\nCustomer1离开座位\n---------------------------------\n理发师&#xff1a;开始给Customer3理发\nCustomer3开始理发\n理发师&#xff1a;Customer3理发结束\nCustomer3理发结束\nCustomer3离开座位\n---------------------------------\n理发师&#xff1a;店里没人&#xff0c;开始休息</pre>\n<p></p>", "created": "2019-05-08T15:32:09Z", "bucket_order": 142, "bucket_name": "Week 5/5 - 5/11", "type": "followup", "tag_good": [], "uid": "jsk4iwnsAnmZ", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "jvfdsj9igb06yl", "updated": "2019-05-08T15:32:09Z", "config": {}}], "tag_good_arr": [], "id": "i9ccmyc49aa3r2", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 32, "num_favorites": 3, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643167719805, "default_anonymity": "no"}, "error": null, "aid": "kyuzmv0dizp1yi"}