{"result": {"folders": ["lab5", "lab6"], "nr": 393, "data": {"embed_links": []}, "created": "2015-05-06T13:11:17Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "full", "when": "2015-05-06T13:11:17Z", "data": "i9crk49kytjs3", "type": "create", "uid_a": "a_0"}, {"to": "i9crk47tfs7s2", "uid": "hxu22d7okof4c1", "anon": "no", "when": "2015-05-06T16:17:06Z", "data": "i9cy730s5ig5d2", "type": "s_answer"}, {"uid": "hxu22d7okof4c1", "anon": "no", "when": "2015-05-06T16:18:11Z", "data": "i9cy8gxkwdh71n", "type": "s_answer_update"}, {"uid": "hxu22d7okof4c1", "anon": "no", "when": "2015-05-06T16:46:03Z", "data": "i9cz8b9hria4e", "type": "s_answer_update"}, {"uid": "hxu22d7okof4c1", "anon": "no", "when": "2015-05-06T16:48:20Z", "data": "i9czb918gor4ui", "type": "s_answer_update"}, {"uid": "hxu22d7okof4c1", "anon": "no", "when": "2015-05-06T16:51:15Z", "data": "i9czezz6ssx3be", "type": "s_answer_update"}, {"uid": "hxu22d7okof4c1", "anon": "no", "when": "2015-05-06T16:52:07Z", "data": "i9czg4lnvc02ko", "type": "s_answer_update"}], "bucket_name": "Today", "history": [{"anon": "full", "uid_a": "a_0", "subject": "initproc是怎样退出的", "created": "2015-05-06T13:11:17Z", "content": "<p>我在做实验的时候通过观察qemu输出</p>\n<pre>stride sched correct result: 1 2 3 4 5<br />all user-mode processes have quit.<br />init check memory pass.<br />kernel panic at kern/process/proc.c:491:<br /> initproc exit.<br />Welcome to the kernel debug monitor!!</pre>\n<p></p>\n<p>发现内核的第二个线程initproc最后会退出&#xff0c;因为有&#34;initproc exit.&#34;这一句</p>\n<p>这一句输出来源于do_exit函数的开头</p>\n<pre>do_exit(int error_code) {\n    if (current == idleproc) {\n        panic(&#34;idleproc exit.\\n&#34;);\n    }\n    if (current == initproc) {\n        panic(&#34;initproc exit.\\n&#34;);\n    }</pre>\n<p>我想问一下initproc是如何到达的do_exit的呢&#xff1f;</p>\n<p>该内核线程在创建的时候是</p>\n<pre>    int pid = kernel_thread(init_main, NULL, 0);</pre>\n<p>而init_main函数的结尾是</p>\n<pre>\n    while (do_wait(0, NULL) == 0) {\n        schedule();\n    }\n\n    cprintf(&#34;all user-mode processes have quit.\\n&#34;);\n    assert(initproc-&gt;cptr == NULL &amp;&amp; initproc-&gt;yptr == NULL &amp;&amp; initproc-&gt;optr == NULL);\n    assert(nr_process == 2);\n    assert(list_next(&amp;proc_list) == &amp;(initproc-&gt;list_link));\n    assert(list_prev(&amp;proc_list) == &amp;(initproc-&gt;list_link));\n\n    cprintf(&#34;init check memory pass.\\n&#34;);\n    return 0;\n}</pre>\n<p>最后的那一个return 0是return到什么地方了呢&#xff1f;为什么又会跳转到do_exit&#xff1f;</p>\n<p></p>\n<p>如果是用户进程的话还是挺好理解的&#xff0c;因为每个用户进程的最后都有一个系统调用exit</p>\n<p>但是这个内核线程&#xff0c;结尾的时候是怎么exit的呢&#xff1f;</p>"}], "type": "question", "tags": ["lab5", "lab6", "student"], "tag_good": [], "unique_views": 143, "children": [{"folders": [], "data": {"embed_links": []}, "children": [], "created": "2015-05-06T16:17:06Z", "bucket_order": 3, "tag_endorse": [], "bucket_name": "Today", "id": "i9cy730opwx5d1", "history": [{"anon": "no", "uid": "hxu22d7okof4c1", "subject": "", "created": "2015-05-06T16:52:07Z", "content": "<p>kernel_thread&#xff08;proc.c&#xff09;函数fork完了就会return到kernel_thread_entry&#xff08;entry.S&#xff09;里面&#xff0c;kernel_thread_entry里面调用*%ebx&#xff08;就是init_main&#xff09;后会回到&#96;pushl %eax&#96;&#xff08;entry.S&#xff09;这一行&#xff0c;就把%eax传给do_exit&#xff08;proc.c&#xff09;了。</p>"}, {"anon": "no", "uid": "hxu22d7okof4c1", "subject": "", "created": "2015-05-06T16:51:15Z", "content": "<p>kernel_thread&#xff08;proc.c&#xff09;函数fork完了就会return到kernel_thread_entry&#xff08;entry.S&#xff09;里面&#xff0c;kernel_thread_entry里面调用*%ebx&#xff08;就是init_main&#xff09;后会回到&#96;pushl %eax&#96;&#xff08;entry.S&#xff09;这一行&#xff0c;就把%eax传给do_exit&#xff08;proc.c&#xff09;了。</p>\n<p></p>\n<p></p>\n<p>题外话&#xff1a;我怎么查到的</p>\n<pre>tiger&#64;ubuntu:~/Documents/ucore_lab/labcodes/lab6$ grep -r &#34;do_exit&#34; *\nkern/process/proc.c:    PROC_ZOMBIE     :   almost dead             -- do_exit\nkern/process/proc.c:                                           |      &#43;--- do_exit --&gt; PROC_ZOMBIE                                &#43;\nkern/process/proc.c:SYS_exit        : process exit,                           --&gt;do_exit\nkern/process/proc.c:                                                                 --&gt;wakeup_proc--&gt;do_wait--&gt;do_exit   \nkern/process/proc.c:// do_exit - called by sys_exit\nkern/process/proc.c:do_exit(int error_code) {\nkern/process/proc.c:    panic(&#34;do_exit will not return!! %d.\\n&#34;, current-&gt;pid);\nkern/process/proc.c:    do_exit(ret);\nkern/process/proc.c:            do_exit(-E_KILLED);\nkern/process/proc.h:int do_exit(int error_code);\nkern/process/entry.S:    call do_exit            # call do_exit to terminate current thread\nkern/trap/trap.c:                do_exit(-E_KILLED);\nkern/trap/trap.c:            do_exit(-E_KILLED);\nkern/trap/trap.c:                do_exit(-E_KILLED);\nkern/syscall/syscall.c:    return do_exit(error_code);</pre>\n<p>有可能的就是</p>\n<pre>kern/process/proc.c:    do_exit(ret);<br />kern/process/entry.S:    call do_exit            # call do_exit to terminate current thread<br />kern/syscall/syscall.c:    return do_exit(error_code);</pre>\n<p>这几个&#xff08;因为另外几个调用do_exit的地方都是常数&#xff0c;不可能&#xff09;&#xff0c;挨个验证。</p>"}, {"anon": "no", "uid": "hxu22d7okof4c1", "subject": "", "created": "2015-05-06T16:48:20Z", "content": "<p>kernel_thread&#xff08;proc.c&#xff09;函数fork完了就会return到kernel_thread_entry&#xff08;entry.S&#xff09;里面&#xff0c;kernel_thread_entry里面调用*%ebx&#xff08;就是init_main&#xff09;后会回到&#96;pushl %eax&#96;&#xff08;entry.S&#xff09;这一行&#xff0c;就把%eax传给do_exit&#xff08;proc.c&#xff09;了。</p>\n<p></p>"}, {"anon": "no", "uid": "hxu22d7okof4c1", "subject": "", "created": "2015-05-06T16:46:03Z", "content": "<p>在kern/process/entry.S里面&#xff0c;它调用fn&#xff0c;最后把%eax作为do_exit的参数。因为init_proc也是fork出来的&#xff0c;proc.c的kernel_thread函数fork完了就会return到kernel_thread_entry里面&#xff0c;kernel_thread_entry里面调用init_proc完后会回到&#96;pushl %eax&#96;这一行&#xff0c;就把%eax传给do_exit了。</p>\n<p></p>"}, {"anon": "no", "uid": "hxu22d7okof4c1", "subject": "", "created": "2015-05-06T16:18:11Z", "content": "<p></p>"}, {"anon": "no", "uid": "hxu22d7okof4c1", "subject": "", "created": "2015-05-06T16:17:06Z", "content": "<p>应该是有一个mainCRTStartup调用main&#xff0c;把main的返回值exit出来的。相当于</p>\n<p></p>\n<pre>void mainCRTStartup() {<br />    exit(main());<br />}</pre>\n<p>但实际上比这复杂&#xff0c;它会先初始化全局变量&#xff0c;初始化一些库&#xff0c;最后会做些清尾工作。这都是C/C&#43;&#43;编译器帮你做的</p>\n<p></p>"}], "type": "s_answer", "tag_endorse_arr": [], "config": {}, "is_tag_endorse": false}], "tag_good_arr": [], "no_answer": 0, "id": "i9crk47tfs7s2", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 3, "num_favorites": 0, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643167730663, "default_anonymity": "no"}, "error": null, "aid": "kyuzn3dzjnt2wp"}