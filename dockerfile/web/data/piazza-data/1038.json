{"result": {"history_size": 1, "folders": ["2017", "课堂问答", "lab4", "lecture13"], "nr": 1038, "data": {"embed_links": []}, "created": "2017-04-10T08:14:08Z", "bucket_order": 3, "no_answer_followup": 2, "change_log": [{"anon": "no", "uid": "hdjonbiyfs62ie", "data": "j1budjgy5ys4eq", "type": "create", "when": "2017-04-10T08:14:08Z"}, {"anon": "no", "uid": "ie7xy8gtpwk1t5", "to": "j1budjgx9ab4ep", "type": "followup", "when": "2017-04-16T08:44:01Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j1budjgx9ab4ep", "type": "feedback", "when": "2017-04-17T01:08:42Z"}, {"anon": "no", "uid": "ie7xy8gtpwk1t5", "to": "j1budjgx9ab4ep", "type": "feedback", "when": "2017-04-17T04:01:48Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j1budjgx9ab4ep", "type": "feedback", "when": "2017-04-17T04:16:13Z"}, {"anon": "no", "uid": "isvxeq6bspf1vn", "to": "j1budjgx9ab4ep", "type": "followup", "when": "2018-04-17T01:07:35Z"}, {"anon": "no", "uid": "je2ib42p5md6au", "to": "j1budjgx9ab4ep", "type": "followup", "when": "2018-04-17T01:08:19Z"}, {"anon": "no", "uid": "je2ib42p5md6au", "to": "j1budjgx9ab4ep", "type": "feedback", "when": "2018-04-17T01:57:49Z"}, {"anon": "no", "uid": "isvxeq6bspf1vn", "to": "j1budjgx9ab4ep", "type": "feedback", "when": "2018-04-18T12:20:25Z"}, {"anon": "no", "uid": "isvxeq6bspf1vn", "to": "j1budjgx9ab4ep", "type": "feedback", "when": "2018-04-18T13:06:33Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j1budjgx9ab4ep", "type": "feedback", "when": "2018-04-20T04:09:15Z"}, {"anon": "no", "uid": "ie7xy2fekwm1np", "to": "j1budjgx9ab4ep", "type": "followup", "when": "2018-04-20T06:21:51Z"}, {"anon": "no", "uid": "j166z5vyA7y", "to": "j1budjgx9ab4ep", "type": "feedback", "when": "2019-11-22T16:19:40Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "2017春季-第十三讲课堂实践练习(3)", "created": "2017-04-10T08:14:08Z", "content": "<p>请两人一组完成“第十三讲 实验四 内核线程管理”中指定小题的回答在此贴中回复&#xff0c;每组同学选做一个数据结构分析和一个流程分析。</p>\n<p></p>\n<p>题目&#xff1a;<br /><a href=\"https://chyyuu.gitbooks.io/os_course_exercises/content/all/05-3-lab4-spoc-discussion.html\">https://chyyuu.gitbooks.io/os_course_exercises/content/all/05-3-lab4-spoc-discussion.html</a></p>\n<p></p>\n<p>视频相关思考题 -&gt; 13.3 执行流程 -&gt; 第5小题</p>\n<p></p>\n<p>分析线程切换流程&#xff0c;找到内核堆栈、页表、寄存器切换的代码位置。</p>"}], "type": "note", "tags": ["2017", "instructor-note", "lab4", "lecture13", "课堂问答"], "tag_good": [], "unique_views": 131, "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p></p><pre>void\nproc_run(struct proc_struct *proc) {\n    if (proc != current) {\n        bool intr_flag;\n        struct proc_struct *prev = current, *next = proc;\n        local_intr_save(intr_flag);\n        {\n            current = proc;\n            <strong>load_esp0(next-&gt;kstack &#43; KSTACKSIZE);</strong>\n            <strong>lcr3(next-&gt;cr3);</strong>\n            <strong>switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context));</strong>\n        }\n        local_intr_restore(intr_flag);\n    }\n}</pre>\n<p></p>", "created": "2017-04-16T08:44:01Z", "bucket_order": 196, "bucket_name": "Week 4/9 - 4/15", "type": "followup", "tag_good": [], "uid": "ie7xy8gtpwk1t5", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>你这里的load_esp0()是只是设置了ts数据结构中的一个字段&#xff0c;并不是真正的堆栈切换。</p>\n<p></p>", "created": "2017-04-17T01:08:42Z", "bucket_order": 195, "bucket_name": "Week 4/16 - 4/22", "type": "feedback", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [], "tag_good_arr": [], "id": "j1lf9eihdkd17h", "updated": "2017-04-17T01:08:42Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>之前理解错了&#xff0c;现在我觉得堆栈切换就在switch_to.S中context.esp的切换&#xff0c;不知道是这样吗&#xff1f;</p>", "created": "2017-04-17T04:01:48Z", "bucket_order": 195, "bucket_name": "Week 4/16 - 4/22", "type": "feedback", "tag_good": [], "uid": "ie7xy8gtpwk1t5", "children": [], "tag_good_arr": [], "id": "j1llg0aet5vun", "updated": "2017-04-17T04:01:48Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>尝试实际跟踪一下运行情况&#xff0c;然后把结果描述一下。如何&#xff1f;</p>", "created": "2017-04-17T04:16:13Z", "bucket_order": 195, "bucket_name": "Week 4/16 - 4/22", "type": "feedback", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [], "tag_good_arr": [], "id": "j1llyjdfbah27", "updated": "2017-04-17T04:16:13Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "j1kg33ghbf547m", "updated": "2017-04-16T08:44:01Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>魏钧宇 2015011263</p>", "created": "2018-04-17T01:07:35Z", "bucket_order": 143, "bucket_name": "Week 4/15 - 4/21", "type": "followup", "tag_good": [], "uid": "isvxeq6bspf1vn", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>我分析了从schedule中调度一个进程开始运行到正式完成切换为止的全过程&#xff0c;以PA4中idle线程向init线程的切换过程为例进行分析&#xff08;这个过程涉及到新线程的创建&#xff0c;所以相对比较复杂&#xff09;</p>\n<p>idle线程创建之初的need_resched字段就会被设置为0&#xff0c;所以一旦执行schedule&#xff0c;立马会调度新创建的init线程执行&#xff0c;从proc_run处开始调度</p>\n<pre>void\nproc_run(struct proc_struct *proc) {\n    if (proc != current) {\n        bool intr_flag;\n        struct proc_struct *prev = current, *next = proc;\n        local_intr_save(intr_flag); //确保操作的原子性\n        {\n            current = proc; //切换current进程&#xff08;在当前例子中讲current从指向idle线程修改为指向init线程&#xff09;\n            load_esp0(next-&gt;kstack &#43; KSTACKSIZE); //修改tss表中的内核堆栈为新的内核堆栈&#xff08;在当前例子中idle的内核堆栈是boot_stack而init的内核堆栈为新分配的一块内核内存区域&#xff09;\n            lcr3(next-&gt;cr3); //修改页表起始地址&#xff08;在当前例子中&#xff0c;这条语句没有意义&#xff0c;因为idle和init共用一张页表boot_pgdir&#xff09;\n            switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context)); //调用switch_to函数执行通用寄存器的切换&#xff08;下面会详细介绍&#xff0c;注意这里的prev -&gt; context是switch_to的第一个参数&#xff08;在当前的例子中就是idle的context字段的地址&#xff0c;next -&gt; context是switch_to的第二个参数&#xff08;在当前的例子中就是init的context字段&#xff09;\n        }\n        local_intr_restore(intr_flag);\n    }\n}</pre>\n<p>这是proc_run的代码&#xff0c;其中从current开始一直到switch_to的4句是进程切换过程中最关键的四条语句&#xff0c;分别对应于切换current指针的目标位置说明当前进程已经切换&#xff0c;修改tss表中的内核堆栈起始地址以支持新进程中的中断操作&#xff0c;修改页表起始地址&#xff0c;重新装载cr3寄存器&#xff0c;调用switch_to函数来完成剩下的切换工作。</p>\n<p>由于switch_to函数对应的context字段的处理&#xff0c;为了下面的描述方便&#xff0c;我们在这里先介绍context字段的详细内容&#xff1a;</p>\n<p></p>\n<pre>struct context {\n    uint32_t eip; //注意&#xff1a;第一个位置保存的指令寄存器eip\n    uint32_t esp; //第二个位置保存了栈顶寄存器esp\n    uint32_t ebx; //剩下位置就都是通用寄存器\n    uint32_t ecx;\n    uint32_t edx;\n    uint32_t esi;\n    uint32_t edi;\n    uint32_t ebp;\n};</pre>\n<p></p>\n<p>下面是switch_to函数的具体内容&#xff1a;</p>\n<p></p>\n<pre>.text\n.globl switch_to\nswitch_to:                      \n\n    movl 4(%esp), %eax #esp指向当前的栈顶&#xff0c;注意这个栈还是原进程的栈&#xff0c;esp&#43;4对应于传入switch_to的第一个参数prev -&gt; context&#xff08;在我们的例子中对应于\n    popl 0(%eax) #context结构中的第一个位置需要当前的eip&#xff0c;当前的栈顶是调用switch_to时的返回地址&#xff08;switch_to的下一条、位于proc_run中&#xff09;&#xff0c;这里将这个地址保存到了idle控制块的context字段中\n    movl %esp, 4(%eax) #将当前的堆栈指针保存到context中&#xff0c;这样未来切换回来的时候&#xff0c;就会从没有调switch_to函数的堆栈情况开始运行\n    movl %ebx, 8(%eax) #保存剩下的通用寄存器&#xff0c;都纷纷保存到idle的context中\n    movl %ecx, 12(%eax)\n    movl %edx, 16(%eax)\n    movl %esi, 20(%eax)\n    movl %edi, 24(%eax)\n    movl %ebp, 28(%eax)\n\n    # restore to&#39;s registers\n    movl 4(%esp), %eax  #由于esp已经将返回地址弹出&#xff0c;所以对应的此时的esp&#43;4就是next -&gt; context的首地址了\n    movl 28(%eax), %ebp #将next -&gt; context中的保存的通用寄存器的值纷纷恢复\n    movl 24(%eax), %edi\n    movl 20(%eax), %esi\n    movl 16(%eax), %edx\n    movl 12(%eax), %ecx\n    movl 8(%eax), %ebx \n    movl 4(%eax), %esp #正式换栈&#xff0c;从此栈正式切换到init线程的栈上\n\n    pushl 0(%eax)      #将init线程context中的eip压入到它的堆栈中&#xff08;首次运行时这个位置在forkret函数处&#xff09;\n\n    ret #跳转到forkret函数中开始执行\n</pre>\n<p>forkret函数如下&#xff1a;</p>\n<p></p>\n<pre>static void\nforkret(void) {\n    forkrets(current-&gt;tf);\n}</pre>\n<p>我们看到它调用了forkrets&#xff0c;同时将当前init线程的tf字段作为参数传入</p>\n<p></p>\n<p>forkrets函数如下&#xff1a;</p>\n<pre>.globl forkrets\nforkrets:\n    # set stack to this new process&#39;s trapframe\n    movl 4(%esp), %esp //现在的esp指向的是forkret的返回位置&#xff0c;esp &#43; 4指向的是current -&gt; tf\n    jmp __trapret</pre>\n<p>我们看到&#xff0c;它使得当前的堆栈指针直接指向了init线程的trapframe的起始地址&#xff0c;然后直接通过jmp指令&#xff0c;跳转到trapret中开始执行</p>\n<p></p>\n<p>由于init线程的初始化是通过中断的方式完成的&#xff0c;我们有必要看看trapframe结构的详细内容&#xff1a;</p>\n<pre>struct trapframe {\n    struct pushregs tf_regs; //init线程初始化运行时所需要的通用寄存器内容\n    \n    //init线程运行在内核态&#xff0c;所以它的栈寄存器都是内核态特权的\t\n    uint16_t tf_gs; //额外的附加段寄存器&#xff0c;无用\n    uint16_t tf_padding0;\n    uint16_t tf_fs; //额外的附加段寄存器&#xff0c;无用\n    uint16_t tf_padding1;\n    uint16_t tf_es; //附加段寄存器是内核态的\n    uint16_t tf_padding2;\n    uint16_t tf_ds; //数据段寄存器是内核态的\n    uint16_t tf_padding3;\n\n    uint32_t tf_trapno; //和切换无关\n    uint32_t tf_err; //和切换无关\n\n    uintptr_t tf_eip; //这里的eip保存的就是kernel_thread_entry的入口地址\n    uint16_t tf_cs; //这里的cs堆栈寄存器保存的是内核态特权的cs\n\n    uint16_t tf_padding4;\n    uint32_t tf_eflags; //eflags标记了新切换的目标线程/进程是否允许中断\n    \n    uintptr_t tf_esp; //这里的esp指向了目标线程/进程的用户堆栈的位置&#xff08;但是在内核线程例子中&#xff0c;运行使用的堆栈只有一个&#xff0c;所以这里被初始化为0&#xff09;\n    uint16_t tf_ss; //这里的ss是内核态的\n    \n    uint16_t tf_padding5;\n} __attribute__((packed));</pre>\n<p></p>\n<p>我们看到trapfram中通过tf_regs的形式保存了一系列通用寄存器&#xff0c;在我们的例子中&#xff0c;这里面就是init线程第一次运行需要的环境&#xff0c;下面是tf_regs的内容</p>\n<pre>struct pushregs {\n    uint32_t reg_edi;\n    uint32_t reg_esi;\n    uint32_t reg_ebp;\n    uint32_t reg_oesp; //这个esp是没有用处的&#xff0c;不会修改堆栈         /* Useless */\n    uint32_t reg_ebx; //这里保存有init运行的第一段代码main函数的入口地址\n    uint32_t reg_edx; \n    uint32_t reg_ecx; //这里保存有init运行的第一段代码的参数\n    uint32_t reg_eax;\n};</pre>\n<p></p>\n<p>trapret函数如下&#xff1a;</p>\n<pre>.globl __trapret\n__trapret:\n    # restore registers from stack\n    popal\n\n    # restore %ds, %es, %fs and %gs\n    popl %gs\n    popl %fs\n    popl %es\n    popl %ds\n\n    # get rid of the trap number and error code\n    addl $0x8, %esp\n    iret</pre>\n<p>我们看到&#xff0c;它首先通过popal初始化了保存在中断帧中的一系列通用寄存器&#xff0c;接下来初始化了段寄存器&#xff08;由于init线程在内核态运行&#xff0c;所以它的各类堆栈寄存器特权都是内核态的&#xff0c;包括gs,fs,es, ds&#xff0c;在顺利将他们都pop以后&#xff0c;此时的esp指向的是trapframe的trapno字段&#xff0c;由于这个字段和下面的errorcode 和这里的进程切换都没有关系&#xff0c;所以直接通过add指令跳过。</p>\n<p></p>\n<p>最后iret的时候&#xff0c;esp指向的是kernel_thread_entry&#xff0c;esp - 4对应于内核态的cs&#xff0c;下面依次有eflags, esp,ss等&#xff0c;此时的iret会一方面修改eip的值使之从kernel_thread_entry开始执行&#xff0c;另一方面将当前的代码段堆栈特权级设置为内核态。</p>\n<p></p>\n<p>接下来init进程就从kernel_thread_entry开始执行了&#xff0c;下面是kernel_thread_entry的函数&#xff1a;</p>\n<pre>.text\n.globl kernel_thread_entry\nkernel_thread_entry:        # void kernel_thread(void)\n\n    pushl %edx              #将init线程的main函数入口地址压栈\n    call *%ebx              #跳转到main函数开始执行\n\n    pushl %eax              # main 返回以后保存eax的数值作为返回值\n    call do_exit            # 调用do_exit</pre>\n<p>其中的main函数很简单就是打印了一个字符串&#xff0c;接下来的exit在PA4中比较简单&#xff0c;在未来还需要完成资源回收的工作等</p>", "created": "2018-04-18T12:20:25Z", "bucket_order": 143, "bucket_name": "Week 4/15 - 4/21", "type": "feedback", "tag_good": [], "uid": "isvxeq6bspf1vn", "children": [], "tag_good_arr": [], "id": "jg52f0bxpeo14q", "updated": "2018-04-18T12:20:25Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>针对trapfram的esp段存在两个疑惑&#xff0c;希望老师同学们帮忙解答一下</p>\n<p></p>\n<p>问题1: 在PA4中&#xff0c;trapframe -&gt; esp 直接被设置为了0&#xff0c;在硬件执行iret的时候是否会弹出这个esp发生栈的切换&#xff1f;</p>\n<p></p>\n<p>问题2: 在context中没有保存eax寄存器的值&#xff0c;这里当然没有问题&#xff0c;但是在一般的进程切换中&#xff0c;这样做是否会有问题&#xff1f;</p>", "created": "2018-04-18T13:06:33Z", "bucket_order": 143, "bucket_name": "Week 4/15 - 4/21", "type": "feedback", "tag_good": [], "uid": "isvxeq6bspf1vn", "children": [], "tag_good_arr": [], "id": "jg542cfd5izqy", "updated": "2018-04-18T13:06:33Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>问题1的回答&#xff1a;在switch_to函数中esp完成恢复后&#xff0c;栈就完成切换了。</p>\n<p></p>\n<p>问题2的回答&#xff1a;一般进程在被抢占时是在时钟中断中完成eax的保存的。在内核中进行switch_to时&#xff0c;就不需要保存了。</p>", "created": "2018-04-20T04:09:15Z", "bucket_order": 143, "bucket_name": "Week 4/15 - 4/21", "type": "feedback", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [], "tag_good_arr": [], "id": "jg7fr2aswjr5j3", "updated": "2018-04-20T04:09:15Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "jg2yxw1n2o75xm", "updated": "2018-04-17T01:07:35Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>沈俊贤 2015011258</p>", "created": "2018-04-17T01:08:19Z", "bucket_order": 143, "bucket_name": "Week 4/15 - 4/21", "type": "followup", "tag_good": [], "uid": "je2ib42p5md6au", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<p><img src=\"/img/1038-1927f60f90ec18ea.jpeg\" alt=\"\" />方便起见直接截取kernel.asm的代码片段</p>\n<p>可以见到</p>\n<p>分别执行load_esp0和lcr3之后&#xff0c;switch_to实现了堆栈切换</p>", "created": "2018-04-17T01:57:49Z", "bucket_order": 143, "bucket_name": "Week 4/15 - 4/21", "type": "feedback", "tag_good": [], "uid": "je2ib42p5md6au", "children": [], "tag_good_arr": [], "id": "jg30qhlkgnm4hi", "updated": "2018-04-17T01:57:49Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "jg2yytwqikg4iy", "updated": "2018-04-17T01:08:19Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>之后补上switch_to的进一步分析</p>", "created": "2018-04-20T06:21:51Z", "bucket_order": 143, "bucket_name": "Week 4/15 - 4/21", "type": "followup", "tag_good": [], "uid": "ie7xy2fekwm1np", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>请问有switch_to的进一步分析吗</p>", "created": "2019-11-22T16:19:40Z", "bucket_order": 60, "bucket_name": "Week 11/17 - 11/23", "type": "feedback", "tag_good": [], "uid": "j166z5vyA7y", "children": [], "tag_good_arr": [], "id": "k3acobna7ps3rd", "updated": "2019-11-22T16:19:40Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "jg7khl8dl205s9", "updated": "2018-04-20T06:21:51Z", "config": {}}], "tag_good_arr": [], "id": "j1budjgx9ab4ep", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 6, "num_favorites": 1, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169016086, "default_anonymity": "no"}, "error": null, "aid": "kyv0en86okf3mf"}