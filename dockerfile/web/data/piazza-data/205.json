{"result": {"history_size": 5, "folders": ["课堂问答"], "nr": 205, "data": {"embed_links": []}, "created": "2015-03-30T06:28:34Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"uid": "i6un4iacNGX", "anon": "no", "when": "2015-03-30T06:28:34Z", "data": "i7vhvpvhhl12ev", "type": "create"}, {"to": "i7vhvpvd2ss2eu", "uid": "i7bq1v7feay2z9", "anon": "no", "when": "2015-03-30T06:35:03Z", "type": "followup"}, {"uid": "hcrrjuyequh4bt", "anon": "no", "when": "2015-03-30T06:36:11Z", "data": "i7vi5huzcdzgh", "type": "update"}, {"to": "i7vhvpvd2ss2eu", "uid": "i6uuk6b68du319", "anon": "no", "when": "2015-03-30T06:41:11Z", "type": "followup"}, {"to": "i7vhvpvd2ss2eu", "uid": "i6uji18l8j51ob", "anon": "no", "when": "2015-03-30T06:47:08Z", "type": "feedback"}, {"to": "i7vhvpvd2ss2eu", "uid": "i6sl02qfUgI", "anon": "no", "when": "2015-03-30T06:53:57Z", "type": "followup"}, {"to": "i7vhvpvd2ss2eu", "uid": "i7013x05eSl", "anon": "no", "when": "2015-03-30T07:05:00Z", "type": "followup"}, {"to": "i7vhvpvd2ss2eu", "uid": "i7bfvegt8am5ir", "anon": "no", "when": "2015-03-30T07:26:01Z", "type": "followup"}, {"uid": "hdjoucuyb836fq", "anon": "no", "when": "2015-03-30T08:06:39Z", "data": "i7vldubi2286j7", "type": "update"}, {"to": "i7vhvpvd2ss2eu", "uid": "i71ev8heKQi", "anon": "no", "when": "2015-03-30T09:56:59Z", "type": "followup"}, {"to": "i7vhvpvd2ss2eu", "uid": "i7013x05eSl", "anon": "no", "when": "2015-03-30T14:40:31Z", "type": "feedback"}, {"to": "i7vhvpvd2ss2eu", "uid": "i6utvrywozd2vd", "anon": "no", "when": "2015-03-30T17:10:44Z", "type": "followup"}, {"uid": "hcrrjuyequh4bt", "anon": "no", "when": "2015-04-01T14:47:52Z", "data": "i7yulizvsnf61m", "type": "update"}, {"uid": "hcrrjuyequh4bt", "anon": "no", "when": "2015-04-01T14:50:49Z", "data": "i7yupbkmia4d6", "type": "update"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hcrrjuyequh4bt", "subject": "lec9-spoc Q1:证明LRU不会出现Belady现象", "created": "2015-04-01T14:50:49Z", "content": "<p>优胜者&#xff1a;</p>\n<p>楼华哲 2012011327</p>\n<p>李日灵 2012011332</p>\n<p>李若愚 2012011353</p>\n<p>周昊 2012011326</p>\n<p></p>\n<p>课堂规定小于等于&#xff14;人一组。</p>\n<p>鼓励非清华学生一起完成spoc 练习&#xff01;</p>\n<p>可以把自己的解答写到你自己的fork的github中的os_exercise 的git repo中。</p>"}, {"anon": "no", "uid": "hcrrjuyequh4bt", "subject": "lec9-spoc Q1:证明LRU不会出现Belady现象", "created": "2015-04-01T14:47:52Z", "content": "<p>优胜者&#xff1a;</p>\n<p>楼华哲 2012011327</p>\n<p>李日灵 2012011332</p>\n<p>李若愚 2012011353</p>\n<p>周昊 2012011326</p>\n<p></p>\n<p>鼓励非清华学生一起完成spoc 练习&#xff01;</p>\n<p>可以把自己的解答写到你自己的fork的github中的os_exercise 的git repo中。</p>"}, {"anon": "no", "uid": "hdjoucuyb836fq", "subject": "lec9-spoc Q1:证明LRU不会出现Belady现象", "created": "2015-03-30T08:06:39Z", "content": "<p></p>"}, {"anon": "no", "uid": "hcrrjuyequh4bt", "subject": "lec9-spoc Q1:证明LRU不会出现Belady现象", "created": "2015-03-30T06:36:11Z", "content": "<p></p>"}, {"anon": "no", "uid": "i6un4iacNGX", "subject": "证明LRU不会出现Belady现象", "created": "2015-03-30T06:28:34Z", "content": "<p></p>"}], "type": "note", "tags": ["student", "unanswered", "课堂问答"], "tag_good": [], "unique_views": 240, "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>楼华哲 2012011327</p>\n<p>李日灵 2012011332</p>\n<p>李若愚 2012011353</p>\n<p>周昊 2012011326</p>\n<p>裴中煜 2012010685</p>\n<p>第一题证明完成&#xff0c;形式化证明稍后和代码一起提交</p>\n<p></p>", "created": "2015-03-30T06:35:03Z", "bucket_order": 354, "bucket_name": "Week 3/29 - 4/4", "type": "followup", "tag_good": [], "uid": "i7bq1v7feay2z9", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>证明如下&#xff1a;</p>\n<pre>    证明&#xff1a;\n        原理:因为小的物理页帧的栈包含于大数目的物理页帧的栈\n        证明根据课堂老师给出的基础&#xff1a;\n            来证明s(t) 始终包含于 s&#39;(t)\n            利用归纳法&#xff0c;假设 1&lt;=i&lt;=t-1 时 s(i)包含于s&#39;(i)&#xff0c;现在要证s(t)依然包含于s&#39;(t)\n            (1) b(t)同时属于s(t)和s&#39;(t)&#xff1a;此时s(t)和s&#39;(t)都不发生变化&#xff0c;满足包含关系&#xff1b;\n            (2) b(t)不属于s(t),属于s&#39;(t)&#xff1a;s(t) 替换后&#xff0c;由于b(t)∈s(t)&#xff0c;所以s(t)包含于s&#39;(t)\n            (3)  (1)和(2)很容易证明&#xff0c;\n                对于b(t)同时不属于s(t-1)和s&#39;(t-1)的情况&#xff0c;我们依然按照视频里栈的方式对s(t-1)和s&#39;(t-1)排序\n                由于s(t-1)包含于s&#39;(t-1),所以s(t-1)内每一个元素都存在于s&#39;(t-1)中。\n                现在两个栈都是按最后一次访问的时间的顺序来排列的&#xff0c;由于s(t)在进行替换时会替换s(t-1)里面最长时间没被访问的元素(栈底)&#xff0c;设为a,那么a显然也存在于s&#39;(t-1)里面&#xff0c;并且它不一定是s&#39;(t-1)的栈底。\n                    A. 当a是s&#39;(t-1)的栈底时&#xff0c;s(t)和s&#39;(t)替换的都是a, s(t) = s(t-1) - {a} &#43; {b(t)} , s&#39;(t) = s&#39;(t-1) - {a} &#43; {b(t)}\n                    B. 当a不是s&#39;(t-1)的栈底是&#xff0c;则s&#39;(t-1)的栈底c必然不属于s(t-1)&#xff0c;否则就会与a是s(t-1)的栈底矛盾&#xff08;即c比a有更长的时间未被访问&#xff09;&#xff0c;此种情况下s(t)和s&#39;(t)依然满足包含关系\n            (4) 由归纳假设可以得知此种情况不存在</pre>", "created": "2015-03-30T06:47:08Z", "bucket_order": 354, "bucket_name": "Week 3/29 - 4/4", "type": "feedback", "tag_good": [], "uid": "i6uji18l8j51ob", "children": [], "tag_good_arr": [], "id": "i7vijlijdm2q2", "updated": "2015-03-30T06:47:08Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "i7vi41mcn6n6h8", "updated": "2015-03-30T06:35:03Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>2012011369 王轩</p>\n<p>2012011367 石伟男</p>\n<p></p>\n<p>参考了http://ranger.uta.edu/~weems/NOTES5314/HW/hw3.3.pdf</p>\n<p><br />假设逻辑页访问顺序为S=a1,a2,....an。令LRU_&lt;sub&gt;i&lt;/sub&gt;(S)表示当物理页面数为i时的缺页次数&#xff0c;我们需要证明的是对于任意的S,i,j&#xff0c;满足LRU_i &gt;= LRU&lt;sub&gt;i&#43;1&lt;/sub&gt;(S) &gt;= LRU&lt;sub&gt;i&#43;2&lt;/sub&gt;(S) &gt;= ... &gt;= LRU&lt;sub&gt;j&lt;/sub&gt;(S)<br /><br />定义一个i个节点的链表是i&#43;1个节点的链表的**前缀**&#xff0c;当且仅当两个链表前i个节点完全相同&#xff0c;仅i&#43;1个点的链表可能在尾部多了1个节点。<br /><br />引理&#xff1a;在访问序列每一步结束的时候&#xff0c;LRU&lt;sub&gt;i&lt;/sub&gt;的链表是LRU&lt;sub&gt;i&#43;1&lt;/sub&gt;的链表的**前缀**。<br /><br />归纳证明这个引理&#xff1a;<br /><br />首先当k = 1时&#xff0c;LRU&lt;sub&gt;1&lt;/sub&gt;和LRU&lt;sub&gt;2&lt;/sub&gt;均产生1次缺失&#xff0c;由a1产生。归纳假设当k &lt; n时&#xff0c;均有LRU&lt;sub&gt;k&lt;/sub&gt;的链表是LRU&lt;sub&gt;k&#43;1&lt;/sub&gt;的链表的**前缀**。<br /><br />考虑当k = n时的情况&#xff1a;<br /><br />* 一种情况是当访问第n&#43;1页时&#xff0c;a&lt;sub&gt;n&#43;1&lt;/sub&gt;已经在LRU&lt;sub&gt;i&lt;/sub&gt;的链表中&#xff0c;此时页面在内存中&#xff0c;那么第n&#43;1个访问结束后&#xff0c;都是将这个页面移动到链表的开头&#xff0c;因此引理成立。<br />* 另一种情况是当访问第n&#43;1页时&#xff0c;a&lt;sub&gt;n&#43;1&lt;/sub&gt;不在LRU&lt;sub&gt;i&lt;/sub&gt;的链表中。这里再细分两种情况&#xff1a;<br />  * a&lt;sub&gt;n&#43;1&lt;/sub&gt;不在LRU&lt;sub&gt;i&#43;1&lt;/sub&gt;的链表中&#xff0c;则发生页缺失&#xff0c;LRU_i和LRU&lt;sub&gt;i&#43;1&lt;/sub&gt;都需要把a_n&#43;1移动到链表头<br />  * a&lt;sub&gt;n&#43;1&lt;/sub&gt;在LRU&lt;sub&gt;i&#43;1&lt;/sub&gt;的链表中&#xff0c;那么由归纳假设&#xff0c;a&lt;sub&gt;n&#43;1&lt;/sub&gt;一定是在链表的最后一页&#xff0c;那么LRU&lt;sub&gt;i&#43;1&lt;/sub&gt;把这一页移动到链表头&#xff0c;将原来链表尾的页面删除&#xff1b;LRU&lt;sub&gt;i&lt;/sub&gt;同样把a&lt;sub&gt;n&#43;1&lt;/sub&gt;移动到链表头&#xff0c;把链表尾的页面删除。那么由归纳假设可知&#xff0c;链表中另外i-1个元素不变&#xff0c;LRU&lt;sub&gt;n&lt;/sub&gt;的链表依然是LRU&lt;sub&gt;n&#43;1&lt;/sub&gt;的前缀。<br />  <br />当引理成立时&#xff0c;若LRU&lt;sub&gt;i&#43;1&lt;/sub&gt;产生页缺失&#xff0c;则LRU&lt;sub&gt;i&lt;/sub&gt;产生页缺失。那么LRU&lt;sub&gt;i&lt;/sub&gt;&gt;=LRU&lt;sub&gt;i&#43;1&lt;/sub&gt;。即结论成立。</p>", "created": "2015-03-30T06:41:11Z", "bucket_order": 354, "bucket_name": "Week 3/29 - 4/4", "type": "followup", "tag_good": [], "uid": "i6uuk6b68du319", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "i7vibxmr1gh7fy", "updated": "2015-03-30T06:41:11Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>设S为物理页面数量为n的LRU算法维护的栈&#xff0c;S1是物理页面数量为n&#43;k的LRU算法维护的栈</p>\n<p>证明在任意时刻&#xff0c;S属于S1&#xff0c;且任意S中元素a&#xff0c;对应到S1中元素a1&#xff0c;满足a的位置小于等于a1的栈位置,即可证明物理页面数量增加的缺页率不会降低。</p>\n<p></p>\n<p>数学归纳法&#xff1a;</p>\n<p>在初始情况下&#xff0c;S与S1都为空&#xff0c;满足任意S中元素a&#xff0c;对应到S1中元素a1</p>\n<p>在t-1时刻满足S属于S1&#xff0c;且任意S中元素a&#xff0c;对应到S1中元素a1&#xff0c;满足a的位置小于等于a1的栈位置</p>\n<p>在T时刻&#xff0c;对于对x页的页面访问请求&#xff0c;可能出现三种情况</p>\n<p>情况1&#xff1a;x属于S&#xff0c;且x属于S1,则经过这一步&#xff0c;需要将S与S1中的x页都置于栈顶部&#xff0c;因为S1的栈大小大于S&#xff0c;所以对于x元素&#xff0c;还是满足x在S中的位置&#xff0c;小于x在S1中的位置。对于原有在S与S1中的元素&#xff0c;在x元素前的元素位置不变&#xff0c;在x后的元素位置整体前移&#xff0c;大小关系保持不变。所以这种情况下依旧满足条件。</p>\n<p>情况2&#xff1a;x不属于S&#xff0c;且x属于S1&#xff0c;x不属于S&#xff0c;就在栈顶压入元素&#xff0c;x位置为n&#xff1b;在s1中找到x&#xff0c;将x元素移至栈定于&#xff0c;依旧满足S中x位置小于等于S1中位置。对于原有在S中的元素&#xff0c;整体前移了一位&#xff0c;S1中元素x前的不变&#xff0c;x后的整体前移1位&#xff0c;所以整体大小关系依旧满足。</p>\n<p>情况3&#xff1a;x不属于S&#xff0c;且x不属于S1&#xff0c;则都在栈尾部加入x&#xff0c;S中位置为n&#xff0c;S1中位置为n&#43;k。同时对于被弹出栈的元素&#xff0c;如果弹出元素相同&#xff0c;则依旧满足。如果弹出元素不同&#xff0c;因为S中的对应元素位置小于等于S1的&#xff0c;所以S1中弹出的元素必然已经不属于S了。所以弹出后依旧满足S属于S1.即在这种情况下依旧满足假设。</p>\n<p>由于假设的存在&#xff0c;s属于S1&#xff0c;即不会出现x属于s&#xff0c;x不属于s1的情况。</p>\n<p></p>\n<p>综上所述&#xff0c;由数学归纳法得&#xff0c;对任意时刻&#xff0c;任意时刻&#xff0c;S属于S1&#xff0c;且任意S中元素a&#xff0c;对应到S1中元素a1&#xff0c;满足a的位置小于等于a1的栈位置。</p>\n<p>即对任意时刻&#xff0c;对S1的缺页数量不会大于S。即物理页数量增加&#xff0c;缺页率不会上升。</p>\n<p></p>\n<p>即证明了&#xff0c;LRU算法&#xff0c;不会出现belady现象。</p>\n<p></p>\n<p></p>\n<p>计22 黄杰 2012011272</p>\n<p>计22 袁源 2012011294</p>\n<p>计24 杜鹃 2012011354</p>\n<p>计24 王妍 2012011352</p>\n<p></p>", "created": "2015-03-30T06:53:57Z", "bucket_order": 354, "bucket_name": "Week 3/29 - 4/4", "type": "followup", "tag_good": [], "uid": "i6sl02qfUgI", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "i7viscxb9pb5sa", "updated": "2015-03-30T06:53:57Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>计23班 鲁逸沁 2012011314</p>\n<p>计23班 谢晓晖 2012011315</p>\n<p></p>\n<p>已证明&#xff0c;之后附上详细形式化证明</p>\n<p></p>", "created": "2015-03-30T07:05:00Z", "bucket_order": 354, "bucket_name": "Week 3/29 - 4/4", "type": "followup", "tag_good": [], "uid": "i7013x05eSl", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p><pre>设在t时刻&#xff0c;S(t)是大小为n的栈中的内容&#xff0c;S’(t)是大小为n&#43;k的栈中的内容&#xff0c;其中k&gt;0,B(t)为新入栈的元素\n只需证明对于任意t&#xff0c;S(t)属于S’(t)&#xff0c;且任意S(t)中元素a&#xff0c;对应到S‘(t)中元素a1&#xff0c;满足a的位置小于等于a1的栈位置,即可证明物理页面数量增加的缺页率不会降低。\n \n数学归纳法&#xff1a;\n在初始情况下&#xff0c;S(0)与S’(0)都为空&#xff0c;满足任意S(0)中元素a&#xff0c;对应到S’(0)中元素a1\n假设在t-1时刻满足S&#xff08;t-1&#xff09;属于S’(t-1)&#xff0c;且任意S(t-1)中元素a&#xff0c;对应到S’(t-1)中元素a1&#xff0c;满足a的位置小于等于a1的栈位置\n在t时刻&#xff0c;对于对B(t)页的页面访问请求&#xff0c;可能出现以下三种情况\n【情况1】&#xff1a;B(t)属于S(t),且B(t)属于S’(t),则经过这一步&#xff0c;需要将S(t)与S’(t)中的B(t)页都置于栈顶部&#xff0c;因为S1的栈大小大于S(t),所以对于B(t)元素&#xff0c;还是满足B(t)在S(t)中的位置&#xff0c;小于B(t)在S’(t)中的位置。对于原有在S(t)与S’(t)中的元素&#xff0c;在B(t)元素前的元素位置不变&#xff0c;在B(t)后的元素位置整体前移&#xff0c;大小关系保持不变。所以这种情况下依旧满足条件。\n【情况2】&#xff1a;B(t)不属于S(t),且B(t)属于S’(t)。B(t)不属于S(t),就在栈顶压入元素&#xff0c;B(t)位置为n&#xff1b;在S‘(t)中找到B(t)&#xff0c;将B(t)元素移至栈顶&#xff0c;依旧满足S(t)中B(t)位置小于等于S‘(t)中位置。对于原有在S(t)中的元素&#xff0c;整体前移了一位&#xff0c;S’(t)中元素B(t)前的不变&#xff0c;B(t)后的整体前移1位&#xff0c;所以整体大小关系依旧满足。\n【情况3】&#xff1a;B(t)不属于S(t),且B(t)不属于S‘(t),则都在栈尾部加入B(t)&#xff0c;S(t)中位置为n&#xff0c;S’(t)中位置为n&#43;k。同时对于被弹出栈的元素&#xff0c;如果弹出元素相同&#xff0c;则依旧满足。如果弹出元素不同&#xff0c;因为S(t)中的对应元素位置小于等于S‘(t)的&#xff0c;所以S’(t)中弹出的元素必然已经不属于S(t)了。所以弹出后依旧满足S(t)属于S‘(t).即在这种情况下依旧满足假设。\n由于假设的存在&#xff0c;S(t)属于S’(t),即不会出现B(t)属于S(t),B(t)不属于S‘(t)的情况。\n \n综上所述&#xff0c;由数学归纳法得&#xff0c;对任意时刻t&#xff0c;S(t)属于S’(t),且任意S(t)中元素a&#xff0c;对应到S’(t)中元素a1&#xff0c;满足a的位置小于等于a1的栈位置。\n即对任意时刻&#xff0c;对S’(t)的缺页数量不会大于S(t)。即物理页数量增加&#xff0c;缺页率不会上升。\n \n即LRU算法不会出现belady现象。</pre>\n<p></p>", "created": "2015-03-30T14:40:31Z", "bucket_order": 354, "bucket_name": "Week 3/29 - 4/4", "type": "feedback", "tag_good": [], "uid": "i7013x05eSl", "children": [], "tag_good_arr": [], "id": "i7vzgczjbnhu9", "updated": "2015-03-30T14:40:31Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "i7vj6kimr6u46n", "updated": "2015-03-30T07:05:00Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>覃伟 2012011278 徐天宇 2012011275 韩慧阳 2012011276 闵延泽 2012011291 杨博文 2012011288</p>\n<p></p>\n<p></p>\n<p>只需要证明对任意的正整数t&#xff0c;s(t)始终包含于s&#39;(t)即可<br />显然&#xff0c;当初始的时候&#xff0c;两个集合都是空&#xff0c;此命题成立&#xff0c;假设 i &lt;= t - 1的时候都成立&#xff0c;只需要证明s(t)包含于s&#39;(t)<br />分三种情况&#xff1a;<br /> b(t) 属于 s(t),又属于 s&#39;(t)<br /> 此时s(t)和s&#39;(t)二者都不会发生变化&#xff0c;成立&#xff1b;<br /> b(t) 不属于 s(t),但属于 s&#39;(t)<br /> 替换之后肯定有b(t) 属于 s(t)&#xff0c;所以s(t)包含于s&#39;(t)&#xff0c;成立&#xff1b;<br /> b(t) 不属于 s(t),也不属于 s&#39;(t)<br /> 根据假设&#xff0c;s(t-1)包含于s’(t-1)&#xff0c;我们假设进行替换的元素是x&#xff0c;那么x就是拥有最长的未访问时间的元素&#xff0c;<br /> 也就是说x位于s‘栈的栈底&#xff0c;如果x同时也被s&#39;替换掉&#xff08;x是s&#39;的栈底&#xff09;&#xff0c;本来包含于s&#39;&#xff08;t-1&#xff09;的s&#xff08;t-1&#xff09;两者同时减去一个元素&#xff0c;加上b&#xff08;t&#xff09;就是新的<br /> s&#xff08;t&#xff09;和s&#39;&#xff08;t&#xff09;&#xff1b;如果x不在s’栈的栈底&#xff0c;那么s&#39;的栈底y拥有比x更久的未访问时间&#xff0c;即y是要被替换的元素&#xff0c;同上&#xff0c;这个时候包含关系仍然成立。<br />综上所述&#xff0c;对任意的正整数t&#xff0c;s(t)始终包含于s&#39;(t)&#xff0c;所以LRU不会存在belady现象。</p>", "created": "2015-03-30T07:26:01Z", "bucket_order": 354, "bucket_name": "Week 3/29 - 4/4", "type": "followup", "tag_good": [], "uid": "i7bfvegt8am5ir", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "i7vjxl9t5hp58", "updated": "2015-03-30T07:26:01Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>计22班 应杰夫 2012011293</p>\n<p></p>\n<p>由于缺页的考察对象在LRU算法维护的栈&#xff0c;即要证明&#xff1a;对于页面数量为n与n&#43;k (k&gt;0) 分别对应的栈S(n)与S(n&#43;k) 始终满足前者元素是后者子集即可。</p>\n<p>为了后续的证明&#xff0c;这里加强条件&#xff0c;即下面将证明&#xff1a;对于页面数量为n与n&#43;k (k&gt;0) 分别对应的栈S(n)与S(n&#43;k) 始终满足前者元素是后者子集&#xff0c;且任意元素在两栈中保持同样的相对顺序。&#xff08;即不存在元素x1,x2 在S(n&#43;k)与S(n)栈中位置分别是x1&#xff0c;x2 和 x2&#xff0c;x1&#xff09;</p>\n<p></p>\n<p>采用归纳法证明 对LRU算法进行步骤数T做归纳&#xff1a;</p>\n<p></p>\n<p>1、当T=0时&#xff0c;S(n)、S(n&#43;k)始终为空栈&#xff0c;显然包含于后者 元素停留时间都是零</p>\n<p></p>\n<p>2、设对于任意T&lt;n-1 均有S(n)包含于S(n&#43;k)&#xff0c;则对于第n步 访问元素x&#xff0c;可能出现三种情况&#xff1a;</p>\n<p>     a. x在S(n)与S(n&#43;k)中均出现</p>\n<p>     b. x在S(n)中出现 未在S(n&#43;k)中出现</p>\n<p>     c. x在S(n)与S(n&#43;k) 均未出现</p>\n<p></p>\n<p>     对于a. 由于x均在栈中&#xff0c;则这第n步操作仅为将x移至栈顶&#xff0c;不发生元素变化&#xff0c;包含关系不变&#xff1b;S(n)与S(n&#43;k)中所有</p>\n<p>                元素间顺序关系保持不变。</p>\n<p></p>\n<p>     对于b. x不在S(n)中,则按要求要去掉栈底部元素并将x放到栈顶&#xff0c;即S(n)中元素减少&#xff0c;而S(n&#43;k)元素不发生变化。</p>\n<p>                故包含关系依然满足&#xff1b;同时S(n&#43;k)中所有非x元素位置加1&#xff0c;S(n)中非栈底元素位置加1。这部分元素保持两栈</p>\n<p>                中相同的位置关系&#xff1b;x元素都在栈顶&#xff0c;故所有元素在两栈中排序方式一致。</p>\n<p></p>\n<p>     对于c. 此时S(n)与S(n&#43;k)都需要去掉栈底元素&#xff0c;只要考虑S(n&#43;k)的栈底是否可能继续留在S(n)中。</p>\n<p>                如果说S(n&#43;k)的栈顶top_k 依旧留在S(n)中&#xff0c;则表示S(n)中原栈顶top_n&#xff08;in S(n)&#xff09; &gt; top_k&#xff08;in S(n)。</p>\n<p>                由于S(n)元素包含于S(n&#43;k)&#xff0c;故top_n也在S(n&#43;k)中&#xff0c;而top_k是S(n&#43;k)的栈底&#xff0c;故&#xff1a;</p>\n<p>                top_n&#xff08;in S(n&#43;k)&#xff09; &lt; top_k&#xff08;in S(n&#43;k)&#xff09;</p>\n<p>                得到结论top_n、top_k在T-1步完成后两栈中的顺序关系不同&#xff0c;与假设前提矛盾。</p>\n<p>               </p>\n<p>                所以S(n&#43;k)的栈底不可能继续留在S(n)&#xff0c;元素包含关系依旧成立。故两栈各自去掉栈底元素&#xff0c;这里也有两个情况&#xff1a;</p>\n<p>                i. 若栈底元素相同&#xff0c;则分别去掉&#xff0c;其他元素位置加1&#xff0c;在两栈间保持同样的相对顺序&#xff1b;x放入栈顶&#xff0c;同样不影响</p>\n<p>               ii. 若栈顶元素不同&#xff0c;则除两栈顶之外元素情况同i&#xff0c;唯一不同的是此时S(n)被去掉的栈头由于在自己的栈中位置最大故S(n)                     将是S(n&#43;k)的上半部分。</p>\n<p></p>\n<p>综合以上&#xff0c;可得到原假设&#xff1a;“对于页面数量为n与n&#43;k (k&gt;0) 分别对应的栈S(n)与S(n&#43;k) 始终满足前者元素是后者子集&#xff0c;且任意元素在两栈中保持同样的相对顺序。” 成立。即证明了LRU不会出现Belady现象。</p>\n<p></p>\n<p></p>", "created": "2015-03-30T09:56:59Z", "bucket_order": 354, "bucket_name": "Week 3/29 - 4/4", "type": "followup", "tag_good": [], "uid": "i71ev8heKQi", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "i7vpbq4u4br3zi", "updated": "2015-03-30T09:56:59Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>陈天昱 李心田 杨皓 章浚源</p>\n<p></p>\n<p>采用数学归纳法证明。</p>\n<p></p>\n<p>初始条件显然满足&#xff0c;现在假设 t - 1 时满足 S(t - 1) ⊂ S&#39;(t - 1) 。</p>\n<p></p>\n<p>考虑 t 时刻的情况&#xff0c;若访问的页面 b(t) ∈ S(t - 1) 且 b(t) ∈ S&#39;(t - 1) &#xff0c;则访问之后的 S(t) S&#39;(t) 均不发生变化&#xff0c;成立。</p>\n<p></p>\n<p>若访问的页面 b(t) ∉ S(t - 1) 但是 b(t) ∈ S&#39;(t - 1) &#xff0c;那么按照 LRU 替换掉 S(t - 1) 中最不常使用的页面换成 b(t) 后仍满足 S(t) ⊂ S&#39;(t) 。成立。</p>\n<p></p>\n<p>若 b(t) ∉ S(t - 1) 而且 b(t) ∉  S&#39;(t - 1)&#xff0c;设 c 是 S 中替换掉的页面&#xff0c;若 c 也是 S&#39; 中替换掉的页面的话&#xff0c;结论成立&#xff0c;因为刚好替换掉了相同的页面换了同一个页面&#xff1b;若 c 不是 S&#39; 替换掉的页面&#xff0c;则 S&#39; 替换掉的页面 d ∉ S(t - 1) &#xff0c;因为 c d 均在 S&#39;(t - 1) 中&#xff0c;替换 d 说明 d 比 c 更不常使用&#xff0c;若 d 在 S 中则应该替换掉 d 而不是 c 。所以原命题依然成立。</p>\n<p></p>\n<p>综上所述&#xff0c;命题得证。</p>", "created": "2015-03-30T17:10:44Z", "bucket_order": 354, "bucket_name": "Week 3/29 - 4/4", "type": "followup", "tag_good": [], "uid": "i6utvrywozd2vd", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "i7w4tjk11c06i2", "updated": "2015-03-30T17:10:44Z", "config": {}}], "tag_good_arr": [], "id": "i7vhvpvd2ss2eu", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 13, "num_favorites": 4, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643167471622, "default_anonymity": "no"}, "error": null, "aid": "kyuzhjiexvt2k4"}