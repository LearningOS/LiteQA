{"result": {"folders": ["lab4"], "nr": 1399, "data": {"embed_links": []}, "created": "2020-02-26T10:44:48Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "stud", "data": "k736zgcmdagcf", "type": "create", "when": "2020-02-26T10:44:48Z", "uid_a": "a_0"}, {"anon": "no", "uid": "jsjp32n2zAHb", "data": "k739wvja9bf163", "to": "k736zgcjmnnce", "type": "s_answer", "when": "2020-02-26T12:06:47Z"}, {"anon": "stud", "to": "k736zgcjmnnce", "type": "followup", "when": "2020-02-27T15:57:20Z", "uid_a": "a_1"}, {"anon": "stud", "to": "k736zgcjmnnce", "type": "feedback", "when": "2020-02-27T23:04:57Z", "uid_a": "a_0"}, {"anon": "no", "uid": "jsjp32n2zAHb", "to": "k736zgcjmnnce", "type": "feedback", "when": "2020-02-28T02:07:02Z"}, {"anon": "stud", "to": "k736zgcjmnnce", "type": "feedback", "when": "2020-02-28T03:11:26Z", "uid_a": "a_1"}], "bucket_name": "Today", "history": [{"anon": "stud", "uid_a": "a_0", "subject": "关于静态内存分配实现的一个问题", "created": "2020-02-26T10:44:48Z", "content": "<p>在阅读并实现lab4 chapter1&#xff08;https://rcore-os.github.io/rCore_tutorial_doc/chapter4/part1.html&#xff09;的时候&#xff0c;关于内存初始化我有一个困惑&#xff0c;</p>\n<pre>for i in (1..(self.m &lt;&lt; 1)) { self.a[i] = 1; }<br />for i in (1..self.n) { self.a[self.m &#43; i] = 0; }<br />for i in (1..self.m).rev() { self.a[i] = self.a[i &lt;&lt; 1] &amp; self.a[(i &lt;&lt; 1) | 1]; }</pre>\n<p>第一行先把整颗完全二叉树初始化&#xff1b;</p>\n<p>第二行把叶节点置为可用&#xff1b;</p>\n<p>第三行bottom-up逐层更新。</p>\n<p>这里可看到&#xff0c;n的语义是total number&#xff0c;m语义是最下一层最左边的那个叶节点。</p>\n<p>我的问题来自第二行&#xff0c;range from 1 to n。两个疑虑&#xff0c;第一个是它不从最左边的那个节点开始mark&#xff0c;它从m的右兄弟开始更新。因为 m必为二的幂次&#xff08;偶数&#xff09;&#xff0c;m&#43;1必为奇数&#xff0c;在以1为根的完全二叉树中&#xff0c;奇数为右子树。</p>\n<p>第二个疑虑就是这样只能拍下 n-1个数&#xff0c;假如我真的进来一个二的幂次&#xff0c;这样会有一个page提前不可用。</p>\n<p></p>\n<p>这是与 self.offet = l-1 想配合的。我在想&#xff0c;假如</p>\n<pre>self.offset = l;<br />...<br />for i in (0..self.n) { self.a[self.m &#43; i] = 0; }</pre>\n<p>会不会更好理解&#xff0c;更能排满一些</p>"}], "type": "question", "tags": ["lab4", "student"], "tag_good": [{"role": "student", "name": "zhongrunxin", "endorser": {}, "admin": false, "photo": null, "id": "k6sv04219im5t1", "photo_url": null, "published": true, "us": false, "facebook_id": null}, {"role": "student", "name": "郑逢时", "endorser": {}, "admin": false, "photo": null, "id": "k6ojtppjd4xxr", "photo_url": null, "published": true, "us": false, "facebook_id": null}], "unique_views": 87, "children": [{"folders": [], "data": {"embed_links": []}, "children": [], "created": "2020-02-26T12:06:47Z", "bucket_order": 3, "tag_endorse": [], "bucket_name": "Today", "id": "k739wvj5h15162", "history": [{"anon": "no", "uid": "jsjp32n2zAHb", "subject": "", "created": "2020-02-26T12:06:47Z", "content": "<md>非常感谢大佬耐心阅读如此反人类的代码还能从里面找到 bug &#xff01;\n正如您所说&#xff0c;目前的实现会有一个物理页面无法分配出去&#xff0c;改成您提供的实现能解决这一问题。</md>"}], "type": "s_answer", "tag_endorse_arr": [], "config": {}, "is_tag_endorse": false}, {"anon": "stud", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>在这段代码里还有一处我不太理解</p>\n<pre>while self.m &lt; self.n &#43; 2 {<br />    self.m = self.m &lt;&lt; 1;<br />}</pre>\n<p>这个是为了得到m(最下层最左边叶节点)</p>\n<p>比如当n = 5的时候&#xff0c;m = 8&#xff0c;这个没问题&#xff1b;但当n=4的时候&#xff0c;m还是为8&#xff0c;这样构造的二叉树有一半没用到...m其实为4就好</p>\n<p></p>\n<pre>while self.m &lt; self.n {<br />    self.m = self.m &lt;&lt; 1;<br />}</pre>\n<p>改成这样是不是更好一点?..</p>", "created": "2020-02-27T15:57:20Z", "bucket_order": 6, "bucket_name": "Last week", "type": "followup", "tag_good": [], "uid_a": "a_1", "children": [{"anon": "stud", "folders": [], "data": {"embed_links": null}, "subject": "<p>我只能回答一半问题</p>\n<p>我在下一篇文章当中给了注释&#xff1a;</p>\n<pre>// why add 2? \n        // one for root start from one instead of zero\n        // another one for total number is contained, say we have 10 number,\n        // naturally, the condition shall be less than 11, you need to take 10 into account\n        while self.leaf_begin &lt; self.total &#43; 2 {\n            self.leaf_begin &lt;&lt;= 1;\n        }</pre>\n<p>实际上这个加二是由于root 从一开始&#xff0c;和total的计数问题。核心要求只有一个&#xff0c;那就是得把所有page放到叶节点上。而注意到另外一点是&#xff0c;我本来期待有一个特定的n&#xff0c;可以使得 m 在 n&#43;2的bound下满足要求但是在 n的bound下不满足&#xff0c;但是m增长的速度是幂指的&#xff0c;凡是不满足上一次条件的直接就翻两倍&#xff0c;好像把bound在紧一点也没啥关系.......</p>\n<p>老实说我没太想好&#xff0c;但是n&#43;2绝对是个安全的位置&#xff0c;但是我没说服自己为什么n就不安全了......</p>", "created": "2020-02-27T23:04:57Z", "bucket_order": 6, "bucket_name": "Last week", "type": "feedback", "tag_good": [{"role": "student", "name": "zhongrunxin", "endorser": {}, "admin": false, "photo": null, "id": "k6sv04219im5t1", "photo_url": null, "published": true, "us": false, "facebook_id": null}], "uid_a": "a_0", "children": [], "tag_good_arr": ["k6sv04219im5t1"], "id": "k75cv5gddds3jc", "updated": "2020-02-27T23:04:57Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<md>大家其实不用过于注意实现的细节&#xff0c;这里只是作为一个参考&#xff0c;理解接口并给出自己的实现才是坠吼的。\n对于 $$n&#43;2$$ 的问题&#xff0c;其实来源于一种非递归的线段树写法(百度搜索zkw线段树或者统计的力量)&#xff0c;它基于位运算&#xff0c;可以只用很小的代码量完成一些比较简单的区间修改/查询操作(如果要支持懒标记的话需要做出一点修改)。实际上&#xff0c;只用一个 for 循环就能完成区间操作。相比传统线段树&#xff0c;即使建树时将线段树建成完全二叉树&#xff0c;在区间操作的的时候代码也相对复杂。然而&#xff0c;为了能够用一个 for 循环就解决问题&#xff0c;底层叶节点至少需要 $$n&#43;2$$ 个&#xff0c;因为 $$M,2M-1$$ 两个节点起到占位作用&#xff0c;是不能使用的。详情可以自己再去查找更多资料。\n我在实现的时候就随便套用了这个模板。但是由于这里的需求仅仅是单点修改/查询&#xff0c;会导致 $$n&#43;2$$ 显得有些冗余了。事实上&#xff0c;在适当的 &#96;&#96;offset&#96;&#96; 配合下&#xff0c;这里将 $$&#43;2$$ 去掉也是完全没问题的。\n欢迎大家使用自己喜欢的数据结构进行优美的实现&#xff01;</md>", "created": "2020-02-28T02:07:02Z", "bucket_order": 6, "bucket_name": "Last week", "type": "feedback", "tag_good": [{"role": "student", "name": "zhongrunxin", "endorser": {}, "admin": false, "photo": null, "id": "k6sv04219im5t1", "photo_url": null, "published": true, "us": false, "facebook_id": null}, {"role": "student", "name": "郑逢时", "endorser": {}, "admin": false, "photo": null, "id": "k6ojtppjd4xxr", "photo_url": null, "published": true, "us": false, "facebook_id": null}], "uid": "jsjp32n2zAHb", "children": [], "tag_good_arr": ["k6sv04219im5t1", "k6ojtppjd4xxr"], "id": "k75jdb06dna4gm", "updated": "2020-02-28T02:07:02Z", "config": {}}, {"anon": "stud", "folders": [], "data": {"embed_links": null}, "subject": "<p>明白啦&#xff0c;谢谢助教跟这位同学~</p>", "created": "2020-02-28T03:11:26Z", "bucket_order": 6, "bucket_name": "Last week", "type": "feedback", "tag_good": [], "uid_a": "a_1", "children": [], "tag_good_arr": [], "id": "k75lo46y90n1gl", "updated": "2020-02-28T03:11:26Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "k74xl7vped55kp", "updated": "2020-02-27T15:57:20Z", "config": {}}], "tag_good_arr": ["k6sv04219im5t1", "k6ojtppjd4xxr"], "no_answer": 0, "id": "k736zgcjmnnce", "config": {"seen": {"267": 5, "622": 6, "754": 7, "1166": 0, "1121": 3, "1385": 1, "92": 2, "306": 4, "97": 8}}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 3, "num_favorites": 1, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169954215, "default_anonymity": "no"}, "error": null, "aid": "kyv0yr3bbqt2w4"}