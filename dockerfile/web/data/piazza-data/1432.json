{"result": {"folders": ["lecture9"], "nr": 1432, "data": {"embed_links": []}, "created": "2020-03-24T13:36:34Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "full", "data": "k85y0co0zbi6pm", "type": "create", "when": "2020-03-24T13:36:34Z", "uid_a": "a_0"}, {"anon": "full", "data": "k85y16o8ntm7g9", "type": "update", "when": "2020-03-24T13:37:13Z", "uid_a": "a_0"}, {"anon": "full", "data": "k85yc2e0cw34tk", "type": "update", "when": "2020-03-24T13:45:41Z", "uid_a": "a_0"}, {"anon": "full", "uid_a": "a_0", "data": "k85yc9cjivt4zi", "type": "update", "when": "2020-03-24T13:45:50Z"}], "bucket_name": "Today", "history": [{"anon": "full", "uid_a": "a_0", "subject": "第九讲课后练习展示", "created": "2020-03-24T13:45:50Z", "content": "<p>题目&#xff1a;</p>\n<p>设计一个简化的进程管理子系统&#xff0c;可以管理并调度如下简化进程。在理解参考代码的基础上&#xff0c;完成&#xff02;YOUR CODE&#34;部分的内容。然后通过测试用例和比较自己的实现与往届同学的结果&#xff0c;评价自己的实现是否正确。</p>\n<p></p>\n<p>需填充代码与参考实现&#xff1a;</p>\n<p>1. <strong>move_to_xxx</strong></p>\n<p></p>\n<pre>#change to READY STATE, the current proc&#39;s state should be expected\n#if pid==-1, then pid=self.curr_proc\ndef move_to_ready(self, expected, pid=-1):\n    #YOUR CODE\n    now_id = pid\n    if now_id == -1:\n        now_id = self.curr_proc\n    assert(self.proc_info[now_id][PROC_STATE] == expected)\n    self.proc_info[now_id][PROC_STATE] = STATE_READY\n    return\n\n#change to RUNNING STATE, the current proc&#39;s state should be expected\ndef move_to_running(self, expected):\n    #YOUR CODE\n    now_id = self.curr_proc\n    assert(self.proc_info[now_id][PROC_STATE] == expected)\n    self.proc_info[now_id][PROC_STATE] = STATE_RUNNING\n    return\n\n#change to DONE STATE, the current proc&#39;s state should be expected\ndef move_to_done(self, expected):\n    #YOUR CODE\n    now_id = self.curr_proc\n    assert(self.proc_info[now_id][PROC_STATE] == expected)\n    self.proc_info[now_id][PROC_STATE] = STATE_DONE\n    return</pre>\n<p>按照注释&#xff0c;对于当前状态的检查不可省略。同时&#xff0c;要注意到 <strong>move_to_ready</strong> 的特殊性&#xff0c;在实际操作系统中&#xff0c;经常需要把另一个进程唤醒&#xff0c;但是不太可能把另一个进程直接置为 <strong>running</strong> 或者 <strong>done</strong>&#xff0c;所以 <strong>move_to_ready</strong> 的参数中含 <strong>pid&#xff0c;</strong>意味着操作的进程不一定是当前进程。</p>\n<p>典型“错误”&#xff1a;</p>\n<pre>def move_to_ready(self):\n    self.proc_info[self.curr_proc][PROC_STATE] = STATE_READY\n\ndef move_to_running(self):\n    self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING\n\ndef move_to_done(self):\n    self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE</pre>\n<p>抽象更好&#xff1a;</p>\n<pre>def change_state(self, expected, target, pid=-1):\n    if pid == -1: pid = self.curr_proc\n    assert(self.proc_info[pid][PROC_STATE] == expected)\n    self.proc_info[pid][PROC_STATE] = target\n\n#change to READY STATE, the current proc&#39;s state should be expected\n#if pid==-1, then pid=self.curr_proc\ndef move_to_ready(self, expected, pid=-1):\n    self.change_state(expected, STATE_READY, pid)\n\n#change to RUNNING STATE, the current proc&#39;s state should be expected\ndef move_to_running(self, expected):\n    self.change_state(expected, STATE_RUNNING, self.curr_proc)\n\n#change to DONE STATE, the current proc&#39;s state should be expected\ndef move_to_done(self, expected):\n    self.change_state(expected, STATE_DONE, self.curr_proc)</pre>\n<p>2. <strong>next_proc</strong></p>\n<pre>def next_proc(self, pid=-1):\n    #YOUR CODE\n    now_id = pid\n    if now_id == -1:\n        now_id = self.curr_proc\n        \n    for i in range(now_id&#43;1, len(self.proc_info)):\n        if (self.proc_info[i][PROC_STATE] == STATE_READY):\n            self.curr_proc = i\n            self.move_to_running(STATE_READY)\n            return\n\n    for i in range(now_id &#43; 1):\n        if (self.proc_info[i][PROC_STATE] == STATE_READY):\n            self.curr_proc = i\n            self.move_to_running(STATE_READY)\n            return</pre>\n<p>按照FCFS的方法&#xff0c;从 <strong>pid&#43;1</strong> 号进程开始分两段查找第一个 <strong>ready</strong> 的进程&#xff0c;如果找不到&#xff0c; <strong>curr_proc </strong>保持不变即可&#xff0c;CPU会执行空指令。</p>\n<p>由于当前题目的情景比较简单&#xff0c;很多其他写法也可以&#xff0c;但是考虑一个尽可能真实、灵活的情景更好。其他写法&#xff1a;</p>\n<pre>def next_proc(self, pid=-1):\n    #YOUR CODE\n    curr = 0\n    if pid == -1:\n        curr = (self.curr_proc &#43; 1) % self.get_num_processes()\n    else:\n        curr = (pid &#43; 1) % self.get_num_processes()\n    while self.proc_info[curr][PROC_STATE] == STATE_DONE: # 如果进程有等待状态&#xff0c;这种写法就失效了。并且可能死循环。\n        curr = (curr &#43; 1) % self.get_num_processes()\n    self.curr_proc = curr\n    self.move_to_running(STATE_READY)\n    return</pre>\n<p>简洁的写法&#xff1a;</p>\n<p>这种写法会从当前进程开始查找 <strong>ready </strong>进程&#xff0c;需要其他部分代码配合。</p>\n<pre>def next_proc(self, pid=-1):\n    #YOUR CODE\n    if pid == -1: pid = self.curr_proc\n    for _ in range(len(self.proc_info) &#43; 1):\n        task = self.proc_info.get(pid)\n        if task is None:\n            pid = 0\n            continue\n        if task[PROC_STATE] == STATE_READY:\n            self.curr_proc = pid\n            self.move_to_running(STATE_READY)\n            return\n        pid &#43;= 1\n    return</pre>\n<p>3. <strong>run</strong> 片段一</p>\n<pre>if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n        len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n    #YOUR CODE\n    instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE][0]\n    del self.proc_info[self.curr_proc][PROC_CODE][0]</pre>\n<p>选择执行的指令&#xff0c;并将其删除。</p>\n<p>等价写法&#xff1a;</p>\n<pre>#YOUR CODE\ninstruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)</pre>\n<p>4. <strong>run</strong> 片段二</p>\n<pre># if this is an YIELD instruction, switch to ready state\n# and add an io completion in the future\nif instruction_to_execute == DO_YIELD:\n    #YOUR CODE\n    self.move_to_ready(STATE_RUNNING)\n    self.next_proc()\n\n# ENDCASE: check if currently running thing is out of instructions\nself.check_if_done()</pre>\n<p>如果进程放弃CPU&#xff0c;将其置为ready&#xff0c;切入下一个进程。</p>\n<p></p>\n<p>本题总的来说比较简单&#xff0c;写法大同小异&#xff0c;&#34;正确&#34;的写法很多&#xff0c;但是考虑的时候最好不要局限于本题的情景&#xff0c;考虑一个更加真实、完整的调度系统&#xff0c;这样写出来的代码会更好一点。</p>"}, {"anon": "full", "uid_a": "a_0", "subject": "第九讲课后练习展示", "created": "2020-03-24T13:45:41Z", "content": "<p>题目&#xff1a;</p>\n<p>设计一个简化的进程管理子系统&#xff0c;可以管理并调度如下简化进程。在理解参考代码的基础上&#xff0c;完成&#xff02;YOUR CODE&#34;部分的内容。然后通过测试用例和比较自己的实现与往届同学的结果&#xff0c;评价自己的实现是否正确。</p>\n<p></p>\n<p>需填充代码与参考实现&#xff1a;</p>\n<p>1. <strong>move_to_xxx</strong></p>\n<p></p>\n<pre>#change to READY STATE, the current proc&#39;s state should be expected\n#if pid==-1, then pid=self.curr_proc\ndef move_to_ready(self, expected, pid=-1):\n    #YOUR CODE\n    now_id = pid\n    if now_id == -1:\n        now_id = self.curr_proc\n    assert(self.proc_info[now_id][PROC_STATE] == expected)\n    self.proc_info[now_id][PROC_STATE] = STATE_READY\n    return\n\n#change to RUNNING STATE, the current proc&#39;s state should be expected\ndef move_to_running(self, expected):\n    #YOUR CODE\n    now_id = self.curr_proc\n    assert(self.proc_info[now_id][PROC_STATE] == expected)\n    self.proc_info[now_id][PROC_STATE] = STATE_RUNNING\n    return\n\n#change to DONE STATE, the current proc&#39;s state should be expected\ndef move_to_done(self, expected):\n    #YOUR CODE\n    now_id = self.curr_proc\n    assert(self.proc_info[now_id][PROC_STATE] == expected)\n    self.proc_info[now_id][PROC_STATE] = STATE_DONE\n    return</pre>\n<p>按照注释&#xff0c;对于当前状态的检查不可省略。同时&#xff0c;要注意到 <strong>move_to_ready</strong> 的特殊性&#xff0c;在实际操作系统中&#xff0c;经常需要把另一个进程唤醒&#xff0c;但是不太可能把另一个进程直接置为 <strong>running</strong> 或者 <strong>done</strong>&#xff0c;所以 <strong>move_to_ready</strong> 的参数中含 <strong>pid&#xff0c;</strong>意味着操作的进程不一定是当前进程。</p>\n<p>典型“错误”&#xff1a;</p>\n<pre>def move_to_ready(self):\n    self.proc_info[self.curr_proc][PROC_STATE] = STATE_READY\n\ndef move_to_running(self):\n    self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING\n\ndef move_to_done(self):\n    self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE</pre>\n<p>抽象更好&#xff1a;</p>\n<pre>def change_state(self, expected, target, pid=-1):\n    if pid == -1: pid = self.curr_proc\n    assert(self.proc_info[pid][PROC_STATE] == expected)\n    self.proc_info[pid][PROC_STATE] = target\n\n#change to READY STATE, the current proc&#39;s state should be expected\n#if pid==-1, then pid=self.curr_proc\ndef move_to_ready(self, expected, pid=-1):\n    self.change_state(expected, STATE_READY, pid)\n\n#change to RUNNING STATE, the current proc&#39;s state should be expected\ndef move_to_running(self, expected):\n    self.change_state(expected, STATE_RUNNING, self.curr_proc)\n\n#change to DONE STATE, the current proc&#39;s state should be expected\ndef move_to_done(self, expected):\n    self.change_state(expected, STATE_DONE, self.curr_proc)</pre>\n<p>2. <strong>next_proc</strong></p>\n<pre>def next_proc(self, pid=-1):\n    #YOUR CODE\n    now_id = pid\n    if now_id == -1:\n        now_id = self.curr_proc\n        \n    for i in range(now_id&#43;1, len(self.proc_info)):\n        if (self.proc_info[i][PROC_STATE] == STATE_READY):\n            self.curr_proc = i\n            self.move_to_running(STATE_READY)\n            return\n\n    for i in range(now_id &#43; 1):\n        if (self.proc_info[i][PROC_STATE] == STATE_READY):\n            self.curr_proc = i\n            self.move_to_running(STATE_READY)\n            return</pre>\n<p>按照FCFS的方法&#xff0c;从 <strong>pid&#43;1</strong> 号进程开始分两段查找第一个 <strong>ready</strong> 的进程&#xff0c;如果找不到&#xff0c; <strong>curr_proc </strong>保持不变即可&#xff0c;CPU会执行空指令。</p>\n<p>由于当前题目的情景比较简单&#xff0c;很多其他写法也可以&#xff0c;但是考虑一个尽可能真实、灵活的情景更好。其他写法&#xff1a;</p>\n<pre>def next_proc(self, pid=-1):\n    #YOUR CODE\n    curr = 0\n    if pid == -1:\n        curr = (self.curr_proc &#43; 1) % self.get_num_processes()\n    else:\n        curr = (pid &#43; 1) % self.get_num_processes()\n    while self.proc_info[curr][PROC_STATE] == STATE_DONE: # 如果进程有等待状态&#xff0c;这种写法就失效了。并且可能死循环。\n        curr = (curr &#43; 1) % self.get_num_processes()\n    self.curr_proc = curr\n    self.move_to_running(STATE_READY)\n    return</pre>\n<p>简洁的写法&#xff1a;</p>\n<p>这种写法会从当前进程开始查找 <strong>ready </strong>进程&#xff0c;需要其他部分代码配合。</p>\n<pre>def next_proc(self, pid=-1):\n    #YOUR CODE\n    if pid == -1: pid = self.curr_proc\n    for _ in range(len(self.proc_info) &#43; 1):\n        task = self.proc_info.get(pid)\n        if task is None:\n            pid = 0\n            continue\n        if task[PROC_STATE] == STATE_READY:\n            self.curr_proc = pid\n            self.move_to_running(STATE_READY)\n            return\n        pid &#43;= 1\n    return</pre>\n<p>3. <strong>run</strong> 片段一</p>\n<pre>if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n        len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n    #YOUR CODE\n    instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE][0]\n    del self.proc_info[self.curr_proc][PROC_CODE][0]</pre>\n<p>选择执行的指令&#xff0c;并将其删除。</p>\n<p>等价写法&#xff1a;</p>\n<pre>#YOUR CODE<br />instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)</pre>\n<p>4. <strong>run</strong> 片段二</p>\n<pre># if this is an YIELD instruction, switch to ready state\n# and add an io completion in the future\nif instruction_to_execute == DO_YIELD:\n    #YOUR CODE\n    self.move_to_ready(STATE_RUNNING)\n    self.next_proc()\n\n# ENDCASE: check if currently running thing is out of instructions\nself.check_if_done()</pre>\n<p>如果进程放弃CPU&#xff0c;将其置为ready&#xff0c;切入下一个进程。</p>\n<p></p>\n<p>本题总的来说比较简单&#xff0c;写法大同小异&#xff0c;&#34;正确&#34;的写法很多&#xff0c;但是考虑的时候最好不要局限于本题的情景&#xff0c;考虑一个更加真实、完整的调度系统&#xff0c;这样写出来的代码会更好一点。</p>"}, {"anon": "full", "uid_a": "a_0", "subject": "第九讲课后练习展示", "created": "2020-03-24T13:37:13Z", "content": "<p>题目&#xff1a;</p>\n<p>设计一个简化的进程管理子系统&#xff0c;可以管理并调度如下简化进程。在理解参考代码的基础上&#xff0c;完成&#xff02;YOUR CODE&#34;部分的内容。然后通过测试用例和比较自己的实现与往届同学的结果&#xff0c;评价自己的实现是否正确。</p>\n<p></p>\n<p>需填充代码与参考实现&#xff1a;</p>\n<p>1. <strong>move_to_xxx</strong></p>\n<p></p>\n<pre>#change to READY STATE, the current proc&#39;s state should be expected\n#if pid==-1, then pid=self.curr_proc\ndef move_to_ready(self, expected, pid=-1):\n    #YOUR CODE\n    now_id = pid\n    if now_id == -1:\n        now_id = self.curr_proc\n    assert(self.proc_info[now_id][PROC_STATE] == expected)\n    self.proc_info[now_id][PROC_STATE] = STATE_READY\n    return\n\n#change to RUNNING STATE, the current proc&#39;s state should be expected\ndef move_to_running(self, expected):\n    #YOUR CODE\n    now_id = self.curr_proc\n    assert(self.proc_info[now_id][PROC_STATE] == expected)\n    self.proc_info[now_id][PROC_STATE] = STATE_RUNNING\n    return\n\n#change to DONE STATE, the current proc&#39;s state should be expected\ndef move_to_done(self, expected):\n    #YOUR CODE\n    now_id = self.curr_proc\n    assert(self.proc_info[now_id][PROC_STATE] == expected)\n    self.proc_info[now_id][PROC_STATE] = STATE_DONE\n    return</pre>\n<p>按照注释&#xff0c;对于当前状态的检查不可省略。同时&#xff0c;要注意到 <strong>move_to_ready</strong> 的特殊性&#xff0c;在实际操作系统中&#xff0c;经常需要把另一个进程唤醒&#xff0c;但是不太可能把另一个进程直接置为 <strong>running</strong> 或者 <strong>done</strong>&#xff0c;所以 <strong>move_to_ready</strong> 的参数中含 <strong>pid&#xff0c;</strong>意味着操作的进程不一定是当前进程。典型错误&#xff1a;</p>\n<p></p>\n<pre>def move_to_ready(self):\n    self.proc_info[self.curr_proc][PROC_STATE] = STATE_READY\n\ndef move_to_running(self):\n    self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING\n\ndef move_to_done(self):\n    self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE</pre>\n<p>2. <strong>next_proc</strong></p>\n<pre>def next_proc(self, pid=-1):\n    #YOUR CODE\n    now_id = pid\n    if now_id == -1:\n        now_id = self.curr_proc\n        \n    for i in range(now_id&#43;1, len(self.proc_info)):\n        if (self.proc_info[i][PROC_STATE] == STATE_READY):\n            self.curr_proc = i\n            self.move_to_running(STATE_READY)\n            return\n\n    for i in range(now_id &#43; 1):\n        if (self.proc_info[i][PROC_STATE] == STATE_READY):\n            self.curr_proc = i\n            self.move_to_running(STATE_READY)\n            return</pre>\n<p>按照FCFS的方法&#xff0c;从 <strong>pid&#43;1</strong> 号进程开始分两段查找第一个 <strong>ready</strong> 的进程&#xff0c;如果找不到&#xff0c; <strong>curr_proc </strong>保持不变即可&#xff0c;CPU会执行空指令。</p>\n<p>由于当前题目的情景比较简单&#xff0c;很多其他写法也可以&#xff0c;但是考虑一个尽可能真实、灵活的情景更好。其他写法&#xff1a;</p>\n<pre>def next_proc(self, pid=-1):\n    #YOUR CODE\n    curr = 0\n    if pid == -1:\n        curr = (self.curr_proc &#43; 1) % self.get_num_processes()\n    else:\n        curr = (pid &#43; 1) % self.get_num_processes()\n    while self.proc_info[curr][PROC_STATE] == STATE_DONE: # 如果进程有等待状态&#xff0c;这种写法就失效了。并且可能死循环。\n        curr = (curr &#43; 1) % self.get_num_processes()\n    self.curr_proc = curr\n    self.move_to_running(STATE_READY)\n    return</pre>\n<p>3. <strong>run</strong> 片段一</p>\n<pre>if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n        len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n    #YOUR CODE\n    instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE][0]\n    del self.proc_info[self.curr_proc][PROC_CODE][0]</pre>\n<p>选择执行的指令&#xff0c;并将其删除。</p>\n<p></p>\n<p>4. <strong>run</strong> 片段二</p>\n<pre># if this is an YIELD instruction, switch to ready state\n# and add an io completion in the future\nif instruction_to_execute == DO_YIELD:\n    #YOUR CODE\n    self.move_to_ready()\n    self.next_proc()\n\n# ENDCASE: check if currently running thing is out of instructions\nself.check_if_done()</pre>\n<p>如果进程放弃CPU&#xff0c;将其置为ready&#xff0c;切入下一个进程。</p>\n<p></p>\n<p>本题总的来说比较简单&#xff0c;写法大同小异&#xff0c;&#34;正确&#34;的写法很多&#xff0c;但是考虑的时候最好不要局限于本题的情景&#xff0c;考虑一个更加真实、完整的调度系统&#xff0c;这样写出来的代码会更好一点。</p>"}, {"anon": "full", "uid_a": "a_0", "subject": "第七讲课后练习展示", "created": "2020-03-24T13:36:34Z", "content": "<p>题目&#xff1a;</p>\n<p>设计一个简化的进程管理子系统&#xff0c;可以管理并调度如下简化进程。在理解参考代码的基础上&#xff0c;完成&#xff02;YOUR CODE&#34;部分的内容。然后通过测试用例和比较自己的实现与往届同学的结果&#xff0c;评价自己的实现是否正确。</p>\n<p></p>\n<p>需填充代码与参考实现&#xff1a;</p>\n<p>1. <strong>move_to_xxx</strong></p>\n<p></p>\n<pre>#change to READY STATE, the current proc&#39;s state should be expected<br />#if pid==-1, then pid=self.curr_proc<br />def move_to_ready(self, expected, pid=-1):<br />    #YOUR CODE<br />    now_id = pid<br />    if now_id == -1:<br />        now_id = self.curr_proc<br />    assert(self.proc_info[now_id][PROC_STATE] == expected)<br />    self.proc_info[now_id][PROC_STATE] = STATE_READY<br />    return<br /><br />#change to RUNNING STATE, the current proc&#39;s state should be expected<br />def move_to_running(self, expected):<br />    #YOUR CODE<br />    now_id = self.curr_proc<br />    assert(self.proc_info[now_id][PROC_STATE] == expected)<br />    self.proc_info[now_id][PROC_STATE] = STATE_RUNNING<br />    return<br /><br />#change to DONE STATE, the current proc&#39;s state should be expected<br />def move_to_done(self, expected):<br />    #YOUR CODE<br />    now_id = self.curr_proc<br />    assert(self.proc_info[now_id][PROC_STATE] == expected)<br />    self.proc_info[now_id][PROC_STATE] = STATE_DONE<br />    return</pre>\n<p>按照注释&#xff0c;对于当前状态的检查不可省略。同时&#xff0c;要注意到 <strong>move_to_ready</strong> 的特殊性&#xff0c;在实际操作系统中&#xff0c;经常需要把另一个进程唤醒&#xff0c;但是不太可能把另一个进程直接置为 <strong>running</strong> 或者 <strong>done</strong>&#xff0c;所以 <strong>move_to_ready</strong> 的参数中含 <strong>pid&#xff0c;</strong>意味着操作的进程不一定是当前进程。典型错误&#xff1a;</p>\n<p></p>\n<pre>def move_to_ready(self):\n    self.proc_info[self.curr_proc][PROC_STATE] = STATE_READY\n\ndef move_to_running(self):\n    self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING\n\ndef move_to_done(self):\n    self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE</pre>\n<p>2. <strong>next_proc</strong></p>\n<pre>def next_proc(self, pid=-1):<br />    #YOUR CODE<br />    now_id = pid<br />    if now_id == -1:<br />        now_id = self.curr_proc<br />        <br />    for i in range(now_id&#43;1, len(self.proc_info)):<br />        if (self.proc_info[i][PROC_STATE] == STATE_READY):<br />            self.curr_proc = i<br />            self.move_to_running(STATE_READY)<br />            return<br /><br />    for i in range(now_id &#43; 1):<br />        if (self.proc_info[i][PROC_STATE] == STATE_READY):<br />            self.curr_proc = i<br />            self.move_to_running(STATE_READY)<br />            return</pre>\n<p>按照FCFS的方法&#xff0c;从 <strong>pid&#43;1</strong> 号进程开始分两段查找第一个 <strong>ready</strong> 的进程&#xff0c;如果找不到&#xff0c; <strong>curr_proc </strong>保持不变即可&#xff0c;CPU会执行空指令。</p>\n<p>由于当前题目的情景比较简单&#xff0c;很多其他写法也可以&#xff0c;但是考虑一个尽可能真实、灵活的情景更好。其他写法&#xff1a;</p>\n<pre>def next_proc(self, pid=-1):\n    #YOUR CODE\n    curr = 0\n    if pid == -1:\n        curr = (self.curr_proc &#43; 1) % self.get_num_processes()\n    else:\n        curr = (pid &#43; 1) % self.get_num_processes()\n    while self.proc_info[curr][PROC_STATE] == STATE_DONE: # 如果进程有等待状态&#xff0c;这种写法就失效了。并且可能死循环。\n        curr = (curr &#43; 1) % self.get_num_processes()\n    self.curr_proc = curr\n    self.move_to_running(STATE_READY)\n    return</pre>\n<p>3. <strong>run</strong> 片段一</p>\n<pre>if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n        len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n    #YOUR CODE\n    instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE][0]\n    del self.proc_info[self.curr_proc][PROC_CODE][0]</pre>\n<p>选择执行的指令&#xff0c;并将其删除。</p>\n<p></p>\n<p>4. <strong>run</strong> 片段二</p>\n<pre># if this is an YIELD instruction, switch to ready state<br /># and add an io completion in the future<br />if instruction_to_execute == DO_YIELD:<br />    #YOUR CODE<br />    self.move_to_ready()<br />    self.next_proc()<br /><br /># ENDCASE: check if currently running thing is out of instructions<br />self.check_if_done()</pre>\n<p>如果进程放弃CPU&#xff0c;将其置为ready&#xff0c;切入下一个进程。</p>\n<p></p>\n<p>本题总的来说比较简单&#xff0c;写法大同小异&#xff0c;&#34;正确&#34;的写法很多&#xff0c;但是考虑的时候最好不要局限于本题的情景&#xff0c;考虑一个更加真实、完整的调度系统&#xff0c;这样写出来的代码会更好一点。</p>"}], "type": "note", "tags": ["lecture9", "student", "unanswered"], "tag_good": [], "unique_views": 63, "children": [], "tag_good_arr": [], "id": "k85y0cnytm36pl", "config": {"seen": {"47": 5, "1027": 9, "1025": 6, "6": 7, "468": 1, "930": 8, "1030": 4, "1194": 0, "1308": 2, "97": 3}}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 1, "num_favorites": 0, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643170028529, "default_anonymity": "no"}, "error": null, "aid": "kyv10cflllz1uf"}