{"result": {"folders": ["lab1", "特权级"], "nr": 1001, "data": {"embed_links": []}, "created": "2017-03-09T09:10:39Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "stud", "data": "j026aynlbx729r", "type": "create", "when": "2017-03-09T09:10:39Z", "uid_a": "a_0"}, {"anon": "no", "uid": "io2ra61elC5", "to": "j026ayni4i629q", "type": "followup", "when": "2017-03-09T12:45:43Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j026ayni4i629q", "type": "feedback", "when": "2017-03-10T00:38:40Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "data": "j0eqck0gaiy4nc", "type": "update", "when": "2017-03-18T04:05:00Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "有关于mm/pmm.c中GDT表的建立", "created": "2017-03-18T04:05:00Z", "content": "<p>在Lab1的实验中需要了解GDT表的建立&#xff0c;于是我在mm/pmm.c文件中找到了如下的定义&#xff1a;</p>\n<p></p>\n<pre>/* *\n * Global Descriptor Table:\n *\n * The kernel and user segments are identical (except for the DPL). To load\n * the %ss register, the CPL must equal the DPL. Thus, we must duplicate the\n * segments for the user and the kernel. Defined as follows:\n *   - 0x0 :  unused (always faults -- for trapping NULL far pointers)\n *   - 0x8 :  kernel code segment\n *   - 0x10:  kernel data segment\n *   - 0x18:  user code segment\n *   - 0x20:  user data segment\n *   - 0x28:  defined for tss, initialized in gdt_init\n * */\nstatic struct segdesc gdt[] = {\n    SEG_NULL,\n    [SEG_KTEXT] = SEG(STA_X | STA_R, 0x0, 0xFFFFFFFF, DPL_KERNEL),\n    [SEG_KDATA] = SEG(STA_W, 0x0, 0xFFFFFFFF, DPL_KERNEL),\n    [SEG_UTEXT] = SEG(STA_X | STA_R, 0x0, 0xFFFFFFFF, DPL_USER),\n    [SEG_UDATA] = SEG(STA_W, 0x0, 0xFFFFFFFF, DPL_USER),\n    [SEG_TSS]    = SEG_NULL,\n};</pre>\n<p>老师在课堂和MOOC中均提到&#xff0c;uCore将x86提供的段机制看作是直接映射&#xff0c;在页机制未启用的前提下&#xff0c;达到了逻辑地址=线性地址=物理地址的效果。观察上面的代码&#xff0c;除了第一个SEG_NULL是硬件需要之外&#xff0c;其他的五个SEG有四个都将地址映射到了0x00000000-0xFFFFFFFF&#xff0c;也就是说&#xff1a;当访存的逻辑地址唯一确定的时候&#xff0c;对应的线性地址就确定了&#xff0c;而对该逻辑地址的权限则由CS或是DS等寄存器决定&#xff0c;因此也可以通过观察CS的值确定当前到底是用户态还是内核态。</p>\n<p></p>\n<p>那么为什么还需要这6个段呢&#xff1f;在课下与陈老师的讨论中&#xff0c;得知这样做的目的是<strong>权限控制</strong>。</p>\n<p>举个例子&#xff0c;当CS为用户态时&#xff0c;如果试图执行某些特权指令或是内核态中断&#xff0c;就会触发x86的13号一般保护异常(  <a href=\"http://ilinuxkernel.com/?p=1388\">http://ilinuxkernel.com/?p=1388</a> )。 在lab1的challenge实验中&#xff0c;建立IDT表的时候&#xff0c;需要把T_SWITCH_TOK特权级别设置为DPL_USER&#xff0c;这样一来&#xff0c;在用户态执行lab1_switch_to_kernel的int指令时&#xff0c;就不会触发一般保护异常了。</p>\n<p></p>\n<p>至于SEG_NULL和SEG_TSS&#xff0c;前者应该是x86硬件需求&#xff0c;后者是之后的lab中会用到的用户用户态和内核态栈切换存储寄存器的临时区域&#xff0c;是动态建立的。</p>\n<p></p>\n<p>但其实写到这里&#xff0c;我还是有一个不太理解的地方&#xff0c;那就是既然之后会有页机制来进行权限控制&#xff0c;为什么还要在这里重复进行检查呢&#xff0c;这一步是多余的吗&#xff08;即段表只设置NULL和KERNEL可以吗&#xff09;&#xff1f;</p>\n<p></p>\n<p>希望同学一起讨论一下&#xff0c;如果我有新的理解再更新。</p>"}, {"anon": "stud", "uid_a": "a_0", "subject": "有关于mm/pmm.c中GDT表的建立", "created": "2017-03-09T09:10:39Z", "content": "<p>在Lab1的实验中需要了解GDT表的建立&#xff0c;于是我在mm/pmm.c文件中找到了如下的定义&#xff1a;</p>\n<p></p>\n<pre>/* *<br /> * Global Descriptor Table:<br /> *<br /> * The kernel and user segments are identical (except for the DPL). To load<br /> * the %ss register, the CPL must equal the DPL. Thus, we must duplicate the<br /> * segments for the user and the kernel. Defined as follows:<br /> *   - 0x0 :  unused (always faults -- for trapping NULL far pointers)<br /> *   - 0x8 :  kernel code segment<br /> *   - 0x10:  kernel data segment<br /> *   - 0x18:  user code segment<br /> *   - 0x20:  user data segment<br /> *   - 0x28:  defined for tss, initialized in gdt_init<br /> * */<br />static struct segdesc gdt[] = {<br />    SEG_NULL,<br />    [SEG_KTEXT] = SEG(STA_X | STA_R, 0x0, 0xFFFFFFFF, DPL_KERNEL),<br />    [SEG_KDATA] = SEG(STA_W, 0x0, 0xFFFFFFFF, DPL_KERNEL),<br />    [SEG_UTEXT] = SEG(STA_X | STA_R, 0x0, 0xFFFFFFFF, DPL_USER),<br />    [SEG_UDATA] = SEG(STA_W, 0x0, 0xFFFFFFFF, DPL_USER),<br />    [SEG_TSS]    = SEG_NULL,<br />};</pre>\n<p>老师在课堂和MOOC中均提到&#xff0c;uCore将x86提供的段机制看作是直接映射&#xff0c;在页机制未启用的前提下&#xff0c;达到了逻辑地址=线性地址=物理地址的效果。观察上面的代码&#xff0c;除了第一个SEG_NULL是硬件需要之外&#xff0c;其他的五个SEG有四个都将地址映射到了0x00000000-0xFFFFFFFF&#xff0c;也就是说&#xff1a;当访存的逻辑地址唯一确定的时候&#xff0c;对应的线性地址就确定了&#xff0c;而对该逻辑地址的权限则由CS或是DS等寄存器决定&#xff0c;因此也可以通过观察CS的值确定当前到底是用户态还是内核态。</p>\n<p></p>\n<p>那么为什么还需要这6个段呢&#xff1f;在课下与陈老师的讨论中&#xff0c;得知这样做的目的是<strong>权限控制</strong>。</p>\n<p>举个例子&#xff0c;当CS为用户态时&#xff0c;如果试图执行某些特权指令或是内核态中断&#xff0c;就会触发x86的13号一般保护异常(  <a href=\"http://ilinuxkernel.com/?p=1388\">http://ilinuxkernel.com/?p=1388</a> )。 在lab1的challenge实验中&#xff0c;建立IDT表的时候&#xff0c;需要把T_SWITCH_TOK特权级别设置为DPL_USER&#xff0c;这样一来&#xff0c;在用户态执行lab1_switch_to_kernel的int指令时&#xff0c;就不会触发一般保护异常了。</p>\n<p></p>\n<p>至于SEG_NULL和SEG_TSS&#xff0c;前者应该是x86硬件需求&#xff0c;后者是之后的lab中会用到的用户用户态和内核态栈切换存储寄存器的临时区域&#xff0c;是动态建立的。</p>\n<p></p>\n<p>但其实写到这里&#xff0c;我还是有一个不太理解的地方&#xff0c;那就是既然之后会有页机制来进行权限控制&#xff0c;为什么还要在这里重复进行检查呢&#xff0c;这一步是多余的吗&#xff08;即段表只设置NULL和KERNEL可以吗&#xff09;&#xff1f;</p>\n<p></p>\n<p>希望同学一起讨论一下&#xff0c;如果我有新的理解再更新。</p>"}], "type": "note", "tags": ["lab1", "student", "特权级"], "tag_good": [{"role": "instructor", "name": "Yong XIANG", "endorser": {}, "admin": true, "photo": null, "id": "hdjonbiyfs62ie", "photo_url": null, "us": false, "class_sections": ["课程设计_i5j09fnsl7k5x0", "清华学生_i5j09fnsl7k5x0", "所有老师和助教_i5j09fnsl7k5x0", "os2018spring_i5j09fnsl7k5x0"], "facebook_id": null}], "unique_views": 213, "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>我觉得是这样&#xff0c;最早只有段机制&#xff0c;x86通过CPL&#xff0c;RPL和DPL机制&#xff08;视频有讲&#xff09;来实现保护模式完整的权限检查&#xff0c;后来用页机制也只是用到了虚拟地址空间&#xff0c;权限管理用的不多。可能为了前向兼容&#xff0c;没有完全抛弃段机制&#xff08;以及基于段机制的完整的权限管理&#xff09;&#xff0c;所以还是要保留用户态和内核态的代码段、数据段来实现权限检查。其他架构比如arm就没有历史包袱&#xff0c;就完全没有段管理机制&#xff0c;是通过其他方式实现权限管理的。</p>", "created": "2017-03-09T12:45:43Z", "bucket_order": 159, "bucket_name": "Week 3/5 - 3/11", "type": "followup", "tag_good": [], "uid": "io2ra61elC5", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>在我看来&#xff0c;段机制与程序的逻辑结构更一致&#xff0c;即权限控制的范围与程序逻辑比较一致&#xff1b;而页机制的权限控制粒度比较细&#xff0c;固定大小对于实现比较方便&#xff0c;但与程序逻辑不是很好协调了。</p>", "created": "2017-03-10T00:38:40Z", "bucket_order": 159, "bucket_name": "Week 3/5 - 3/11", "type": "feedback", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [], "tag_good_arr": [], "id": "j033gejhbm95mk", "updated": "2017-03-10T00:38:40Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "j02dzjtxuei4ra", "updated": "2017-03-09T12:45:43Z", "config": {}}], "tag_good_arr": ["hdjonbiyfs62ie"], "id": "j026ayni4i629q", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 8, "num_favorites": 2, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643168959080, "default_anonymity": "no"}, "error": null, "aid": "kyv0df8odh65su"}