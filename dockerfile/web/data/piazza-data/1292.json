{"result": {"folders": ["lecture8", "2019"], "nr": 1292, "data": {"embed_links": []}, "created": "2019-03-23T13:44:26Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "jsilaonbtO8o", "data": "jtljou4em8s6fv", "type": "create", "when": "2019-03-23T13:44:26Z"}, {"anon": "no", "uid": "jsilaonbtO8o", "data": "jtljqr6qrao7oy", "type": "update", "when": "2019-03-23T13:45:56Z"}, {"anon": "no", "uid": "jt1eweiz2OX1", "to": "jtljou4curr6ft", "type": "followup", "when": "2019-03-24T11:27:01Z"}, {"anon": "no", "uid": "jsilaonbtO8o", "data": "jtmxnzy91fr3s3", "type": "update", "when": "2019-03-24T13:03:28Z"}, {"anon": "no", "uid": "jsilaonbtO8o", "to": "jtljou4curr6ft", "type": "feedback", "when": "2019-03-24T13:36:01Z"}, {"anon": "no", "uid": "jshne2lh3x54pa", "to": "jtljou4curr6ft", "type": "feedback", "when": "2019-03-31T09:18:52Z"}, {"anon": "no", "uid": "jsilaonbtO8o", "to": "jtljou4curr6ft", "type": "feedback", "when": "2019-03-31T09:35:24Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "jtljou4curr6ft", "type": "feedback", "when": "2019-04-03T23:55:10Z"}, {"anon": "no", "uid": "jsn9fs59DCSn", "to": "jtljou4curr6ft", "type": "feedback", "when": "2019-04-04T07:04:38Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "jtljou4curr6ft", "type": "feedback", "when": "2019-04-05T03:47:52Z"}, {"anon": "no", "uid": "jshne2lh3x54pa", "to": "jtljou4curr6ft", "type": "feedback", "when": "2019-04-05T03:56:41Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "jtljou4curr6ft", "type": "feedback", "when": "2019-04-05T04:07:41Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "jsilaonbtO8o", "subject": "缺页异常是否有可能嵌套&#xff1f;", "created": "2019-03-24T13:03:28Z", "content": "<p>3月21日周四的课上&#xff0c;向老师问了这个问题。课后我在piazza上搜了搜&#xff0c;发现之前的学长也有类似的疑问&#xff08;参见<a href=\"http://piazza.com/class/i5j09fnsl7k5x0?cid=761\" target=\"_blank\"> https://piazza.com/class/i5j09fnsl7k5x0?cid=761</a>&#xff09;。课上讨论后&#xff0c;得到的结论是不能。最近两天我又找了一些资料&#xff0c;现把结论总结如下。</p>\n<p></p>\n<p>首先&#xff0c;这个“不能”的结论从道理上完全说得通。考虑缺页异常嵌套的情况&#xff0c;也就是在处理第一个缺页异常的时候&#xff0c;又发生了缺页异常。第二次发生的缺页异常&#xff0c;最可能的情况是访问缺页服务例程时&#xff0c;又出异常了。这种情况下&#xff0c;相当于“甩了一个只有自己能接的锅”——可以想象&#xff0c;当系统试图去处理这个第二次发生的缺页异常时&#xff0c;还得找到缺页服务例程&#xff1b;但此时&#xff0c;缺页服务例程又缺页了&#xff0c;引发了第三次、第四次、...、第N次缺页异常。</p>\n<p>这就成了死循环&#xff0c;问题无法解决了。事实上&#xff0c;这样的死循环是致命的——三次&#xff08;嵌套的&#xff09;异常就会让机器直接重启&#xff08;见<a href=\"https://wiki.osdev.org/Triple_Fault\" target=\"_blank\">Triple Fault</a>&#xff09;。</p>\n<p></p>\n<p>然而我们知道&#xff0c;缺页异常也是一种中断&#xff0c;而同种类型的中断是无法嵌套的。事实上&#xff0c;当一个中断服务例程执行时&#xff0c;相应的中断线对所有进程都是屏蔽的&#xff0c;这避免了一个同种类型的中断抢进来。因此&#xff0c;从这个角度上来说&#xff0c;缺页异常也无法嵌套地处理。</p>\n<p></p>\n<p>但进一步想&#xff0c;当前的中断总得处理完。要是当前的中断&#xff08;缺页异常&#xff09;因为其相应的中断服务例程访问失败而处理不完&#xff0c;还是会死在这里——这种情况应该被特判。</p>\n<p>先来思考之前学长的给出的场景&#xff08;<a href=\"http://piazza.com/class/i5j09fnsl7k5x0?cid=761\" target=\"_blank\">https://piazza.com/class/i5j09fnsl7k5x0?cid=761</a>&#xff09;是否有可能&#xff1a;缺页异常服务例程如果被交换出去&#xff0c;就会嵌套了。</p>\n<p>然而这种场景其实应该是不存在的&#xff0c;因为我们不会让中断服务例程交换出去。根据<a href=\"https://objectkuan.gitbooks.io/ucore-docs/content/lab3/lab3_5_2_page_swapping_principles.html\" target=\"_blank\">页面换出机制</a>&#xff0c;被内核直接使用的内核空间的页面不能被换出。以ucore为例&#xff0c;中断服务例程应该都存在kern/trap/下&#xff0c;这肯定在内核空间&#xff0c;不会被换出。</p>\n<p></p>\n<p>然而&#xff0c;还会有一种情况&#xff1a;中断服务例程如果有bug&#xff0c;比如在执行缺页异常服务例程时不慎访问了某个野指针&#xff0c;就又不行了&#xff1b;保证所有的中断服务例程一定没有bug&#xff0c;这可能有些困难。那么这种情况要怎么处理呢&#xff1f;</p>\n<p>通过查阅资料&#xff0c;我发现这应该是<a href=\"https://wiki.osdev.org/Double_Fault#Double_Fault\" target=\"_blank\">Double Fault</a>。Double fault是存在的&#xff0c;于是&#xff0c;缺页异常可能两个嵌套在一起&#xff0c;但三个肯定就不行了。</p>\n<p>在x86架构中&#xff0c;处理这样的双重异常的唯一可靠方法是通过硬件上下文切换&#xff08;见<a href=\"https://wiki.osdev.org/Context_Switching#Hardware_Context_Switching\" target=\"_blank\">Hardware Context Switching</a>&#xff1b;中断向量表的0x08位是给双重异常准备的&#xff0c;见<a href=\"https://wiki.osdev.org/Interrupt_Vector_Table\" target=\"_blank\">Interrupt Vector Table</a>&#xff09;&#xff1b;此外&#xff0c;x86_64架构中将硬件上下文切换取消掉了&#xff0c;解决双重异常的机制取而代之是Interrupt Stack Table&#xff08;可参考 <a href=\"https://os.phil-opp.com/double-fault-exceptions/\" target=\"_blank\">https://os.phil-opp.com/double-fault-exceptions/</a> 给出的详细介绍&#xff09;。</p>\n<p></p>\n<p>至此&#xff0c;我得到的最终结论是&#xff1a;缺页异常最多是两个嵌套在一起&#xff0c;三个及以上就不行了。</p>\n<p></p>\n<p>不知道得到的结论是否正确&#xff1f;请大家指正&#xff01;</p>"}, {"anon": "no", "uid": "jsilaonbtO8o", "subject": "缺页异常是否有可能嵌套&#xff1f;", "created": "2019-03-23T13:45:56Z", "content": "<p>3月21日周四的课上&#xff0c;向老师问了这个问题。课后我在piazza上搜了搜&#xff0c;发现之前的学长也有类似的疑问&#xff08;参见<a href=\"http://piazza.com/class/i5j09fnsl7k5x0?cid=761\" target=\"_blank\"> https://piazza.com/class/i5j09fnsl7k5x0?cid=761</a>&#xff09;。课上讨论后&#xff0c;得到的结论是不能。最近两天我又找了一些资料&#xff0c;现把结论总结如下。</p>\n<p></p>\n<p>首先&#xff0c;这个“不能”的结论从道理上完全说得通。考虑缺页异常嵌套的情况&#xff0c;也就是在处理第一个缺页异常的时候&#xff0c;又发生了缺页异常。第二次发生的缺页异常&#xff0c;最可能的情况是访问缺页服务例程时&#xff0c;又出异常了。这种情况下&#xff0c;相当于“甩了一个只有自己能接的锅”——可以想象&#xff0c;当系统试图去处理这个第二次发生的缺页异常时&#xff0c;还得找到缺页服务例程&#xff1b;但此时&#xff0c;缺页服务例程又缺页了&#xff0c;引发了第三次、第四次、...、第N次缺页异常。</p>\n<p>这就成了死循环&#xff0c;问题无法解决了。事实上&#xff0c;这样的死循环是致命的——三次&#xff08;嵌套的&#xff09;异常就会让机器直接重启&#xff08;见<a href=\"https://wiki.osdev.org/Triple_Fault\" target=\"_blank\">Triple Fault</a>&#xff09;。</p>\n<p></p>\n<p>然而我们知道&#xff0c;缺页异常也是一种中断&#xff0c;而同种类型的中断是无法嵌套的。事实上&#xff0c;当一个中断服务例程执行时&#xff0c;相应的中断线对所有进程都是屏蔽的&#xff0c;这避免了一个同种类型的中断抢进来。因此&#xff0c;从这个角度上来说&#xff0c;缺页异常也无法嵌套地处理。</p>\n<p></p>\n<p>但进一步想&#xff0c;当前的中断总得处理完。要是当前的中断&#xff08;缺页异常&#xff09;因为其相应的中断服务例程访问失败而处理不完&#xff0c;还是会死在这里——这种情况应该被特判。</p>\n<p>先来思考之前学长的给出的场景&#xff08;<a href=\"http://piazza.com/class/i5j09fnsl7k5x0?cid=761\" target=\"_blank\">https://piazza.com/class/i5j09fnsl7k5x0?cid=761</a>&#xff09;是否有可能&#xff1a;缺页异常服务例程如果被交换出去&#xff0c;就会嵌套了。</p>\n<p>然而这种场景其实应该是不存在的&#xff0c;因为我们不会让中断服务例程交换出去。根据<a href=\"https://objectkuan.gitbooks.io/ucore-docs/content/lab3/lab3_5_2_page_swapping_principles.html\" target=\"_blank\">页面换出机制</a>&#xff0c;被内核直接使用的内核空间的页面不能被换出。以ucore为例&#xff0c;中断服务例程应该都存在kern/trap/下&#xff0c;这肯定在内核空间&#xff0c;不会被换出。</p>\n<p></p>\n<p>然而&#xff0c;还会有一种情况&#xff1a;中断服务例程如果有bug&#xff0c;比如在执行缺页异常服务例程时不慎访问了某个野指针&#xff0c;就又不行了&#xff1b;保证所有的中断服务例程一定没有bug&#xff0c;这可能有些困难。那么这种情况要怎么处理呢&#xff1f;</p>\n<p>通过查阅资料&#xff0c;我发现这应该是<a href=\"https://wiki.osdev.org/Double_Fault#Double_Fault\" target=\"_blank\">Double Fault</a>。Double fault是存在的&#xff0c;于是&#xff0c;缺页异常可能两个嵌套在一起&#xff0c;但三个肯定就不行了。</p>\n<p>在x86架构中&#xff0c;处理这样的双重异常的唯一可靠方法是通过硬件上下文切换&#xff08;见<a href=\"https://wiki.osdev.org/Context_Switching#Hardware_Context_Switching\" target=\"_blank\">Hardware Context Switching</a>&#xff1b;中断向量表的0x08位是给双重异常准备的&#xff0c;见<a href=\"https://wiki.osdev.org/Interrupt_Vector_Table\" target=\"_blank\">Interrupt Vector Table</a>&#xff09;&#xff1b;此外&#xff0c;x86_64架构中将硬件上下文切换取消掉了&#xff0c;解决双重异常的机制取而代之是Interrupt Stack Table&#xff08;可参考 <a href=\"https://os.phil-opp.com/double-fault-exceptions/\" target=\"_blank\">https://os.phil-opp.com/double-fault-exceptions/</a> 给出的详细介绍&#xff09;。</p>\n<p></p>\n<p>至此&#xff0c;我得到的最终结论是&#xff1a;缺页异常最多是两个嵌套在一起&#xff0c;三个及以上就不行了。</p>\n<p></p>\n<p>不知道得到的结论是否正确&#xff1f;请大家指正&#xff01;</p>"}, {"anon": "no", "uid": "jsilaonbtO8o", "subject": "缺页异常是否有可能嵌套&#xff1f;", "created": "2019-03-23T13:44:26Z", "content": "<p>3月21日周四的课上&#xff0c;向老师问了这个问题。课后我在piazza上搜了搜&#xff0c;发现之前的学长也有类似的疑问&#xff08;参见<a href=\"http://piazza.com/class/i5j09fnsl7k5x0?cid=761\" target=\"_blank\"> https://piazza.com/class/i5j09fnsl7k5x0?cid=761</a>&#xff09;。课上讨论后&#xff0c;得到的结论是不能。最近两天我又找了一些资料&#xff0c;现把结论总结如下。</p>\n<p></p>\n<p>首先&#xff0c;这个“不能”的结论从道理上完全说得通。考虑缺页异常嵌套的情况&#xff0c;也就是在处理第一个缺页异常的时候&#xff0c;又发生了缺页异常。第二次发生的缺页异常&#xff0c;最可能的情况是访问缺页服务例程时&#xff0c;又出异常了。这种情况下&#xff0c;相当于“甩了一个只有自己能接的锅”——可以想象&#xff0c;当系统试图去处理这个第二次发生的缺页异常时&#xff0c;还得找到缺页服务例程&#xff1b;但此时&#xff0c;缺页服务例程又缺页了&#xff0c;引发了第三次、第四次、...、第N次缺页异常。</p>\n<p>这就成了死循环&#xff0c;问题无法解决了。事实上&#xff0c;这样的死循环是致命的——三次&#xff08;嵌套的&#xff09;异常就会让机器直接重启&#xff08;见<a href=\"https://wiki.osdev.org/Triple_Fault\" target=\"_blank\">Triple Fault</a>&#xff09;。</p>\n<p></p>\n<p>然而我们知道&#xff0c;缺页异常也是一种中断&#xff0c;而同种类型的中断是无法嵌套的。事实上&#xff0c;当一个中断服务例程执行时&#xff0c;相应的中断线对所有进程都是屏蔽的&#xff0c;这避免了一个同种类型的中断抢进来。因此&#xff0c;从这个角度上来说&#xff0c;缺页异常也无法嵌套地处理。</p>\n<p></p>\n<p>但进一步想&#xff0c;当前的中断总得处理完。要是当前的中断&#xff08;缺页异常&#xff09;因为其相应的中断服务例程访问失败而处理不完&#xff0c;还是会死在这里——这种情况应该被特判。</p>\n<p>先来思考之前学长的给出的场景&#xff08;<a href=\"http://piazza.com/class/i5j09fnsl7k5x0?cid=761\" target=\"_blank\">https://piazza.com/class/i5j09fnsl7k5x0?cid=761</a>&#xff09;是否有可能&#xff1a;缺页异常服务例程如果被交换出去&#xff0c;就会嵌套了。</p>\n<p>然而这种场景其实应该是不存在的&#xff0c;因为我们不会让中断服务例程交换出去。根据<a href=\"https://objectkuan.gitbooks.io/ucore-docs/content/lab3/lab3_5_2_page_swapping_principles.html\" target=\"_blank\">页面换出机制</a>&#xff0c;被内核直接使用的内核空间的页面不能被换出。以ucore为例&#xff0c;中断服务例程应该都存在kern/trap/下&#xff0c;这肯定在内核空间&#xff0c;不会被换出。</p>\n<p></p>\n<p>然而&#xff0c;还会有一种情况&#xff1a;中断服务例程如果有bug&#xff0c;比如在执行缺页异常服务例程时不慎访问了某个野指针&#xff0c;就又不行了&#xff1b;保证所有的中断服务例程一定没有bug&#xff0c;这可能有些困难。那么这种情况要怎么处理呢&#xff1f;</p>\n<p>通过查阅资料&#xff0c;我发现这应该是<a href=\"https://wiki.osdev.org/Double_Fault#Double_Fault\" target=\"_blank\">Double Fault</a>。Double fault是存在的&#xff0c;于是&#xff0c;缺页异常可能两个嵌套在一起&#xff0c;但三个肯定就不行了。</p>\n<p>在x86架构中&#xff0c;处理这样的双重异常的唯一可靠方法是通过硬件上下文切换&#xff08;见<a href=\"https://wiki.osdev.org/Context_Switching#Hardware_Context_Switching\" target=\"_blank\">Hardware Context Switching</a>&#xff1b;中断向量表的0x08位是给双重异常准备的&#xff0c;见<a href=\"https://wiki.osdev.org/Interrupt_Vector_Table\" target=\"_blank\">Interrupt Vector Table</a>&#xff09;&#xff1b;此外&#xff0c;x86_64架构中将硬件上下文切换取消掉了&#xff0c;解决双重异常的机制取而代之是Interrupt Stack Table&#xff08;可参考 <a href=\"https://os.phil-opp.com/double-fault-exceptions/\" target=\"_blank\">https://os.phil-opp.com/double-fault-exceptions/</a> 给出的详细介绍&#xff09;。</p>\n<p></p>\n<p>至此&#xff0c;我得到的最终结论是&#xff1a;缺页异常最多是两个嵌套在一起&#xff0c;三个及以上就不行了。</p>\n<p></p>\n<p>不知道得到的结论是否正确&#xff1f;请大家指正&#xff01;</p>"}], "type": "question", "tags": ["2019", "lecture8", "student", "unanswered"], "tag_good": [], "unique_views": 151, "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>我在qemu中尝试了一下&#xff0c;通过输出和gdb调试都能发现缺页异常的处理例程的最大嵌套层数似乎并不是2。但是看起来也不能无限制的嵌套&#xff0c;大约在480层的时候qemu会卡住一下&#xff0c;然后回到最初的状态&#xff0c;再次输出这些内容&#xff0c;也许是发生了重启。</p>\n<p><img src=\"/img/1292-67217d3becd94b95.png\" alt=\"\" /></p>\n<p></p>", "created": "2019-03-24T11:27:01Z", "bucket_order": 53, "bucket_name": "Week 3/24 - 3/30", "type": "followup", "tag_good": [], "uid": "jt1eweiz2OX1", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>赞&#xff01;看起来QEMU中三重异常并没有导致重启。</p>\n<p>我只在维基百科上&#xff08;https://en.wikipedia.org/wiki/Triple_fault&#xff09;找到说&#xff1a;<em>In QEMU, a triple fault produces a dump of the virtual machine in the console, with the instruction pointer set to the instruction that triggered the first exception. </em></p>\n<p><em></em>不知道实际应该是怎么样的&#xff1f;求教…</p>", "created": "2019-03-24T13:36:01Z", "bucket_order": 53, "bucket_name": "Week 3/24 - 3/30", "type": "feedback", "tag_good": [], "uid": "jsilaonbtO8o", "children": [], "tag_good_arr": [], "id": "jtmytutn68j98", "updated": "2019-03-24T13:36:01Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>Double Fault 类似于在LDT表中指向缺页中断的地址会导致缺页中断&#xff0c;这时候系统会去找另一个特殊的中断处理程序&#xff0c;如果还有问题&#xff08;比如这个地址也缺页或者没权限&#xff09;&#xff0c;这时候就是 Triple Fault&#xff0c;就会重启了。</p>\n<p></p>\n<p>你说的情况&#xff0c;也就是嵌套中断&#xff0c;在硬件上是没有任何问题的。CPU 并不关心中断的嵌套&#xff0c;一旦跳转到中断服务例程就视为被处理了。就是说&#xff0c;一旦成功跳转到中断服务例程&#xff0c;CPU和在正常运行状态没有任何区别。</p>", "created": "2019-03-31T09:18:52Z", "bucket_order": 52, "bucket_name": "Week 3/31 - 4/6", "type": "feedback", "tag_good": [], "uid": "jshne2lh3x54pa", "children": [], "tag_good_arr": [], "id": "jtwpq4nf9iy2ug", "updated": "2019-03-31T09:18:52Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>原来如此&#xff01;感谢Harry&#xff5e;</p>", "created": "2019-03-31T09:35:24Z", "bucket_order": 52, "bucket_name": "Week 3/31 - 4/6", "type": "feedback", "tag_good": [], "uid": "jsilaonbtO8o", "children": [], "tag_good_arr": [], "id": "jtwqbdpvrhj7oq", "updated": "2019-03-31T09:35:24Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>我不认为缺页异常会嵌套480层。通过在缺页异常中打印函数调用栈可以确认是什么情况。请 李晨昊 确认一下。如何&#xff1f;</p>", "created": "2019-04-03T23:55:10Z", "bucket_order": 52, "bucket_name": "Week 3/31 - 4/6", "type": "feedback", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [], "tag_good_arr": [], "id": "ju1vclmlu463wt", "updated": "2019-04-03T23:55:10Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>对上文作一个补充。在李晨昊代码基础上打印了调用栈&#xff0c;发现如果在PageFault中断处理例程中出现PageFault&#xff0c;确实会出现异常嵌套的问题</p>\n<p></p>\n<pre>static int\npgfault_handler(struct trapframe *tf) {\n    extern struct mm_struct *check_mm_struct;\n    static int cnt = 0;\n    cprintf(&#34;pgfault_handler : %d, ebp: 0x%x\\n&#34;, &#43;&#43;cnt, read_ebp());\n    if (cnt &lt; 54) {\n        *(int *)(100) = 0; // trigger a page fault\n    } else {\n        print_stackframe(); // stop and print stack frame\n    }\n    print_pgfault(tf);\n    if (check_mm_struct != NULL) {\n        return do_pgfault(check_mm_struct, tf-&gt;tf_err, rcr2());\n    }\n    panic(&#34;unhandled page fault.\\n&#34;);\n}</pre>\n<p></p>\n<p>高亮部分为递归的 PageFault 异常处理程序部分</p>\n<p></p>\n<p><img src=\"/img/1292-6e9f6b22b5f022ec.png\" alt=\"高亮部分为递归进行的 PageFault 处理部分\" /></p>\n<p></p>\n<p>注意在图中第五次就打断递归进行了输出&#xff0c;但实验时50次递归时依然可以正常输出重复递归的调用栈。但到60层以上时则不能正常输出&#xff0c;推测可能和爆栈有关。</p>", "created": "2019-04-04T07:04:38Z", "bucket_order": 52, "bucket_name": "Week 3/31 - 4/6", "type": "feedback", "tag_good": [], "uid": "jsn9fs59DCSn", "children": [], "tag_good_arr": [], "id": "ju2aowwap44fi", "updated": "2019-04-04T07:04:38Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>这个输出信息表明&#xff0c;这里出现了中断或异常的嵌套。但从获取的这个函数调用栈信息来看&#xff0c;并不是缺页异常的嵌套。</p>\n<p></p>\n<p>如果可能&#xff0c;继续分析嵌套的是什么中断或异常。</p>", "created": "2019-04-05T03:47:52Z", "bucket_order": 52, "bucket_name": "Week 3/31 - 4/6", "type": "feedback", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [], "tag_good_arr": [], "id": "ju3j3pln5prk", "updated": "2019-04-05T03:47:52Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>是缺页异常的嵌套&#xff0c;之所以在下面的调用栈里面没有出现 pgfault_handler 是因为发生异常以后的处理机制使得 uCore 实现的 stack unwinding 不能发现出现异常的函数。</p>", "created": "2019-04-05T03:56:41Z", "bucket_order": 52, "bucket_name": "Week 3/31 - 4/6", "type": "feedback", "tag_good": [], "uid": "jshne2lh3x54pa", "children": [], "tag_good_arr": [], "id": "ju3jf1zy9pn4ii", "updated": "2019-04-05T03:56:41Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>验证是否是缺页异常的可能方法是&#xff0c;打印触发中断或异常的中断号信息。目前的证据还不充分。</p>", "created": "2019-04-05T04:07:41Z", "bucket_order": 52, "bucket_name": "Week 3/31 - 4/6", "type": "feedback", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [], "tag_good_arr": [], "id": "ju3jt73bmm0xq", "updated": "2019-04-05T04:07:41Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "jtmu7ykjow83uf", "updated": "2019-03-24T11:27:01Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "jtljou4curr6ft", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 5, "num_favorites": 5, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169671722, "default_anonymity": "no"}, "error": null, "aid": "kyv0sp4aedhde"}