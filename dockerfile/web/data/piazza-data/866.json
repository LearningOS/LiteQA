{"result": {"history_size": 2, "folders": ["lecture19", "2016"], "nr": 866, "data": {"embed_links": []}, "created": "2016-05-15T12:43:40Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"uid": "i0iaabhcht167g", "anon": "no", "when": "2016-05-15T12:43:40Z", "data": "io8kp1ryt4y5va", "type": "create"}, {"to": "io8kp1rw93n5v9", "uid": "i0c90j8pjf56sn", "anon": "no", "when": "2016-05-15T14:36:11Z", "data": "io8opqvh4vf6rc", "type": "s_answer"}, {"uid": "i0c90j8pjf56sn", "anon": "no", "when": "2016-05-15T14:36:36Z", "data": "io8oqad4jkh3uv", "type": "s_answer_update"}, {"to": "io8kp1rw93n5v9", "uid": "hcrrjuyequh4bt", "anon": "no", "when": "2016-05-18T05:34:04Z", "data": "iocfo5doqcq6xm", "type": "i_answer"}, {"uid": "hcrrjuyequh4bt", "anon": "no", "when": "2016-05-18T05:34:44Z", "data": "iocfp0air1h76l", "type": "i_answer_update"}, {"uid": "hcrrjuyequh4bt", "anon": "no", "when": "2016-05-18T05:34:55Z", "data": "iocfp8oixes7jd", "type": "i_answer_update"}, {"to": "io8kp1rw93n5v9", "uid": "i0c90j8pjf56sn", "anon": "no", "when": "2016-05-18T08:12:05Z", "type": "followup"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "data": "jh5ok5t42ad2ad", "type": "update", "when": "2018-05-14T03:19:59Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "关于ucore管程实现中next_count的想法", "created": "2018-05-14T03:19:59Z", "content": "<p>在完成lab7的时候突然考虑到ucore实现中一种情况可能会导致管程next_count大于1&#xff0c;但课上课下老师和同学说next_count不会大于1&#xff08;我之前也一直认为不会大于1&#xff09;</p>\n<p>构造这种情况需要使用3个线程a,b,c、2个条件c1,c2&#xff0c;对应函数大概如下</p>\n<ul><li>func_a(): wait(c1)</li><li>func_b(): wait(c2) signal(c1)</li><li>func_c(): signal(c2&#xff09;</li></ul>\n<p></p>\n<p>假设abc依次执行。</p>\n<ol><li>线程a遇到条件c1阻塞&#xff0c;于是在wait中关闭互斥锁。</li><li>线程b进入&#xff0c;遇到条件c2阻塞&#xff0c;并在wait中关闭互斥锁。</li><li>线程c进入&#xff0c;在signal函数中up条件c2的信号量&#xff0c;并down信号量next阻塞&#xff08;Hoare机制&#xff09;&#xff0c;next_count为1</li><li>线程b继续执行&#xff0c;在signal函数中由于c1被线程a需求&#xff0c;于是线程b会up条件c1的信号量&#xff0c;并down信号量next阻塞&#xff0c;此时&#xff0c;next被down了两次&#xff0c;对应next_count为2</li><li>线程a结束&#xff0c;结束时唤醒线程b&#xff0c;唤醒后next_count减为1</li><li>线程b结束&#xff0c;结束时唤醒线程c&#xff0c;唤醒后next_count为0</li><li>线程c结束&#xff0c;关闭互斥锁</li></ol>\n<p></p>"}, {"anon": "no", "uid": "i0iaabhcht167g", "subject": "关于ucore管程实现中next_count的想法", "created": "2016-05-15T12:43:40Z", "content": "<p>在完成lab7的时候突然考虑到ucore实现中一种情况可能会导致管程next_count大于1&#xff0c;但课上课下老师和同学说next_count不会大于1&#xff08;我之前也一直认为不会大于1&#xff09;</p>\n<p>构造这种情况需要使用3个线程a,b,c、2个条件c1,c2&#xff0c;对应函数大概如下</p>\n<ul><li>func_a(): wait(c1)</li><li>func_b(): wait(c2) signal(c1)</li><li>func_c(): signal(c2&#xff09;</li></ul>\n<p></p>\n<p>假设abc依次执行。</p>\n<ol><li>线程a遇到条件c1阻塞&#xff0c;于是在wait中关闭互斥锁。</li><li>线程b进入&#xff0c;遇到条件c2阻塞&#xff0c;并在wait中关闭互斥锁。</li><li>线程c进入&#xff0c;在signal函数中up条件c2的信号量&#xff0c;并down信号量next阻塞&#xff08;Hoare机制&#xff09;&#xff0c;next_count为1</li><li>线程b继续执行&#xff0c;在signal函数中由于c1被线程a需求&#xff0c;于是线程b会up条件c1的信号量&#xff0c;并down信号量next阻塞&#xff0c;此时&#xff0c;next被down了两次&#xff0c;对应next_count为2</li><li>线程a结束&#xff0c;结束时唤醒线程b&#xff0c;唤醒后next_count减为1</li><li>线程b结束&#xff0c;结束时唤醒线程c&#xff0c;唤醒后next_count为0</li><li>线程c结束&#xff0c;关闭互斥锁</li></ol>\n<p></p>"}], "type": "question", "tags": ["2016", "lecture19", "student"], "tag_good": [{"role": "instructor", "name": "Yu Chen", "endorser": {}, "admin": true, "photo": "1378950179_35.png", "id": "hcrrjuyequh4bt", "photo_url": "https://cdn-uploads.piazza.com/photos/hcrrjuyequh4bt/1378950179_35.png", "us": false, "class_sections": ["课程设计_i5j09fnsl7k5x0", "清华学生_i5j09fnsl7k5x0", "所有老师和助教_i5j09fnsl7k5x0", "os2018spring_i5j09fnsl7k5x0"], "facebook_id": null}, {"role": "", "name": "Liu Xiaohong", "endorser": {}, "admin": false, "photo": null, "id": "i0ccfx63sir1e", "photo_url": null, "published": true, "us": false, "class_sections": ["清华学生_i5j09fnsl7k5x0"], "facebook_id": null}, {"role": "student", "name": "雷乐其hit1170300203雷乐其", "endorser": {}, "admin": false, "photo": null, "id": "kny98auwe6b4a7", "photo_url": null, "published": true, "us": false, "facebook_id": null}], "unique_views": 172, "children": [{"history_size": 2, "folders": [], "data": {"embed_links": []}, "created": "2016-05-15T14:36:11Z", "bucket_order": 3, "tag_endorse": [{"role": "instructor", "name": "Yu Chen", "endorser": {}, "admin": true, "photo": "1378950179_35.png", "id": "hcrrjuyequh4bt", "photo_url": "https://cdn-uploads.piazza.com/photos/hcrrjuyequh4bt/1378950179_35.png", "us": false, "class_sections": ["课程设计_i5j09fnsl7k5x0", "清华学生_i5j09fnsl7k5x0", "所有老师和助教_i5j09fnsl7k5x0", "os2018spring_i5j09fnsl7k5x0"], "facebook_id": null}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "i0c90j8pjf56sn", "subject": "", "created": "2016-05-15T14:36:36Z", "content": "<p>如果在func_b的wait和signal之间加上</p>\n<pre>if(mtp-&gt;next_count&gt;0)\n         up(&amp;(mtp-&gt;next));\n      else\n         up(&amp;(mtp-&gt;mutex));</pre>\n<p>就不会有这个问题。</p>\n<p></p>\n<p>所以我的理解是&#xff0c;尽管一个进程&#xff08;A&#xff09;signal释放了另一个进程&#xff08;B&#xff09;的资源后&#xff0c;B进程应当在用完后把控制权还给A&#xff08;next_count--&#xff09;&#xff0c;而不是继续使用。</p>\n<p>&#xff08;即使用权的交接以临界区为单位&#xff0c;而不是以进程为单位。&#xff09;</p>\n<p></p>\n<p>这就是之前陈渝老师说的</p>\n<p></p>\n<blockquote>\n<p>这样在他退出时&#xff0c;由于next_count&gt;0&#xff0c;所以会执行signal(mt.next)&#xff0c;</p>\n</blockquote>\n<p></p>\n<p></p>"}, {"anon": "no", "uid": "i0c90j8pjf56sn", "subject": "", "created": "2016-05-15T14:36:11Z", "content": "<p>我的理解是&#xff0c;如果在func_b的wait和signal之间加上</p>\n<pre>if(mtp-&gt;next_count&gt;0)\n         up(&amp;(mtp-&gt;next));\n      else\n         up(&amp;(mtp-&gt;mutex));</pre>\n<p>就不会有这个问题。</p>\n<p></p>\n<p>所以我的理解是尽管一个进程&#xff08;A&#xff09;signal释放了另一个进程&#xff08;B&#xff09;的资源后&#xff0c;B进程应当在用完后把控制权还给A&#xff08;next_count--&#xff09;&#xff0c;而不是继续使用。</p>\n<p>&#xff08;即使用权的交接以临界区为单位&#xff0c;而不是以进程为单位。&#xff09;</p>\n<p></p>\n<p>这就是之前陈渝老师说的</p>\n<p></p>\n<blockquote>\n<p>这样在他退出时&#xff0c;由于next_count&gt;0&#xff0c;所以会执行signal(mt.next)&#xff0c;</p>\n</blockquote>\n<p></p>\n<p></p>"}], "type": "s_answer", "tag_endorse_arr": ["hcrrjuyequh4bt"], "children": [], "id": "io8opqvdtwa6rb", "config": {}, "is_tag_endorse": false}, {"history_size": 3, "folders": [], "data": {"embed_links": []}, "created": "2016-05-18T05:34:04Z", "bucket_order": 3, "tag_endorse": [{"role": "student", "name": "雷乐其hit1170300203雷乐其", "endorser": {}, "admin": false, "photo": null, "id": "kny98auwe6b4a7", "photo_url": null, "published": true, "us": false, "facebook_id": null}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hcrrjuyequh4bt", "subject": "", "created": "2016-05-18T05:34:55Z", "content": "<p>Q: 如果在func_b的wait和signal之间加上</p>\n<pre>if(mtp-&gt;next_count&gt;0)\n         up(&amp;(mtp-&gt;next));\n      else\n         up(&amp;(mtp-&gt;mutex));</pre>\n<p></p>\n<p>我理解,如果加上上述语句&#xff0c;代码就不对了&#xff0c;因为如果执行了&#xff02; up(&amp;(mtp-&gt;mutex));&#xff02;OR&#xff02; up(&amp;(mtp-&gt;next));&#xff02; 则管程中函数应该只被一个进程执行的限制就被打破了&#xff0e;</p>\n<p></p>\n<p>所以&#xff0c;根据你列举的实例&#xff0c;next_count会大于1&#xff0e;　</p>"}, {"anon": "no", "uid": "hcrrjuyequh4bt", "subject": "", "created": "2016-05-18T05:34:44Z", "content": "<p>Q: 如果在func_b的wait和signal之间加上</p>\n<pre>if(mtp-&gt;next_count&gt;0)\n         up(&amp;(mtp-&gt;next));\n      else\n         up(&amp;(mtp-&gt;mutex));</pre>\n<p></p>\n<p>我理解,如果加上上述语句&#xff0c;代码就不对了&#xff0c;因为如果执行了&#xff02; up(&amp;(mtp-&gt;mutex));&#xff02;OR&#xff02; up(&amp;(mtp-&gt;next));&#xff02; 则管程中函数应该只被一个进程执行的限制就被打破了&#xff0e;</p>\n<p></p>\n<p>所以&#xff0c;根据你的列举的实例&#xff0c;next_count会大于1&#xff0e;　</p>"}, {"anon": "no", "uid": "hcrrjuyequh4bt", "subject": "", "created": "2016-05-18T05:34:04Z", "content": "<p>Q: 如果在func_b的wait和signal之间加上</p>\n<pre>if(mtp-&gt;next_count&gt;0)\n         up(&amp;(mtp-&gt;next));\n      else\n         up(&amp;(mtp-&gt;mutex));</pre>\n<p></p>\n<p>我理解,如果加上上述语句&#xff0c;代码就不对了&#xff0c;因为如果执行了&#xff02; up(&amp;(mtp-&gt;mutex));&#xff02;OR&#xff02; up(&amp;(mtp-&gt;next));&#xff02; 则管程中函数应该只被一个进程执行的限制就被打破了&#xff0e;</p>\n<p></p>\n<p>所以&#xff0c;根据你的举例&#xff0c;next_count会大于1&#xff0e;　</p>"}], "type": "i_answer", "tag_endorse_arr": ["kny98auwe6b4a7"], "children": [], "id": "iocfo5dnr1k6xl", "config": {}, "is_tag_endorse": false}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>我的意思是如果以临界区为单位的话&#xff0c;释放之后还要再acquire一次mutex&#xff08;这样应该就可以保证一次只有一个进程了&#xff09;</p>", "created": "2016-05-18T08:12:05Z", "bucket_order": 291, "bucket_name": "Week 5/15 - 5/21", "type": "followup", "tag_good": [], "uid": "i0c90j8pjf56sn", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "ioclbcy3lie60", "updated": "2016-05-18T08:12:05Z", "config": {}}], "tag_good_arr": ["hcrrjuyequh4bt", "i0ccfx63sir1e", "kny98auwe6b4a7"], "no_answer": 0, "id": "io8kp1rw93n5v9", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 7, "num_favorites": 3, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643168658312, "default_anonymity": "no"}, "error": null, "aid": "kyv06z60nxg1l9"}