{"result": {"folders": ["lab1"], "nr": 1147, "data": {"embed_links": []}, "created": "2018-03-09T08:31:43Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "ie7xy761h101s7", "data": "jejomtnv69c5k3", "type": "create", "when": "2018-03-09T08:31:43Z"}, {"anon": "no", "uid": "isu0wqaoff5125", "to": "jejomtnsmuy5k2", "type": "followup", "when": "2018-03-09T08:43:26Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "jejomtnsmuy5k2", "type": "followup", "when": "2018-03-09T15:46:16Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "ie7xy761h101s7", "subject": "关于lab1课件上第31页“gcc内联汇编-Example 2”的解释", "created": "2018-03-09T08:31:43Z", "content": "<p></p><div>\n<div>应向勇老师要求&#xff0c;我整理了课后和老师讨论的结果。</div>\n<br />\n<div>以下是原课件内容&#xff1a;</div>\n<br />\n<div></div>\n<div>看到这个example当时我有一个疑问&#xff0c;就是为什么要有中间的ebx和eax寄存器进行过渡&#xff0c;还要移到栈上进行再进行或操作。</div>\n<br />\n<div>比如为什么不能是这样的&#xff1f;&#xff08;简称“m1”&#xff09;</div>\n<div></div>\n<pre>;m1<br />movl %cr0, 12(%esp)<br />orl $-2147483648, 12(%esp)<br />movl 12(%esp), %cr0</pre>\n</div>\n<div></div>\n<div>或者这样&#xff08;“m2”&#xff09;</div>\n<div></div>\n<div>\n<pre>;m2<br />movl %cr0, %ebx<br />orl $-2147483648, %ebx<br />movl %ebx, %cr0</pre>\n</div>\n<div><br />\n<div>下面我先对每句c代码进行解释&#xff0c;并说明相对应的汇编代码&#xff1a;</div>\n<br />\n<pre>uint32_t cr0; // 无对应汇编&#xff0c;但gcc会给cr0分配存储单元&#xff0c;这里在栈上 -&gt; 12(%esp)<br /><br />asm volatile (&#34;movl %%cr0, %0\\n&#34; :&#34;=r&#34;(cr0));<br />/*<br />movl %cr0, %ebx<br />movl %ebx, 12(%esp)<br />将cr0寄存器内容移动到cr0变量 -&gt; 12(%esp)<br />之所以要两步是<br />1. 因为cr0是控制寄存器&#xff0c;不能和栈&#xff08;内存&#xff09;直接操作&#xff0c;需要寄存器进行过渡&#xff08;解释了m1的错误&#xff09;<br />2. 存到栈上是因为可能后面还需要用到cr0变量&#xff0c;所以把这临时变量分配到了栈上&#xff08;解释了m2&#xff09;<br />3. 同时编译器为了忠实地实现每步内联汇编的内容&#xff0c;不再进一步优化代码<br />*/<br /><br />cr0 |= 0x80000000; // orl $-2147483648, 12(%esp)&#xff0c;即把cr0最前面一位置1<br /><br />asm volatile (&#34;movl %0, %%cr0\\n&#34; ::&#34;r&#34;(cr0));<br />/*<br />movl 12(%esp), %eax<br />movl %eax, %cr0<br />将变量cr0的内容移到cr0寄存器上&#xff0c;需要两步的原因同上<br />*/</pre>\n</div>"}], "type": "note", "tags": ["lab1", "student"], "tag_good": [], "unique_views": 117, "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>对于m1&#xff1a;对于控制寄存器的mov操作不是普通的mov&#xff0c;不支持内存操作数。</p>\n<p></p>\n<p>对于m2&#xff1a;开启编译器优化后&#xff0c;生成的代码和您说的就类似了。</p>", "created": "2018-03-09T08:43:26Z", "bucket_order": 118, "bucket_name": "Week 3/4 - 3/10", "type": "followup", "tag_good": [], "uid": "isu0wqaoff5125", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "jejp1w8i8125jz", "updated": "2018-03-09T08:43:26Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>我点评一下&#xff0c;这里对内联汇编的思考是深入的。这个例子很好地说明了&#xff0c;在操作系统内核中&#xff0c;内联汇编与编译优化和指令的紧密关系。希望有更多的同学能从类似的角度来分析其他的内核代码&#xff0c;应该会很有收获。</p>", "created": "2018-03-09T15:46:16Z", "bucket_order": 118, "bucket_name": "Week 3/4 - 3/10", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "jek45nlem9m7kx", "updated": "2018-03-09T15:46:16Z", "config": {}}], "tag_good_arr": [], "id": "jejomtnsmuy5k2", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 4, "num_favorites": 0, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169235527, "default_anonymity": "no"}, "error": null, "aid": "kyv0jcjrs2e1fg"}