{"result": {"folders": ["lecture15"], "nr": 1461, "data": {"embed_links": []}, "created": "2020-05-06T12:17:31Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "jsjptolvvI0o", "data": "k9vb4b37td2js", "v": "all", "type": "create", "when": "2020-05-06T12:17:31Z"}, {"anon": "no", "uid": "jsjptolvvI0o", "data": "k9vb6lzy2zx405", "type": "update", "when": "2020-05-06T12:19:18Z"}, {"anon": "no", "uid": "jsjptolvvI0o", "data": "k9vbao9n4c92t0", "type": "update", "when": "2020-05-06T12:22:28Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "jsjptolvvI0o", "subject": "2020春-15讲课后习题展示", "created": "2020-05-06T12:22:28Z", "content": "<p><strong>问题&#xff1a;</strong></p>\n<p></p>\n<p>阅读代码和相关文件&#xff0c;理解用pthread实现多线程矢量加法的程序框架和命令行参数。然后分析“vector-deadlock.c”和“main-common.c”中的源代码。最后&#xff0c;分析命令“./vector-deadlock -n 2 -l 1 -v”在多次执行时的输出信息产生变化的原因。</p>\n<p></p>\n<p><strong>参考回答&#xff08;合理即可&#xff09;&#xff1a;</strong></p>\n<p></p>\n<p>屠铭浩 2017013666 https://git.tsinghua.edu.cn/tmh17/os-2020</p>\n<h2>vector-deadlock</h2>\n<blockquote>\n<p>vector-deadlock的处理方法为顺序为dst和src向量申请lock&#xff0c;进行相加后再按顺序解除lock。</p>\n<p>不同线程对于lock的竞争按申请顺序先来后到&#xff0c;因此从图中可以看出&#xff0c;向量加法执行的顺序是不定的。</p>\n<p>并且&#xff0c;这种方法是会出现死锁情况的。当两个线程分别执行<code>vector_add(v1,v2)</code>与<code>vector_add(v2,v1)</code>时&#xff0c;有可能线程1申请到v1的lock&#xff0c;线程2申请到v2的lock&#xff0c;此时就出现了死锁现象。</p>\n<p></p>\n</blockquote>\n<h2><a href=\"#vector-global-order\"></a>vector-global-order</h2>\n<blockquote>\n<p>这种方法给向量申请lock的操作定义了一个顺序&#xff0c;即按照向量的地址排序依次申请lock。这样一来&#xff0c;就避免了vector-deadlock中可能出现的死锁现象。</p>\n</blockquote>\n<h2><a href=\"#vector-try-wait\"></a>vector-try-wait</h2>\n<blockquote>\n<p>这种方法在申请lock的时候使用<code>pthread_mutex_trylock()</code>进行尝试&#xff0c;如果失败则放弃已有的lock&#xff0c;返回到最顶部重新进行尝试。以此保证能同时获得两个向量的lock。</p>\n<p>在少数情况下&#xff0c;有可能出现多次重新尝试的情况。</p>\n</blockquote>\n<h2><a href=\"#vector-avoid-hold-and-wait\"></a>vector-avoid-hold-and-wait</h2>\n<blockquote>\n<p>这种方法设置了一个叫<code>global</code>的lock&#xff0c;用于管理申请向量lock操作。当线程要获取向量的lock时&#xff0c;首先要获取<code>global</code>的lock&#xff0c;这保证了线程在申请向量的lock时可以一次性申请完所有向量的lock&#xff0c;而不受影响。</p>\n<p>但是在向量较多的时候&#xff0c;这种方法不允许不同线程同时申请不相关向量的lock&#xff0c;对于效率有一定的影响。</p>\n</blockquote>\n<h2><a href=\"#vector-nolock\"></a>vector-nolock</h2>\n<blockquote>\n<p>这种方法没有用到lock&#xff0c;而是调用了原子操作<code>fetch-and-add</code>来解决同步问题。</p>\n<p>但是这种方法是依次对向量的每一维进行原子的加法&#xff0c;因此并没有解决同步问题。只有当向量的维度为1时&#xff0c;是可靠的。</p>\n</blockquote>\n<p dir=\"ltr\"></p>\n<p dir=\"ltr\">章家维 https://git.tsinghua.edu.cn/jiawei-z17/dead_lock</p>\n<p dir=\"ltr\"></p>\n<p dir=\"ltr\">分析<code>vector-deadlock.c</code>的内容。 这一文件中&#xff0c;<code>vector_add</code>函数的主要行为&#xff1a;先申请目的向量的锁&#xff0c;成功后则继续申请源向量的锁&#xff0c;然后执行加法。现若某个线程执行<code>vector_add(v1,v2)</code>&#xff0c;另一线程同时执行<code>vector_add(v2,v1)</code>&#xff0c;则前者先获取<code>v1</code>的锁&#xff0c;同时后者获取<code>v2</code>的锁。接着前者试图获取<code>v2</code>的锁&#xff0c;发现其被占用&#xff0c;于是进入阻塞&#xff0c;然而不释放<code>v1</code>的锁资源。同理后者也进入阻塞&#xff0c;同样不释放<code>v2</code>的锁资源。这样就出现相互等待的状况&#xff0c;进入死锁。</p>"}, {"anon": "no", "uid": "jsjptolvvI0o", "subject": "2020春-15讲课后习题展示", "created": "2020-05-06T12:19:18Z", "content": "<p><strong>问题&#xff1a;</strong></p>\n<p></p>\n<p>阅读压缩包中的“README”文件和相关源代码文件&#xff0c;理解用pthread实现多线程矢量加法的程序框架和命令行参数。然后分析“vector-deadlock.c”和“main-common.c”中的源代码。最后&#xff0c;分析命令“./vector-deadlock -n 2 -l 1 -v”在多次执行时的输出信息产生变化的原因。</p>\n<p></p>\n<p><strong>参考回答&#xff08;合理即可&#xff09;&#xff1a;</strong></p>\n<p></p>\n<p>屠铭浩 2017013666 https://git.tsinghua.edu.cn/tmh17/os-2020</p>\n<h2>vector-deadlock</h2>\n<blockquote>\n<p>vector-deadlock的处理方法为顺序为dst和src向量申请lock&#xff0c;进行相加后再按顺序解除lock。</p>\n<p>不同线程对于lock的竞争按申请顺序先来后到&#xff0c;因此从图中可以看出&#xff0c;向量加法执行的顺序是不定的。</p>\n<p>并且&#xff0c;这种方法是会出现死锁情况的。当两个线程分别执行<code>vector_add(v1,v2)</code>与<code>vector_add(v2,v1)</code>时&#xff0c;有可能线程1申请到v1的lock&#xff0c;线程2申请到v2的lock&#xff0c;此时就出现了死锁现象。</p>\n<p></p>\n</blockquote>\n<h2><a href=\"#vector-global-order\"></a>vector-global-order</h2>\n<blockquote>\n<p>这种方法给向量申请lock的操作定义了一个顺序&#xff0c;即按照向量的地址排序依次申请lock。这样一来&#xff0c;就避免了vector-deadlock中可能出现的死锁现象。</p>\n</blockquote>\n<h2><a href=\"#vector-try-wait\"></a>vector-try-wait</h2>\n<blockquote>\n<p>这种方法在申请lock的时候使用<code>pthread_mutex_trylock()</code>进行尝试&#xff0c;如果失败则放弃已有的lock&#xff0c;返回到最顶部重新进行尝试。以此保证能同时获得两个向量的lock。</p>\n<p>在少数情况下&#xff0c;有可能出现多次重新尝试的情况。</p>\n</blockquote>\n<h2><a href=\"#vector-avoid-hold-and-wait\"></a>vector-avoid-hold-and-wait</h2>\n<blockquote>\n<p>这种方法设置了一个叫<code>global</code>的lock&#xff0c;用于管理申请向量lock操作。当线程要获取向量的lock时&#xff0c;首先要获取<code>global</code>的lock&#xff0c;这保证了线程在申请向量的lock时可以一次性申请完所有向量的lock&#xff0c;而不受影响。</p>\n<p>但是在向量较多的时候&#xff0c;这种方法不允许不同线程同时申请不相关向量的lock&#xff0c;对于效率有一定的影响。</p>\n</blockquote>\n<h2><a href=\"#vector-nolock\"></a>vector-nolock</h2>\n<blockquote>\n<p>这种方法没有用到lock&#xff0c;而是调用了原子操作<code>fetch-and-add</code>来解决同步问题。</p>\n<p>但是这种方法是依次对向量的每一维进行原子的加法&#xff0c;因此并没有解决同步问题。只有当向量的维度为1时&#xff0c;是可靠的。</p>\n</blockquote>\n<p dir=\"ltr\"></p>\n<p dir=\"ltr\">章家维 https://git.tsinghua.edu.cn/jiawei-z17/dead_lock</p>\n<p dir=\"ltr\"></p>\n<p dir=\"ltr\">分析<code>vector-deadlock.c</code>的内容。 这一文件中&#xff0c;<code>vector_add</code>函数的主要行为&#xff1a;先申请目的向量的锁&#xff0c;成功后则继续申请源向量的锁&#xff0c;然后执行加法。现若某个线程执行<code>vector_add(v1,v2)</code>&#xff0c;另一线程同时执行<code>vector_add(v2,v1)</code>&#xff0c;则前者先获取<code>v1</code>的锁&#xff0c;同时后者获取<code>v2</code>的锁。接着前者试图获取<code>v2</code>的锁&#xff0c;发现其被占用&#xff0c;于是进入阻塞&#xff0c;然而不释放<code>v1</code>的锁资源。同理后者也进入阻塞&#xff0c;同样不释放<code>v2</code>的锁资源。这样就出现相互等待的状况&#xff0c;进入死锁。</p>"}, {"anon": "no", "uid": "jsjptolvvI0o", "subject": "2020春-15讲课后习题展示", "created": "2020-05-06T12:17:31Z", "content": "<p>问题&#xff1a;</p>\n<p></p>\n<p>阅读压缩包中的“README”文件和相关源代码文件&#xff0c;理解用pthread实现多线程矢量加法的程序框架和命令行参数。然后分析“vector-deadlock.c”和“main-common.c”中的源代码。最后&#xff0c;分析命令“./vector-deadlock -n 2 -l 1 -v”在多次执行时的输出信息产生变化的原因。</p>\n<p></p>\n<p>参考回答&#xff08;合理即可&#xff09;&#xff1a;</p>\n<p></p>\n<p>屠铭浩 2017013666 https://git.tsinghua.edu.cn/tmh17/os-2020</p>\n<h2>vector-deadlock</h2>\n<blockquote>\n<p>vector-deadlock的处理方法为顺序为dst和src向量申请lock&#xff0c;进行相加后再按顺序解除lock。</p>\n<p>不同线程对于lock的竞争按申请顺序先来后到&#xff0c;因此从图中可以看出&#xff0c;向量加法执行的顺序是不定的。</p>\n<p>并且&#xff0c;这种方法是会出现死锁情况的。当两个线程分别执行<code>vector_add(v1,v2)</code>与<code>vector_add(v2,v1)</code>时&#xff0c;有可能线程1申请到v1的lock&#xff0c;线程2申请到v2的lock&#xff0c;此时就出现了死锁现象。</p>\n<p></p>\n</blockquote>\n<h2><a href=\"#vector-global-order\"></a>vector-global-order</h2>\n<blockquote>\n<p>这种方法给向量申请lock的操作定义了一个顺序&#xff0c;即按照向量的地址排序依次申请lock。这样一来&#xff0c;就避免了vector-deadlock中可能出现的死锁现象。</p>\n</blockquote>\n<h2><a href=\"#vector-try-wait\"></a>vector-try-wait</h2>\n<blockquote>\n<p>这种方法在申请lock的时候使用<code>pthread_mutex_trylock()</code>进行尝试&#xff0c;如果失败则放弃已有的lock&#xff0c;返回到最顶部重新进行尝试。以此保证能同时获得两个向量的lock。</p>\n<p>在少数情况下&#xff0c;有可能出现多次重新尝试的情况。</p>\n</blockquote>\n<h2><a href=\"#vector-avoid-hold-and-wait\"></a>vector-avoid-hold-and-wait</h2>\n<blockquote>\n<p>这种方法设置了一个叫<code>global</code>的lock&#xff0c;用于管理申请向量lock操作。当线程要获取向量的lock时&#xff0c;首先要获取<code>global</code>的lock&#xff0c;这保证了线程在申请向量的lock时可以一次性申请完所有向量的lock&#xff0c;而不受影响。</p>\n<p>但是在向量较多的时候&#xff0c;这种方法不允许不同线程同时申请不相关向量的lock&#xff0c;对于效率有一定的影响。</p>\n</blockquote>\n<h2><a href=\"#vector-nolock\"></a>vector-nolock</h2>\n<blockquote>\n<p>这种方法没有用到lock&#xff0c;而是调用了原子操作<code>fetch-and-add</code>来解决同步问题。</p>\n<p>但是这种方法是依次对向量的每一维进行原子的加法&#xff0c;因此并没有解决同步问题。只有当向量的维度为1时&#xff0c;是可靠的。</p>\n</blockquote>\n<p dir=\"ltr\"></p>\n<p dir=\"ltr\">章家维 https://git.tsinghua.edu.cn/jiawei-z17/dead_lock</p>\n<p dir=\"ltr\"></p>\n<p dir=\"ltr\">分析<code>vector-deadlock.c</code>的内容。 这一文件中&#xff0c;<code>vector_add</code>函数的主要行为&#xff1a;先申请目的向量的锁&#xff0c;成功后则继续申请源向量的锁&#xff0c;然后执行加法。现若某个线程执行<code>vector_add(v1,v2)</code>&#xff0c;另一线程同时执行<code>vector_add(v2,v1)</code>&#xff0c;则前者先获取<code>v1</code>的锁&#xff0c;同时后者获取<code>v2</code>的锁。接着前者试图获取<code>v2</code>的锁&#xff0c;发现其被占用&#xff0c;于是进入阻塞&#xff0c;然而不释放<code>v1</code>的锁资源。同理后者也进入阻塞&#xff0c;同样不释放<code>v2</code>的锁资源。这样就出现相互等待的状况&#xff0c;进入死锁。</p>"}], "type": "note", "tags": ["lecture15", "student"], "tag_good": [], "unique_views": 121, "children": [], "tag_good_arr": [], "id": "k9vb4b35ebk2jr", "config": {"seen": {"894": 3, "1202": 9, "469": 7, "305": 2, "50": 6, "182": 4, "1030": 1, "1308": 0, "64": 8, "97": 5}}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 1, "num_favorites": 0, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643170112181, "default_anonymity": "no"}, "error": null, "aid": "kyv124z98mc2b0"}