{"result": {"folders": ["lecture12", "课堂问答"], "nr": 1305, "data": {"embed_links": []}, "created": "2019-04-14T14:45:01Z", "bucket_order": 3, "no_answer_followup": 1, "change_log": [{"anon": "no", "uid": "jslzojqyo841dn", "data": "juh1jh2d2do3h2", "type": "create", "when": "2019-04-14T14:45:01Z"}, {"anon": "no", "uid": "ju69lug52OdQ", "to": "juh1jh2bhl3h1", "type": "followup", "when": "2019-04-28T09:09:52Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "jslzojqyo841dn", "subject": "关于lec12中fork()演示代码运行结果的问题", "created": "2019-04-14T14:45:01Z", "content": "<p></p><p><strong>问题描述</strong>&#xff1a;lec12中&#xff0c;有一段关于fork()的演示代码&#xff0c;但是在运行过程中我发现&#xff0c;printf的结果和课件上的不一致。主要现象是&#xff0c;如果是在shell中直接运行&#xff0c;那么输出结果和课件上的是相同的&#xff0c;但是如果把输出结果重定向到文件中则会多输出一些重复的信息。具体代码与现象如下</p>\n<p>测试代码&#xff08;和课件上略有不同&#xff0c;但效果相似&#xff09;</p>\n<pre>  #include &lt;stdio.h&gt;<br />  #include &lt;unistd.h&gt;<br />  ​<br />  void printInfo(int pid) {<br />      if (pid == 0) {<br />          printf(&#34;I am the son! My pid is %d\\n&#34;, getpid());<br />      } else if (pid &gt; 0) {<br />          printf(&#34;I am the father! My pid is %d\\t&#34;, getpid());<br />          printf(&#34;My son&#39;s pid is %d\\n&#34;, pid);<br />  ​<br />      } else {<br />          printf(&#34;ERROR !\\n&#34;);<br />      }<br />  }<br />  ​<br />  const int LOOP = 2;<br />  ​<br />  int main () {<br />      // FILE *ft = freopen(&#34;out.txt&#34;,&#34;w&#34;,stdout);   // 重定向<br />      // setvbuf(ft, NULL, _IOLBF, 0);               // 修改缓冲策略<br />  ​<br />      int i;<br />      for (i = 0; i &lt; LOOP; i&#43;&#43;) {<br />          int pid = fork();<br />          if (pid &lt; 0) return 1;<br />          printInfo(pid);<br />      }<br />      return 0;<br />  }</pre>\n<p>在shell中运行的现象</p>\n<p><img src=\"/img/1305-cc3e408b472838c0.png\" alt=\"\" /></p>\n<p>重定向到文件out.txt后现象为</p>\n<p><img src=\"/img/1305-227222318c6dda16.png\" alt=\"\" /></p>\n<p>可以看到&#xff0c;out.txt中输出信息相比stdout要多出两行。</p>\n<p></p>\n<p><strong>问题结论</strong>&#xff1a;经过与老师、助教、同学们的讨论&#xff0c;得出的结论是因为缓冲区的问题&#xff0c;printf调用后会先把要打印的字符串放到缓冲区中&#xff0c;等到某一时刻统一进行刷新。在stdout中printf是默认采用的行缓冲策略&#xff0c;因此遇到换行符号时就会刷新缓冲区&#xff0c;但是重定向到文件中后默认采用全缓冲&#xff0c;调用fork()后子进程时会把父进程缓冲区的内容进行复制&#xff0c;子进程打印时就会把缓冲区的内容都打印出来&#xff0c;而有些内容是从父进程中拷贝过来的&#xff0c;因此会产生上述问题。</p>\n<p>如果使用setvbuf修改缓冲策略也可以解决上述问题。</p>"}], "type": "note", "tags": ["lecture12", "student", "课堂问答"], "tag_good": [], "unique_views": 99, "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p></p><pre>按照老师上课所讲&#xff0c;当进程3822执行完成时&#xff0c;就绪队列顺序应是3823-&gt;3824,此时3823开始执行fork()生成3825&#xff0c;此时就绪队列应是3824-&gt;3825&#xff0c;然后依次打印他俩才对&#xff0c;理论上结果应该是下面的情况才对&#xff0c;跟上述结果不一致&#xff0c;请问各位老师同学们是我哪里出错了吗&#xff1f;<br />I am the father! My pid is 3822 My son&#39;s pid is 3823<br />I am the father! My pid is 3822 My son&#39;s pid is 3824<br />I am the son! My pid is 3823<br />I am the father! My pid is 3823 My son&#39;s pid is 3825<br />I am the son! My pid is 3824<br />I am the son! My pid is 3825</pre>", "created": "2019-04-28T09:09:52Z", "bucket_order": 51, "bucket_name": "Week 4/28 - 5/4", "type": "followup", "tag_good": [], "uid": "ju69lug52OdQ", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "jv0pqeq2kao2fa", "updated": "2019-04-28T09:09:52Z", "config": {}}], "tag_good_arr": [], "id": "juh1jh2bhl3h1", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 2, "num_favorites": 1, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169705684, "default_anonymity": "no"}, "error": null, "aid": "kyv0tfbolzi3m6"}