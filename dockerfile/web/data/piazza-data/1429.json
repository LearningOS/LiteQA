{"result": {"folders": ["lecture8"], "nr": 1429, "data": {"embed_links": []}, "created": "2020-03-18T15:55:29Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "je2ib27z6a7691", "data": "k7xibw3z20y1ft", "type": "create", "when": "2020-03-18T15:55:30Z"}, {"anon": "no", "uid": "je2ib27z6a7691", "data": "k7xifoj5ral1ic", "type": "update", "when": "2020-03-18T15:58:26Z"}, {"anon": "no", "uid": "je2ib27z6a7691", "data": "k7xihvf460233y", "type": "update", "when": "2020-03-18T16:00:09Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "je2ib27z6a7691", "subject": "第八讲课后练习参考解答", "created": "2020-03-18T16:00:09Z", "content": "<md>## 题目描述\n\n确定选择一种页面置换算法&#xff08;0&#xff1a;工作集页置换算法&#xff0c;1&#xff1a;缺页率置换算法&#xff0c;2&#xff1a;LRU-K&#xff09;中的一种来设计一个应用程序&#xff08;可基于rust, python, ruby, C, C&#43;&#43;&#xff0c;LISP等&#xff09;模拟实现&#xff0c;并给出测试用例和测试结果。请参考如下python代码或独自实现。\n\n* [页置换算法实现的参考实例](https://github.com/chyyuu/ucore_os_lab/blob/master/related_info/lab3/page-replacement-policy.py)\n\n## 工作集置换算法\n\n&gt; 2017011428\n&gt; https://git.tsinghua.edu.cn/jiaor17/os-homework/tree/master/%E7%AC%AC%E5%85%AB%E8%AE%B2%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A\n\n### 核心代码\n\n&#96;&#96;&#96;\nfor nStr in addrList:\n    # first, lookup\n    n = int(nStr)\n    if policy == &#39;WS&#39;:\n        try:\n            idx = memory.index(n)\n            hits = hits &#43; 1\n        except:\n            idx = -1\n            miss = miss &#43; 1\n        memory.append(n)\n        victim = -1\n        if len(memory)&gt;windowsize:\n            victim = memory.pop(0)\n            if victim in memory:\n                victim = -1\n        if notrace == False:\n            print &#39;Access: %d  %s %s -&gt; %12s &lt;- %s  Working Set: %12s Replaced:%s [Hits:%d Misses:%d]&#39; % (n, hfunc(idx), leftStr, memory, riteStr,list(set(memory)), vfunc(victim), hits, miss)\n&#96;&#96;&#96;\n\n### 测试结果\n\n使用课件中的测例 &#96;3,3,4,2,3,5,3,5,1,4&#96;&#xff1a;\n\n&#96;&#96;&#96;\npython2 .\\hw8.py -a 3,3,4,2,3,5,3,5,1,4 -c -w 4 -p WS -i 5,4,1\n\nARG addresses 3,3,4,2,3,5,3,5,1,4\nARG initlist 5,4,1\nARG policy WS\nARG clockbits 1\nARG pageframesize 3\nARG windowsize 4\nARG seed 0\nARG notrace False\n\nSolving...\n\nAccess: 3  MISS Left  -&gt; [5, 4, 1, 3] &lt;- Right  Working Set: [1, 3, 4, 5] Replaced:- [Hits:0 Misses:1]\nAccess: 3  HIT  Left  -&gt; [4, 1, 3, 3] &lt;- Right  Working Set:    [1, 3, 4] Replaced:5 [Hits:1 Misses:1]\nAccess: 4  HIT  Left  -&gt; [1, 3, 3, 4] &lt;- Right  Working Set:    [1, 3, 4] Replaced:- [Hits:2 Misses:1]\nAccess: 2  MISS Left  -&gt; [3, 3, 4, 2] &lt;- Right  Working Set:    [2, 3, 4] Replaced:1 [Hits:2 Misses:2]\nAccess: 3  HIT  Left  -&gt; [3, 4, 2, 3] &lt;- Right  Working Set:    [2, 3, 4] Replaced:- [Hits:3 Misses:2]\nAccess: 5  MISS Left  -&gt; [4, 2, 3, 5] &lt;- Right  Working Set: [2, 3, 4, 5] Replaced:- [Hits:3 Misses:3]\nAccess: 3  HIT  Left  -&gt; [2, 3, 5, 3] &lt;- Right  Working Set:    [2, 3, 5] Replaced:4 [Hits:4 Misses:3]\nAccess: 5  HIT  Left  -&gt; [3, 5, 3, 5] &lt;- Right  Working Set:       [3, 5] Replaced:2 [Hits:5 Misses:3]\nAccess: 1  MISS Left  -&gt; [5, 3, 5, 1] &lt;- Right  Working Set:    [1, 3, 5] Replaced:- [Hits:5 Misses:4]\nAccess: 4  MISS Left  -&gt; [3, 5, 1, 4] &lt;- Right  Working Set: [1, 3, 4, 5] Replaced:- [Hits:5 Misses:5]\n\nFINALSTATS hits 5   misses 5   hitrate 50.00\n&#96;&#96;&#96;\n\n## 缺页率置换算法\n\n&gt; 2017011456\n&gt; https://git.tsinghua.edu.cn/chang-li17/os_homework\n\n### 实现过程\n\n1. 给定一个缺页时间差的窗口 $\\Delta T$\n2. 访存命中时&#xff0c;将访问的页号加入被访问过页面的一个记录表中\n3. 缺页时&#xff0c;如果本次缺页距离上一次缺页的时间差大于 $\\Delta T$&#xff0c;则遍历所有存储空间中的页面。如果页面在上一次缺页到这一次缺页时未被访问过&#xff0c;则从存储空间中删去\n4. 缺页时&#xff0c;如果本次缺页距离上一次缺页的时间差不大于 $\\Delta T$&#xff0c;则只需要把此页面加入页表&#xff0c;并且把该页号存入记录表中\n5. 考虑边界情况。如果存储空间已被占满且需要加入页面&#xff0c;那么退化成FIFO算法&#xff0c;把最早进入的那个页面置换成新的页面\n\n### 核心代码\n\n&#96;&#96;&#96;\nfor nStr in addrList:\n    # first, lookup\n    n = int(nStr)\n    try:\n        idx = memory.index(n)\n        hits = hits &#43; 1\n        if policy == &#39;LRU&#39; :\n            update = memory.remove(n)\n            memory.append(n) # puts it on MRU side\n        elif policy == &#39;PFR&#39; :\n            faulttime = faulttime &#43; 1\n            visit[idx] = True\n    except:\n        idx = -1\n        miss = miss &#43; 1\n\n    victim = -1        \n    if idx == -1:\n        # 缺页率置换算法&#xff0c;发生在缺页时。算法流程&#xff1a;\n        # 如果未发生缺页&#xff0c;缺页间隔&#43;1&#xff1b;\n        # 如果发生缺页&#xff0c;记录缺页间隔。如果缺页间隔大于等于设定的窗口值&#xff0c;删去当前页表中所有未访问的页面\n        # 特别的&#xff0c;如果页面满了还得插入&#xff0c;则强制弹出地址最低的一个页\n        if policy == &#39;PFR&#39;:\n            del_time = 0\n            if cdebug2:\n                print faulttime\n                assert(faulttime &gt; 0)\n            if faulttime &gt; deltatime:\n                for i in range(0,len(memory)):\n                    # 该页面没被访问过&#xff0c;删去\n                    if not visit[i]:    \n                        if cdebug2:\n                            print memory[i - del_time], &#34;没被访问&#34;\n                        memory.pop(i - del_time)\n                        del_time = del_time &#43; 1\n                        \n            # 重置缺页间隔\n            faulttime = 1\n            # 重置访问记录\n            visit = []\n            for i in range(0,len(memory)):\n                visit.append(False)\n            if cdebug2:\n                print memory\n\n        # miss, replace?\n        # print &#39;BUG count, pageframesize:&#39;, count, pageframesize\n        if count == pageframesize:\n            # must replace, 特别地&#xff0c;对于缺页率置换算法&#xff0c;如果满了也强制换掉第一个界面\n            if policy == &#34;PFR&#34;:\n                if len(memory) == pageframesize:\n                    victim = memory.pop(0)\n                    visit.pop(0)\n        else:\n            # miss, but no replacement needed (page frame not full)\n            victim = -1\n            count = count &#43; 1\n\n        # now add to memory\n        memory.append(n)\n        \n        # 对于缺页率置换算法&#xff0c;需要把新加入的页面设为已访问页面\n        if policy == &#39;PFR&#39;:\n            visit.append(True)\n        if cdebug:\n            print &#39;LEN (a)&#39;, len(memory)\n        if victim != -1:\n            assert(victim not in memory)\n\n    if notrace == False:\n        print &#39;Access: %d  %s %s -&gt; %12s &lt;- %s Replaced:%s [Hits:%d Misses:%d]&#39; % (n, hfunc(idx), leftStr, memory, riteStr, vfunc(victim), hits, miss)\n&#96;&#96;&#96;\n\n### 测试结果\n\n使用课件中的测例 &#96;1, 4, 5, 3, 3, 4, 2, 3, 5, 3, 5, 1, 4&#96;&#xff1a;\n\n&#96;&#96;&#96;\npython page-replacement-policy.py -a 1,4,5,3,3,4,2,3,5,3,5,1,4 -p PFR -T 2 -f 4 -c\n\nARG addresses 1,4,5,3,3,4,2,3,5,3,5,1,4\nARG policy PFR\nARG clockbits 1\nARG deltatime 2\nARG pageframesize 4\nARG seed 0\nARG notrace False\n\nSolving...\n\nAccess: 1  MISS Left  -&gt;          [1] &lt;- Right Replaced:- [Hits:0 Misses:1]\nAccess: 4  MISS Left  -&gt;       [1, 4] &lt;- Right Replaced:- [Hits:0 Misses:2]\nAccess: 5  MISS Left  -&gt;    [1, 4, 5] &lt;- Right Replaced:- [Hits:0 Misses:3]\nAccess: 3  MISS Left  -&gt; [1, 4, 5, 3] &lt;- Right Replaced:- [Hits:0 Misses:4]\nAccess: 3  HIT  Left  -&gt; [1, 4, 5, 3] &lt;- Right Replaced:- [Hits:1 Misses:4]\nAccess: 4  HIT  Left  -&gt; [1, 4, 5, 3] &lt;- Right Replaced:- [Hits:2 Misses:4]\nAccess: 2  MISS Left  -&gt;    [4, 3, 2] &lt;- Right Replaced:- [Hits:2 Misses:5]\nAccess: 3  HIT  Left  -&gt;    [4, 3, 2] &lt;- Right Replaced:- [Hits:3 Misses:5]\nAccess: 5  MISS Left  -&gt; [4, 3, 2, 5] &lt;- Right Replaced:- [Hits:3 Misses:6]\nAccess: 3  HIT  Left  -&gt; [4, 3, 2, 5] &lt;- Right Replaced:- [Hits:4 Misses:6]\nAccess: 5  HIT  Left  -&gt; [4, 3, 2, 5] &lt;- Right Replaced:- [Hits:5 Misses:6]\nAccess: 1  MISS Left  -&gt;    [3, 5, 1] &lt;- Right Replaced:- [Hits:5 Misses:7]\nAccess: 4  MISS Left  -&gt; [3, 5, 1, 4] &lt;- Right Replaced:- [Hits:5 Misses:8]\n\nFINALSTATS hits 5   misses 8   hitrate 38.46\n&#96;&#96;&#96;</md>"}, {"anon": "no", "uid": "je2ib27z6a7691", "subject": "第八讲课后练习参考解答", "created": "2020-03-18T15:58:26Z", "content": "<md>## 工作集置换算法\n\n&gt; 2017011428\n&gt; https://git.tsinghua.edu.cn/jiaor17/os-homework/tree/master/%E7%AC%AC%E5%85%AB%E8%AE%B2%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A\n\n### 核心代码\n\n&#96;&#96;&#96;\nfor nStr in addrList:\n    # first, lookup\n    n = int(nStr)\n    if policy == &#39;WS&#39;:\n        try:\n            idx = memory.index(n)\n            hits = hits &#43; 1\n        except:\n            idx = -1\n            miss = miss &#43; 1\n        memory.append(n)\n        victim = -1\n        if len(memory)&gt;windowsize:\n            victim = memory.pop(0)\n            if victim in memory:\n                victim = -1\n        if notrace == False:\n            print &#39;Access: %d  %s %s -&gt; %12s &lt;- %s  Working Set: %12s Replaced:%s [Hits:%d Misses:%d]&#39; % (n, hfunc(idx), leftStr, memory, riteStr,list(set(memory)), vfunc(victim), hits, miss)\n&#96;&#96;&#96;\n\n### 测试结果\n\n使用课件中的测例 &#96;3,3,4,2,3,5,3,5,1,4&#96;&#xff1a;\n\n&#96;&#96;&#96;\npython2 .\\hw8.py -a 3,3,4,2,3,5,3,5,1,4 -c -w 4 -p WS -i 5,4,1\n\nARG addresses 3,3,4,2,3,5,3,5,1,4\nARG initlist 5,4,1\nARG policy WS\nARG clockbits 1\nARG pageframesize 3\nARG windowsize 4\nARG seed 0\nARG notrace False\n\nSolving...\n\nAccess: 3  MISS Left  -&gt; [5, 4, 1, 3] &lt;- Right  Working Set: [1, 3, 4, 5] Replaced:- [Hits:0 Misses:1]\nAccess: 3  HIT  Left  -&gt; [4, 1, 3, 3] &lt;- Right  Working Set:    [1, 3, 4] Replaced:5 [Hits:1 Misses:1]\nAccess: 4  HIT  Left  -&gt; [1, 3, 3, 4] &lt;- Right  Working Set:    [1, 3, 4] Replaced:- [Hits:2 Misses:1]\nAccess: 2  MISS Left  -&gt; [3, 3, 4, 2] &lt;- Right  Working Set:    [2, 3, 4] Replaced:1 [Hits:2 Misses:2]\nAccess: 3  HIT  Left  -&gt; [3, 4, 2, 3] &lt;- Right  Working Set:    [2, 3, 4] Replaced:- [Hits:3 Misses:2]\nAccess: 5  MISS Left  -&gt; [4, 2, 3, 5] &lt;- Right  Working Set: [2, 3, 4, 5] Replaced:- [Hits:3 Misses:3]\nAccess: 3  HIT  Left  -&gt; [2, 3, 5, 3] &lt;- Right  Working Set:    [2, 3, 5] Replaced:4 [Hits:4 Misses:3]\nAccess: 5  HIT  Left  -&gt; [3, 5, 3, 5] &lt;- Right  Working Set:       [3, 5] Replaced:2 [Hits:5 Misses:3]\nAccess: 1  MISS Left  -&gt; [5, 3, 5, 1] &lt;- Right  Working Set:    [1, 3, 5] Replaced:- [Hits:5 Misses:4]\nAccess: 4  MISS Left  -&gt; [3, 5, 1, 4] &lt;- Right  Working Set: [1, 3, 4, 5] Replaced:- [Hits:5 Misses:5]\n\nFINALSTATS hits 5   misses 5   hitrate 50.00\n&#96;&#96;&#96;\n\n## 缺页率置换算法\n\n&gt; 2017011456\n&gt; https://git.tsinghua.edu.cn/chang-li17/os_homework\n\n### 实现过程\n\n1. 给定一个缺页时间差的窗口 $\\Delta T$\n2. 访存命中时&#xff0c;将访问的页号加入被访问过页面的一个记录表中\n3. 缺页时&#xff0c;如果本次缺页距离上一次缺页的时间差大于 $\\Delta T$&#xff0c;则遍历所有存储空间中的页面。如果页面在上一次缺页到这一次缺页时未被访问过&#xff0c;则从存储空间中删去\n4. 缺页时&#xff0c;如果本次缺页距离上一次缺页的时间差不大于 $\\Delta T$&#xff0c;则只需要把此页面加入页表&#xff0c;并且把该页号存入记录表中\n5. 考虑边界情况。如果存储空间已被占满且需要加入页面&#xff0c;那么退化成FIFO算法&#xff0c;把最早进入的那个页面置换成新的页面\n\n### 核心代码\n\n&#96;&#96;&#96;\nfor nStr in addrList:\n    # first, lookup\n    n = int(nStr)\n    try:\n        idx = memory.index(n)\n        hits = hits &#43; 1\n        if policy == &#39;LRU&#39; :\n            update = memory.remove(n)\n            memory.append(n) # puts it on MRU side\n        elif policy == &#39;PFR&#39; :\n            faulttime = faulttime &#43; 1\n            visit[idx] = True\n    except:\n        idx = -1\n        miss = miss &#43; 1\n\n    victim = -1        \n    if idx == -1:\n        # 缺页率置换算法&#xff0c;发生在缺页时。算法流程&#xff1a;\n        # 如果未发生缺页&#xff0c;缺页间隔&#43;1&#xff1b;\n        # 如果发生缺页&#xff0c;记录缺页间隔。如果缺页间隔大于等于设定的窗口值&#xff0c;删去当前页表中所有未访问的页面\n        # 特别的&#xff0c;如果页面满了还得插入&#xff0c;则强制弹出地址最低的一个页\n        if policy == &#39;PFR&#39;:\n            del_time = 0\n            if cdebug2:\n                print faulttime\n                assert(faulttime &gt; 0)\n            if faulttime &gt; deltatime:\n                for i in range(0,len(memory)):\n                    # 该页面没被访问过&#xff0c;删去\n                    if not visit[i]:    \n                        if cdebug2:\n                            print memory[i - del_time], &#34;没被访问&#34;\n                        memory.pop(i - del_time)\n                        del_time = del_time &#43; 1\n                        \n            # 重置缺页间隔\n            faulttime = 1\n            # 重置访问记录\n            visit = []\n            for i in range(0,len(memory)):\n                visit.append(False)\n            if cdebug2:\n                print memory\n\n        # miss, replace?\n        # print &#39;BUG count, pageframesize:&#39;, count, pageframesize\n        if count == pageframesize:\n            # must replace, 特别地&#xff0c;对于缺页率置换算法&#xff0c;如果满了也强制换掉第一个界面\n            if policy == &#34;PFR&#34;:\n                if len(memory) == pageframesize:\n                    victim = memory.pop(0)\n                    visit.pop(0)\n        else:\n            # miss, but no replacement needed (page frame not full)\n            victim = -1\n            count = count &#43; 1\n\n        # now add to memory\n        memory.append(n)\n        \n        # 对于缺页率置换算法&#xff0c;需要把新加入的页面设为已访问页面\n        if policy == &#39;PFR&#39;:\n            visit.append(True)\n        if cdebug:\n            print &#39;LEN (a)&#39;, len(memory)\n        if victim != -1:\n            assert(victim not in memory)\n\n    if notrace == False:\n        print &#39;Access: %d  %s %s -&gt; %12s &lt;- %s Replaced:%s [Hits:%d Misses:%d]&#39; % (n, hfunc(idx), leftStr, memory, riteStr, vfunc(victim), hits, miss)\n&#96;&#96;&#96;\n\n### 测试结果\n\n使用课件中的测例 &#96;1, 4, 5, 3, 3, 4, 2, 3, 5, 3, 5, 1, 4&#96;&#xff1a;\n\n&#96;&#96;&#96;\npython page-replacement-policy.py -a 1,4,5,3,3,4,2,3,5,3,5,1,4 -p PFR -T 2 -f 4 -c\n\nARG addresses 1,4,5,3,3,4,2,3,5,3,5,1,4\nARG policy PFR\nARG clockbits 1\nARG deltatime 2\nARG pageframesize 4\nARG seed 0\nARG notrace False\n\nSolving...\n\nAccess: 1  MISS Left  -&gt;          [1] &lt;- Right Replaced:- [Hits:0 Misses:1]\nAccess: 4  MISS Left  -&gt;       [1, 4] &lt;- Right Replaced:- [Hits:0 Misses:2]\nAccess: 5  MISS Left  -&gt;    [1, 4, 5] &lt;- Right Replaced:- [Hits:0 Misses:3]\nAccess: 3  MISS Left  -&gt; [1, 4, 5, 3] &lt;- Right Replaced:- [Hits:0 Misses:4]\nAccess: 3  HIT  Left  -&gt; [1, 4, 5, 3] &lt;- Right Replaced:- [Hits:1 Misses:4]\nAccess: 4  HIT  Left  -&gt; [1, 4, 5, 3] &lt;- Right Replaced:- [Hits:2 Misses:4]\nAccess: 2  MISS Left  -&gt;    [4, 3, 2] &lt;- Right Replaced:- [Hits:2 Misses:5]\nAccess: 3  HIT  Left  -&gt;    [4, 3, 2] &lt;- Right Replaced:- [Hits:3 Misses:5]\nAccess: 5  MISS Left  -&gt; [4, 3, 2, 5] &lt;- Right Replaced:- [Hits:3 Misses:6]\nAccess: 3  HIT  Left  -&gt; [4, 3, 2, 5] &lt;- Right Replaced:- [Hits:4 Misses:6]\nAccess: 5  HIT  Left  -&gt; [4, 3, 2, 5] &lt;- Right Replaced:- [Hits:5 Misses:6]\nAccess: 1  MISS Left  -&gt;    [3, 5, 1] &lt;- Right Replaced:- [Hits:5 Misses:7]\nAccess: 4  MISS Left  -&gt; [3, 5, 1, 4] &lt;- Right Replaced:- [Hits:5 Misses:8]\n\nFINALSTATS hits 5   misses 8   hitrate 38.46\n&#96;&#96;&#96;</md>"}, {"anon": "no", "uid": "je2ib27z6a7691", "subject": "第八讲课后练习参考解答", "created": "2020-03-18T15:55:29Z", "content": "<md>## 工作集置换算法\n\n&gt; 2017011428\n&gt; https://git.tsinghua.edu.cn/jiaor17/os-homework/tree/master/%E7%AC%AC%E5%85%AB%E8%AE%B2%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A\n\n### 核心代码\n\n&#96;&#96;&#96;\nfor nStr in addrList:\n    # first, lookup\n    n = int(nStr)\n    if policy == &#39;WS&#39;:\n        try:\n            idx = memory.index(n)\n            hits = hits &#43; 1\n        except:\n            idx = -1\n            miss = miss &#43; 1\n        memory.append(n)\n        victim = -1\n        if len(memory)&gt;windowsize:\n            victim = memory.pop(0)\n            if victim in memory:\n                victim = -1\n        if notrace == False:\n            print &#39;Access: %d  %s %s -&gt; %12s &lt;- %s  Working Set: %12s Replaced:%s [Hits:%d Misses:%d]&#39; % (n, hfunc(idx), leftStr, memory, riteStr,list(set(memory)), vfunc(victim), hits, miss)\n&#96;&#96;&#96;\n\n### 测试结果\n\n使用课件中的测例 &#96;3,3,4,2,3,5,3,5,1,4&#96;&#xff1a;\n\n&#96;&#96;&#96;\npython2 .\\hw8.py -a 3,3,4,2,3,5,3,5,1,4 -c -w 4 -p WS -i 5,4,1\n\nARG addresses 3,3,4,2,3,5,3,5,1,4\nARG initlist 5,4,1\nARG policy WS\nARG clockbits 1\nARG pageframesize 3\nARG windowsize 4\nARG seed 0\nARG notrace False\n\nSolving...\n\nAccess: 3  MISS Left  -&gt; [5, 4, 1, 3] &lt;- Right  Working Set: [1, 3, 4, 5] Replaced:- [Hits:0 Misses:1]\nAccess: 3  HIT  Left  -&gt; [4, 1, 3, 3] &lt;- Right  Working Set:    [1, 3, 4] Replaced:5 [Hits:1 Misses:1]\nAccess: 4  HIT  Left  -&gt; [1, 3, 3, 4] &lt;- Right  Working Set:    [1, 3, 4] Replaced:- [Hits:2 Misses:1]\nAccess: 2  MISS Left  -&gt; [3, 3, 4, 2] &lt;- Right  Working Set:    [2, 3, 4] Replaced:1 [Hits:2 Misses:2]\nAccess: 3  HIT  Left  -&gt; [3, 4, 2, 3] &lt;- Right  Working Set:    [2, 3, 4] Replaced:- [Hits:3 Misses:2]\nAccess: 5  MISS Left  -&gt; [4, 2, 3, 5] &lt;- Right  Working Set: [2, 3, 4, 5] Replaced:- [Hits:3 Misses:3]\nAccess: 3  HIT  Left  -&gt; [2, 3, 5, 3] &lt;- Right  Working Set:    [2, 3, 5] Replaced:4 [Hits:4 Misses:3]\nAccess: 5  HIT  Left  -&gt; [3, 5, 3, 5] &lt;- Right  Working Set:       [3, 5] Replaced:2 [Hits:5 Misses:3]\nAccess: 1  MISS Left  -&gt; [5, 3, 5, 1] &lt;- Right  Working Set:    [1, 3, 5] Replaced:- [Hits:5 Misses:4]\nAccess: 4  MISS Left  -&gt; [3, 5, 1, 4] &lt;- Right  Working Set: [1, 3, 4, 5] Replaced:- [Hits:5 Misses:5]\n\nFINALSTATS hits 5   misses 5   hitrate 50.00\n&#96;&#96;&#96;\n\n## 缺页率置换算法\n\n&gt; 2017011456\n&gt; https://git.tsinghua.edu.cn/chang-li17/os_homework\n\n### 实现过程\n\n1. 给定一个缺页时间差的窗口 $\\Delta T$\n2. 访存命中时&#xff0c;将访问的页号加入被访问过页面的一个记录表中\n3. 缺页时&#xff0c;如果本次缺页距离上一次缺页的时间差大于 $\\Delta T$&#xff0c;则遍历所有存储空间中的页面。如果页面在上一次缺页到这一次缺页时未被访问过&#xff0c;则从存储空间中删去\n4. 缺页时&#xff0c;如果本次缺页距离上一次缺页的时间差不大于 $\\Delta T$&#xff0c;则只需要把此页面加入页表&#xff0c;并且把该页号存入记录表中\n5. 考虑边界情况。如果存储空间已被占满且需要加入页面&#xff0c;那么退化成FIFO算法&#xff0c;把最早进入的那个页面置换成新的页面\n\n### 核心代码\n\n&#96;&#96;&#96;\nfor nStr in addrList:\n    # first, lookup\n    n = int(nStr)\n    try:\n        idx = memory.index(n)\n        hits = hits &#43; 1\n        if policy == &#39;LRU&#39; :\n            update = memory.remove(n)\n            memory.append(n) # puts it on MRU side\n        elif policy == &#39;PFR&#39; :\n            faulttime = faulttime &#43; 1\n            visit[idx] = True\n    except:\n        idx = -1\n        miss = miss &#43; 1\n\n    victim = -1        \n    if idx == -1:\n        # 缺页率置换算法&#xff0c;发生在缺页时。算法流程&#xff1a;\n        # 如果未发生缺页&#xff0c;缺页间隔&#43;1&#xff1b;\n        # 如果发生缺页&#xff0c;记录缺页间隔。如果缺页间隔大于等于设定的窗口值&#xff0c;删去当前页表中所有未访问的页面\n        # 特别的&#xff0c;如果页面满了还得插入&#xff0c;则强制弹出地址最低的一个页\n        if policy == &#39;PFR&#39;:\n            del_time = 0\n            if cdebug2:\n                print faulttime\n                assert(faulttime &gt; 0)\n            if faulttime &gt; deltatime:\n                for i in range(0,len(memory)):\n                    # 该页面没被访问过&#xff0c;删去\n                    if not visit[i]:    \n                        if cdebug2:\n                            print memory[i - del_time], &#34;没被访问&#34;\n                        memory.pop(i - del_time)\n                        del_time = del_time &#43; 1\n                        \n            # 重置缺页间隔\n            faulttime = 1\n            # 重置访问记录\n            visit = []\n            for i in range(0,len(memory)):\n                visit.append(False)\n            if cdebug2:\n                print memory\n\n        # miss, replace?\n        # print &#39;BUG count, pageframesize:&#39;, count, pageframesize\n        if count == pageframesize:\n            # must replace, 特别地&#xff0c;对于缺页率置换算法&#xff0c;如果满了也强制换掉第一个界面\n            if policy == &#34;PFR&#34;:\n                if len(memory) == pageframesize:\n                    victim = memory.pop(0)\n                    visit.pop(0)\n        else:\n            # miss, but no replacement needed (page frame not full)\n            victim = -1\n            count = count &#43; 1\n\n        # now add to memory\n        memory.append(n)\n        \n        # 对于缺页率置换算法&#xff0c;需要把新加入的页面设为已访问页面\n        if policy == &#39;PFR&#39;:\n            visit.append(True)\n        if cdebug:\n            print &#39;LEN (a)&#39;, len(memory)\n        if victim != -1:\n            assert(victim not in memory)\n\n    if notrace == False:\n        print &#39;Access: %d  %s %s -&gt; %12s &lt;- %s Replaced:%s [Hits:%d Misses:%d]&#39; % (n, hfunc(idx), leftStr, memory, riteStr, vfunc(victim), hits, miss)\n&#96;&#96;&#96;\n\n### 测试结果\n\n使用课件中的测例 &#96;1, 4, 5, 3, 3, 4, 2, 3, 5, 3, 5, 1, 4&#96;&#xff1a;\n\n&#96;&#96;&#96;\nmachine&#64;ubuntu:~/Desktop/os_homework/hw4$ python page-replacement-policy.py -a 1,4,5,3,3,4,2,3,5,3,5,1,4 -p PFR -T 2 -f 4 -c\n\nARG addresses 1,4,5,3,3,4,2,3,5,3,5,1,4\nARG policy PFR\nARG clockbits 1\nARG deltatime 2\nARG pageframesize 4\nARG seed 0\nARG notrace False\n\nSolving...\n\nAccess: 1  MISS Left  -&gt;          [1] &lt;- Right Replaced:- [Hits:0 Misses:1]\nAccess: 4  MISS Left  -&gt;       [1, 4] &lt;- Right Replaced:- [Hits:0 Misses:2]\nAccess: 5  MISS Left  -&gt;    [1, 4, 5] &lt;- Right Replaced:- [Hits:0 Misses:3]\nAccess: 3  MISS Left  -&gt; [1, 4, 5, 3] &lt;- Right Replaced:- [Hits:0 Misses:4]\nAccess: 3  HIT  Left  -&gt; [1, 4, 5, 3] &lt;- Right Replaced:- [Hits:1 Misses:4]\nAccess: 4  HIT  Left  -&gt; [1, 4, 5, 3] &lt;- Right Replaced:- [Hits:2 Misses:4]\nAccess: 2  MISS Left  -&gt;    [4, 3, 2] &lt;- Right Replaced:- [Hits:2 Misses:5]\nAccess: 3  HIT  Left  -&gt;    [4, 3, 2] &lt;- Right Replaced:- [Hits:3 Misses:5]\nAccess: 5  MISS Left  -&gt; [4, 3, 2, 5] &lt;- Right Replaced:- [Hits:3 Misses:6]\nAccess: 3  HIT  Left  -&gt; [4, 3, 2, 5] &lt;- Right Replaced:- [Hits:4 Misses:6]\nAccess: 5  HIT  Left  -&gt; [4, 3, 2, 5] &lt;- Right Replaced:- [Hits:5 Misses:6]\nAccess: 1  MISS Left  -&gt;    [3, 5, 1] &lt;- Right Replaced:- [Hits:5 Misses:7]\nAccess: 4  MISS Left  -&gt; [3, 5, 1, 4] &lt;- Right Replaced:- [Hits:5 Misses:8]\n\nFINALSTATS hits 5   misses 8   hitrate 38.46\n&#96;&#96;&#96;</md>"}], "type": "note", "tags": ["lecture8", "student"], "tag_good": [], "unique_views": 94, "children": [], "tag_good_arr": [], "id": "k7xibw3xwxp1fs", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 1, "num_favorites": 0, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643170023689, "default_anonymity": "no"}, "error": null, "aid": "kyv108p5k5c1cu"}