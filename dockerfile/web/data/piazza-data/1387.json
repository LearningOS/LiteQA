{"result": {"folders": ["lecture2"], "nr": 1387, "data": {"embed_links": []}, "created": "2020-02-21T15:54:24Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "je2ib27z6a7691", "data": "k6wcubw2yl65to", "type": "create", "when": "2020-02-21T15:54:24Z"}, {"anon": "no", "uid": "je2ib27z6a7691", "data": "k6wd0lc17o13j0", "type": "update", "when": "2020-02-21T15:59:16Z"}, {"anon": "no", "uid": "je2ib27z6a7691", "data": "k6wd3x9wfbt77i", "type": "update", "when": "2020-02-21T16:01:51Z"}, {"anon": "no", "uid": "je2ib27z6a7691", "data": "k6wd5634aqcg4", "type": "update", "when": "2020-02-21T16:02:49Z"}, {"anon": "no", "uid": "k6ps4vld2to58n", "to": "k6wcubvzk935tn", "type": "followup", "when": "2020-02-23T09:45:54Z"}, {"anon": "no", "uid": "k6ohjbqv89e5ji", "to": "k6wcubvzk935tn", "type": "followup", "when": "2020-02-24T05:14:25Z"}, {"anon": "no", "uid": "k6og1cszbk29q", "to": "k6wcubvzk935tn", "type": "feedback", "when": "2020-02-24T09:08:31Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "je2ib27z6a7691", "subject": "第二讲课后练习参考实现", "created": "2020-02-21T16:02:49Z", "content": "<p><md><br /># 示例一(C):<br />&gt; https://git.tsinghua.edu.cn/yx-liu14/os_course<br /></md></p>\n<pre>#include &lt;execinfo.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint *stack_bottom;\n \nvoid print_stacktrace() {\n    int size = 100;\n    void * array[100];\n    int stack_num = backtrace(array, size);\n    char ** stacktrace = backtrace_symbols(array, stack_num);\n    int num = stack_num - 3;\n    printf(&#34;A total of %d stacks\\n&#34;, num);\n     \n    register int *current_ebp __asm__ (&#34;%ebp&#34;);\n    int *ebp = current_ebp;\n    int k = 0;\n    while (ebp != stack_bottom) {\n        printf(&#34;stack %d: &#34;, num-k);\n        printf(&#34;%s\\n&#34;, stacktrace[&#43;&#43;k]);\n        int *upper_ebp = (int*) *ebp; \n        int len = upper_ebp - ebp;\n        printf(&#34;(0x%0x) &#34;, int(ebp));\n        for (int i = 0; i &lt; len; i&#43;&#43;) \n            printf(&#34;0x%0x &#34;, *(ebp&#43;i));\n        printf(&#34;\\n&#34;);\n        ebp = upper_ebp;\n    }\n    free(stacktrace);\n}\n\nvoid fun1() {\n    printf(&#34;stack trace begin:\\n&#34;);\n    print_stacktrace();\n}\n\nvoid fun2(int a) {\n    fun1();\n}\n\nvoid fun3(int a, int b) {\n    fun2(3);\n}\n\nint main() {\n    register int *main_ebp __asm__ (&#34;%ebp&#34;);\n    stack_bottom = main_ebp; \n    fun3(1, 2);\n}</pre>\n<md><br />## 编译命令<br /><br />&#96;&#96;&#96;<br />g&#43;&#43; stack.cpp -o stack -rdynamic -m32<br />&#96;&#96;&#96;<br /><br />## 结果<br /><br />&#96;&#96;&#96;<br />stack trace begin:<br />A total of 4 stacks<br />stack 4: ./test(_Z4fun1v&#43;0x17) [0x8048967]<br />(0xffcb34e8) 0xffcb3508 0x8048967 0x8048a85 0xf7757fed 0xffcb3518 0x0 0x8048502 0xf776b900<br />stack 3: ./test(_Z4fun2i&#43;0xb) [0x8048974]<br />(0xffcb3508) 0xffcb3518 0x8048974 0x177ff8e 0x1<br />stack 2: ./test(_Z4fun3ii&#43;0x12) [0x8048988]<br />(0xffcb3518) 0xffcb3538 0x8048988 0x3 0xf74274ec 0x804a000 0x8048a12 0x1 0xffcb35f4<br />stack 1: ./test(main&#43;0x24) [0x80489ae]<br />(0xffcb3538) 0xffcb3558 0x80489ae 0x1 0x2 0x80489cb 0xf75db000 0x80489c0 0x0<br />&#96;&#96;&#96;<br /><br />## 说明<br /><br />* 使用了 libc 中的 &#96;backtrace()&#96; 和 &#96;backtrace_symbols()&#96; 函数&#xff0c;获取调用栈中的函数名、返回地址等信息。<br />* 32 位程序&#xff0c;函数参数存在栈上。<br /></md>\n<p></p>\n<md><br /># 示例二(Rust):<br /><br />&gt; https://git.tsinghua.edu.cn/chengjw17/backtrace<br /></md>\n<p>lib.rs:</p>\n<pre>#[macro_export]\nmacro_rules! fn_name {\n    () =&gt; ({\n        fn _f() {}\n        fn type_name_of&lt;T&gt;(_: T) -&gt; &amp;&#39;static str {\n            std::any::type_name::&lt;T&gt;()\n        }\n//        type_name_of(_f).split(&#34;::&#34;).nth(1).unwrap()\n        let name = type_name_of(_f);\n        &amp;name[..name.len() - 4]\n    })\n}\n\n#[cfg(target_arch = &#34;x86_64&#34;)]\n#[macro_export]\nmacro_rules! trace {\n    ($params: expr) =&gt; ({\n        let mut p = [0 as usize; 4];\n        let stack_ptr: usize;\n        unsafe {\n            asm!(&#34;mov %rcx, $0&#34; : &#34;=r&#34;(p[0]) ::: &#34;volatile&#34;);\n            asm!(&#34;mov %rdx, $0&#34; : &#34;=r&#34;(p[1]) ::: &#34;volatile&#34;);\n            asm!(&#34;mov %r8, $0&#34; : &#34;=r&#34;(p[2]) ::: &#34;volatile&#34;);\n            asm!(&#34;mov %r9, $0&#34; : &#34;=r&#34;(p[3]) ::: &#34;volatile&#34;);\n            asm!(&#34;mov %rsp, $0&#34; : &#34;=r&#34;(stack_ptr) ::: &#34;volatile&#34;);\n        }\n        println!(&#34;function {} at {:#X}&#34;, fn_name!(), stack_ptr);\n        for index in 0..$params.min(4) {\n            println!(&#34;\\targ{}: {}&#34;, index, p[index]);\n        }\n    })\n}</pre>\n<p>main.rs:</p>\n<pre>#![feature(asm)]\n#[macro_use]\nextern crate backtrace;\n\nfn fibonacci(n: u64, r: u64) -&gt; u64 {\n    trace!(2);\n    match n {\n        0 =&gt; 0,\n        1 =&gt; 1,\n        _ =&gt; fibonacci(n - 1, r &lt;&lt; 1) &#43; fibonacci(n - 2, r &lt;&lt; 1)\n    }\n}\n\nfn sum(n: u64) -&gt; u64 {\n    trace!(1);\n    match n {\n        0 =&gt; 0,\n        _ =&gt; sum(n - 1) &#43; n\n    }\n}\n\nfn main() {\n    println!(&#34;fibonacci of 20: {}\\n&#34;, fibonacci(20, 1));\n    println!(&#34;sum of 1 to 10: {}&#34;, sum(10));\n}</pre>\n<md><br />## 结果<br /><br />&#96;&#96;&#96;<br />function backtrace::fibonacci at 0x7FFEE1E0FE50<br /> arg0: 20<br /> arg1: 1<br />function backtrace::fibonacci at 0x7FFEE1E0FBC0<br /> arg0: 19<br /> arg1: 2<br />function backtrace::fibonacci at 0x7FFEE1E0F930<br /> arg0: 18<br /> arg1: 4<br />function backtrace::fibonacci at 0x7FFEE1E0F6A0<br /> arg0: 17<br /> arg1: 8<br />function backtrace::fibonacci at 0x7FFEE1E0F410<br /> arg0: 16<br /> arg1: 16<br />function backtrace::fibonacci at 0x7FFEE1E0F180<br />......<br />......<br />......<br />function backtrace::fibonacci at 0x7FFEE1E0E220<br /> arg0: 0<br /> arg1: 2048<br />function backtrace::fibonacci at 0x7FFEE1E0E4B0<br /> arg0: 1<br /> arg1: 1024<br />function backtrace::fibonacci at 0x7FFEE1E0E740<br /> arg0: 2<br /> arg1: 512<br />function backtrace::fibonacci at 0x7FFEE1E0E4B0<br /> arg0: 1<br /> arg1: 1024<br />function backtrace::fibonacci at 0x7FFEE1E0E4B0<br /> arg0: 0<br /> arg1: 1024<br />fibonacci of 20: 6765<br /><br />function backtrace::sum at 0x7FFEE1E0FE80<br /> arg0: 10<br />function backtrace::sum at 0x7FFEE1E0FC20<br /> arg0: 9<br />function backtrace::sum at 0x7FFEE1E0F9C0<br /> arg0: 8<br />function backtrace::sum at 0x7FFEE1E0F760<br /> arg0: 7<br />function backtrace::sum at 0x7FFEE1E0F500<br /> arg0: 6<br />function backtrace::sum at 0x7FFEE1E0F2A0<br /> arg0: 5<br />function backtrace::sum at 0x7FFEE1E0F040<br /> arg0: 4<br />function backtrace::sum at 0x7FFEE1E0EDE0<br /> arg0: 3<br />function backtrace::sum at 0x7FFEE1E0EB80<br /> arg0: 2<br />function backtrace::sum at 0x7FFEE1E0E920<br /> arg0: 1<br />function backtrace::sum at 0x7FFEE1E0E6C0<br /> arg0: 0<br />sum of 1 to 10: 55<br />&#96;&#96;&#96;<br /><br />## 说明<br /><br />* 使用 &#96;std::any::type_name::&lt;T&gt;()&#96; 获取函数符号名。<br />* 64 位程序&#xff0c;函数参数通过寄存器传递&#xff0c;具体使用哪几个寄存器因调用约定(calling convention)而异&#xff0c;如该同学使用的是 &#96;%rcx&#96;, &#96;%rdx&#96;, &#96;%r8&#96;, &#96;%r9&#96;。<br /></md>\n<p></p>\n<p></p>"}, {"anon": "no", "uid": "je2ib27z6a7691", "subject": "第二讲课后练习参考实现", "created": "2020-02-21T16:01:51Z", "content": "<p><md><br /># 示例一(C):<br /><br />&gt; https://git.tsinghua.edu.cn/yx-liu14/os_course<br /></md>\n</p><pre>#include &lt;execinfo.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint *stack_bottom;\n \nvoid print_stacktrace() {\n    int size = 100;\n    void * array[100];\n    int stack_num = backtrace(array, size);\n    char ** stacktrace = backtrace_symbols(array, stack_num);\n    int num = stack_num - 3;\n    printf(&#34;A total of %d stacks\\n&#34;, num);\n     \n    register int *current_ebp __asm__ (&#34;%ebp&#34;);\n    int *ebp = current_ebp;\n    int k = 0;\n    while (ebp != stack_bottom) {\n        printf(&#34;stack %d: &#34;, num-k);\n        printf(&#34;%s\\n&#34;, stacktrace[&#43;&#43;k]);\n        int *upper_ebp = (int*) *ebp; \n        int len = upper_ebp - ebp;\n        printf(&#34;(0x%0x) &#34;, int(ebp));\n        for (int i = 0; i &lt; len; i&#43;&#43;) \n            printf(&#34;0x%0x &#34;, *(ebp&#43;i));\n        printf(&#34;\\n&#34;);\n        ebp = upper_ebp;\n    }\n    free(stacktrace);\n}\n\nvoid fun1() {\n    printf(&#34;stack trace begin:\\n&#34;);\n    print_stacktrace();\n}\n\nvoid fun2(int a) {\n    fun1();\n}\n\nvoid fun3(int a, int b) {\n    fun2(3);\n}\n\nint main() {\n    register int *main_ebp __asm__ (&#34;%ebp&#34;);\n    stack_bottom = main_ebp; \n    fun3(1, 2);\n}</pre>\n<md><br />## 编译命令<br /><br />&#96;&#96;&#96;<br />g&#43;&#43; stack.cpp -o stack -rdynamic -m32<br />&#96;&#96;&#96;<br /><br />## 结果<br /><br />&#96;&#96;&#96;<br />stack trace begin:<br />A total of 4 stacks<br />stack 4: ./test(_Z4fun1v&#43;0x17) [0x8048967]<br />(0xffcb34e8) 0xffcb3508 0x8048967 0x8048a85 0xf7757fed 0xffcb3518 0x0 0x8048502 0xf776b900<br />stack 3: ./test(_Z4fun2i&#43;0xb) [0x8048974]<br />(0xffcb3508) 0xffcb3518 0x8048974 0x177ff8e 0x1<br />stack 2: ./test(_Z4fun3ii&#43;0x12) [0x8048988]<br />(0xffcb3518) 0xffcb3538 0x8048988 0x3 0xf74274ec 0x804a000 0x8048a12 0x1 0xffcb35f4<br />stack 1: ./test(main&#43;0x24) [0x80489ae]<br />(0xffcb3538) 0xffcb3558 0x80489ae 0x1 0x2 0x80489cb 0xf75db000 0x80489c0 0x0<br />&#96;&#96;&#96;<br /><br />## 说明<br /><br />* 使用了 libc 中的 &#96;backtrace()&#96; 和 &#96;backtrace_symbols()&#96; 函数&#xff0c;获取调用栈中的函数名、返回地址等信息。<br />* 32 位程序&#xff0c;函数参数存在栈上。<br /></md>\n<p></p>\n<md><br /># 示例二(Rust):<br /><br />&gt; https://git.tsinghua.edu.cn/chengjw17/backtrace<br /></md>\n<p>lib.rs:</p>\n<pre>#[macro_export]\nmacro_rules! fn_name {\n    () =&gt; ({\n        fn _f() {}\n        fn type_name_of&lt;T&gt;(_: T) -&gt; &amp;&#39;static str {\n            std::any::type_name::&lt;T&gt;()\n        }\n//        type_name_of(_f).split(&#34;::&#34;).nth(1).unwrap()\n        let name = type_name_of(_f);\n        &amp;name[..name.len() - 4]\n    })\n}\n\n#[cfg(target_arch = &#34;x86_64&#34;)]\n#[macro_export]\nmacro_rules! trace {\n    ($params: expr) =&gt; ({\n        let mut p = [0 as usize; 4];\n        let stack_ptr: usize;\n        unsafe {\n            asm!(&#34;mov %rcx, $0&#34; : &#34;=r&#34;(p[0]) ::: &#34;volatile&#34;);\n            asm!(&#34;mov %rdx, $0&#34; : &#34;=r&#34;(p[1]) ::: &#34;volatile&#34;);\n            asm!(&#34;mov %r8, $0&#34; : &#34;=r&#34;(p[2]) ::: &#34;volatile&#34;);\n            asm!(&#34;mov %r9, $0&#34; : &#34;=r&#34;(p[3]) ::: &#34;volatile&#34;);\n            asm!(&#34;mov %rsp, $0&#34; : &#34;=r&#34;(stack_ptr) ::: &#34;volatile&#34;);\n        }\n        println!(&#34;function {} at {:#X}&#34;, fn_name!(), stack_ptr);\n        for index in 0..$params.min(4) {\n            println!(&#34;\\targ{}: {}&#34;, index, p[index]);\n        }\n    })\n}</pre>\n<p>main.rs:</p>\n<pre>#![feature(asm)]\n#[macro_use]\nextern crate backtrace;\n\nfn fibonacci(n: u64, r: u64) -&gt; u64 {\n    trace!(2);\n    match n {\n        0 =&gt; 0,\n        1 =&gt; 1,\n        _ =&gt; fibonacci(n - 1, r &lt;&lt; 1) &#43; fibonacci(n - 2, r &lt;&lt; 1)\n    }\n}\n\nfn sum(n: u64) -&gt; u64 {\n    trace!(1);\n    match n {\n        0 =&gt; 0,\n        _ =&gt; sum(n - 1) &#43; n\n    }\n}\n\nfn main() {\n    println!(&#34;fibonacci of 20: {}\\n&#34;, fibonacci(20, 1));\n    println!(&#34;sum of 1 to 10: {}&#34;, sum(10));\n}</pre>\n<md><br />## 结果<br /><br />&#96;&#96;&#96;<br />function backtrace::fibonacci at 0x7FFEE1E0FE50<br /> arg0: 20<br /> arg1: 1<br />function backtrace::fibonacci at 0x7FFEE1E0FBC0<br /> arg0: 19<br /> arg1: 2<br />function backtrace::fibonacci at 0x7FFEE1E0F930<br /> arg0: 18<br /> arg1: 4<br />function backtrace::fibonacci at 0x7FFEE1E0F6A0<br /> arg0: 17<br /> arg1: 8<br />function backtrace::fibonacci at 0x7FFEE1E0F410<br /> arg0: 16<br /> arg1: 16<br />function backtrace::fibonacci at 0x7FFEE1E0F180<br />......<br />......<br />......<br />function backtrace::fibonacci at 0x7FFEE1E0E220<br /> arg0: 0<br /> arg1: 2048<br />function backtrace::fibonacci at 0x7FFEE1E0E4B0<br /> arg0: 1<br /> arg1: 1024<br />function backtrace::fibonacci at 0x7FFEE1E0E740<br /> arg0: 2<br /> arg1: 512<br />function backtrace::fibonacci at 0x7FFEE1E0E4B0<br /> arg0: 1<br /> arg1: 1024<br />function backtrace::fibonacci at 0x7FFEE1E0E4B0<br /> arg0: 0<br /> arg1: 1024<br />fibonacci of 20: 6765<br /><br />function backtrace::sum at 0x7FFEE1E0FE80<br /> arg0: 10<br />function backtrace::sum at 0x7FFEE1E0FC20<br /> arg0: 9<br />function backtrace::sum at 0x7FFEE1E0F9C0<br /> arg0: 8<br />function backtrace::sum at 0x7FFEE1E0F760<br /> arg0: 7<br />function backtrace::sum at 0x7FFEE1E0F500<br /> arg0: 6<br />function backtrace::sum at 0x7FFEE1E0F2A0<br /> arg0: 5<br />function backtrace::sum at 0x7FFEE1E0F040<br /> arg0: 4<br />function backtrace::sum at 0x7FFEE1E0EDE0<br /> arg0: 3<br />function backtrace::sum at 0x7FFEE1E0EB80<br /> arg0: 2<br />function backtrace::sum at 0x7FFEE1E0E920<br /> arg0: 1<br />function backtrace::sum at 0x7FFEE1E0E6C0<br /> arg0: 0<br />sum of 1 to 10: 55<br />&#96;&#96;&#96;<br /><br />## 说明<br /><br />* 使用 &#96;std::any::type_name::&lt;T&gt;()&#96; 获取函数符号名。<br />* 64 位程序&#xff0c;函数参数通过寄存器传递&#xff0c;具体使用哪几个寄存器因调用约定(calling convention)而异&#xff0c;如该同学使用的是 &#96;%rcx&#96;, &#96;%rdx&#96;, &#96;%r8&#96;, &#96;%r9&#96;。<br /></md>\n<p></p><p></p>"}, {"anon": "no", "uid": "je2ib27z6a7691", "subject": "第二讲课后练习参考实现", "created": "2020-02-21T15:59:16Z", "content": "<p><md><br /># 示例一(C):<br /><br />&gt; https://git.tsinghua.edu.cn/yx-liu14/os_course<br /><br />&#96;&#96;&#96;<br />#include &lt;execinfo.h&gt;<br />#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;<br />,,.,,.asdasd.,.≥,<br />int *stack_bottom;<br /> <br />void print_stacktrace() {<br /> int size = 100;<br /> void * array[100];<br /> int stack_num = backtrace(array, size);<br /> char ** stacktrace = backtrace_symbols(array, stack_num);<br /> int num = stack_num - 3;<br /> printf(&#34;A total of %d stacks\\n&#34;, num);<br /> <br /> register int *current_ebp __asm__ (&#34;%ebp&#34;);<br /> int *ebp = current_ebp;<br /> int k = 0;<br /> while (ebp != stack_bottom) {<br /> printf(&#34;stack %d: &#34;, num-k);<br /> printf(&#34;%s\\n&#34;, stacktrace[&#43;&#43;k]);<br /> int *upper_ebp = (int*) *ebp; <br /> int len = upper_ebp - ebp;<br /> printf(&#34;(0x%0x) &#34;, int(ebp));<br /> for (int i = 0; i &lt; len; i&#43;&#43;) <br /> printf(&#34;0x%0x &#34;, *(ebp&#43;i));<br /> printf(&#34;\\n&#34;);<br /> ebp = upper_ebp;<br /> }<br /> free(stacktrace);<br />}<br /><br />void fun1() {<br /> printf(&#34;stack trace begin:\\n&#34;);<br /> print_stacktrace();<br />}<br /><br />void fun2(int a) {<br /> fun1();<br />}<br /><br />void fun3(int a, int b) {<br /> fun2(3);<br />}<br /><br />int main() {<br /> register int *main_ebp __asm__ (&#34;%ebp&#34;);<br /> stack_bottom = main_ebp; <br /> fun3(1, 2);<br />}<br />&#96;&#96;&#96;<br /><br />## 编译命令<br /><br />&#96;&#96;&#96;<br />g&#43;&#43; stack.cpp -o stack -rdynamic -m32<br />&#96;&#96;&#96;<br /><br />## 结果<br /><br />&#96;&#96;&#96;<br />stack trace begin:<br />A total of 4 stacks<br />stack 4: ./test(_Z4fun1v&#43;0x17) [0x8048967]<br />(0xffcb34e8) 0xffcb3508 0x8048967 0x8048a85 0xf7757fed 0xffcb3518 0x0 0x8048502 0xf776b900<br />stack 3: ./test(_Z4fun2i&#43;0xb) [0x8048974]<br />(0xffcb3508) 0xffcb3518 0x8048974 0x177ff8e 0x1<br />stack 2: ./test(_Z4fun3ii&#43;0x12) [0x8048988]<br />(0xffcb3518) 0xffcb3538 0x8048988 0x3 0xf74274ec 0x804a000 0x8048a12 0x1 0xffcb35f4<br />stack 1: ./test(main&#43;0x24) [0x80489ae]<br />(0xffcb3538) 0xffcb3558 0x80489ae 0x1 0x2 0x80489cb 0xf75db000 0x80489c0 0x0<br />&#96;&#96;&#96;<br /><br />## 说明<br /><br />* 使用了 libc 中的 &#96;backtrace()&#96; 和 &#96;backtrace_symbols()&#96; 函数&#xff0c;获取调用栈中的函数名、返回地址等信息。<br />* 32 位程序&#xff0c;函数参数存在栈上。<br /></md></p>\n<p></p>\n<md><br /># 示例二(Rust):<br /><br />&gt; https://git.tsinghua.edu.cn/chengjw17/backtrace<br /></md>\n<p>lib.rs:</p>\n<pre>#[macro_export]\nmacro_rules! fn_name {\n    () =&gt; ({\n        fn _f() {}\n        fn type_name_of&lt;T&gt;(_: T) -&gt; &amp;&#39;static str {\n            std::any::type_name::&lt;T&gt;()\n        }\n//        type_name_of(_f).split(&#34;::&#34;).nth(1).unwrap()\n        let name = type_name_of(_f);\n        &amp;name[..name.len() - 4]\n    })\n}\n\n#[cfg(target_arch = &#34;x86_64&#34;)]\n#[macro_export]\nmacro_rules! trace {\n    ($params: expr) =&gt; ({\n        let mut p = [0 as usize; 4];\n        let stack_ptr: usize;\n        unsafe {\n            asm!(&#34;mov %rcx, $0&#34; : &#34;=r&#34;(p[0]) ::: &#34;volatile&#34;);\n            asm!(&#34;mov %rdx, $0&#34; : &#34;=r&#34;(p[1]) ::: &#34;volatile&#34;);\n            asm!(&#34;mov %r8, $0&#34; : &#34;=r&#34;(p[2]) ::: &#34;volatile&#34;);\n            asm!(&#34;mov %r9, $0&#34; : &#34;=r&#34;(p[3]) ::: &#34;volatile&#34;);\n            asm!(&#34;mov %rsp, $0&#34; : &#34;=r&#34;(stack_ptr) ::: &#34;volatile&#34;);\n        }\n        println!(&#34;function {} at {:#X}&#34;, fn_name!(), stack_ptr);\n        for index in 0..$params.min(4) {\n            println!(&#34;\\targ{}: {}&#34;, index, p[index]);\n        }\n    })\n}</pre>\n<p>main.rs:</p>\n<pre>#![feature(asm)]\n#[macro_use]\nextern crate backtrace;\n\nfn fibonacci(n: u64, r: u64) -&gt; u64 {\n    trace!(2);\n    match n {\n        0 =&gt; 0,\n        1 =&gt; 1,\n        _ =&gt; fibonacci(n - 1, r &lt;&lt; 1) &#43; fibonacci(n - 2, r &lt;&lt; 1)\n    }\n}\n\nfn sum(n: u64) -&gt; u64 {\n    trace!(1);\n    match n {\n        0 =&gt; 0,\n        _ =&gt; sum(n - 1) &#43; n\n    }\n}\n\nfn main() {\n    println!(&#34;fibonacci of 20: {}\\n&#34;, fibonacci(20, 1));\n    println!(&#34;sum of 1 to 10: {}&#34;, sum(10));\n}</pre>\n<md><br />## 结果<br /><br />&#96;&#96;&#96;<br />function backtrace::fibonacci at 0x7FFEE1E0FE50<br /> arg0: 20<br /> arg1: 1<br />function backtrace::fibonacci at 0x7FFEE1E0FBC0<br /> arg0: 19<br /> arg1: 2<br />function backtrace::fibonacci at 0x7FFEE1E0F930<br /> arg0: 18<br /> arg1: 4<br />function backtrace::fibonacci at 0x7FFEE1E0F6A0<br /> arg0: 17<br /> arg1: 8<br />function backtrace::fibonacci at 0x7FFEE1E0F410<br /> arg0: 16<br /> arg1: 16<br />function backtrace::fibonacci at 0x7FFEE1E0F180<br />......<br />......<br />......<br />function backtrace::fibonacci at 0x7FFEE1E0E220<br /> arg0: 0<br /> arg1: 2048<br />function backtrace::fibonacci at 0x7FFEE1E0E4B0<br /> arg0: 1<br /> arg1: 1024<br />function backtrace::fibonacci at 0x7FFEE1E0E740<br /> arg0: 2<br /> arg1: 512<br />function backtrace::fibonacci at 0x7FFEE1E0E4B0<br /> arg0: 1<br /> arg1: 1024<br />function backtrace::fibonacci at 0x7FFEE1E0E4B0<br /> arg0: 0<br /> arg1: 1024<br />fibonacci of 20: 6765<br /><br />function backtrace::sum at 0x7FFEE1E0FE80<br /> arg0: 10<br />function backtrace::sum at 0x7FFEE1E0FC20<br /> arg0: 9<br />function backtrace::sum at 0x7FFEE1E0F9C0<br /> arg0: 8<br />function backtrace::sum at 0x7FFEE1E0F760<br /> arg0: 7<br />function backtrace::sum at 0x7FFEE1E0F500<br /> arg0: 6<br />function backtrace::sum at 0x7FFEE1E0F2A0<br /> arg0: 5<br />function backtrace::sum at 0x7FFEE1E0F040<br /> arg0: 4<br />function backtrace::sum at 0x7FFEE1E0EDE0<br /> arg0: 3<br />function backtrace::sum at 0x7FFEE1E0EB80<br /> arg0: 2<br />function backtrace::sum at 0x7FFEE1E0E920<br /> arg0: 1<br />function backtrace::sum at 0x7FFEE1E0E6C0<br /> arg0: 0<br />sum of 1 to 10: 55<br />&#96;&#96;&#96;<br /><br />## 说明<br /><br />* 使用 &#96;std::any::type_name::&lt;T&gt;()&#96; 获取函数符号名。<br />* 64 位程序&#xff0c;函数参数通过寄存器传递&#xff0c;具体使用哪几个寄存器因调用约定(calling convention)而异&#xff0c;如该同学使用的是 &#96;%rcx&#96;, &#96;%rdx&#96;, &#96;%r8&#96;, &#96;%r9&#96;。<br /></md>\n<p></p>"}, {"anon": "no", "uid": "je2ib27z6a7691", "subject": "第二讲课后练习参考实现", "created": "2020-02-21T15:54:24Z", "content": "<p><md><br /># 示例一(C):<br /><br />&gt; https://git.tsinghua.edu.cn/yx-liu14/os_course<br /><br />&#96;&#96;&#96;<br />#include &lt;execinfo.h&gt;<br />#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;<br /><br />int *stack_bottom;<br /> <br />void print_stacktrace() {<br /> int size = 100;<br /> void * array[100];<br /> int stack_num = backtrace(array, size);<br /> char ** stacktrace = backtrace_symbols(array, stack_num);<br /> int num = stack_num - 3;<br /> printf(&#34;A total of %d stacks\\n&#34;, num);<br /> <br /> register int *current_ebp __asm__ (&#34;%ebp&#34;);<br /> int *ebp = current_ebp;<br /> int k = 0;<br /> while (ebp != stack_bottom) {<br /> printf(&#34;stack %d: &#34;, num-k);<br /> printf(&#34;%s\\n&#34;, stacktrace[&#43;&#43;k]);<br /> int *upper_ebp = (int*) *ebp; <br /> int len = upper_ebp - ebp;<br /> printf(&#34;(0x%0x) &#34;, int(ebp));<br /> for (int i = 0; i &lt; len; i&#43;&#43;) <br /> printf(&#34;0x%0x &#34;, *(ebp&#43;i));<br /> printf(&#34;\\n&#34;);<br /> ebp = upper_ebp;<br /> }<br /> free(stacktrace);<br />}<br /><br />void fun1() {<br /> printf(&#34;stack trace begin:\\n&#34;);<br /> print_stacktrace();<br />}<br /><br />void fun2(int a) {<br /> fun1();<br />}<br /><br />void fun3(int a, int b) {<br /> fun2(3);<br />}<br /><br />int main() {<br /> register int *main_ebp __asm__ (&#34;%ebp&#34;);<br /> stack_bottom = main_ebp; <br /> fun3(1, 2);<br />}<br />&#96;&#96;&#96;<br /><br />## 编译命令<br /><br />&#96;&#96;&#96;<br />g&#43;&#43; stack.cpp -o stack -rdynamic -m32<br />&#96;&#96;&#96;<br /><br />## 结果<br /><br />&#96;&#96;&#96;<br />stack trace begin:<br />A total of 4 stacks<br />stack 4: ./test(_Z4fun1v&#43;0x17) [0x8048967]<br />(0xffcb34e8) 0xffcb3508 0x8048967 0x8048a85 0xf7757fed 0xffcb3518 0x0 0x8048502 0xf776b900<br />stack 3: ./test(_Z4fun2i&#43;0xb) [0x8048974]<br />(0xffcb3508) 0xffcb3518 0x8048974 0x177ff8e 0x1<br />stack 2: ./test(_Z4fun3ii&#43;0x12) [0x8048988]<br />(0xffcb3518) 0xffcb3538 0x8048988 0x3 0xf74274ec 0x804a000 0x8048a12 0x1 0xffcb35f4<br />stack 1: ./test(main&#43;0x24) [0x80489ae]<br />(0xffcb3538) 0xffcb3558 0x80489ae 0x1 0x2 0x80489cb 0xf75db000 0x80489c0 0x0<br />&#96;&#96;&#96;<br /><br />## 说明<br /><br />* 使用了 libc 中的 &#96;backtrace()&#96; 和 &#96;backtrace_symbols()&#96; 函数&#xff0c;获取调用栈中的函数名、返回地址等信息。<br />* 32 位程序&#xff0c;函数参数存在栈上。<br /></md>\n</p><p></p>\n<md><br /># 示例二(Rust):<br /><br />&gt; https://git.tsinghua.edu.cn/chengjw17/backtrace<br /></md>\n<p>lib.rs:</p>\n<pre>#[macro_export]\nmacro_rules! fn_name {\n    () =&gt; ({\n        fn _f() {}\n        fn type_name_of&lt;T&gt;(_: T) -&gt; &amp;&#39;static str {\n            std::any::type_name::&lt;T&gt;()\n        }\n//        type_name_of(_f).split(&#34;::&#34;).nth(1).unwrap()\n        let name = type_name_of(_f);\n        &amp;name[..name.len() - 4]\n    })\n}\n\n#[cfg(target_arch = &#34;x86_64&#34;)]\n#[macro_export]\nmacro_rules! trace {\n    ($params: expr) =&gt; ({\n        let mut p = [0 as usize; 4];\n        let stack_ptr: usize;\n        unsafe {\n            asm!(&#34;mov %rcx, $0&#34; : &#34;=r&#34;(p[0]) ::: &#34;volatile&#34;);\n            asm!(&#34;mov %rdx, $0&#34; : &#34;=r&#34;(p[1]) ::: &#34;volatile&#34;);\n            asm!(&#34;mov %r8, $0&#34; : &#34;=r&#34;(p[2]) ::: &#34;volatile&#34;);\n            asm!(&#34;mov %r9, $0&#34; : &#34;=r&#34;(p[3]) ::: &#34;volatile&#34;);\n            asm!(&#34;mov %rsp, $0&#34; : &#34;=r&#34;(stack_ptr) ::: &#34;volatile&#34;);\n        }\n        println!(&#34;function {} at {:#X}&#34;, fn_name!(), stack_ptr);\n        for index in 0..$params.min(4) {\n            println!(&#34;\\targ{}: {}&#34;, index, p[index]);\n        }\n    })\n}</pre>\n<p>main.rs:</p>\n<pre>#![feature(asm)]\n#[macro_use]\nextern crate backtrace;\n\nfn fibonacci(n: u64, r: u64) -&gt; u64 {\n    trace!(2);\n    match n {\n        0 =&gt; 0,\n        1 =&gt; 1,\n        _ =&gt; fibonacci(n - 1, r &lt;&lt; 1) &#43; fibonacci(n - 2, r &lt;&lt; 1)\n    }\n}\n\nfn sum(n: u64) -&gt; u64 {\n    trace!(1);\n    match n {\n        0 =&gt; 0,\n        _ =&gt; sum(n - 1) &#43; n\n    }\n}\n\nfn main() {\n    println!(&#34;fibonacci of 20: {}\\n&#34;, fibonacci(20, 1));\n    println!(&#34;sum of 1 to 10: {}&#34;, sum(10));\n}</pre>\n<md><br />## 结果<br /><br />&#96;&#96;&#96;<br />function backtrace::fibonacci at 0x7FFEE1E0FE50<br /> arg0: 20<br /> arg1: 1<br />function backtrace::fibonacci at 0x7FFEE1E0FBC0<br /> arg0: 19<br /> arg1: 2<br />function backtrace::fibonacci at 0x7FFEE1E0F930<br /> arg0: 18<br /> arg1: 4<br />function backtrace::fibonacci at 0x7FFEE1E0F6A0<br /> arg0: 17<br /> arg1: 8<br />function backtrace::fibonacci at 0x7FFEE1E0F410<br /> arg0: 16<br /> arg1: 16<br />function backtrace::fibonacci at 0x7FFEE1E0F180<br />......<br />......<br />......<br />function backtrace::fibonacci at 0x7FFEE1E0E220<br /> arg0: 0<br /> arg1: 2048<br />function backtrace::fibonacci at 0x7FFEE1E0E4B0<br /> arg0: 1<br /> arg1: 1024<br />function backtrace::fibonacci at 0x7FFEE1E0E740<br /> arg0: 2<br /> arg1: 512<br />function backtrace::fibonacci at 0x7FFEE1E0E4B0<br /> arg0: 1<br /> arg1: 1024<br />function backtrace::fibonacci at 0x7FFEE1E0E4B0<br /> arg0: 0<br /> arg1: 1024<br />fibonacci of 20: 6765<br /><br />function backtrace::sum at 0x7FFEE1E0FE80<br /> arg0: 10<br />function backtrace::sum at 0x7FFEE1E0FC20<br /> arg0: 9<br />function backtrace::sum at 0x7FFEE1E0F9C0<br /> arg0: 8<br />function backtrace::sum at 0x7FFEE1E0F760<br /> arg0: 7<br />function backtrace::sum at 0x7FFEE1E0F500<br /> arg0: 6<br />function backtrace::sum at 0x7FFEE1E0F2A0<br /> arg0: 5<br />function backtrace::sum at 0x7FFEE1E0F040<br /> arg0: 4<br />function backtrace::sum at 0x7FFEE1E0EDE0<br /> arg0: 3<br />function backtrace::sum at 0x7FFEE1E0EB80<br /> arg0: 2<br />function backtrace::sum at 0x7FFEE1E0E920<br /> arg0: 1<br />function backtrace::sum at 0x7FFEE1E0E6C0<br /> arg0: 0<br />sum of 1 to 10: 55<br />&#96;&#96;&#96;<br /><br />## 说明<br /><br />* 使用 &#96;std::any::type_name::&lt;T&gt;()&#96; 获取函数符号名。<br />* 64 位程序&#xff0c;函数参数通过寄存器传递&#xff0c;具体使用哪几个寄存器因调用约定(calling convention)而异&#xff0c;如该同学使用的是 &#96;%rcx&#96;, &#96;%rdx&#96;, &#96;%r8&#96;, &#96;%r9&#96;。<br /></md><p></p>"}], "type": "note", "tags": ["lecture2", "student"], "tag_good": [{"role": "student", "name": "Ziqian Zhong", "endorser": {}, "admin": false, "photo": null, "id": "k6ogcaqgzlq47x", "photo_url": null, "us": false, "facebook_id": null}], "unique_views": 174, "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>金在源已补交 <a href=\"https://git.tsinghua.edu.cn/jin-zy16/os_hw/tree/master/lec2\">https://git.tsinghua.edu.cn/jin-zy16/os_hw/tree/master/lec2</a></p>", "created": "2020-02-23T09:45:54Z", "bucket_order": 34, "bucket_name": "Week 2/23 - 2/29", "type": "followup", "tag_good": [], "uid": "k6ps4vld2to58n", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "k6yuk5awg477h2", "updated": "2020-02-23T09:45:54Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>关于示例1&#xff08;C语言&#xff09;的实现有几个问题&#xff1a;</p>\n<p>1. <strong>函数调用参数</strong>这里只是简单地打印了从ebp到upper_ebp中所指向的所有内存&#xff0c;其中包含old_ebp, return_address等非函数调用参数。</p>\n<p>2. 想问backtrace_symbols()是怎样实现的呢&#xff1f;诸暨追溯我可以理解&#xff0c;但是如何根据每个函数的return_address得到函数名和偏置量&#xff08;如&#xff1a;test(_Z4fun1v&#43;0x17)&#xff09;呢&#xff1f;</p>", "created": "2020-02-24T05:14:25Z", "bucket_order": 34, "bucket_name": "Week 2/23 - 2/29", "type": "followup", "tag_good": [], "uid": "k6ohjbqv89e5ji", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<md>backtrace_symbols里面的信息应该是从ELF的动态符号表里面读出的\n&gt; Currently, the function name and offset can only be obtained on systems that use the ELF binary format for programs and libraries. On other systems, only the hexadecimal return address will be present. Also, you may need to pass additional flags to the linker to make the function names available to the program. (For example, on systems using GNU ld, you must pass -rdynamic.)\n\n&gt; -rdynamic\nPass the flag *-export-dynamic* to the ELF linker, on targets that support it. This instructs the linker to add all symbols, not only used ones, to the dynamic symbol table. This option is needed for some uses of *dlopen* or to allow obtaining backtraces from within a program.\n\n我试了一下&#xff0c;编译时如果不加-rdynamic选项&#xff0c;得到如下结果\n&#96;&#96;&#96;\nSigfault occured at 0xdeadbeef, from 0x560720b64a1a\nCall stack: \n11 /lib/x86_64-linux-gnu/libc.so.6(&#43;0x3ef20) [0x7f651528df20]\n10 ./main(&#43;0xa1a) [0x560720b64a1a]\n9 ./main(&#43;0xa36) [0x560720b64a36]\n8 ./main(&#43;0xa45) [0x560720b64a45]\n7 ./main(&#43;0xa45) [0x560720b64a45]\n6 ./main(&#43;0xa45) [0x560720b64a45]\n5 ./main(&#43;0xa45) [0x560720b64a45]\n4 ./main(&#43;0xa45) [0x560720b64a45]\n3 ./main(&#43;0xac6) [0x560720b64ac6]\n2 /lib/x86_64-linux-gnu/libc.so.6(__libc_start_main&#43;0xe7) [0x7f6515270b97]\n1 ./main(&#43;0x7da) [0x560720b647da]\n&#96;&#96;&#96;\n\n加了之后得到\n&#96;&#96;&#96;\nSigfault occured at 0xdeadbeef, from 0x55b1a2239c7a\nCall stack: \n11 /lib/x86_64-linux-gnu/libc.so.6(&#43;0x3ef20) [0x7fa94c084f20]\n10 ./main(_Z11faulty_funcv&#43;0x9) [0x55b1a2239c7a]\n9 ./main(_Z9recursioni&#43;0x16) [0x55b1a2239c96]\n8 ./main(_Z9recursioni&#43;0x25) [0x55b1a2239ca5]\n7 ./main(_Z9recursioni&#43;0x25) [0x55b1a2239ca5]\n6 ./main(_Z9recursioni&#43;0x25) [0x55b1a2239ca5]\n5 ./main(_Z9recursioni&#43;0x25) [0x55b1a2239ca5]\n4 ./main(_Z9recursioni&#43;0x25) [0x55b1a2239ca5]\n3 ./main(main&#43;0x7e) [0x55b1a2239d26]\n2 /lib/x86_64-linux-gnu/libc.so.6(__libc_start_main&#43;0xe7) [0x7fa94c067b97]\n1 ./main(_start&#43;0x2a) [0x55b1a2239a3a]\n&#96;&#96;&#96;\n可以使用&#96;readelf -s elf_name&#96;查看ELF的符号表&#xff0c;在我的程序里面&#xff0c;加了&#96;-rdynamic&#96;选项后&#xff0c;&#96;.dynsym&#96;表中将出现我自定义函数的符号&#xff0c;诸如\n&#96;&#96;&#96;\n20: 0000000000000c80    40 FUNC    GLOBAL DEFAULT   14 _Z9recursioni\n...\n29: 0000000000000c71    15 FUNC    GLOBAL DEFAULT   14 _Z11faulty_funcv\n&#96;&#96;&#96;\n\n\n参考[Backtraces (The GNU C Library)](https://www.gnu.org/software/libc/manual/html_node/Backtraces.html)\n</md>", "created": "2020-02-24T09:08:31Z", "bucket_order": 34, "bucket_name": "Week 2/23 - 2/29", "type": "feedback", "tag_good": [{"role": "student", "name": "Xuyang Jin", "endorser": {}, "admin": false, "photo": null, "id": "k6ohjbqv89e5ji", "photo_url": null, "us": false, "facebook_id": null}], "uid": "k6og1cszbk29q", "children": [], "tag_good_arr": ["k6ohjbqv89e5ji"], "id": "k708nxjmy5wkt", "updated": "2020-02-24T09:08:31Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "k700av1lxpu7pk", "updated": "2020-02-24T05:14:25Z", "config": {}}], "tag_good_arr": ["k6ogcaqgzlq47x"], "id": "k6wcubvzk935tn", "config": {"seen": {"583": 4, "34": 3, "1027": 6, "797": 8, "995": 9, "1146": 0, "1012": 7, "391": 5, "1194": 1, "1072": 2}}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 4, "num_favorites": 1, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169918675, "default_anonymity": "no"}, "error": null, "aid": "kyv0xzo3pbn7jy"}