{"result": {"folders": ["lab3"], "nr": 759, "data": {"embed_links": []}, "created": "2016-04-02T03:37:09Z", "bucket_order": 3, "no_answer_followup": 1, "change_log": [{"uid": "i0ccfx63sir1e", "anon": "no", "when": "2016-04-02T03:37:09Z", "data": "imil8lp2f8o1ri", "type": "create"}, {"uid": "i0ccfx63sir1e", "anon": "no", "when": "2016-04-02T03:38:52Z", "data": "imilat1uxje3xa", "type": "update"}, {"uid": "i0ccfx63sir1e", "anon": "no", "when": "2016-04-02T03:40:48Z", "data": "imildaqdhud4p7", "type": "update"}, {"uid": "i0ccfx63sir1e", "anon": "no", "when": "2016-04-02T03:41:44Z", "data": "imilehm7opo50s", "type": "update"}, {"uid": "i0ccfx63sir1e", "anon": "no", "when": "2016-04-02T03:42:03Z", "data": "imilewse3ku55u", "type": "update"}, {"uid": "i0ccfx63sir1e", "anon": "no", "when": "2016-04-02T03:44:34Z", "data": "imili4xwl0a6dl", "type": "update"}, {"uid": "i0ccfx63sir1e", "anon": "no", "when": "2016-04-02T03:45:05Z", "data": "imilit1tt636k5", "type": "update"}, {"uid": "i0ccfx63sir1e", "anon": "no", "when": "2016-04-02T03:45:34Z", "data": "imiljfnp9wt71s", "type": "update"}, {"uid": "i0ccfx63sir1e", "anon": "no", "when": "2016-04-02T03:46:39Z", "data": "imilktnc1y34df", "type": "update"}, {"uid": "i0ccfx63sir1e", "anon": "no", "when": "2016-04-02T03:48:18Z", "data": "imilmy193iz5me", "type": "update"}, {"uid": "i0ccfx63sir1e", "anon": "no", "when": "2016-04-02T03:50:55Z", "data": "imilqas8gco24k", "type": "update"}, {"uid": "i0ccfx63sir1e", "anon": "no", "when": "2016-04-02T03:52:39Z", "data": "imilsivsk162un", "type": "update"}, {"uid": "i0ccfx63sir1e", "anon": "no", "when": "2016-04-02T03:53:02Z", "data": "imilt0ugsdo39p", "type": "update"}, {"to": "imil8lp05rr1rh", "uid": "i6w84pnmjCQ", "anon": "no", "when": "2016-04-02T03:54:47Z", "type": "followup"}, {"uid": "i0ccfx63sir1e", "anon": "no", "when": "2016-04-02T03:56:55Z", "data": "imily0jcgfrbp", "type": "update"}, {"to": "imil8lp05rr1rh", "uid": "i0ccfx63sir1e", "anon": "no", "when": "2016-04-02T03:59:22Z", "type": "feedback"}, {"uid": "i0ccfx63sir1e", "anon": "no", "when": "2016-04-02T04:01:42Z", "data": "imim4674tmr2q5", "type": "update"}, {"uid": "i0ccfx63sir1e", "anon": "no", "when": "2016-04-02T04:04:17Z", "data": "imim7hui79040m", "type": "update"}, {"uid": "hs2swpdtr91gu", "anon": "no", "when": "2016-04-07T14:36:06Z", "data": "imqdza2gypb5m8", "type": "update"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hs2swpdtr91gu", "subject": "关于ucore的do_fault根据error code的分流处理", "created": "2016-04-07T14:36:06Z", "content": "<p><a href=\"https://www.piazza.com/class/i5j09fnsl7k5x0?cid=757\">https://piazza.com/class/i5j09fnsl7k5x0?cid=757</a></p>\n<p>我对该问题的理解&#xff0c;欢迎大家继续讨论。</p>\n<p></p>\n<p>1、lab的代码注释里这样描述3个flag bits&#xff1a;</p>\n<pre>-- The P flag (bit 0) indicates whether the exception was due to a not-present page (0)\n                      or to either an access rights violation or the use of a reserved bit (1).\n-- The W/R flag (bit 1) indicates whether the memory access that caused the exception\n                        was a read (0) or write (1).\n-- The U/S flag (bit 2) indicates whether the processor was executing at user mode (1)\n                        or supervisor mode (0) at the time of the exception.</pre>\n<p>2、Intel Manual的相关描述&#xff0c;截取片段&#xff1a;</p>\n<p><img src=\"/img/759-1dd0c9cc236a5e9.png\" width=\"478\" height=\"310\" /></p>\n<p>小结intel的文档内容&#xff1a;</p>\n<ul><li>造成page fault有两种情况<ol><li>线性地址转换无效&#xff1b;</li><li>线性地址转换有效&#xff0c;但权限不合法。</li></ol></li><li>线性地址转换无效的原因\n<ul><li>页表项的P位为0&#xff0c;或保留位reserved为1。</li></ul>\n</li><li>error code的P位\n<ul><li>如果页表项的P位为0&#xff0c;则error code的P位为0。</li></ul>\n</li></ul>\n<p>3、清晰的error code的图表示</p>\n<p><img src=\"/img/759-56fb6ca8cf37e456.png\" width=\"476\" height=\"295\" /></p>\n<p>4、结论</p>\n<ul><li>从文档和图示&#xff0c;基本能得知x86的page-fault及其发生时的error code的工作。</li><li>error code的P位\n<ul><li>P位为0时&#xff0c;表示page-fault缺页&#xff08;准确来说&#xff0c;是entry的P位为0&#xff09;。</li><li>P位为1时&#xff0c;则不是因为缺页&#xff0c;而是因为page-level protection violation&#xff0c;即我们应该检测后面的标志位。</li></ul>\n</li><li>ucore的do_pgfault中\n<ul><li>P为0的处理&#xff0c;即case 0和case 2&#xff0c;作为缺页处理&#xff0c;没问题。</li><li>P为1时&#xff0c;这时应该检测后面的标志位。先看case 1&#xff0c;ucore直接failed&#xff0c;也就是说&#xff0c;非缺页的读操作产生的page fault&#xff0c;ucore不做处理&#xff08;后面的U/S、RSVD或I/D的错误&#xff09;&#xff0c;可以理解&#xff0c;没问题。再看看case 3&#xff0c;ucore先检测虚地址管理vma的写位&#xff0c;如果vma有写的权限&#xff0c;而发生了page fault&#xff0c;那么可能是entry没有写权限&#xff0c;因此可以尝试在entry添加上写权限。问题在于&#xff0c;如果不是因为entry的写权限造成的page fault的呢&#xff1f;此时ucore将陷入死循环&#xff01;</li></ul>\n</li><li>简单总结\n<ul><li>ucore的page fault处理P=1,W/R=1的情况时&#xff0c;只处理了因为entry缺少写权限的情况&#xff0c;而没有考虑entry有写权限而由其它权限造成的异常&#xff0c;该处理可能导致ucore陷入死循环。赞同高思达同学对此处的质疑。</li></ul>\n</li></ul>\n<p>5、参考</p>\n<ul><li>Intel 64 and IA-32 ASD’s Manual 3A, Chapter 4, 4.7 PAGE-FAULT EXCEPTIONS</li><li>Intel 64 and IA-32 ASD’s Manual 3A, Chapter 6, 6.15 EXCEPTION AND INTERRUPT REFERENCE</li></ul>"}, {"anon": "no", "uid": "i0ccfx63sir1e", "subject": "关于ucore的do_fault根据error code的分流处理", "created": "2016-04-02T04:04:17Z", "content": "<p><a href=\"https://www.piazza.com/class/i5j09fnsl7k5x0?cid=757\">https://piazza.com/class/i5j09fnsl7k5x0?cid=757</a></p>\n<p>我对该问题的理解&#xff0c;欢迎大家继续讨论。</p>\n<p></p>\n<p>1、lab的代码注释里这样描述3个flag bits&#xff1a;</p>\n<pre>-- The P flag (bit 0) indicates whether the exception was due to a not-present page (0)\n                      or to either an access rights violation or the use of a reserved bit (1).\n-- The W/R flag (bit 1) indicates whether the memory access that caused the exception\n                        was a read (0) or write (1).\n-- The U/S flag (bit 2) indicates whether the processor was executing at user mode (1)\n                        or supervisor mode (0) at the time of the exception.</pre>\n<p>2、Intel Manual的相关描述&#xff0c;截取片段&#xff1a;</p>\n<p><img src=\"/img/759-1dd0c9cc236a5e9.png\" width=\"478\" height=\"310\" /></p>\n<p>小结intel的文档内容&#xff1a;</p>\n<ul><li>造成page fault有两种情况<ol><li>线性地址转换无效&#xff1b;</li><li>线性地址转换有效&#xff0c;但权限不合法。</li></ol></li><li>线性地址转换无效的原因\n<ul><li>页表项的P位为0&#xff0c;或保留位reserved为1。</li></ul>\n</li><li>error code的P位\n<ul><li>如果页表项的P位为0&#xff0c;则error code的P位为0。</li></ul>\n</li></ul>\n<p>3、清晰的error code的图表示</p>\n<p><img src=\"/img/759-56fb6ca8cf37e456.png\" width=\"476\" height=\"295\" /></p>\n<p>4、结论</p>\n<ul><li>从文档和图示&#xff0c;基本能得知x86的page-fault及其发生时的error code的工作。</li><li>error code的P位\n<ul><li>P位为0时&#xff0c;表示page-fault缺页&#xff08;准确来说&#xff0c;是entry的P位为0&#xff09;。</li><li>P位为1时&#xff0c;则不是因为缺页&#xff0c;而是因为page-level protection violation&#xff0c;即我们应该检测后面的标志位。</li></ul>\n</li><li>ucore的do_pgfault中\n<ul><li>P为0的处理&#xff0c;即case 0和case 2&#xff0c;作为缺页处理&#xff0c;没问题。</li><li>P为1时&#xff0c;这时应该检测后面的标志位。先看case 1&#xff0c;ucore直接failed&#xff0c;也就是说&#xff0c;非缺页的读操作产生的page fault&#xff0c;ucore不做处理&#xff08;后面的U/S、RSVD或I/D的错误&#xff09;&#xff0c;可以理解&#xff0c;没问题。再看看case 3&#xff0c;ucore先检测虚地址管理vma的写位&#xff0c;如果vma有写的权限&#xff0c;而发生了page fault&#xff0c;那么可能是entry没有写权限&#xff0c;因此可以尝试在entry添加上写权限。问题在于&#xff0c;如果不是因为entry的写权限造成的page fault的呢&#xff1f;此时ucore将陷入死循环&#xff01;</li></ul>\n</li><li>简单总结\n<ul><li>ucore的page fault处理P=1,W/R=1的情况时&#xff0c;只处理了因为entry缺少写权限的情况&#xff0c;而没有考虑entry有写权限而由其它权限造成的异常&#xff0c;该处理可能导致ucore陷入死循环。赞同高思达同学对此处的质疑。</li></ul>\n</li></ul>\n<p>5、参考</p>\n<ul><li>Intel 64 and IA-32 ASD’s Manual 3A, Chapter 4, 4.7 PAGE-FAULT EXCEPTIONS</li><li>Intel 64 and IA-32 ASD’s Manual 3A, Chapter 6, 6.15 EXCEPTION AND INTERRUPT REFERENCE</li></ul>"}, {"anon": "no", "uid": "i0ccfx63sir1e", "subject": "关于ucore的do_fault根据error code的分流处理", "created": "2016-04-02T04:01:42Z", "content": "<p><a href=\"https://www.piazza.com/class/i5j09fnsl7k5x0?cid=757\">https://piazza.com/class/i5j09fnsl7k5x0?cid=757</a></p>\n<p>我对该问题的理解&#xff0c;欢迎大家继续讨论。</p>\n<p></p>\n<p>1、lab的代码注释里这样描述3个flag bits&#xff1a;</p>\n<pre>-- The P flag (bit 0) indicates whether the exception was due to a not-present page (0)\n                      or to either an access rights violation or the use of a reserved bit (1).\n-- The W/R flag (bit 1) indicates whether the memory access that caused the exception\n                        was a read (0) or write (1).\n-- The U/S flag (bit 2) indicates whether the processor was executing at user mode (1)\n                        or supervisor mode (0) at the time of the exception.</pre>\n<p>2、Intel Manual的相关描述&#xff0c;截取片段&#xff1a;</p>\n<p><img src=\"/img/759-1dd0c9cc236a5e9.png\" width=\"478\" height=\"310\" /></p>\n<p>小结intel的文档内容&#xff1a;</p>\n<ul><li>造成page fault有两种情况<ol><li>线性地址转换无效&#xff1b;</li><li>线性地址转换有效&#xff0c;但权限不合法。</li></ol></li><li>线性地址转换无效的原因\n<ul><li>页表项的P位为0&#xff0c;或保留位reserved为1。</li></ul>\n</li><li>error code的P位\n<ul><li>如果页表项的P位为0&#xff0c;则error code的P位为0。</li></ul>\n</li></ul>\n<p>3、清晰的error code的图表示</p>\n<p><img src=\"/img/759-56fb6ca8cf37e456.png\" width=\"476\" height=\"295\" /></p>\n<p>4、结论</p>\n<ul><li>从文档和图示&#xff0c;基本能得知x86的page-fault及其发生时的error code的工作。</li><li>error code的P位\n<ul><li>P位为0时&#xff0c;表示page-fault缺页&#xff08;准确来说&#xff0c;是entry的P位为0&#xff09;。</li><li>P位为1时&#xff0c;则不是因为缺页&#xff0c;而是因为page-level protection violation&#xff0c;即我们应该检测后面的标志位。</li></ul>\n</li><li>ucore的do_pgfault中\n<ul><li>P为0的处理&#xff0c;即case 0和case 2&#xff0c;作为缺页处理&#xff0c;没问题。</li><li>P为1时&#xff0c;这时应该检测后面的标志位。先看case 1&#xff0c;ucore直接failed&#xff0c;也就是说&#xff0c;非缺页的读操作产生的page fault&#xff0c;ucore不做处理&#xff08;后面的U/S、RSVD或I/D的错误&#xff09;&#xff0c;可以理解&#xff0c;没问题。再看看case 3&#xff0c;ucore先检测虚地址管理vma的写位&#xff0c;如果vma有写的权限&#xff0c;而发生了page fault&#xff0c;那么可能是entry没有写权限&#xff0c;因此可以尝试在entry添加上写权限。问题在于&#xff0c;如果不是因为entry的写权限造成的page fault的呢&#xff1f;此时ucore将陷入死循环&#xff01;</li></ul>\n</li><li>简单总结\n<ul><li>ucore的page fault处理P=1,W/R=1的情况时&#xff0c;只处理了因为entry缺少写权限的情况&#xff0c;而没有考虑entry有写权限而由其它权限造成的异常&#xff0c;该处理可能导致ucore陷入死循环。赞同高思达同学对此处的质疑。既然do_pgfault将error_code与操作3&#xff0c;那么就是不考虑P位和W/R位以外的标志位&#xff0c;那么最好case 3像case 1那样处理比较好。事实上&#xff0c;do_pgfault用switch(error_code&amp;3)分类处理不太妥&#xff0c;可以考虑为串行&#xff0c;如if(error_code&amp;1)、if(error_code&amp;2)~</li></ul>\n</li></ul>\n<p>5、参考</p>\n<ul><li>Intel 64 and IA-32 ASD’s Manual 3A, Chapter 4, 4.7 PAGE-FAULT EXCEPTIONS</li><li>Intel 64 and IA-32 ASD’s Manual 3A, Chapter 6, 6.15 EXCEPTION AND INTERRUPT REFERENCE</li></ul>"}, {"anon": "no", "uid": "i0ccfx63sir1e", "subject": "关于ucore的do_fault根据error code的分流处理", "created": "2016-04-02T03:56:55Z", "content": "<p><a href=\"https://www.piazza.com/class/i5j09fnsl7k5x0?cid=757\">https://piazza.com/class/i5j09fnsl7k5x0?cid=757</a></p>\n<p>我对该问题的理解&#xff0c;欢迎大家继续讨论。</p>\n<p></p>\n<p>1、lab的代码注释里这样描述3个flag bits&#xff1a;</p>\n<pre>-- The P flag (bit 0) indicates whether the exception was due to a not-present page (0)\n                      or to either an access rights violation or the use of a reserved bit (1).\n-- The W/R flag (bit 1) indicates whether the memory access that caused the exception\n                        was a read (0) or write (1).\n-- The U/S flag (bit 2) indicates whether the processor was executing at user mode (1)\n                        or supervisor mode (0) at the time of the exception.</pre>\n<p>2、Intel Manual的相关描述&#xff0c;截取片段&#xff1a;</p>\n<p><img src=\"/img/759-1dd0c9cc236a5e9.png\" width=\"478\" height=\"310\" /></p>\n<p>小结intel的文档内容&#xff1a;</p>\n<ul><li>造成page fault有两种情况<ol><li>线性地址转换无效&#xff1b;</li><li>线性地址转换有效&#xff0c;但权限不合法。</li></ol></li><li>线性地址转换无效的原因\n<ul><li>页表项的P位为0&#xff0c;或保留位reserved为1。</li></ul>\n</li><li>error code的P位\n<ul><li>如果页表项的P位为0&#xff0c;则error code的P位为0。</li></ul>\n</li></ul>\n<p>3、清晰的error code的图表示</p>\n<p><img src=\"/img/759-56fb6ca8cf37e456.png\" width=\"476\" height=\"295\" /></p>\n<p>4、结论</p>\n<ul><li>从文档和图示&#xff0c;基本能得知x86的page-fault及其发生时的error code的工作。</li><li>error code的P位\n<ul><li>P位为0时&#xff0c;表示page-fault缺页&#xff08;准确来说&#xff0c;是entry的P位为0&#xff09;。</li><li>P位为1时&#xff0c;则不是因为缺页&#xff0c;而是因为page-level protection violation&#xff0c;即我们应该检测后面的标志位。</li></ul>\n</li><li>ucore的do_pgfault中\n<ul><li>P为0的处理&#xff0c;即case 0和case 2&#xff0c;作为缺页处理&#xff0c;没问题。</li><li>P为1时&#xff0c;这时应该检测后面的标志位。先看case 1&#xff0c;ucore直接failed&#xff0c;也就是说&#xff0c;非缺页的读操作产生的page fault&#xff0c;ucore不做处理&#xff08;后面的U/S、RSVD或I/D的错误&#xff09;&#xff0c;可以理解&#xff0c;没问题。再看看case 3&#xff0c;ucore先检测虚地址管理vma的写位&#xff0c;如果vma有写的权限&#xff0c;而发生了page fault&#xff0c;那么可能是entry没有写权限&#xff0c;因此可以尝试在entry添加上写权限。问题在于&#xff0c;如果不是因为entry的写权限造成的page fault的呢&#xff1f;此时ucore将陷入死循环&#xff01;</li></ul>\n</li><li>简单总结\n<ul><li>ucore的page fault处理P=1,W/R=1的情况时&#xff0c;只处理了因为entry缺少写权限的情况&#xff0c;而没有考虑entry有写权限而由其它权限造成的异常&#xff0c;该处理可能导致ucore陷入死循环。赞同高思达同学对此处的质疑。既然do_pgfault将error_code与操作3&#xff0c;那么就是不考虑P位和W/R位以外的标志位&#xff0c;那么最好case 3像case 1那样处理比较好。事实上&#xff0c;do_pgfault用switch(error_code&amp;3)分类处理不太妥&#xff0c;可以考虑为串行&#xff0c;如if(error_code&amp;1)、if(error_code&amp;2)~</li></ul>\n</li></ul>\n<p></p>"}, {"anon": "no", "uid": "i0ccfx63sir1e", "subject": "关于ucore的do_fault根据error code的分流处理", "created": "2016-04-02T03:53:02Z", "content": "<p><a href=\"https://www.piazza.com/class/i5j09fnsl7k5x0?cid=757\">https://piazza.com/class/i5j09fnsl7k5x0?cid=757</a></p>\n<p>我对该问题的理解&#xff0c;欢迎大家继续讨论。</p>\n<p></p>\n<p>1、lab的代码注释里这样描述3个flag bits&#xff1a;</p>\n<pre>-- The P flag (bit 0) indicates whether the exception was due to a not-present page (0)\n                      or to either an access rights violation or the use of a reserved bit (1).\n-- The W/R flag (bit 1) indicates whether the memory access that caused the exception\n                        was a read (0) or write (1).\n-- The U/S flag (bit 2) indicates whether the processor was executing at user mode (1)\n                        or supervisor mode (0) at the time of the exception.</pre>\n<p>2、Intel Manual的相关描述&#xff0c;截取片段&#xff1a;</p>\n<p><img src=\"/img/759-1dd0c9cc236a5e9.png\" width=\"478\" height=\"310\" /></p>\n<p>小结intel的文档内容&#xff1a;</p>\n<ul><li>造成page fault有两种情况<ol><li>线性地址转换无效&#xff1b;</li><li>线性地址转换有效&#xff0c;但权限不合法。</li></ol></li><li>线性地址转换无效的原因\n<ul><li>页表项的P位为0&#xff0c;或保留位reserved为1。</li></ul>\n</li><li>error code的P位\n<ul><li>如果页表项的P位为0&#xff0c;则error code的P位为0。</li></ul>\n</li></ul>\n<p>3、清晰的error code的图表示</p>\n<p><img src=\"/img/759-56fb6ca8cf37e456.png\" width=\"476\" height=\"295\" /></p>\n<p>4、结论</p>\n<ul><li>从文档和图示&#xff0c;基本能得知x86的page-fault及其发生时的error code的工作。</li><li>error code的P位\n<ul><li>P位为0时&#xff0c;表示page-fault缺页&#xff08;准确来说&#xff0c;是entry的P位为0&#xff09;。</li><li>P位为1时&#xff0c;则不是因为缺页&#xff0c;而是因为page-level protection violation&#xff0c;即我们应该检测后面的标志位。</li></ul>\n</li><li>ucore的do_pgfault中\n<ul><li>P为0的处理&#xff0c;即case 0和case 2&#xff0c;作为缺页处理&#xff0c;没问题。</li><li>P为1时&#xff0c;这时应该检测后面的标志位。先看case 1&#xff0c;ucore直接failed&#xff0c;也就是说&#xff0c;非缺页的读操作产生的page fault&#xff0c;ucore不做处理&#xff08;后面的U/S、RSVD或I/D的错误&#xff09;&#xff0c;可以理解&#xff0c;没问题。再看看case 3&#xff0c;ucore先检测虚地址管理vma的写位&#xff0c;如果vma有写的权限&#xff0c;而发生了page fault&#xff0c;那么可能是entry没有写权限&#xff0c;因此可以尝试在entry添加上写权限。问题在于&#xff0c;如果不是因为entry的写权限造成的page fault的呢&#xff1f;此时ucore将陷入死循环&#xff01;</li></ul>\n</li><li>简单总结\n<ul><li>ucore的page fault处理P=1,W/R=1的情况时&#xff0c;只处理了因为entry缺少写权限的情况&#xff0c;而没有考虑entry有写权限而由其它权限造成的异常&#xff0c;该处理可能导致ucore陷入死循环。赞同高思达同学对此处的质疑。</li></ul>\n</li></ul>\n<p></p>"}, {"anon": "no", "uid": "i0ccfx63sir1e", "subject": "关于ucore的do_fault根据error code的分流处理", "created": "2016-04-02T03:52:39Z", "content": "<p><a href=\"https://www.piazza.com/class/i5j09fnsl7k5x0?cid=757\">https://piazza.com/class/i5j09fnsl7k5x0?cid=757</a></p>\n<p>我对该问题的理解&#xff0c;欢迎大家继续讨论。</p>\n<p></p>\n<p>1、lab的代码注释里这样描述3个flag bits&#xff1a;</p>\n<pre>-- The P flag (bit 0) indicates whether the exception was due to a not-present page (0)\n                      or to either an access rights violation or the use of a reserved bit (1).\n-- The W/R flag (bit 1) indicates whether the memory access that caused the exception\n                        was a read (0) or write (1).\n-- The U/S flag (bit 2) indicates whether the processor was executing at user mode (1)\n                        or supervisor mode (0) at the time of the exception.</pre>\n<p>2、Intel Manual的相关描述&#xff0c;截取片段&#xff1a;</p>\n<p><img src=\"/img/759-1dd0c9cc236a5e9.png\" width=\"478\" height=\"310\" /></p>\n<p>小结intel的文档内容&#xff1a;</p>\n<ul><li>造成page fault有两种情况<ol><li>线性地址转换无效&#xff1b;</li><li>线性地址转换有效&#xff0c;但权限不合法。</li></ol></li><li>线性地址转换无效的原因\n<ul><li>页表项的P位为0&#xff0c;或保留位reserved为1。</li></ul>\n</li><li>error code的P位\n<ul><li>如果页表项的P位为0&#xff0c;则error code的P位为0。</li></ul>\n</li></ul>\n<p>3、清晰的error code的图表示</p>\n<p><img src=\"/img/759-56fb6ca8cf37e456.png\" width=\"476\" height=\"295\" /></p>\n<p>4、结论</p>\n<ul><li>从文档和图示&#xff0c;基本能得知x86的page-fault及其发生时的error code的工作。</li><li>error code的P位\n<ul><li>P位为0时&#xff0c;表示page-fault缺页&#xff08;准确来说&#xff0c;是entry的P位为0&#xff09;。</li><li>P位为1时&#xff0c;则不是因为缺页&#xff0c;而是因为page-level protection violation&#xff0c;即我们应该检测后面的标志位。</li></ul>\n</li><li>ucore的do_pgfault中\n<ul><li>P为0的处理&#xff0c;即case 0和case 2&#xff0c;作为缺页处理&#xff0c;没问题。</li><li>P为1时&#xff0c;这时应该检测后面的标志位。先看case 1&#xff0c;ucore直接failed&#xff0c;也就是说&#xff0c;非缺页的读操作产生的page fault&#xff0c;ucore不做处理&#xff08;后面的U/S、RSVD或I/D的错误&#xff09;&#xff0c;可以理解&#xff0c;没问题。再看看case 3&#xff0c;ucore先检测虚地址管理vma的写位&#xff0c;如果vma有写的权限&#xff0c;而发生了page fault&#xff0c;那么可能是entry没有写权限&#xff0c;因此可以尝试在entry添加上写权限。问题在于&#xff0c;如果不是因为entry的写权限造成的page fault的呢&#xff1f;此时ucore将陷入死循环&#xff01;</li></ul>\n</li><li>简单总结\n<ul><li>ucore的page fault处理P=1,W/R=1的情况时&#xff0c;只处理了因为entry缺少写权限的情况&#xff0c;而没有考虑entry有写权限而由其它权限造成的异常&#xff0c;该处理可能导致ucore陷入死循环。赞同高思达同学认为此处的error code的处理有问题。</li></ul>\n</li></ul>\n<p></p>"}, {"anon": "no", "uid": "i0ccfx63sir1e", "subject": "关于ucore的do_fault根据error code的分流处理", "created": "2016-04-02T03:50:55Z", "content": "<p><a href=\"https://www.piazza.com/class/i5j09fnsl7k5x0?cid=757\">https://piazza.com/class/i5j09fnsl7k5x0?cid=757</a></p>\n<p>我对该问题的理解&#xff0c;欢迎大家继续讨论。</p>\n<p></p>\n<p>1、lab的代码注释里这样描述3个flag bits&#xff1a;</p>\n<pre>-- The P flag (bit 0) indicates whether the exception was due to a not-present page (0)\n                      or to either an access rights violation or the use of a reserved bit (1).\n-- The W/R flag (bit 1) indicates whether the memory access that caused the exception\n                        was a read (0) or write (1).\n-- The U/S flag (bit 2) indicates whether the processor was executing at user mode (1)\n                        or supervisor mode (0) at the time of the exception.</pre>\n<p>2、Intel Manual的相关描述&#xff0c;截取片段&#xff1a;</p>\n<p><img src=\"/img/759-1dd0c9cc236a5e9.png\" width=\"478\" height=\"310\" /></p>\n<p>小结intel的文档内容&#xff1a;</p>\n<ul><li>造成page fault有两种情况<ol><li>线性地址转换无效&#xff1b;</li><li>线性地址转换有效&#xff0c;但权限不合法。</li></ol></li><li>线性地址转换无效的原因\n<ul><li>页表项的P位为0&#xff0c;或保留位reserved为1。</li></ul>\n</li><li>error code的P位\n<ul><li>如果页表项的P位为0&#xff0c;则error code的P位为0。</li></ul>\n</li></ul>\n<p>3、清晰的error code的图表示</p>\n<p><img src=\"/img/759-56fb6ca8cf37e456.png\" width=\"476\" height=\"295\" /></p>\n<p>4、结论</p>\n<ul><li>从文档和图示&#xff0c;基本能得知x86的page-fault及其发生时的error code的工作。</li><li>error code的P位\n<ul><li>P位为0时&#xff0c;表示page-fault缺页&#xff08;准确来说&#xff0c;是entry的P位为0&#xff09;。</li><li>P位为1时&#xff0c;则不是因为缺页&#xff0c;而是因为page-level protection violation&#xff0c;即我们应该检测后面的标志位。</li></ul>\n</li><li>ucore的do_pgfault中\n<ul><li>P为0的处理&#xff0c;即case 0和case 2&#xff0c;作为缺页处理&#xff0c;没问题。</li><li>P为1时&#xff0c;这时应该检测后面的标志位。先看case 1&#xff0c;ucore直接failed&#xff0c;也就是说&#xff0c;非缺页的读操作产生的page fault&#xff0c;ucore不做处理&#xff08;后面的U/S、RSVD或I/D的错误&#xff09;&#xff0c;可以理解&#xff0c;没问题。再看看case 3&#xff0c;ucore先检测虚地址管理vma的写位&#xff0c;如果vma有写的权限&#xff0c;而发生了page fault&#xff0c;那么可能是entry没有写权限&#xff0c;因此可以尝试在entry添加上写权限。问题在于&#xff0c;如果不是因为entry的写权限造成的page fault的呢&#xff1f;此时ucore将陷入死循环&#xff01;</li></ul>\n</li><li>简单总结\n<ul><li>ucore的page fault处理P=1,W/R=1的情况时&#xff0c;只处理了因为entry缺少写权限的情况&#xff0c;而没有考虑entry有写权限&#xff0c;由于其它权限造成的异常&#xff0c;该处理可能导致ucore陷入死循环。赞同高思达同学认为此处的error code的处理有问题。</li></ul>\n</li></ul>\n<p></p>"}, {"anon": "no", "uid": "i0ccfx63sir1e", "subject": "关于ucore的do_fault根据error code的分流处理", "created": "2016-04-02T03:48:18Z", "content": "<p><a href=\"https://www.piazza.com/class/i5j09fnsl7k5x0?cid=757\">https://piazza.com/class/i5j09fnsl7k5x0?cid=757</a></p>\n<p>我对该问题的理解&#xff0c;欢迎大家继续讨论。</p>\n<p></p>\n<p>1、lab的代码注释里这样描述3个flag bits&#xff1a;</p>\n<pre>-- The P flag (bit 0) indicates whether the exception was due to a not-present page (0)\n                      or to either an access rights violation or the use of a reserved bit (1).\n-- The W/R flag (bit 1) indicates whether the memory access that caused the exception\n                        was a read (0) or write (1).\n-- The U/S flag (bit 2) indicates whether the processor was executing at user mode (1)\n                        or supervisor mode (0) at the time of the exception.</pre>\n<p>2、Intel Manual的相关描述&#xff0c;截取片段&#xff1a;</p>\n<p><img src=\"/img/759-1dd0c9cc236a5e9.png\" width=\"478\" height=\"310\" /></p>\n<p>小结intel的文档内容&#xff1a;</p>\n<ul><li>造成page fault有两种情况<ol><li>线性地址转换无效&#xff1b;</li><li>线性地址转换有效&#xff0c;但权限不合法。</li></ol></li><li>线性地址转换无效的原因\n<ul><li>页表项的P位为0&#xff0c;或保留位reserved为1。</li></ul>\n</li><li>error code的P位\n<ul><li>如果页表项的P位为0&#xff0c;则error code的P位为0。</li></ul>\n</li></ul>\n<p>3、清晰的error code的图表示</p>\n<p><img src=\"/img/759-56fb6ca8cf37e456.png\" width=\"476\" height=\"295\" /></p>\n<p>4、结论</p>\n<ul><li>从文档和图示&#xff0c;基本能得知x86的page-fault及其发生时的error code的工作。</li><li>error code的P位\n<ul><li>P位为0时&#xff0c;表示page-fault缺页&#xff08;准确来说&#xff0c;是entry的P位为0&#xff09;。</li><li>P位为1时&#xff0c;则不是因为缺页&#xff0c;而是因为page-level protection violation&#xff0c;即我们应该检测后面的标志位。</li></ul>\n</li><li>ucore的do_pgfault中\n<ul><li>P为0的处理&#xff0c;即case 0和case 2&#xff0c;正确地检测其它位&#xff0c;并作为缺页处理&#xff0c;没问题。</li><li>P为1时&#xff0c;这时应该检测后面的标志位&#xff0c;先看case 1&#xff0c;ucore直接failed&#xff0c;也就是说&#xff0c;非缺页的读操作产生的page fault&#xff0c;ucore不做处理&#xff08;后面的U/S、RSVD或I/D的错误&#xff09;&#xff0c;可以理解&#xff0c;没问题。再看看case 3&#xff0c;ucore先检测虚地址管理vma的写位&#xff0c;如果vma有写的权限&#xff0c;而发生了page fault&#xff0c;那么可能是entry没有写权限&#xff0c;因此可以尝试在entry添加上写权限。问题在于&#xff0c;如果不是因为entry的写权限造成的page fault的呢&#xff1f;此时ucore将陷入死循环&#xff01;</li></ul>\n</li><li>简单总结\n<ul><li>ucore的page fault处理P=1,W/R=1的情况时&#xff0c;只处理了因为entry缺少写权限的情况&#xff0c;而没有考虑entry有写权限&#xff0c;由于其它权限造成的异常&#xff0c;该处理可能导致ucore陷入死循环。赞同高思达同学认为此处的error code的处理有问题。</li></ul>\n</li></ul>\n<p></p>"}, {"anon": "no", "uid": "i0ccfx63sir1e", "subject": "关于ucore的do_fault根据error code的分流处理", "created": "2016-04-02T03:46:39Z", "content": "<p><a href=\"https://www.piazza.com/class/i5j09fnsl7k5x0?cid=757\">https://piazza.com/class/i5j09fnsl7k5x0?cid=757</a></p>\n<p>我对该问题的理解&#xff0c;欢迎大家继续讨论。</p>\n<p></p>\n<p>1、lab的代码注释里这样描述3个flag bits&#xff1a;</p>\n<pre>-- The P flag (bit 0) indicates whether the exception was due to a not-present page (0)\n                      or to either an access rights violation or the use of a reserved bit (1).\n-- The W/R flag (bit 1) indicates whether the memory access that caused the exception\n                        was a read (0) or write (1).\n-- The U/S flag (bit 2) indicates whether the processor was executing at user mode (1)\n                        or supervisor mode (0) at the time of the exception.</pre>\n<p>2、Intel Manual的相关描述&#xff0c;截取片段&#xff1a;</p>\n<p><img src=\"/img/759-1dd0c9cc236a5e9.png\" width=\"478\" height=\"310\" /></p>\n<p>小结intel的文档内容&#xff1a;</p>\n<ul><li>造成page fault有两种情况<ol><li>线性地址转换无效&#xff1b;</li><li>线性地址转换有效&#xff0c;但权限不合法。</li></ol></li><li>线性地址转换无效的原因\n<ul><li>页表项的P位为0&#xff0c;或保留位reserved为1。</li></ul>\n</li><li>error code的P位\n<ul><li>如果页表项的P位为0&#xff0c;则error code的P位为0。</li></ul>\n</li></ul>\n<p>3、清晰的error code的图表示</p>\n<p><img src=\"/img/759-56fb6ca8cf37e456.png\" width=\"476\" height=\"295\" /></p>\n<p>4、结论</p>\n<ul><li>从文档和图示&#xff0c;基本能得知x86的page-fault及其发生时的error code的工作。</li><li>error code的P位\n<ul><li>P位为0时&#xff0c;表示page-fault缺页&#xff08;准确来说&#xff0c;是entry的P位为0&#xff09;。</li><li>P位为1时&#xff0c;则不是因为缺页&#xff0c;而是因为page-level protection violation&#xff0c;即我们应该检测后面的标志位。</li></ul>\n</li><li>ucore的do_pgfault中\n<ul><li>P为0的处理&#xff0c;即case 0和case 2&#xff0c;正确地检测其它位&#xff0c;并作为缺页处理&#xff0c;没问题。</li><li>P为1时&#xff0c;这时应该检测后面的标志位&#xff0c;先看case 1&#xff0c;ucore直接failed&#xff0c;也就是如果不是缺页的读操作产生的page fault&#xff0c;那么就是后面的U/S、RSVD或I/D的错误&#xff0c;ucore不做处理&#xff0c;可以理解&#xff0c;没问题。再看看case 3&#xff0c;ucore先检测虚地址管理vma的写位&#xff0c;如果vma有写的权限&#xff0c;而发生了page fault&#xff0c;那么可能是entry没有写权限&#xff0c;因此可以尝试在entry添加上写权限。问题在于&#xff0c;如果不是因为entry的写权限造成的page fault的呢&#xff1f;此时ucore将陷入死循环&#xff01;</li></ul>\n</li><li>简单总结\n<ul><li>ucore的page fault处理P=1,W/R=1的情况时&#xff0c;只处理了因为entry缺少写权限的情况&#xff0c;而没有考虑entry有写权限&#xff0c;由于其它权限造成的异常&#xff0c;该处理可能导致ucore陷入死循环。赞同高思达同学认为此处的error code的处理有问题。</li></ul>\n</li></ul>\n<p></p>"}, {"anon": "no", "uid": "i0ccfx63sir1e", "subject": "关于ucore的do_fault根据error code的分流处理", "created": "2016-04-02T03:45:34Z", "content": "<p><a href=\"https://www.piazza.com/class/i5j09fnsl7k5x0?cid=757\">https://piazza.com/class/i5j09fnsl7k5x0?cid=757</a></p>\n<p>我对该问题的理解&#xff0c;欢迎大家继续讨论。</p>\n<p></p>\n<p>1、lab的代码注释里这样描述3个flag bits&#xff1a;</p>\n<pre>-- The P flag (bit 0) indicates whether the exception was due to a not-present page (0)\n                      or to either an access rights violation or the use of a reserved bit (1).\n-- The W/R flag (bit 1) indicates whether the memory access that caused the exception\n                        was a read (0) or write (1).\n-- The U/S flag (bit 2) indicates whether the processor was executing at user mode (1)\n                        or supervisor mode (0) at the time of the exception.</pre>\n<p>2、Intel Manual的相关描述&#xff0c;截取片段&#xff1a;</p>\n<p><img src=\"/img/759-1dd0c9cc236a5e9.png\" width=\"478\" height=\"310\" /></p>\n<p>小结intel的文档内容&#xff1a;</p>\n<ul><li>造成page fault有两种情况<ol><li>线性地址转换无效&#xff1b;</li><li>线性地址转换有效&#xff0c;但权限不合法。</li></ol></li><li>线性地址转换无效的原因\n<ul><li>页表项的P位为0&#xff0c;或保留位reserved为1。</li></ul>\n</li><li>error code的P位\n<ul><li>如果页表项的P位为0&#xff0c;则error code的P位为0。</li></ul>\n</li></ul>\n<p>3、清晰的error code的图表示</p>\n<p><img src=\"/img/759-56fb6ca8cf37e456.png\" width=\"476\" height=\"295\" /></p>\n<p>4、结论</p>\n<ul><li>从文档和图示&#xff0c;基本能得知x86的page-fault及其发生时的error code的工作。</li><li>error codeP位为0时&#xff0c;表示page-fault缺页&#xff08;准确来说&#xff0c;是entry的P位为0&#xff09;&#xff1b;P位为1时&#xff0c;则不是因为缺页&#xff0c;而是因为page-level protection violation&#xff0c;即我们应该检测后面的标志位。</li><li>ucore的do_pgfault中&#xff1a; P为0的处理&#xff0c;即case 0和case 2&#xff0c;正确地检测其它位&#xff0c;并作为缺页处理&#xff0c;没问题。 P为1时&#xff0c;这时应该检测后面的标志位&#xff0c;先看case 1&#xff0c;ucore直接failed&#xff0c;也就是如果不是缺页的读操作产生的page fault&#xff0c;那么就是后面的U/S、RSVD或I/D的错误&#xff0c;ucore不做处理&#xff0c;可以理解&#xff0c;没问题。再看看case 3&#xff0c;ucore先检测虚地址管理vma的写位&#xff0c;如果vma有写的权限&#xff0c;而发生了page fault&#xff0c;那么可能是entry没有写权限&#xff0c;因此可以尝试在entry添加上写权限。问题在于&#xff0c;如果不是因为entry的写权限造成的page fault的呢&#xff1f;此时ucore将陷入死循环&#xff01;</li><li>简单总结&#xff1a;ucore的page fault处理P=1,W/R=1的情况时&#xff0c;只处理了因为entry缺少写权限的情况&#xff0c;而没有考虑entry有写权限&#xff0c;由于其它权限造成的异常&#xff0c;该处理可能导致ucore陷入死循环。赞同高思达同学认为此处的error code的处理有问题。</li></ul>\n<p></p>"}, {"anon": "no", "uid": "i0ccfx63sir1e", "subject": "关于ucore的do_fault根据error code的分流处理", "created": "2016-04-02T03:45:05Z", "content": "<p><a href=\"https://www.piazza.com/class/i5j09fnsl7k5x0?cid=757\">https://piazza.com/class/i5j09fnsl7k5x0?cid=757</a></p>\n<p>我对该问题的理解&#xff0c;欢迎大家继续讨论。</p>\n<p></p>\n<p>1、lab的代码注释里这样描述3个flag bits&#xff1a;</p>\n<pre>-- The P flag (bit 0) indicates whether the exception was due to a not-present page (0)\n                      or to either an access rights violation or the use of a reserved bit (1).\n-- The W/R flag (bit 1) indicates whether the memory access that caused the exception\n                        was a read (0) or write (1).\n-- The U/S flag (bit 2) indicates whether the processor was executing at user mode (1)\n                        or supervisor mode (0) at the time of the exception.</pre>\n<p>2、Intel Manual的相关描述&#xff0c;截取片段&#xff1a;</p>\n<p><img src=\"/img/759-1dd0c9cc236a5e9.png\" width=\"478\" height=\"310\" /></p>\n<p>小结intel的文档内容&#xff1a;</p>\n<ul><li>造成page fault有两种情况<ol><li>线性地址转换无效&#xff1b;</li><li>线性地址转换有效&#xff0c;但权限不合法。</li></ol></li><li>线性地址转换无效的原因\n<ul><li>页表项的P位为0&#xff0c;或保留位reserved为1。</li></ul>\n</li><li>error code的P位\n<ul><li>如果页表项的P位为0&#xff0c;则error code的P位为0。</li></ul>\n</li></ul>\n<p>3、清晰的error code的图表示</p>\n<p><img src=\"/img/759-56fb6ca8cf37e456.png\" width=\"476\" height=\"295\" /></p>\n<p>4、结论</p>\n<ul><li>从文档和图示&#xff0c;基本能得知page-fault及其发生时的error code的工作。</li><li>error codeP位为0时&#xff0c;表示page-fault缺页&#xff08;准确来说&#xff0c;是entry的P位为0&#xff09;&#xff1b;P位为1时&#xff0c;则不是因为缺页&#xff0c;而是因为page-level protection violation&#xff0c;即我们应该检测后面的标志位。</li><li>ucore的do_pgfault中&#xff1a; P为0的处理&#xff0c;即case 0和case 2&#xff0c;正确地检测其它位&#xff0c;并作为缺页处理&#xff0c;没问题。 P为1时&#xff0c;这时应该检测后面的标志位&#xff0c;先看case 1&#xff0c;ucore直接failed&#xff0c;也就是如果不是缺页的读操作产生的page fault&#xff0c;那么就是后面的U/S、RSVD或I/D的错误&#xff0c;ucore不做处理&#xff0c;可以理解&#xff0c;没问题。再看看case 3&#xff0c;ucore先检测虚地址管理vma的写位&#xff0c;如果vma有写的权限&#xff0c;而发生了page fault&#xff0c;那么可能是entry没有写权限&#xff0c;因此可以尝试在entry添加上写权限。问题在于&#xff0c;如果不是因为entry的写权限造成的page fault的呢&#xff1f;此时ucore将陷入死循环&#xff01;</li><li>简单总结&#xff1a;ucore的page fault处理P=1,W/R=1的情况时&#xff0c;只处理了因为entry缺少写权限的情况&#xff0c;而没有考虑entry有写权限&#xff0c;由于其它权限造成的异常&#xff0c;该处理可能导致ucore陷入死循环。赞同高思达同学认为此处的error code的处理有问题。</li></ul>\n<p></p>"}, {"anon": "no", "uid": "i0ccfx63sir1e", "subject": "关于ucore的do_fault根据error code的分流处理", "created": "2016-04-02T03:44:34Z", "content": "<p><a href=\"https://www.piazza.com/class/i5j09fnsl7k5x0?cid=757\">https://piazza.com/class/i5j09fnsl7k5x0?cid=757</a></p>\n<p>我对该问题的理解&#xff0c;欢迎大家继续讨论。</p>\n<p></p>\n<p>1、lab的代码注释里这样描述3个flag bits&#xff1a;</p>\n<pre>-- The P flag (bit 0) indicates whether the exception was due to a not-present page (0)\n                      or to either an access rights violation or the use of a reserved bit (1).\n-- The W/R flag (bit 1) indicates whether the memory access that caused the exception\n                        was a read (0) or write (1).\n-- The U/S flag (bit 2) indicates whether the processor was executing at user mode (1)\n                        or supervisor mode (0) at the time of the exception.</pre>\n<p>2、Intel Manual的相关描述&#xff0c;截取片段&#xff1a;</p>\n<p><img src=\"/img/759-1dd0c9cc236a5e9.png\" width=\"519\" height=\"336\" /></p>\n<p>小结intel的文档内容&#xff1a;</p>\n<ul><li>造成page fault有两种情况<ol><li>线性地址转换无效&#xff1b;</li><li>线性地址转换有效&#xff0c;但权限不合法。</li></ol></li><li>线性地址转换无效的原因\n<ul><li>页表项的P位为0&#xff0c;或保留位reserved为1。</li></ul>\n</li><li>error code的P位\n<ul><li>如果页表项的P位为0&#xff0c;则error code的P位为0。</li></ul>\n</li></ul>\n<p>3、清晰的error code的图表示</p>\n<p><img src=\"/img/759-56fb6ca8cf37e456.png\" width=\"476\" height=\"295\" /></p>\n<p>4、结论</p>\n<ul><li>从文档和图示&#xff0c;基本能得知page-fault及其发生时的error code的工作。</li><li>error codeP位为0时&#xff0c;表示page-fault缺页&#xff08;准确来说&#xff0c;是entry的P位为0&#xff09;&#xff1b;P位为1时&#xff0c;则不是因为缺页&#xff0c;而是因为page-level protection violation&#xff0c;即我们应该检测后面的标志位。</li><li>ucore的do_pgfault中&#xff1a; P为0的处理&#xff0c;即case 0和case 2&#xff0c;正确地检测其它位&#xff0c;并作为缺页处理&#xff0c;没问题。 P为1时&#xff0c;这时应该检测后面的标志位&#xff0c;先看case 1&#xff0c;ucore直接failed&#xff0c;也就是如果不是缺页的读操作产生的page fault&#xff0c;那么就是后面的U/S、RSVD或I/D的错误&#xff0c;ucore不做处理&#xff0c;可以理解&#xff0c;没问题。再看看case 3&#xff0c;ucore先检测虚地址管理vma的写位&#xff0c;如果vma有写的权限&#xff0c;而发生了page fault&#xff0c;那么可能是entry没有写权限&#xff0c;因此可以尝试在entry添加上写权限。问题在于&#xff0c;如果不是因为entry的写权限造成的page fault的呢&#xff1f;此时ucore将陷入死循环&#xff01;</li><li>简单总结&#xff1a;ucore的page fault处理P=1,W/R=1的情况时&#xff0c;只处理了因为entry缺少写权限的情况&#xff0c;而没有考虑entry有写权限&#xff0c;由于其它权限造成的异常&#xff0c;该处理可能导致ucore陷入死循环。赞同高思达同学认为此处的error code的处理有问题。</li></ul>\n<p></p>"}, {"anon": "no", "uid": "i0ccfx63sir1e", "subject": "关于ucore的do_fault根据error code的分流处理", "created": "2016-04-02T03:42:03Z", "content": "<p><a href=\"https://www.piazza.com/class/i5j09fnsl7k5x0?cid=757\">https://piazza.com/class/i5j09fnsl7k5x0?cid=757</a></p>\n<p>我对该问题的理解&#xff0c;欢迎大家继续讨论。</p>\n<p></p>\n<p>1、lab的代码注释里这样描述3个flag bits&#xff1a;</p>\n<pre>-- The P flag (bit 0) indicates whether the exception was due to a not-present page (0)\n                      or to either an access rights violation or the use of a reserved bit (1).\n-- The W/R flag (bit 1) indicates whether the memory access that caused the exception\n                        was a read (0) or write (1).\n-- The U/S flag (bit 2) indicates whether the processor was executing at user mode (1)\n                        or supervisor mode (0) at the time of the exception.</pre>\n<p>2、Intel Manual的相关描述&#xff0c;截取片段&#xff1a;</p>\n<p><img src=\"/img/759-1dd0c9cc236a5e9.png\" width=\"519\" height=\"336\" /></p>\n<p>小结intel的文档内容&#xff1a;</p>\n<pre>1、造成page fault有两种情况\n    ①线性地址转换无效&#xff1b;\n    ②线性地址转换有效&#xff0c;但权限不合法。\n2、线性地址转换无效的原因\n    页表项的P位为0&#xff0c;或保留位reserved为1。\n3、error code的P位\n    如果页表项的P位为0&#xff0c;则error code的P位为0。</pre>\n<p>3、清晰的error code的图表示</p>\n<p><img src=\"/img/759-56fb6ca8cf37e456.png\" width=\"476\" height=\"295\" /></p>\n<p>4、结论</p>\n<ul><li>从文档和图示&#xff0c;基本能得知page-fault及其发生时的error code的工作。</li><li>error codeP位为0时&#xff0c;表示page-fault缺页&#xff08;准确来说&#xff0c;是entry的P位为0&#xff09;&#xff1b;P位为1时&#xff0c;则不是因为缺页&#xff0c;而是因为page-level protection violation&#xff0c;即我们应该检测后面的标志位。</li><li>ucore的do_pgfault中&#xff1a; P为0的处理&#xff0c;即case 0和case 2&#xff0c;正确地检测其它位&#xff0c;并作为缺页处理&#xff0c;没问题。 P为1时&#xff0c;这时应该检测后面的标志位&#xff0c;先看case 1&#xff0c;ucore直接failed&#xff0c;也就是如果不是缺页的读操作产生的page fault&#xff0c;那么就是后面的U/S、RSVD或I/D的错误&#xff0c;ucore不做处理&#xff0c;可以理解&#xff0c;没问题。再看看case 3&#xff0c;ucore先检测虚地址管理vma的写位&#xff0c;如果vma有写的权限&#xff0c;而发生了page fault&#xff0c;那么可能是entry没有写权限&#xff0c;因此可以尝试在entry添加上写权限。问题在于&#xff0c;如果不是因为entry的写权限造成的page fault的呢&#xff1f;此时ucore将陷入死循环&#xff01;</li><li>简单总结&#xff1a;ucore的page fault处理P=1,W/R=1的情况时&#xff0c;只处理了因为entry缺少写权限的情况&#xff0c;而没有考虑entry有写权限&#xff0c;由于其它权限造成的异常&#xff0c;该处理可能导致ucore陷入死循环。赞同高思达同学认为此处的error code的处理有问题。</li></ul>\n<p></p>"}, {"anon": "no", "uid": "i0ccfx63sir1e", "subject": "关于ucore的do_fault根据error code的分流处理", "created": "2016-04-02T03:41:44Z", "content": "<p><a href=\"https://www.piazza.com/class/i5j09fnsl7k5x0?cid=757\">https://piazza.com/class/i5j09fnsl7k5x0?cid=757</a></p>\n<p>我对该问题的理解&#xff0c;欢迎大家继续讨论。</p>\n<p></p>\n<p>1、lab的代码注释里这样描述3个flag bits&#xff1a;</p>\n<pre>-- The P flag (bit 0) indicates whether the exception was due to a not-present page (0)\n                      or to either an access rights violation or the use of a reserved bit (1).\n-- The W/R flag (bit 1) indicates whether the memory access that caused the exception\n                        was a read (0) or write (1).\n-- The U/S flag (bit 2) indicates whether the processor was executing at user mode (1)\n                        or supervisor mode (0) at the time of the exception.</pre>\n<p>2、Intel Manual的相关描述&#xff0c;截取片段&#xff1a;</p>\n<p><img src=\"/img/759-1dd0c9cc236a5e9.png\" width=\"519\" height=\"336\" /></p>\n<p>小结intel的文档内容&#xff1a;</p>\n<pre>1、造成page fault有两种情况\n    ①线性地址转换无效&#xff1b;\n    ②线性地址转换有效&#xff0c;但权限不合法。\n2、线性地址转换无效的原因\n    页表项的P位为0&#xff0c;或保留位reserved为1。\n3、error code的P位\n    如果页表项的P位为0&#xff0c;则error code的P位为0。</pre>\n<p>3、清晰的error code的图表示</p>\n<p><img src=\"/img/759-56fb6ca8cf37e456.png\" width=\"476\" height=\"295\" /></p>\n<p>4、结论</p>\n<ul><li>从文档和图示&#xff0c;基本能得知page-fault及其发生时的error code的工作。</li><li>error codeP位为0时&#xff0c;表示page-fault缺页&#xff08;准确来说&#xff0c;是entry的P位为0&#xff09;&#xff1b;P位为1时&#xff0c;则不是因为缺页&#xff0c;而是因为page-level protection violation&#xff0c;即我们应该检测后面的标志位。</li><li>ucore的do_pgfault中&#xff1a; P为0的处理&#xff0c;即case 0和case 2&#xff0c;正确地检测其它位&#xff0c;并作为缺页处理&#xff0c;没问题。 P为1时&#xff0c;这时应该检测后面的标志位&#xff0c;先看case 1&#xff0c;ucore直接failed&#xff0c;也就是如果不是缺页的读操作产生的page fault&#xff0c;那么就是后面的U/S、RSVD或I/D的错误&#xff0c;ucore不做处理&#xff0c;可以理解&#xff0c;没问题。再看看case 3&#xff0c;ucore先检测虚地址管理vma的写位&#xff0c;如果vma有写的权限&#xff0c;而发生了page fault&#xff0c;那么可能是entry没有写权限&#xff0c;因此可以尝试在entry添加上写权限。问题在于&#xff0c;如果不是因为entry的写权限造成的page fault的呢&#xff1f;此时ucore将陷入死循环&#xff01;</li><li>简单总结&#xff1a;ucore的page fault处理P=1,W/R=1的情况时&#xff0c;只处理了因为entry缺少写权限的情况&#xff0c;而没有考虑entry有写权限&#xff0c;由于其它权限造成的异常&#xff0c;该处理可能导致ucore陷入死循环。赞同高思达同学认为此处的error code的处理有问题。</li></ul>\n<p></p>"}, {"anon": "no", "uid": "i0ccfx63sir1e", "subject": "关于ucore的do_fault根据error code的分流处理", "created": "2016-04-02T03:40:48Z", "content": "<p><a href=\"https://www.piazza.com/class/i5j09fnsl7k5x0?cid=757\">https://piazza.com/class/i5j09fnsl7k5x0?cid=757</a></p>\n<p>我对该问题的理解&#xff0c;欢迎大家继续讨论。</p>\n<p></p>\n<p>1、lab的代码注释里这样描述3个flag bits&#xff1a;</p>\n<pre>-- The P flag (bit 0) indicates whether the exception was due to a not-present page (0)\n                      or to either an access rights violation or the use of a reserved bit (1).\n-- The W/R flag (bit 1) indicates whether the memory access that caused the exception\n                        was a read (0) or write (1).\n-- The U/S flag (bit 2) indicates whether the processor was executing at user mode (1)\n                        or supervisor mode (0) at the time of the exception.</pre>\n<p>2、Intel Manual的相关描述&#xff0c;截取片段&#xff1a;</p>\n<p><img src=\"/img/759-1dd0c9cc236a5e9.png\" width=\"519\" height=\"336\" /></p>\n<p>小结intel的文档内容&#xff1a;</p>\n<pre>1、造成page fault有两种情况\n    ①线性地址转换无效&#xff1b;\n    ②线性地址转换有效&#xff0c;但权限不合法。\n2、线性地址转换无效的原因\n    页表项的P位为0&#xff0c;或保留位reserved为1。\n3、error code的P位\n    如果页表项的P位为0&#xff0c;则error code的P位为0。</pre>\n<p>3、清晰的error code的图表示</p>\n<p><img src=\"/img/759-56fb6ca8cf37e456.png\" width=\"476\" height=\"295\" /></p>\n<p>4、结论</p>\n<ul><li>从文档和图示&#xff0c;基本能得知page-fault及其发生时的error code的工作。</li><li>error codeP位为0时&#xff0c;表示page-fault缺页&#xff08;准确来说&#xff0c;是entry的P位为0&#xff09;&#xff1b;P位为1时&#xff0c;则不是因为缺页&#xff0c;而是因为page-level protection violation&#xff0c;即我们应该检测后面的标志位。</li><li>ucore的do_pgfault中&#xff1a; P为0的处理&#xff0c;即case 0和case 2&#xff0c;正确地检测其它位&#xff0c;并作为缺页处理&#xff0c;没问题。 P为1时&#xff0c;这时应该检测后面的标志位&#xff0c;先看case 1&#xff0c;ucore直接failed&#xff0c;也就是如果不是缺页的读操作产生的page fault&#xff0c;那么就是后面的U/S、RSVD或I/D的错误&#xff0c;ucore不做处理&#xff0c;可以理解&#xff0c;没问题。再看看case 3&#xff0c;ucore先检测虚地址管理vma的写位&#xff0c;如果vma有写的权限&#xff0c;而发生了page fault&#xff0c;那么可能是entry没有写权限&#xff0c;因此可以尝试在entry添加上写权限。问题在于&#xff0c;如果不是因为entry的写权限造成的page fault的呢&#xff1f;此时ucore将陷入死循环&#xff01;</li><li>简单总结&#xff1a;ucore的page fault处理P=1,W/R=1的情况时&#xff0c;只处理了因为entry缺少写权限的情况&#xff0c;而没有考虑entry有写权限&#xff0c;由于其它权限造成的异常&#xff0c;该处理可能导致ucore陷入死循环。高思达同学认为此处的error code的处理有问题&#xff0c;是合理的。</li></ul>\n<p></p>"}, {"anon": "no", "uid": "i0ccfx63sir1e", "subject": "关于ucore的do_fault根据error code的分流处理", "created": "2016-04-02T03:38:52Z", "content": "<p><a href=\"https://www.piazza.com/class/i5j09fnsl7k5x0?cid=757\">https://piazza.com/class/i5j09fnsl7k5x0?cid=757</a></p>\n<p>我对该问题的理解&#xff0c;欢迎大家继续讨论。</p>\n<p></p>\n<p>1、lab的代码注释里这样描述3个flag bits&#xff1a;</p>\n<pre>-- The P flag (bit 0) indicates whether the exception was due to a not-present page (0)\n                      or to either an access rights violation or the use of a reserved bit (1).\n-- The W/R flag (bit 1) indicates whether the memory access that caused the exception\n                        was a read (0) or write (1).\n-- The U/S flag (bit 2) indicates whether the processor was executing at user mode (1)\n                        or supervisor mode (0) at the time of the exception.</pre>\n<p>2、Intel Manual的相关描述&#xff0c;截取片段&#xff1a;</p>\n<p><img src=\"/img/759-1dd0c9cc236a5e9.png\" width=\"519\" height=\"336\" /></p>\n<p>小结intel的文档内容&#xff1a;</p>\n<pre>1、造成page fault有两种情况\n    ①线性地址转换无效&#xff1b;\n    ②线性地址转换有效&#xff0c;但权限不合法。\n2、线性地址转换无效的原因\n    页表项的P位为0&#xff0c;或保留位reserved为1。\n3、error code的P位\n    如果页表项的P位为0&#xff0c;则error code的P位为0。</pre>\n<p>3、清晰的error code的图表示</p>\n<p><img src=\"/img/759-56fb6ca8cf37e456.png\" width=\"476\" height=\"295\" /></p>\n<p>4、结论</p>\n<pre>    从文档和图示&#xff0c;基本能得知page-fault及其发生时的error code的工作。\n    error codeP位为0时&#xff0c;表示page-fault缺页&#xff08;准确来说&#xff0c;是entry的P位为0&#xff09;&#xff1b;P位为1时&#xff0c;则不是因为缺页&#xff0c;而是因为page-level protection violation&#xff0c;即我们应该检测后面的标志位。\n    ucore的do_pgfault中&#xff1a;\n    P为0的处理&#xff0c;即case 0和case 2&#xff0c;正确地检测其它位&#xff0c;并作为缺页处理&#xff0c;没问题。\n    P为1时&#xff0c;这时应该检测后面的标志位&#xff0c;先看case 1&#xff0c;ucore直接failed&#xff0c;也就是如果不是缺页的读操作产生的page fault&#xff0c;那么就是后面的U/S、RSVD或I/D的错误&#xff0c;ucore不做处理&#xff0c;可以理解&#xff0c;没问题。再看看case 3&#xff0c;ucore先检测虚地址管理vma的写位&#xff0c;如果vma有写的权限&#xff0c;而发生了page fault&#xff0c;那么可能是entry没有写权限&#xff0c;因此可以尝试在entry添加上写权限。问题在于&#xff0c;如果不是因为entry的写权限造成的page fault的呢&#xff1f;此时ucore将陷入死循环&#xff01;\n    简单总结&#xff1a;ucore的page fault处理P=1,W/R=1的情况时&#xff0c;只处理了因为entry缺少写权限的情况&#xff0c;而没有考虑entry有写权限&#xff0c;由于其它权限造成的异常&#xff0c;该处理可能导致ucore陷入死循环。高思达同学认为此处的error code的处理有问题&#xff0c;是合理的。</pre>\n<p></p>"}, {"anon": "no", "uid": "i0ccfx63sir1e", "subject": "关于ucore的do_fault根据error code的分流处理", "created": "2016-04-02T03:37:09Z", "content": "<p>1、lab的代码注释里这样描述3个flag bits&#xff1a;</p>\n<pre>-- The P flag (bit 0) indicates whether the exception was due to a not-present page (0)\n                      or to either an access rights violation or the use of a reserved bit (1).\n-- The W/R flag (bit 1) indicates whether the memory access that caused the exception\n                        was a read (0) or write (1).\n-- The U/S flag (bit 2) indicates whether the processor was executing at user mode (1)\n                        or supervisor mode (0) at the time of the exception.</pre>\n<p>2、Intel Manual的相关描述&#xff0c;截取片段&#xff1a;</p>\n<p><img src=\"/img/759-1dd0c9cc236a5e9.png\" width=\"519\" height=\"336\" /></p>\n<p>小结intel的文档内容&#xff1a;</p>\n<pre>1、造成page fault有两种情况<br />    ①线性地址转换无效&#xff1b;<br />    ②线性地址转换有效&#xff0c;但权限不合法。<br />2、线性地址转换无效的原因<br />    页表项的P位为0&#xff0c;或保留位reserved为1。<br />3、error code的P位<br />    如果页表项的P位为0&#xff0c;则error code的P位为0。</pre>\n<p>3、清晰的error code的图表示</p>\n<p><img src=\"/img/759-56fb6ca8cf37e456.png\" width=\"476\" height=\"295\" /></p>\n<p>4、结论</p>\n<pre>    从文档和图示&#xff0c;基本能得知page-fault及其发生时的error code的工作。<br />    error codeP位为0时&#xff0c;表示page-fault缺页&#xff08;准确来说&#xff0c;是entry的P位为0&#xff09;&#xff1b;P位为1时&#xff0c;则不是因为缺页&#xff0c;而是因为page-level protection violation&#xff0c;即我们应该检测后面的标志位。<br />    ucore的do_pgfault中&#xff1a;<br />    P为0的处理&#xff0c;即case 0和case 2&#xff0c;正确地检测其它位&#xff0c;并作为缺页处理&#xff0c;没问题。<br />    P为1时&#xff0c;这时应该检测后面的标志位&#xff0c;先看case 1&#xff0c;ucore直接failed&#xff0c;也就是如果不是缺页的读操作产生的page fault&#xff0c;那么就是后面的U/S、RSVD或I/D的错误&#xff0c;ucore不做处理&#xff0c;可以理解&#xff0c;没问题。再看看case 3&#xff0c;ucore先检测虚地址管理vma的写位&#xff0c;如果vma有写的权限&#xff0c;而发生了page fault&#xff0c;那么可能是entry没有写权限&#xff0c;因此可以尝试在entry添加上写权限。问题在于&#xff0c;如果不是因为entry的写权限造成的page fault的呢&#xff1f;此时ucore将陷入死循环&#xff01;<br />    简单总结&#xff1a;ucore的page fault处理P=1,W/R=1的情况时&#xff0c;只处理了因为entry缺少写权限的情况&#xff0c;而没有考虑entry有写权限&#xff0c;由于其它权限造成的异常&#xff0c;该处理可能导致ucore陷入死循环。高思达同学认为此处的error code的处理有问题&#xff0c;是合理的。</pre>\n<p></p>"}], "type": "note", "tags": ["lab3", "student", "unanswered"], "tag_good": [{"role": "instructor", "name": "Yong XIANG", "endorser": {}, "admin": true, "photo": null, "id": "hdjonbiyfs62ie", "photo_url": null, "us": false, "class_sections": ["课程设计_i5j09fnsl7k5x0", "清华学生_i5j09fnsl7k5x0", "所有老师和助教_i5j09fnsl7k5x0", "os2018spring_i5j09fnsl7k5x0"], "facebook_id": null}, {"role": "", "name": "Bo Gao", "endorser": {}, "admin": false, "photo": null, "id": "ic226rac4j5jw", "photo_url": null, "published": true, "us": false, "class_sections": ["清华学生_i5j09fnsl7k5x0"], "facebook_id": null}, {"role": "student", "name": "叶子鹏", "endorser": {}, "admin": false, "photo": null, "id": "i0f24oie8102cr", "photo_url": null, "published": true, "us": false, "class_sections": ["清华学生_i5j09fnsl7k5x0"], "facebook_id": null}, {"role": "instructor", "name": "Yu Chen", "endorser": {}, "admin": true, "photo": "1378950179_35.png", "id": "hcrrjuyequh4bt", "photo_url": "https://d1b10bmlvqabco.cloudfront.net/photos/hcrrjuyequh4bt/1378950179_35.png", "us": false, "class_sections": ["课程设计_i5j09fnsl7k5x0", "清华学生_i5j09fnsl7k5x0", "所有老师和助教_i5j09fnsl7k5x0", "os2018spring_i5j09fnsl7k5x0"], "facebook_id": null}, {"role": "", "name": "高思达(2013011413)", "endorser": {}, "admin": false, "photo": "1416805692_35.png", "id": "i0gl5kctugw3xi", "photo_url": "https://d1b10bmlvqabco.cloudfront.net/photos/i0gl5kctugw3xi/1416805692_35.png", "published": true, "us": false, "class_sections": ["清华学生_i5j09fnsl7k5x0"], "facebook_id": null}], "unique_views": 131, "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>跟风问&#xff0c;所以解决办法是不是应该判断一下其他位&#xff1f;但是因<tt>为到lab3为</tt>止不会发生这些错误所以答案里并没有处理&#xff1f;</p>", "created": "2016-04-02T03:54:47Z", "bucket_order": 211, "bucket_name": "Week 3/27 - 4/2", "type": "followup", "tag_good": [], "uid": "i6w84pnmjCQ", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>嗯。或许可以这样&#xff0c;后面再加上判断&#xff0c;if((error_code&amp;3==3) &amp;&amp; (ptep-&gt;flags &amp; PTE_W)) { goto failed; }</p>", "created": "2016-04-02T03:59:22Z", "bucket_order": 211, "bucket_name": "Week 3/27 - 4/2", "type": "feedback", "tag_good": [], "uid": "i0ccfx63sir1e", "children": [], "tag_good_arr": [], "id": "imim16du9p81rj", "updated": "2016-04-02T03:59:22Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "imilva0myc45sw", "updated": "2016-04-02T03:54:47Z", "config": {}}], "tag_good_arr": ["hdjonbiyfs62ie", "ic226rac4j5jw", "i0f24oie8102cr", "hcrrjuyequh4bt", "i0gl5kctugw3xi"], "id": "imil8lp05rr1rh", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 6, "num_favorites": 3, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643168404134, "default_anonymity": "no"}, "error": null, "aid": "kyv01j1j5r91kk"}