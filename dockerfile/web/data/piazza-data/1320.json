{"result": {"folders": ["lecture17", "2019"], "nr": 1320, "data": {"embed_links": []}, "created": "2019-05-02T03:11:18Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "ju69lug52OdQ", "data": "jv62op18fw5300", "type": "create", "when": "2019-05-02T03:11:18Z"}, {"anon": "no", "uid": "ju69lug52OdQ", "data": "jv6ap9eplqe39f", "type": "update", "when": "2019-05-02T06:55:42Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "ju69lug52OdQ", "subject": "peterson算法的“谦让”与“不谦让”", "created": "2019-05-02T06:55:42Z", "content": "<p>peterson的“谦让式”:turn=对方</p>\n<p>如果改成“不谦让式”:turn=自己,如下代码所示&#xff1a;</p>\n<pre>&lt;code&gt;ENTRY PROTOCOL (for Process i ):\n    /* claim the resource */\n    flags[i ] = BUSY;\n\n    /* give away the turn */\n    turn = i ;\n    /* wait while the other process is using the resource *and* has the turn */\n    while ((flags[j ] == BUSY) &amp;&amp; (turn != i )) {\n    }\n    /*i进入临界区*/\nEXIT PROTOCOL (for Process i ):\n    /* release the resource */\n    flags[i ] = FREE;\n&lt;/code&gt;</pre>\n<p>不满足三要素中的“空闲让进”&#xff0c;查阅wiki中progress中说&#xff0c;当两个进程都申请进入临界区时&#xff0c;先进的那个即使出来又申请进入&#xff0c;也是不允许连续两次都让同一个进程进入临界区的。所以&#xff0c;这里必须是“谦让式”turn=对方。参考&#xff1a;<a href=\"https://en.wikipedia.org/wiki/Peterson%27s_algorithm\">https://en.wikipedia.org/wiki/Peterson%27s_algorithm</a></p>\n<p>如有错误请大家指正&#xff0c;谢谢。</p>"}, {"anon": "no", "uid": "ju69lug52OdQ", "subject": "peterson算法的“谦让”与“不谦让”", "created": "2019-05-02T03:11:18Z", "content": "<p>peterson的“谦让式”:turn=对方</p>\n<p>如果改成“不谦让式”:turn=自己,如下代码所示&#xff1a;</p>\n<pre>&lt;code&gt;ENTRY PROTOCOL (for Process i ):\n    /* claim the resource */\n    flags[i ] = BUSY;\n\n    /* give away the turn */\n    turn = i ;\n    /* wait while the other process is using the resource *and* has the turn */\n    while ((flags[j ] == BUSY) &amp;&amp; (turn != i )) {\n    }\n    /*i进入临界区*/\nEXIT PROTOCOL (for Process i ):\n    /* release the resource */\n    flags[i ] = FREE;\n&lt;/code&gt;</pre>\n<p>理论上也能够满足&#xff1a;互斥&#xff0c;前进</p>\n<p>至于“有限等待”&#xff0c;情况是这样&#xff1a;</p>\n<p>  eg.前提&#xff1a;i,j同时请求cpu(不谦让式)</p>\n<p>        假如j先占用cpu。使用完后flag[j]=false&#xff0c;此时如果切换到pi,不满足循环条件&#xff0c;i可进入临界区&#xff1b;如果当时并未切换到pi&#xff0c;而是pj继续请求临界区&#xff0c;此时&#xff0c;pj再次获得临界资源。</p>\n<p>但是首先&#xff0c;这其中i是有机会获得临界资源的&#xff1b;</p>\n<p>其次&#xff0c;j不再请求之后&#xff0c;i也会得到临界资源。</p>\n<p></p>\n<p>question:</p>\n<p>1. 这种情况算不算“有限等待”呢&#xff1f;</p>\n<p>2. 如果算的话&#xff0c;是不是能够替换“谦让式”peterson算法呢&#xff1f;</p>\n<p></p>"}], "type": "note", "tags": ["2019", "lecture17", "student", "unanswered"], "tag_good": [], "unique_views": 79, "children": [], "tag_good_arr": [], "id": "jv62op164bn2zz", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 1, "num_favorites": 0, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169741466, "default_anonymity": "no"}, "error": null, "aid": "kyv0u6xmagd7e3"}