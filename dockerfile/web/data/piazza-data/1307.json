{"result": {"folders": ["lecture14", "2019"], "nr": 1307, "data": {"embed_links": []}, "created": "2019-04-14T20:50:51Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "jslfact6jvaN", "data": "juhelyg8yjv3x1", "type": "create", "when": "2019-04-14T20:50:51Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "data": "jutgf35oh8h6wn", "type": "update", "when": "2019-04-23T07:14:44Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "页表自映射问题的探究", "created": "2019-04-23T07:14:44Z", "content": "<p>期中考试中有一道页表自映射的题目&#xff0c;自己当时在考试中并没有做出来&#xff0c;在课下进行探究之后得到下面关于页表自映射的认识。</p>\n<p>页表自映射实际上就是某一个页目录项指向自己所在页的起始地址。32位系统下&#xff0c;所有的PTE所占的空间刚好是4MB。如果将这些PTE连续地放在内存中&#xff0c;那么这4MB内存空间对应的PTE&#xff08;称为PTE的PTE&#xff09;刚好在一个4KB页中&#xff0c;而这个4KB在页目录表中刚好也占一项。这也就让我们能够实现页表自映射的建立。而通过这样的设定&#xff0c;我们也可以得到一些有趣的效果。</p>\n<p>1. 通过一个页的PTE(xPTE)的虚地址v_pte&#xff0c;可以直接得到该页的虚地址为(v_pte&lt;&lt;10)</p>\n<p>2. 通过一个页表的PDE(xPDE)的虚地址v_pde&#xff0c;可以直接得到该页表所在页的虚地址为( v_pde&lt;&lt;10)</p>\n<p>下面解释第一个 &#xff0c;我们假设某一个页表项虚拟地址为v_pte&#xff08;低两位为0&#xff09;&#xff0c;其在转换为物理地址的过程中&#xff0c;BIT(31, 22)为页目录表的偏移&#xff0c;由上面的设定得到的PDE指向页目录项的起始地址&#xff0c;BIT(21, 12)为在页表的偏移&#xff0c;再计算页内偏移BIT(11, 0)&#xff0c;得到该页表项的物理地址。</p>\n<p>下面我们想知道该页表项指向的物理地址对应的虚拟地址&#xff0c;我们需要做的就是让某个虚拟地址v对应的页表项地址为v_pte&#xff0c;有上面v_pte转变为物理地址的过程&#xff0c;我们需要BITv(31, 22) = BITv_pte(21, 12)&#xff0c;这样该物理地址对应的页表就是v_pte所在的页&#xff0c;由于v_pte的页内偏移为BITv_pte(11, 0)&#xff0c;则BITv_pte(11, 2)对应的页表项偏移正好指向xPTE的地址&#xff0c;所以BITv(21, 12)=BITv_pte(11, 2)。且v_pte的低两位为0&#xff0c;所以v_pte &lt;&lt; 10就是v_pte所在页的虚拟地址。第2点类似&#xff0c;就不再赘述。</p>\n<p>上面是我对页表自映射的一些认识&#xff0c;欢迎大家的补充和纠正&#xff5e;</p>\n<p>参考网页&#xff1a;<a href=\"https://www.cnblogs.com/richardustc/archive/2013/04/12/3015694.html\" target=\"_blank\">https://www.cnblogs.com/richardustc/archive/2013/04/12/3015694.html</a></p>"}, {"anon": "no", "uid": "jslfact6jvaN", "subject": "页表自映射问题的探究", "created": "2019-04-14T20:50:51Z", "content": "<p>期中考试中有一道页表自映射的题目&#xff0c;自己当时在考试中并没有做出来&#xff0c;在课下进行探究之后得到下面关于页表自映射的认识。</p>\n<p>页表自映射实际上就是某一个页目录项指向自己所在页的起始地址。32位系统下&#xff0c;所有的PTE所占的空间刚好是4MB。如果将这些PTE连续地放在内存中&#xff0c;那么这4MB内存空间对应的PTE&#xff08;称为PTE的PTE&#xff09;刚好在一个4KB页中&#xff0c;而这个4KB在页目录表中刚好也占一项。这也就让我们能够实现页表自映射的建立。而通过这样的设定&#xff0c;我们也可以得到一些有趣的效果。</p>\n<p>1. 通过一个页的PTE(xPTE)的虚地址v_pte&#xff0c;可以直接得到该页的虚地址为(v_pte&lt;&lt;10)</p>\n<p>2. 通过一个页表的PDE(xPDE)的虚地址v_pde&#xff0c;可以直接得到该页表所在页的虚地址为( v_pde&lt;&lt;10)</p>\n<p>下面解释第一个 &#xff0c;我们假设某一个页表项虚拟地址为v_pte&#xff08;低两位为0&#xff09;&#xff0c;其在转换为物理地址的过程中&#xff0c;BIT(31, 22)为页目录表的偏移&#xff0c;由上面的设定得到的PDE指向页目录项的起始地址&#xff0c;BIT(21, 12)为在页表的偏移&#xff0c;再计算页内偏移BIT(11, 0)&#xff0c;得到该页表项的物理地址。</p>\n<p>下面我们想知道该页表项指向的物理地址对应的虚拟地址&#xff0c;我们需要做的就是让某个虚拟地址v对应的页表项地址为v_pte&#xff0c;有上面v_pte转变为物理地址的过程&#xff0c;我们需要BITv(31, 22) = BITv_pte(21, 12)&#xff0c;这样该物理地址对应的页表就是v_pte所在的页&#xff0c;由于v_pte的页内偏移为BITv_pte(11, 0)&#xff0c;则BITv_pte(11, 2)对应的页表项偏移正好指向xPTE的地址&#xff0c;所以BITv(21, 12)=BITv_pte(11, 2)。且v_pte的低两位为0&#xff0c;所以v_pte &lt;&lt; 10就是v_pte所在页的虚拟地址。第2点类似&#xff0c;就不再赘述。</p>\n<p>上面是我对页表自映射的一些认识&#xff0c;欢迎大家的补充和纠正&#xff5e;</p>\n<p>参考网页&#xff1a;<a href=\"https://www.cnblogs.com/richardustc/archive/2013/04/12/3015694.html\" target=\"_blank\">https://www.cnblogs.com/richardustc/archive/2013/04/12/3015694.html</a></p>"}], "type": "note", "tags": ["2019", "lecture14", "student"], "tag_good": [], "unique_views": 96, "children": [], "tag_good_arr": [], "id": "juhelyg5v6h3x0", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 2, "num_favorites": 3, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169713176, "default_anonymity": "no"}, "error": null, "aid": "kyv0tl3sdr4hy"}