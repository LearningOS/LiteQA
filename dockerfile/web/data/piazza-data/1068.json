{"result": {"folders": ["2017", "lecture20", "课堂问答"], "nr": 1068, "data": {"embed_links": []}, "created": "2017-05-05T15:42:11Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "hdjonbiyfs62ie", "data": "j2c0e0zh5oy4va", "type": "create", "when": "2017-05-05T15:42:11Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j2c0e0zfpsg4v9", "type": "followup", "when": "2017-05-05T15:47:12Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j2c0e0zfpsg4v9", "type": "followup", "when": "2017-05-05T15:47:19Z"}, {"anon": "no", "uid": "isvxeq6bspf1vn", "to": "j2c0e0zfpsg4v9", "type": "feedback", "when": "2018-05-19T09:06:01Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "2017春季-第二十讲课堂实践练习", "created": "2017-05-05T15:42:11Z", "content": "<p>请两人一组完成“第二十讲 死锁和进程通信”中指定题目&#xff0c;回答在此贴中回复&#xff0c;每组同学选做一个小题目。</p>\n<p></p>\n<p>题目&#xff1a;<br /><a href=\"https://chyyuu.gitbooks.io/os_course_exercises/content/all/08-1-spoc-discussion.html\">https://chyyuu.gitbooks.io/os_course_exercises/content/all/08-1-spoc-discussion.html</a></p>\n<p></p>\n<p>(1)在Linux系统下测试不同通信机制的性能差异<br />视频相关思考题 -&gt; 20.7 消息队列和共享内存 -&gt; 第2小题</p>\n<p></p>\n<p>(2)实现银行家算法<br />小组思考题 -&gt; 第1小题</p>"}], "type": "note", "tags": ["2017", "instructor-note", "lecture20", "课堂问答"], "tag_good": [], "unique_views": 140, "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>请选择“(1)在Linux系统下测试不同通信机制的性能差异”的同学在此贴后面自己的回答结果。</p>", "created": "2017-05-05T15:47:12Z", "bucket_order": 152, "bucket_name": "Week 4/30 - 5/6", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "j2c0khtxq7w7n9", "updated": "2017-05-05T15:47:12Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>请选择“(2)实现银行家算法”的同学在此贴后面自己的回答结果。</p>", "created": "2017-05-05T15:47:19Z", "bucket_order": 152, "bucket_name": "Week 4/30 - 5/6", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>使用java实现了银行家算法&#xff0c;代码如下&#xff1a;</p>\n<p></p>\n<p>process.java</p>\n<pre>import java.util.*;\npublic class Process {\n\tint r_num;\n\tint id;\n\tint[][] Resource; // For Max, All, Request\n\t\n\tScanner scn = new Scanner(System.in);\n\t\n\tProcess(int i, int r){\n\t\tid = i&#43;1;\n\t\tr_num = r;\n\t\tResource = new int[3][r];\n\t\tSystem.out.println(&#34;Process &#34; &#43; id &#43; &#34; has been established&#34;);\n\t\twhile(true) {\n\t\t\tSystem.out.println(&#34;Please input data: &#34;);\n\t\t\tString path = scn.nextLine();\n\t\t\tString[] ss = path.split(&#34;;&#34;);\n\t\t\tassert(ss.length == 2);\n\t\t\t/*\n\t\t\tif (ss.length != 2) {\n\t\t\t\tSystem.out.println(&#34;Wrong input&#34;);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t*/\n\t\t\t\n\t\t\tString[] Max = ss[0].split(&#34;,&#34;);\n\t\t\tString[] Alloc = ss[1].split(&#34;,&#34;);\n\t\t\t\n\t\t\tassert(Max.length == Alloc.length);\n\t\t\tassert(Max.length == r);\n\t\t\t\n\t\t\t/*\n\t\t\tif (Max.length != Alloc.length || Max.length != r) {\n\t\t\t\tSystem.out.println(&#34;Wrong input&#34;);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t*/\n\t\t\t\n\t\t\tfor (int j = 0; j &lt; Max.length; j&#43;&#43;) {\n\t\t\t\tResource[0][j] = Integer.parseInt(Max[j]);\n\t\t\t\tResource[1][j] = Integer.parseInt(Alloc[j]);\n\t\t\t\tassert(Resource[0][j] &gt; Resource[1][j]);\n\t\t\t\tResource[2][j] = Resource[0][j] - Resource[1][j];\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tpublic int get_num(int i, int j) {\n\t\treturn Resource[i][j];\n\t}\n\tpublic int get_max(int j) {\n\t\treturn Resource[0][j];\n\t}\n\tpublic int get_alloc(int j) {\n\t\treturn Resource[1][j];\n\t}\n\tpublic int get_remain(int j) {\n\t\treturn Resource[2][j];\n\t}\n\tpublic boolean can_finish(int[] Remaining) {\n\t\tassert(Remaining.length == r_num);\n\t\tfor (int i = 0; i &lt; r_num; i&#43;&#43;) {\n\t\t\tif (get_remain(i) &gt; Remaining[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}</pre>\n<p></p>\n<p>main.java</p>\n<pre>import java.util.*;\n\npublic class main {\n\tstatic int resource;\n\tstatic int process;\n\tpublic static void main(String argv[]) {\n\t\tScanner scn = new Scanner(System.in);\n\t\t\n\t\tSystem.out.println(&#34;Bank Algorithm&#34;);\n\t\t\n\t\tSystem.out.println(&#34;Please input the num of resource&#34;);\n\t\tresource = Integer.parseInt(scn.nextLine());\n\t\tSystem.out.println(&#34;Please input the num of process&#34;);\n\t\tprocess = Integer.parseInt(scn.nextLine());\n\t\t\n\t\tboolean[] pro_finish = new boolean[process];\n\t\tArrayList&lt;Process&gt; pl = new ArrayList&lt;Process&gt;();\n\t\tfor(int i = 0; i &lt; process; i&#43;&#43;) {\n\t\t\tpl.add(new Process(i, resource));\n\t\t\tpro_finish[i] = false;\n\t\t}\n\t\t\n\t\tint[] remaining = new int[resource];\n\t\tSystem.out.println(&#34;Please input the remaining resource&#34;);\n\t\tString[] rems = scn.nextLine().split(&#34;,&#34;);\n\t\tassert(rems.length == resource);\n\t\tfor (int i = 0; i &lt; rems.length; i&#43;&#43;) {\n\t\t\tremaining[i] = Integer.parseInt(rems[i]); \n\t\t}\n\t\t\n\t\tboolean deadlock = true;\n\t\tArrayList&lt;Integer&gt; safe_queue = new ArrayList&lt;Integer&gt;();\n\t\t\n\t\twhile(true) {\n\t\t\tboolean all_true = true;\n\t\t\t\n\t\t\tfor(int i = 0; i &lt; process; i&#43;&#43;) {\n\t\t\t\tif (pro_finish[i] == false) {\n\t\t\t\t\tall_true = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (all_true) {\n\t\t\t\tdeadlock = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tboolean find = false;\n\t\t\t\n\t\t\tfor (int i = 0; i &lt; process; i&#43;&#43;) {\n\t\t\t\tif (pro_finish[i]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tProcess now = pl.get(i);\n\t\t\t\tif (now.can_finish(remaining)) {\n\t\t\t\t\tfor(int j = 0; j &lt; resource; j&#43;&#43;) {\n\t\t\t\t\t\tremaining[j] &#43;= now.get_alloc(j);\n\t\t\t\t\t}\n\t\t\t\t\tpro_finish[i] = true;\n\t\t\t\t\tfind = true;\n\t\t\t\t\tsafe_queue.add(now.id);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!find) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\tif (deadlock) {\n\t\tSystem.out.println(&#34;Dead Lock&#34;);\n\t}else {\n\t\tassert(safe_queue.size() == process);\n\t\tSystem.out.println(&#34;There is not a Dead Lock and the safe queue is as follow&#34;);\n\t\tfor (int i = 0; i &lt; safe_queue.size(); i&#43;&#43;) {\n\t\t\tSystem.out.print(safe_queue.get(i) &#43; &#34; &#34;);\n\t\t}\n\t}\n\t}\n}</pre>\n<p>使用ppt上的两个例子分别测试如下&#xff1a;</p>\n<p>有死锁的情况</p>\n<p><img src=\"/img/1068-41c9438e94db8d31.png\" alt=\"\" /></p>\n<p>没有死锁的&#xff0c;同时给出了安全队列</p>\n<p><img src=\"/img/1068-5218ec17797c0a81.png\" alt=\"\" /></p>\n<p></p>", "created": "2018-05-19T09:06:01Z", "bucket_order": 98, "bucket_name": "Week 5/13 - 5/19", "type": "feedback", "tag_good": [], "uid": "isvxeq6bspf1vn", "children": [], "tag_good_arr": [], "id": "jhd64esjyqr299", "updated": "2018-05-19T09:06:01Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "j2c0kmubsub6qm", "updated": "2017-05-05T15:47:19Z", "config": {}}], "tag_good_arr": [], "id": "j2c0e0zfpsg4v9", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 2, "num_favorites": 0, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169067698, "default_anonymity": "no"}, "error": null, "aid": "kyv0fr1udhz1su"}