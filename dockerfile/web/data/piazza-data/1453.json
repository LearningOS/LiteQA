{"result": {"folders": ["lab1"], "nr": 1453, "data": {"embed_links": []}, "created": "2020-04-16T12:23:53Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "k7c3mir535phw", "data": "k92qjgxw1d22gj", "v": "all", "type": "create", "when": "2020-04-16T12:23:53Z"}, {"anon": "stud", "data": "k9aso6f09ya1qa", "to": "k92qjgxtw6r2gi", "type": "s_answer", "when": "2020-04-22T03:45:42Z", "uid_a": "a_0"}, {"anon": "no", "uid": "k7c3mir535phw", "data": "k9auchkw45j7au", "type": "s_answer_update", "when": "2020-04-22T04:32:35Z"}, {"anon": "stud", "data": "k9auptz4kvl6gl", "type": "s_answer_update", "when": "2020-04-22T04:42:58Z", "uid_a": "a_0"}, {"anon": "no", "uid": "k7c3mir535phw", "to": "k92qjgxtw6r2gi", "type": "followup", "when": "2020-04-22T04:47:27Z"}, {"anon": "stud", "to": "k92qjgxtw6r2gi", "type": "feedback", "when": "2020-04-22T05:19:36Z", "uid_a": "a_0"}, {"anon": "stud", "data": "k9ay0a3qxpx3f5", "type": "s_answer_update", "when": "2020-04-22T06:15:04Z", "uid_a": "a_0"}, {"anon": "stud", "data": "k9ay2vefhqq5e7", "type": "s_answer_update", "when": "2020-04-22T06:17:05Z", "uid_a": "a_0"}, {"anon": "no", "uid": "k7c3mir535phw", "to": "k92qjgxtw6r2gi", "type": "feedback", "when": "2020-04-22T07:01:22Z"}, {"anon": "stud", "to": "k92qjgxtw6r2gi", "type": "feedback", "when": "2020-04-22T07:02:12Z", "uid_a": "a_0"}, {"anon": "no", "uid": "k7c3mir535phw", "to": "k92qjgxtw6r2gi", "type": "feedback", "when": "2020-04-22T07:02:46Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "k7c3mir535phw", "subject": "关于BIOS和boot loader地址的问题", "created": "2020-04-16T12:23:53Z", "content": "<p>x86体系如8086的CPU通电后第一条指令0xffff0</p>\n<p>运行&#xff0c;运行的是一条ljmp指令&#xff0c;然后最后会把bootloader加载到0x7c00开始的物理地址处。我想问的是&#xff1a;0xffff0地址是整个x86体系都这样吗&#xff08;通电后CS和IP都一样吗&#xff09;&#xff1b;以及bootloader从0x7c00开始运行&#xff0c;那么bootloader是由写OS的人一同写的吗&#xff0c;还是由硬件厂商提供的呢</p>"}], "type": "question", "tags": ["lab1", "student"], "tag_good": [{"role": "student", "name": "方里明", "endorser": {}, "admin": false, "photo": null, "id": "k7c3mir535phw", "photo_url": null, "us": false, "facebook_id": null}], "unique_views": 143, "children": [{"folders": [], "data": {"embed_links": []}, "children": [], "created": "2020-04-22T03:45:42Z", "bucket_order": 3, "tag_endorse": [{"role": "student", "name": "方里明", "endorser": {}, "admin": false, "photo": null, "id": "k7c3mir535phw", "photo_url": null, "us": false, "facebook_id": null}], "bucket_name": "Today", "id": "k9aso6ex73o1q7", "history": [{"anon": "stud", "uid_a": "a_0", "subject": "", "created": "2020-04-22T06:17:05Z", "content": "<md>\n1. 因为历史兼容性的原因，整个x86体系&ldquo;看起来&rdquo;都是这样：`eip`都是`0xFFF0`，`cs`的`selector`都是`0xF000`，这和8086是一致的，对8086而言第一条指令地址就是`0xFFFF0`。但是对x86而言，初始化以后`cs`的`selector`和`base`是不匹配的，x86的`base`是`0xFFFF0000`，所以在x86下第一条指令地址是`0xFFFFFFF0`，它被映射到BIOS的ROM上，这条指令是`ljmp`，`ljmp`会刷新`cs`，之后`cs`的`selector`和`base`就一致了\n2. bootloader不是OS作者写的，由硬件厂商负责，~~只是都要遵循第一条指令在`0xFFFFFFF0`这个规则。~~<div></div>\n<div></div>\n<div>哦哦多谢，意思就是后期x86刚开始不完全一致而是通过ljmp进行向后兼容从而一致呗</div>\n<div>那么bootloader有两个文件，一个是main.c一个是boot.s，在boot.s里会读取kernel数据，这样看起来，kernel在disk上存放的扇区也是比较特殊且统一的咯</div>\n\n--\n（追问可以用下面的followup discussions）\n\n~~bootloader一般做的事是加载磁盘的引导扇区（第一个扇区）到内存~~，再根据引导扇区进一步把OS kernel加载到内存。所以kernel理论上可以存放在任意扇区，只要引导扇区能正确加载kernel就行。\n\n-- 勘误：\n上述第2点中“只是都要遵循第一条指令在`0xFFFFFFF0`这个规则”一句有误，这里说的应该是BIOS而不是bootloader，BIOS由主板硬件厂商提供。“bootloader一般做的事是加载磁盘的引导扇区（第一个扇区）到内存”一句也有误，这里说的还是BIOS，bootloader正是存储于引导扇区中、被BIOS加载到内存`0x7C00`处的程序。bootloader的功能就是进一步加载OS到内存，一般不由OS作者编写。\n</md>"}, {"anon": "stud", "uid_a": "a_0", "subject": "", "created": "2020-04-22T06:15:04Z", "content": "<md>\n1. 因为历史兼容性的原因，整个x86体系&ldquo;看起来&rdquo;都是这样：`eip`都是`0xFFF0`，`cs`的`selector`都是`0xF000`，这和8086是一致的，对8086而言第一条指令地址就是`0xFFFF0`。但是对x86而言，初始化以后`cs`的`selector`和`base`是不匹配的，x86的`base`是`0xFFFF0000`，所以在x86下第一条指令地址是`0xFFFFFFF0`，它被映射到BIOS的ROM上，这条指令是`ljmp`，`ljmp`会刷新`cs`，之后`cs`的`selector`和`base`就一致了\n2. bootloader不是OS作者写的，由硬件厂商负责，只是都要遵循第一条指令在`0xFFFFFFF0`这个规则。<div></div>\n<div></div>\n<div>哦哦多谢，意思就是后期x86刚开始不完全一致而是通过ljmp进行向后兼容从而一致呗</div>\n<div>那么bootloader有两个文件，一个是main.c一个是boot.s，在boot.s里会读取kernel数据，这样看起来，kernel在disk上存放的扇区也是比较特殊且统一的咯</div>\n\n--\n（追问可以用下面的followup discussions）\n\nbootloader一般做的事是加载磁盘的引导扇区（第一个扇区）到内存，再根据引导扇区进一步把OS kernel加载到内存。所以kernel理论上可以存放在任意扇区，只要引导扇区能正确加载kernel就行。\n\n-- 勘误：\n上述第2点中“只是都要遵循第一条指令在`0xFFFFFFF0`这个规则”一句有误，这里说的应该是BIOS而不是bootloader，BIOS由主板硬件厂商提供。“bootloader一般做的事是加载磁盘的引导扇区（第一个扇区）到内存”一句也有误，这里说的还是BIOS，bootloader正是存储于引导扇区中、被BIOS加载到内存`0x7C00`处的程序。bootloader的功能就是进一步加载OS到内存，一般不由OS作者编写。\n</md>"}, {"anon": "stud", "uid_a": "a_0", "subject": "", "created": "2020-04-22T04:42:58Z", "content": "<md>\n1. 因为历史兼容性的原因，整个x86体系&ldquo;看起来&rdquo;都是这样：`eip`都是`0xFFF0`，`cs`的`selector`都是`0xF000`，这和8086是一致的，对8086而言第一条指令地址就是`0xFFFF0`。但是对x86而言，初始化以后`cs`的`selector`和`base`是不匹配的，x86的`base`是`0xFFFF0000`，所以在x86下第一条指令地址是`0xFFFFFFF0`，它被映射到BIOS的ROM上，这条指令是`ljmp`，`ljmp`会刷新`cs`，之后`cs`的`selector`和`base`就一致了\n2. bootloader不是OS作者写的，由硬件厂商负责，只是都要遵循第一条指令在`0xFFFFFFF0`这个规则。<div></div>\n<div></div>\n<div>哦哦多谢，意思就是后期x86刚开始不完全一致而是通过ljmp进行向后兼容从而一致呗</div>\n<div>那么bootloader有两个文件，一个是main.c一个是boot.s，在boot.s里会读取kernel数据，这样看起来，kernel在disk上存放的扇区也是比较特殊且统一的咯</div>\n\n--\n（追问可以用下面的followup discussions）\n\nbootloader一般做的事是加载磁盘的引导扇区（第一个扇区）到内存，再根据引导扇区进一步把OS kernel加载到内存。所以kernel理论上可以存放在任意扇区，只要引导扇区能正确加载kernel就行。\n</md>"}, {"anon": "no", "uid": "k7c3mir535phw", "subject": "", "created": "2020-04-22T04:32:35Z", "content": "<md><br>1. 因为历史兼容性的原因，整个x86体系“看起来”都是这样：`eip`都是`0xFFF0`，`cs`的`selector`都是`0xF000`，这和8086是一致的，对8086而言第一条指令地址就是`0xFFFF0`。但是对x86而言，初始化以后`cs`的`selector`和`base`是不匹配的，x86的`base`是`0xFFFF0000`，所以在x86下第一条指令地址是`0xFFFFFFF0`，它被映射到BIOS的ROM上，这条指令是`ljmp`，`ljmp`会刷新`cs`，之后`cs`的`selector`和`base`就一致了<br>2. bootloader不是OS作者写的，由硬件厂商负责，只是都要遵循第一条指令在`0xFFFFFFF0`这个规则。<br></md><div><br /></div><div><br /></div><div>哦哦多谢&#xff0c;意思就是后期x86刚开始不完全一致而是通过ljmp进行向后兼容从而一致呗</div><div>那么bootloader有两个文件&#xff0c;一个是main.c一个是boot.s&#xff0c;在boot.s里会读取kernel数据&#xff0c;这样看起来&#xff0c;kernel在disk上存放的扇区也是比较特殊且统一的咯</div><div><br /></div>"}, {"anon": "stud", "uid_a": "a_0", "subject": "", "created": "2020-04-22T03:45:42Z", "content": "<md>\n1. 因为历史兼容性的原因，整个x86体系“看起来”都是这样：`eip`都是`0xFFF0`，`cs`的`selector`都是`0xF000`，这和8086是一致的，对8086而言第一条指令地址就是`0xFFFF0`。但是对x86而言，初始化以后`cs`的`selector`和`base`是不匹配的，x86的`base`是`0xFFFF0000`，所以在x86下第一条指令地址是`0xFFFFFFF0`，它被映射到BIOS的ROM上，这条指令是`ljmp`，`ljmp`会刷新`cs`，之后`cs`的`selector`和`base`就一致了\n2. bootloader不是OS作者写的，由硬件厂商负责，只是都要遵循第一条指令在`0xFFFFFFF0`这个规则。\n</md>"}], "type": "s_answer", "tag_endorse_arr": ["k7c3mir535phw"], "config": {}, "is_tag_endorse": false}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "奥&#xff01;最后一个问题额&#xff08;lab1内容有点多&#xff09;<div>磁盘的引导扇区内容应该是os作者的范围了吧&#xff0c;不然后续没法知道如何导入kernel数据</div>", "created": "2020-04-22T04:47:27Z", "bucket_order": 3, "bucket_name": "Today", "type": "followup", "tag_good": [], "uid": "k7c3mir535phw", "children": [{"anon": "stud", "folders": [], "data": {"embed_links": null}, "subject": "<md>\n也不是。磁盘是有文件系统格式的&#xff0c;这个文件系统格式是有统一标准的&#xff0c;比如FAT32&#xff0c;NTFS之类&#xff0c;引导扇区遵从文件系统要求。OS在安装&#xff08;烧录&#xff09;到磁盘时&#xff0c;会根据磁盘格式在引导扇区写入正确的内容指明kernel从哪里开始&#xff0c;这样BIOS启动时就会根据引导扇区从正确的磁盘位置把OS加载到正确的内存位置。OS作者负责的范围其实比你想象的有限&#xff0c;大概从OS被正确加载到内存中以后才开始。\n</md>", "created": "2020-04-22T05:19:36Z", "bucket_order": 3, "bucket_name": "Today", "type": "feedback", "tag_good": [], "uid_a": "a_0", "children": [], "tag_good_arr": [], "id": "k9aw0y65v29567", "updated": "2020-04-22T05:19:36Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "奥&#xff01;有点清楚了<div>感谢</div>", "created": "2020-04-22T07:01:22Z", "bucket_order": 3, "bucket_name": "Today", "type": "feedback", "tag_good": [], "uid": "k7c3mir535phw", "children": [], "tag_good_arr": [], "id": "k9azntjf47e2lt", "updated": "2020-04-22T07:01:22Z", "config": {}}, {"anon": "stud", "folders": [], "data": {"embed_links": null}, "subject": "<md>\n前面的部分有一些错误&#xff0c;我写在了勘误里&#xff0c;希望你看到了:-)\n</md>", "created": "2020-04-22T07:02:12Z", "bucket_order": 3, "bucket_name": "Today", "type": "feedback", "tag_good": [], "uid_a": "a_0", "children": [], "tag_good_arr": [], "id": "k9azow9nxn12wq", "updated": "2020-04-22T07:02:12Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "看了看了", "created": "2020-04-22T07:02:46Z", "bucket_order": 3, "bucket_name": "Today", "type": "feedback", "tag_good": [], "uid": "k7c3mir535phw", "children": [], "tag_good_arr": [], "id": "k9azplxbrpl3mq", "updated": "2020-04-22T07:02:46Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "k9auvllqqwu36z", "updated": "2020-04-22T04:47:27Z", "config": {}}], "tag_good_arr": ["k7c3mir535phw"], "no_answer": 0, "id": "k92qjgxtw6r2gi", "config": {"seen": {"1316": 3, "1137": 6, "444": 8, "1311": 9, "105": 1, "743": 5, "106": 0, "997": 4, "779": 7, "172": 2}}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 2, "num_favorites": 2, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643170095085, "default_anonymity": "no"}, "error": null, "aid": "kyv11rsdi9cpw"}