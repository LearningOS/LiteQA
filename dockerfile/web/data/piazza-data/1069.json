{"result": {"folders": ["lecture18", "2018"], "nr": 1069, "data": {"embed_links": []}, "created": "2017-05-06T14:47:56Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "ikjdo9jtz0e2jq", "data": "j2ddw434mc24ei", "type": "create", "when": "2017-05-06T14:47:56Z"}, {"anon": "no", "uid": "ikjdo9jtz0e2jq", "data": "j2ddxp946fp4tl", "type": "update", "when": "2017-05-06T14:49:10Z"}, {"anon": "no", "uid": "i5g31e12hcr27s", "to": "j2ddw43190u4eh", "type": "followup", "when": "2017-05-06T15:22:06Z"}, {"anon": "no", "uid": "ikjdo9jtz0e2jq", "data": "j2eaxnekcfb4ei", "type": "update", "when": "2017-05-07T06:12:55Z"}, {"anon": "no", "uid": "izb0cbqbyzd6wf", "to": "j2ddw43190u4eh", "type": "followup", "when": "2017-05-08T13:55:11Z"}, {"anon": "no", "uid": "ikjdo9jtz0e2jq", "data": "j2lfaltfshs4pw", "type": "update", "when": "2017-05-12T05:49:21Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j2ddw43190u4eh", "type": "followup", "when": "2017-06-01T16:18:33Z"}, {"anon": "no", "uid": "i0fcjeg6hm4qw", "to": "j2ddw43190u4eh", "type": "feedback", "when": "2017-06-22T16:05:53Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j2ddw43190u4eh", "type": "feedback", "when": "2017-06-23T02:40:52Z"}, {"anon": "no", "uid": "isypo4jw2xg4de", "to": "j2ddw43190u4eh", "type": "followup", "when": "2018-06-20T07:21:56Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j2ddw43190u4eh", "type": "feedback", "when": "2018-06-20T16:32:32Z"}, {"anon": "no", "uid": "isypo4jw2xg4de", "to": "j2ddw43190u4eh", "type": "feedback", "when": "2018-06-24T16:08:46Z"}, {"anon": "no", "uid": "isypo4jw2xg4de", "to": "j2ddw43190u4eh", "type": "feedback", "when": "2018-06-25T08:46:05Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j2ddw43190u4eh", "type": "feedback", "when": "2018-06-26T01:29:31Z"}, {"anon": "no", "uid": "isypo4jw2xg4de", "to": "j2ddw43190u4eh", "type": "feedback", "when": "2018-06-26T04:37:21Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j2ddw43190u4eh", "type": "feedback", "when": "2018-06-26T05:59:24Z"}, {"anon": "no", "uid": "isypo4jw2xg4de", "to": "j2ddw43190u4eh", "type": "feedback", "when": "2018-06-26T08:19:10Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "data": "jt9steffz8c1bu", "type": "update", "when": "2019-03-15T08:26:42Z"}, {"anon": "no", "uid": "jslfact6jvaN", "to": "j2ddw43190u4eh", "type": "followup", "when": "2019-05-08T18:20:13Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j2ddw43190u4eh", "type": "feedback", "when": "2019-05-09T14:43:46Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "理发师问题", "created": "2019-03-15T08:26:42Z", "content": "<p> 理发师问题&#xff1a;理发店理有一位理发师、一把理发椅和5把供等候理发的顾客坐的椅子。如果没有顾客&#xff0c;理发师便在理发椅上睡觉。一个顾客到来时&#xff0c;它必须叫醒理发师&#xff0c;如果理发师正在理发时又有顾客来到&#xff0c;则如果有空椅子可坐&#xff0c;就坐下来等待&#xff0c;否则就离开。</p>\n<p>之前的解法存在问题&#xff0c;因为试图获得一个信号量的等待队列在linux中是不太理智的行为&#xff0c;麻烦很大&#xff0c;所以我放弃了这一尝试。</p>\n<p>目前解法&#xff0c;设置顾客15名&#xff0c;在15秒内分散来到&#xff0c;理发时间3秒&#xff0c;测试用例已完善。</p>\n<pre>#include &lt;pthread.h&gt; \n#include &lt;stdio.h&gt; \n#include &lt;unistd.h&gt; \n#include &lt;stdlib.h&gt;\n#include &lt;semaphore.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;assert.h&gt;\n#define N 15\ntypedef struct{\nint num;\nint time;\n}arg;\nint b[]={1,10,3,9,4,8,5,6,7,6,4,6,7,8};\n//信号量和控制量定义\nsem_t barbeready;//为0表示理发师未准备好&#xff0c;顾客需等待;为1表示可以服务\nsem_t accessseats;//每一个线程都需要在开头申请&#xff0c;在结尾释放&#xff0c;与临界区类似&#xff0c;为1表示可以申请\nsem_t custready;//为0表示没有顾客&#xff0c;理发师睡觉;不为0表示有顾客\nsem_t mutex;\nint current=-1;\nint numofseats=5;//共5个空位\n//理发师线程\nvoid*barber(){\n\twhile(1){\n\t\tsem_wait(&amp;custready);//等待顾客到来\n\t\tsem_wait(&amp;accessseats);//进入临界区\n\t\tnumofseats&#43;=1;//座位增加\n\t\tsem_post(&amp;barbeready);//理发师做好准备\n\t\tsem_post(&amp;accessseats);//离开临界区\n\t\tsem_wait(&amp;mutex);\n\t\tprintf(&#34;barber is serving %d\\n&#34;,current);//一个顾客接受服务\n\t\tsleep(3);//3秒钟理发时间\n\t\tprintf(&#34;%d over\\n&#34;,current);\n\t}\n\treturn NULL;\n}\nvoid*customer(void*args){\n\tint*arg=(int*)args;\n\tif(arg[0]%3==0)sleep(0);\n\telse if(arg[0]%3==1)sleep(10);\n\telse sleep(arg[1]);\n\tsem_wait(&amp;accessseats);//进入临界区\n\tfor(int i=0;i&lt;=arg[0];i&#43;&#43;)printf(&#34;\\t&#34;);\n\tprintf(&#34;come\\n&#34;,arg[0]);//宣告到来\n\tif(numofseats&gt;0){//判断是否有空位\n\t\tnumofseats-=1;\n\t\tsem_post(&amp;custready);//宣告顾客到来\n\t\tsem_post(&amp;accessseats);//离开临界区\n\t\tfor(int i=0;i&lt;=arg[0];i&#43;&#43;)printf(&#34;\\t&#34;);\n\t\tprintf(&#34;waiting\\n&#34;,arg[0]);\n\t\tsem_wait(&amp;barbeready);//等待理发师准备\n\t\tcurrent=arg[0];\n\t\tfor(int i=0;i&lt;=arg[0];i&#43;&#43;)printf(&#34;\\t&#34;);\n\t\tprintf(&#34;served\\n&#34;,arg[0]);\n\t\tsem_post(&amp;mutex);\n\t}\n\telse{\n\t\tsem_post(&amp;accessseats);//没有座位&#xff0c;直接离开临界区\n\t\tfor(int i=0;i&lt;=arg[0];i&#43;&#43;)printf(&#34;\\t&#34;);\n\t\tprintf(&#34;leave\\n&#34;,arg[0]);\n\t}\n\treturn NULL;\n}\nint main(){\n\t//以下对信号量进行初始化\n\tsem_init(&amp;barbeready,0,0);\n\tsem_init(&amp;accessseats,0,1);\n\tsem_init(&amp;custready,0,0);\n\tsem_init(&amp;mutex,0,0);\n\tprintf(&#34;barber\\t&#34;);\n\tfor(int i=0;i&lt;N;i&#43;&#43;)printf(&#34;%d\\t&#34;,i);\n\tprintf(&#34;\\n&#34;);\n\t//创建1个理发师和N个顾客线程\n\tpthread_t*barberid=malloc(sizeof(pthread_t));\n\tpthread_create(barberid,NULL,barber,NULL);\n\targ*a=malloc(N*sizeof(arg));\n\tfor(int i=0;i&lt;N;i&#43;&#43;){\n\t\ta[i].num=i;\n\t\ta[i].time=b[i];\n\t}\n\tpthread_t*customerid=malloc(N*sizeof(pthread_t));\n\tfor(int i=0;i&lt;N;i&#43;&#43;)pthread_create(&amp;customerid[i],NULL,customer,&amp;(a[i]));\n\tsleep(36);\n\treturn 0;\n}\n</pre>\n<p>参考了https://en.wikipedia.org/wiki/Sleeping_barber_problem。部分输出如下&#xff1a;</p>\n<pre>barber\t0\t1\t2\t3\t4\t5\t6\t7\t8\t9\t10\t11\t12\t13\t14\t\n\tcome\n\twaiting\n\t\t\t\tcome\n\t\t\t\twaiting\n\tserved\nbarber is serving 0\n\t\t\t\t\t\t\tcome\n\t\t\t\t\t\t\twaiting\n\t\t\t\t\t\t\t\t\t\tcome\n\t\t\t\t\t\t\t\t\t\twaiting\n\t\t\t\t\t\t\t\t\t\t\t\t\tcome\n\t\t\t\t\t\t\t\t\t\t\t\t\twaiting\n\t\t\tcome\n\t\t\twaiting\n0 over\n\t\t\t\tserved\nbarber is serving 3\n\t\t\t\t\t\t\t\t\t\t\t\tcome\n\t\t\t\t\t\t\t\t\t\t\t\twaiting\n3 over\n\t\t\t\t\t\t\tserved\nbarber is serving 6\n\t\t\t\t\t\t\t\t\tcome\n\t\t\t\t\t\t\t\t\twaiting\n\t\t\t\t\t\tcome\n\t\t\t\t\t\tleave\n6 over\n\t\t\t\t\t\t\t\t\t\tserved\nbarber is serving 9\n\t\t\t\t\tcome\n\t\t\t\t\twaiting\n\t\tcome\n\t\tleave\n\t\t\t\t\t\t\t\tcome\n\t\t\t\t\t\t\t\tleave\n\t\t\t\t\t\t\t\t\t\t\tcome\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tleave\n\tcome\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tleave\n9 over\n\t\t\t\t\t\t\t\t\t\t\t\t\tserved\nbarber is serving 12\n12 over\n\t\t\tserved\nbarber is serving 2\n2 over\n\t\t\t\t\t\t\t\t\t\t\t\tserved\nbarber is serving 11\n11 over\n\t\t\t\t\t\t\t\t\tserved\nbarber is serving 8\n8 over\n\t\t\t\t\tserved\nbarber is serving 4\n4 over</pre>"}, {"anon": "no", "uid": "ikjdo9jtz0e2jq", "subject": "理发师问题", "created": "2017-05-12T05:49:21Z", "content": "<p> 理发师问题&#xff1a;理发店理有一位理发师、一把理发椅和5把供等候理发的顾客坐的椅子。如果没有顾客&#xff0c;理发师便在理发椅上睡觉。一个顾客到来时&#xff0c;它必须叫醒理发师&#xff0c;如果理发师正在理发时又有顾客来到&#xff0c;则如果有空椅子可坐&#xff0c;就坐下来等待&#xff0c;否则就离开。</p>\n<p>之前的解法存在问题&#xff0c;因为试图获得一个信号量的等待队列在linux中是不太理智的行为&#xff0c;麻烦很大&#xff0c;所以我放弃了这一尝试。</p>\n<p>目前解法&#xff0c;设置顾客15名&#xff0c;在15秒内分散来到&#xff0c;理发时间3秒&#xff0c;测试用例已完善。</p>\n<pre>#include &lt;pthread.h&gt; <br />#include &lt;stdio.h&gt; <br />#include &lt;unistd.h&gt; <br />#include &lt;stdlib.h&gt;<br />#include &lt;semaphore.h&gt;<br />#include &lt;fcntl.h&gt;<br />#include &lt;assert.h&gt;<br />#define N 15<br />typedef struct{<br />int num;<br />int time;<br />}arg;<br />int b[]={1,10,3,9,4,8,5,6,7,6,4,6,7,8};<br />//信号量和控制量定义<br />sem_t barbeready;//为0表示理发师未准备好&#xff0c;顾客需等待;为1表示可以服务<br />sem_t accessseats;//每一个线程都需要在开头申请&#xff0c;在结尾释放&#xff0c;与临界区类似&#xff0c;为1表示可以申请<br />sem_t custready;//为0表示没有顾客&#xff0c;理发师睡觉;不为0表示有顾客<br />sem_t mutex;<br />int current=-1;<br />int numofseats=5;//共5个空位<br />//理发师线程<br />void*barber(){<br />\twhile(1){<br />\t\tsem_wait(&amp;custready);//等待顾客到来<br />\t\tsem_wait(&amp;accessseats);//进入临界区<br />\t\tnumofseats&#43;=1;//座位增加<br />\t\tsem_post(&amp;barbeready);//理发师做好准备<br />\t\tsem_post(&amp;accessseats);//离开临界区<br />\t\tsem_wait(&amp;mutex);<br />\t\tprintf(&#34;barber is serving %d\\n&#34;,current);//一个顾客接受服务<br />\t\tsleep(3);//3秒钟理发时间<br />\t\tprintf(&#34;%d over\\n&#34;,current);<br />\t}<br />\treturn NULL;<br />}<br />void*customer(void*args){<br />\tint*arg=(int*)args;<br />\tif(arg[0]%3==0)sleep(0);<br />\telse if(arg[0]%3==1)sleep(10);<br />\telse sleep(arg[1]);<br />\tsem_wait(&amp;accessseats);//进入临界区<br />\tfor(int i=0;i&lt;=arg[0];i&#43;&#43;)printf(&#34;\\t&#34;);<br />\tprintf(&#34;come\\n&#34;,arg[0]);//宣告到来<br />\tif(numofseats&gt;0){//判断是否有空位<br />\t\tnumofseats-=1;<br />\t\tsem_post(&amp;custready);//宣告顾客到来<br />\t\tsem_post(&amp;accessseats);//离开临界区<br />\t\tfor(int i=0;i&lt;=arg[0];i&#43;&#43;)printf(&#34;\\t&#34;);<br />\t\tprintf(&#34;waiting\\n&#34;,arg[0]);<br />\t\tsem_wait(&amp;barbeready);//等待理发师准备<br />\t\tcurrent=arg[0];<br />\t\tfor(int i=0;i&lt;=arg[0];i&#43;&#43;)printf(&#34;\\t&#34;);<br />\t\tprintf(&#34;served\\n&#34;,arg[0]);<br />\t\tsem_post(&amp;mutex);<br />\t}<br />\telse{<br />\t\tsem_post(&amp;accessseats);//没有座位&#xff0c;直接离开临界区<br />\t\tfor(int i=0;i&lt;=arg[0];i&#43;&#43;)printf(&#34;\\t&#34;);<br />\t\tprintf(&#34;leave\\n&#34;,arg[0]);<br />\t}<br />\treturn NULL;<br />}<br />int main(){<br />\t//以下对信号量进行初始化<br />\tsem_init(&amp;barbeready,0,0);<br />\tsem_init(&amp;accessseats,0,1);<br />\tsem_init(&amp;custready,0,0);<br />\tsem_init(&amp;mutex,0,0);<br />\tprintf(&#34;barber\\t&#34;);<br />\tfor(int i=0;i&lt;N;i&#43;&#43;)printf(&#34;%d\\t&#34;,i);<br />\tprintf(&#34;\\n&#34;);<br />\t//创建1个理发师和N个顾客线程<br />\tpthread_t*barberid=malloc(sizeof(pthread_t));<br />\tpthread_create(barberid,NULL,barber,NULL);<br />\targ*a=malloc(N*sizeof(arg));<br />\tfor(int i=0;i&lt;N;i&#43;&#43;){<br />\t\ta[i].num=i;<br />\t\ta[i].time=b[i];<br />\t}<br />\tpthread_t*customerid=malloc(N*sizeof(pthread_t));<br />\tfor(int i=0;i&lt;N;i&#43;&#43;)pthread_create(&amp;customerid[i],NULL,customer,&amp;(a[i]));<br />\tsleep(36);<br />\treturn 0;<br />}\n</pre>\n<p>参考了https://en.wikipedia.org/wiki/Sleeping_barber_problem。部分输出如下&#xff1a;</p>\n<pre>barber\t0\t1\t2\t3\t4\t5\t6\t7\t8\t9\t10\t11\t12\t13\t14\t<br />\tcome<br />\twaiting<br />\t\t\t\tcome<br />\t\t\t\twaiting<br />\tserved<br />barber is serving 0<br />\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\twaiting<br />\t\t\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\t\t\twaiting<br />\t\t\t\t\t\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\t\t\t\t\t\twaiting<br />\t\t\tcome<br />\t\t\twaiting<br />0 over<br />\t\t\t\tserved<br />barber is serving 3<br />\t\t\t\t\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\t\t\t\t\twaiting<br />3 over<br />\t\t\t\t\t\t\tserved<br />barber is serving 6<br />\t\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\t\twaiting<br />\t\t\t\t\t\tcome<br />\t\t\t\t\t\tleave<br />6 over<br />\t\t\t\t\t\t\t\t\t\tserved<br />barber is serving 9<br />\t\t\t\t\tcome<br />\t\t\t\t\twaiting<br />\t\tcome<br />\t\tleave<br />\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\tleave<br />\t\t\t\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tleave<br />\tcome<br />\t\t\t\t\t\t\t\t\t\t\t\t\t\tleave<br />9 over<br />\t\t\t\t\t\t\t\t\t\t\t\t\tserved<br />barber is serving 12<br />12 over<br />\t\t\tserved<br />barber is serving 2<br />2 over<br />\t\t\t\t\t\t\t\t\t\t\t\tserved<br />barber is serving 11<br />11 over<br />\t\t\t\t\t\t\t\t\tserved<br />barber is serving 8<br />8 over<br />\t\t\t\t\tserved<br />barber is serving 4<br />4 over</pre>"}, {"anon": "no", "uid": "ikjdo9jtz0e2jq", "subject": "理发师问题", "created": "2017-05-07T06:12:55Z", "content": "<p> 理发师问题&#xff1a;理发店理有一位理发师、一把理发椅和5把供等候理发的顾客坐的椅子。如果没有顾客&#xff0c;理发师便在理发椅上睡觉。一个顾客到来时&#xff0c;它必须叫醒理发师&#xff0c;如果理发师正在理发时又有顾客来到&#xff0c;则如果有空椅子可坐&#xff0c;就坐下来等待&#xff0c;否则就离开。</p>\n<p>之前的解法存在问题&#xff0c;因为试图获得一个信号量的等待队列在linux中是不太理智的行为&#xff0c;麻烦很大&#xff0c;所以我放弃了这一尝试。</p>\n<p>目前解法&#xff0c;设置顾客15名&#xff0c;在15秒内分散来到&#xff0c;理发时间3秒。&#xff08;测试用例待完善&#xff0c;目前测试是有5名顾客在第0秒到来&#xff0c;5名顾客在第10秒到来&#xff0c;其他顾客随机到来&#xff09;</p>\n<pre>#include &lt;pthread.h&gt; <br />#include &lt;stdio.h&gt; <br />#include &lt;unistd.h&gt; <br />#include &lt;stdlib.h&gt;<br />#include &lt;semaphore.h&gt;<br />#include &lt;fcntl.h&gt;<br />#include &lt;assert.h&gt;<br />#define N 15<br />//信号量和控制量定义<br />sem_t barbeready;//为0表示理发师未准备好&#xff0c;顾客需等待;为1表示可以服务<br />sem_t accessseats;//每一个线程都需要在开头申请&#xff0c;在结尾释放&#xff0c;与临界区类似&#xff0c;为1表示可以申请<br />sem_t custready;//为0表示没有顾客&#xff0c;理发师睡觉;不为0表示有顾客<br />sem_t mutex;<br />int current=-1;<br />int numofseats=5;//共5个空位<br />//理发师线程<br />void*barber(){<br />\twhile(1){<br />\t\tsem_wait(&amp;custready);//等待顾客到来<br />\t\tsem_wait(&amp;accessseats);//进入临界区<br />\t\tnumofseats&#43;=1;//座位增加<br />\t\tsem_post(&amp;barbeready);//理发师做好准备<br />\t\tsem_post(&amp;accessseats);//离开临界区<br />\t\tsem_wait(&amp;mutex);<br />\t\tprintf(&#34;barber is serving %d\\n&#34;,current);//一个顾客接受服务<br />\t\tsleep(3);//3秒钟理发时间<br />\t\tprintf(&#34;%d over\\n&#34;,current);<br />\t}<br />\treturn NULL;<br />}<br />void*customer(void*args){<br />\tint*arg=(int*)args;<br />\tif(arg[0]%3==0)sleep(0);<br />\telse if(arg[0]%3==1)sleep(10);<br />\telse sleep(rand()%N);<br />\tsem_wait(&amp;accessseats);//进入临界区<br />\tfor(int i=0;i&lt;=arg[0];i&#43;&#43;)printf(&#34;\\t&#34;);<br />\tprintf(&#34;come\\n&#34;,arg[0]);//宣告到来<br />\tif(numofseats&gt;0){//判断是否有空位<br />\t\tnumofseats-=1;<br />\t\tsem_post(&amp;custready);//宣告顾客到来<br />\t\tsem_post(&amp;accessseats);//离开临界区<br />\t\tfor(int i=0;i&lt;=arg[0];i&#43;&#43;)printf(&#34;\\t&#34;);<br />\t\tprintf(&#34;waiting\\n&#34;,arg[0]);<br />\t\tsem_wait(&amp;barbeready);//等待理发师准备<br />\t\tcurrent=arg[0];<br />\t\tfor(int i=0;i&lt;=arg[0];i&#43;&#43;)printf(&#34;\\t&#34;);<br />\t\tprintf(&#34;served\\n&#34;,arg[0]);<br />\t\tsem_post(&amp;mutex);<br />\t}<br />\telse{<br />\t\tsem_post(&amp;accessseats);//没有座位&#xff0c;直接离开临界区<br />\t\tfor(int i=0;i&lt;=arg[0];i&#43;&#43;)printf(&#34;\\t&#34;);<br />\t\tprintf(&#34;leave\\n&#34;,arg[0]);<br />\t}<br />\treturn NULL;<br />}<br />int main(){<br />\t//以下对信号量进行初始化<br />\tsem_init(&amp;barbeready,0,0);<br />\tsem_init(&amp;accessseats,0,1);<br />\tsem_init(&amp;custready,0,0);<br />\tsem_init(&amp;mutex,0,0);<br />\tprintf(&#34;barber\\t&#34;);<br />\tfor(int i=0;i&lt;N;i&#43;&#43;)printf(&#34;%d\\t&#34;,i);<br />\tprintf(&#34;\\n&#34;);<br />\t//创建1个理发师和N个顾客线程<br />\tpthread_t*barberid=malloc(sizeof(pthread_t));<br />\tpthread_create(barberid,NULL,barber,NULL);<br />\tint*num=malloc(N*sizeof(int));<br />\tfor(int i=0;i&lt;N;i&#43;&#43;)num[i]=i;<br />\tpthread_t*customerid=malloc(N*sizeof(pthread_t));<br />\tfor(int i=0;i&lt;N;i&#43;&#43;)pthread_create(&amp;customerid[i],NULL,customer,&amp;(num[i]));<br />\tsleep(36);<br />\treturn 0;<br />}\n</pre>\n<p>参考了https://en.wikipedia.org/wiki/Sleeping_barber_problem。部分输出如下&#xff1a;</p>\n<pre>barber\t0\t1\t2\t3\t4\t5\t6\t7\t8\t9\t10\t11\t12\t13\t14\t<br />\tcome<br />\twaiting<br />\t\t\t\tcome<br />\t\t\t\twaiting<br />\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\twaiting<br />\t\t\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\t\t\twaiting<br />\t\t\t\t\t\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\t\t\t\t\t\twaiting<br />\tserved<br />barber is serving 0<br />\t\t\t\t\t\tcome<br />\t\t\t\t\t\twaiting<br />0 over<br />\t\t\t\tserved<br />barber is serving 3<br />3 over<br />\t\t\t\t\t\t\tserved<br />barber is serving 6<br />\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twaiting<br />6 over<br />\t\t\t\t\t\t\t\t\t\tserved<br />barber is serving 9<br />\t\tcome<br />\t\twaiting<br />\t\t\t\t\tcome<br />\t\t\t\t\twaiting<br />\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\tleave<br />\t\t\t\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\t\t\t\tleave<br />\t\t\t\t\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\t\t\t\t\tleave<br />\t\t\t\t\t\t\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\t\t\t\t\t\t\tleave<br />\t\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\t\tleave<br />9 over<br />\t\t\t\t\t\t\t\t\t\t\t\t\tserved<br />barber is serving 12<br />\t\t\tcome<br />\t\t\twaiting<br />12 over<br />\t\t\t\t\t\tserved<br />barber is serving 5<br />5 over<br />\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tserved<br />barber is serving 14<br />14 over<br />\t\tserved<br />barber is serving 1<br />1 over<br />\t\t\t\t\tserved<br />barber is serving 4<br />4 over<br />\t\t\tserved<br />barber is serving 2<br />2 over</pre>"}, {"anon": "no", "uid": "ikjdo9jtz0e2jq", "subject": "理发师问题", "created": "2017-05-06T14:49:10Z", "content": "<p> 理发师问题&#xff1a;理发店理有一位理发师、一把理发椅和5把供等候理发的顾客坐的椅子。如果没有顾客&#xff0c;理发师便在理发椅上睡觉。一个顾客到来时&#xff0c;它必须叫醒理发师&#xff0c;如果理发师正在理发时又有顾客来到&#xff0c;则如果有空椅子可坐&#xff0c;就坐下来等待&#xff0c;否则就离开。</p>\n<p>Linux解法&#xff0c;设置顾客100名&#xff0c;在100秒内分散来到&#xff0c;理发时间3秒。</p>\n<pre>#include &lt;pthread.h&gt; \n#include &lt;stdio.h&gt; \n#include &lt;unistd.h&gt; \n#include &lt;stdlib.h&gt;\n#include &lt;semaphore.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;assert.h&gt;\n#define N 100\n//链表操作\ntypedef struct n{\n\tstruct n*next;\n\tstruct n*prev;\n\tint i;\n}node;\nnode*header,*trailer;\nint dequeue(){\n\tnode*d=header-&gt;next;\n\tassert(d!=trailer);\n\td-&gt;prev-&gt;next=d-&gt;next;\n\td-&gt;next-&gt;prev=d-&gt;prev;\n\tint result=d-&gt;i;\n\tfree(d);\n\treturn result;\n}\nvoid enqueue(int result){\n\tnode*d=malloc(sizeof(node));\n\td-&gt;i=result;\n\td-&gt;next=trailer;\n\td-&gt;prev=trailer-&gt;prev;\n\ttrailer-&gt;prev=d;\n\td-&gt;prev-&gt;next=d;\n}\n//输出链表信息\nvoid printwaiting(){\n\tprintf(&#34;waiting: &#34;);\n\tfor(node*n=header-&gt;next;n!=trailer;n=n-&gt;next)printf(&#34;%d\\t&#34;,n-&gt;i);\n\tprintf(&#34;\\n&#34;);\n}\n//信号量和控制量定义\nsem_t barbeready;//为0表示理发师未准备好&#xff0c;顾客需等待;为1表示可以服务\nsem_t accessseats;//每一个线程都需要在开头申请&#xff0c;在结尾释放&#xff0c;与临界区类似&#xff0c;为1表示可以申请\nsem_t custready;//为0表示没有顾客&#xff0c;理发师睡觉;不为0表示有顾客\nint numofseats=5;//共5个空位\n//理发师线程\nvoid*barber(){\n\twhile(1){\n\t\tsem_wait(&amp;custready);//等待顾客到来\n\t\tsem_wait(&amp;accessseats);//进入临界区\n\t\tnumofseats&#43;=1;//座位增加\n\t\tsem_post(&amp;barbeready);//理发师做好准备\n\t\tsem_post(&amp;accessseats);//离开临界区\n\t\tprintwaiting();\n\t\tprintf(&#34;%d is served\\n&#34;,dequeue());//队首接受服务\n\t\tsleep(3);//3秒钟理发时间\n\t}\n\treturn NULL;\n}\nvoid*customer(void*args){\n\tint*arg=(int*)args;\n\tsleep(rand()%N);\n\tsem_wait(&amp;accessseats);//进入临界区\n\tprintf(&#34;%d comes\\n&#34;,arg[0]);//宣告到来\n\tif(numofseats&gt;0){//判断是否有空位\n\t\tnumofseats-=1;\n\t\tenqueue(arg[0]);//自己入队\n\t\tsem_post(&amp;custready);//宣告顾客到来\n\t\tsem_post(&amp;accessseats);//离开临界区\n\t\tsem_wait(&amp;barbeready);//等待理发师准备;不可以和上一句颠倒&#xff0c;否则理发师进程虽然可以得到barbeready信号量做好准备&#xff0c;但不能进入临界区&#xff0c;造成死锁。\n\t}\n\telse{\n\t\tsem_post(&amp;accessseats);//没有座位&#xff0c;直接离开临界区\n\t\tprintf(&#34;%d leave\\n&#34;,arg[0]);\n\t}\n\treturn NULL;\n}\nint main(){\n\t//以下对链表进行初始化\n\theader=malloc(sizeof(node));\n\ttrailer=malloc(sizeof(node));\n\theader-&gt;prev=trailer-&gt;next=NULL;\n\theader-&gt;i=trailer-&gt;i=-1;\n\theader-&gt;next=trailer;\n\ttrailer-&gt;prev=header;\n\t//以下对信号量进行初始化\n\tsem_init(&amp;barbeready,0,0);\n\tsem_init(&amp;accessseats,0,1);\n\tsem_init(&amp;custready,0,0);\n\t//创建1个理发师和N个顾客线程\n\tpthread_t*barberid=malloc(sizeof(pthread_t));\n\tpthread_create(barberid,NULL,barber,NULL);\n\tint*num=malloc(N*sizeof(int));\n\tfor(int i=0;i&lt;N;i&#43;&#43;)num[i]=i;\n\tpthread_t*customerid=malloc(N*sizeof(pthread_t));\n\tfor(int i=0;i&lt;N;i&#43;&#43;)pthread_create(&amp;customerid[i],NULL,customer,&amp;(num[i]));\n\tsleep(110);\n\treturn 0;\n}\n</pre>\n<p>参考了https://en.wikipedia.org/wiki/Sleeping_barber_problem。部分输出如下&#xff1a;</p>\n<pre>31 comes\nwaiting: 31\t\n31 is served\n86 comes\nwaiting: 86\t\n86 is served\n60 comes\n65 comes\nwaiting: 60\t65\t\n60 is served\n81 comes\n20 comes\n38 comes\nwaiting: 65\t81\t20\t38\t\n65 is served\n95 comes\n50 comes\n68 comes\n68 leave\nwaiting: 81\t20\t38\t95\t50\t\n81 is served\n74 comes\n4 comes\n4 leave\n48 comes\n48 leave\nwaiting: 20\t38\t95\t50\t74\t\n20 is served\n43 comes\nwaiting: 38\t95\t50\t74\t43\t\n38 is served\n9 comes\n42 comes\n42 leave\n32 comes\n32 leave\n27 comes\n27 leave\nwaiting: 95\t50\t74\t43\t9\t\n95 is served\n47 comes\n70 comes\n70 leave\n61 comes\n61 leave\n15 comes\n15 leave\n17 comes\n17 leave\n51 comes\n51 leave\nwaiting: 50\t74\t43\t9\t47\t\n50 is served\n96 comes\n11 comes\n11 leave\n63 comes\n63 leave\n23 comes\n23 leave\n30 comes\n30 leave\n40 comes\n40 leave\n67 comes\n67 leave\nwaiting: 74\t43\t9\t47\t96\t\n74 is served\n25 comes\n90 comes\n90 leave\nwaiting: 43\t9\t47\t96\t25\t\n43 is served\n76 comes</pre>\n<p></p>"}, {"anon": "no", "uid": "ikjdo9jtz0e2jq", "subject": "理发师问题", "created": "2017-05-06T14:47:56Z", "content": "<p> 理发师问题&#xff1a;理发店理有一位理发师、一把理发椅和5把供等候理发的顾客坐的椅子。如果没有顾客&#xff0c;理发师便在理发椅上睡觉。一个顾客到来时&#xff0c;它必须叫醒理发师&#xff0c;如果理发师正在理发时又有顾客来到&#xff0c;则如果有空椅子可坐&#xff0c;就坐下来等待&#xff0c;否则就离开。</p>\n<p>Linux解法&#xff1a;</p>\n<pre>#include &lt;pthread.h&gt; <br />#include &lt;stdio.h&gt; <br />#include &lt;unistd.h&gt; <br />#include &lt;stdlib.h&gt;<br />#include &lt;semaphore.h&gt;<br />#include &lt;fcntl.h&gt;<br />#include &lt;assert.h&gt;<br />#define N 100<br />//链表操作<br />typedef struct n{<br />\tstruct n*next;<br />\tstruct n*prev;<br />\tint i;<br />}node;<br />node*header,*trailer;<br />int dequeue(){<br />\tnode*d=header-&gt;next;<br />\tassert(d!=trailer);<br />\td-&gt;prev-&gt;next=d-&gt;next;<br />\td-&gt;next-&gt;prev=d-&gt;prev;<br />\tint result=d-&gt;i;<br />\tfree(d);<br />\treturn result;<br />}<br />void enqueue(int result){<br />\tnode*d=malloc(sizeof(node));<br />\td-&gt;i=result;<br />\td-&gt;next=trailer;<br />\td-&gt;prev=trailer-&gt;prev;<br />\ttrailer-&gt;prev=d;<br />\td-&gt;prev-&gt;next=d;<br />}<br />//输出链表信息<br />void printwaiting(){<br />\tprintf(&#34;waiting: &#34;);<br />\tfor(node*n=header-&gt;next;n!=trailer;n=n-&gt;next)printf(&#34;%d\\t&#34;,n-&gt;i);<br />\tprintf(&#34;\\n&#34;);<br />}<br />//信号量和控制量定义<br />sem_t barbeready;//为0表示理发师未准备好&#xff0c;顾客需等待;为1表示可以服务<br />sem_t accessseats;//每一个线程都需要在开头申请&#xff0c;在结尾释放&#xff0c;与临界区类似&#xff0c;为1表示可以申请<br />sem_t custready;//为0表示没有顾客&#xff0c;理发师睡觉;不为0表示有顾客<br />int numofseats=5;//共5个空位<br />//理发师线程<br />void*barber(){<br />\twhile(1){<br />\t\tsem_wait(&amp;custready);//等待顾客到来<br />\t\tsem_wait(&amp;accessseats);//进入临界区<br />\t\tnumofseats&#43;=1;//座位增加<br />\t\tsem_post(&amp;barbeready);//理发师做好准备<br />\t\tsem_post(&amp;accessseats);//离开临界区<br />\t\tprintwaiting();<br />\t\tprintf(&#34;%d is served\\n&#34;,dequeue());//队首接受服务<br />\t\tsleep(3);//3秒钟理发时间<br />\t}<br />\treturn NULL;<br />}<br />void*customer(void*args){<br />\tint*arg=(int*)args;<br />\tsleep(rand()%N);<br />\tsem_wait(&amp;accessseats);//进入临界区<br />\tprintf(&#34;%d comes\\n&#34;,arg[0]);//宣告到来<br />\tif(numofseats&gt;0){//判断是否有空位<br />\t\tnumofseats-=1;<br />\t\tenqueue(arg[0]);//自己入队<br />\t\tsem_post(&amp;custready);//宣告顾客到来<br />\t\tsem_post(&amp;accessseats);//离开临界区<br />\t\tsem_wait(&amp;barbeready);//等待理发师准备;不可以和上一句颠倒&#xff0c;否则理发师进程虽然可以得到barbeready信号量做好准备&#xff0c;但不能进入临界区&#xff0c;造成死锁。<br />\t}<br />\telse{<br />\t\tsem_post(&amp;accessseats);//没有座位&#xff0c;直接离开临界区<br />\t\tprintf(&#34;%d leave\\n&#34;,arg[0]);<br />\t}<br />\treturn NULL;<br />}<br />int main(){<br />\t//以下对链表进行初始化<br />\theader=malloc(sizeof(node));<br />\ttrailer=malloc(sizeof(node));<br />\theader-&gt;prev=trailer-&gt;next=NULL;<br />\theader-&gt;i=trailer-&gt;i=-1;<br />\theader-&gt;next=trailer;<br />\ttrailer-&gt;prev=header;<br />\t//以下对信号量进行初始化<br />\tsem_init(&amp;barbeready,0,0);<br />\tsem_init(&amp;accessseats,0,1);<br />\tsem_init(&amp;custready,0,0);<br />\t//创建1个理发师和N个顾客线程<br />\tpthread_t*barberid=malloc(sizeof(pthread_t));<br />\tpthread_create(barberid,NULL,barber,NULL);<br />\tint*num=malloc(N*sizeof(int));<br />\tfor(int i=0;i&lt;N;i&#43;&#43;)num[i]=i;<br />\tpthread_t*customerid=malloc(N*sizeof(pthread_t));<br />\tfor(int i=0;i&lt;N;i&#43;&#43;)pthread_create(&amp;customerid[i],NULL,customer,&amp;(num[i]));<br />\tsleep(110);<br />\treturn 0;<br />}<br /></pre>\n<p>参考了https://en.wikipedia.org/wiki/Sleeping_barber_problem。部分输出如下&#xff1a;</p>\n<pre>31 comes<br />waiting: 31\t<br />31 is served<br />86 comes<br />waiting: 86\t<br />86 is served<br />60 comes<br />65 comes<br />waiting: 60\t65\t<br />60 is served<br />81 comes<br />20 comes<br />38 comes<br />waiting: 65\t81\t20\t38\t<br />65 is served<br />95 comes<br />50 comes<br />68 comes<br />68 leave<br />waiting: 81\t20\t38\t95\t50\t<br />81 is served<br />74 comes<br />4 comes<br />4 leave<br />48 comes<br />48 leave<br />waiting: 20\t38\t95\t50\t74\t<br />20 is served<br />43 comes<br />waiting: 38\t95\t50\t74\t43\t<br />38 is served<br />9 comes<br />42 comes<br />42 leave<br />32 comes<br />32 leave<br />27 comes<br />27 leave<br />waiting: 95\t50\t74\t43\t9\t<br />95 is served<br />47 comes<br />70 comes<br />70 leave<br />61 comes<br />61 leave<br />15 comes<br />15 leave<br />17 comes<br />17 leave<br />51 comes<br />51 leave<br />waiting: 50\t74\t43\t9\t47\t<br />50 is served<br />96 comes<br />11 comes<br />11 leave<br />63 comes<br />63 leave<br />23 comes<br />23 leave<br />30 comes<br />30 leave<br />40 comes<br />40 leave<br />67 comes<br />67 leave<br />waiting: 74\t43\t9\t47\t96\t<br />74 is served<br />25 comes<br />90 comes<br />90 leave<br />waiting: 43\t9\t47\t96\t25\t<br />43 is served<br />76 comes</pre>\n<p></p>"}], "type": "note", "tags": ["2018", "lecture18", "student"], "tag_good": [{"role": "instructor", "name": "Yong XIANG", "endorser": {}, "admin": true, "photo": null, "id": "hdjonbiyfs62ie", "photo_url": null, "us": false, "class_sections": ["课程设计_i5j09fnsl7k5x0", "清华学生_i5j09fnsl7k5x0", "所有老师和助教_i5j09fnsl7k5x0", "os2018spring_i5j09fnsl7k5x0"], "facebook_id": null}], "unique_views": 182, "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p><a href=\"https://gist.github.com/mengcz13/c032ef918cf8ceb34761cc207c9a80ed\">https://gist.github.com/mengcz13/c032ef918cf8ceb34761cc207c9a80ed</a></p>\n<p></p>\n<pre>Barber is sleeping...\n1 customer entered, and 0 customers are waiting...\n1 customer sits at 0!\nSEAT0\tSEAT1\tSEAT2\tBARBERSEAT\n1\t0\t0\t0\nBarber starts working...\n2 customer entered, and 0 customers are waiting...\n2 customer sits at 0!\nSEAT0\tSEAT1\tSEAT2\tBARBERSEAT\n2\t0\t0\t1\n3 customer entered, and 1 customers are waiting...\n3 customer sits at 1!\nSEAT0\tSEAT1\tSEAT2\tBARBERSEAT\n2\t3\t0\t1\nCustomer 1 has just had his hair cut!\nBarber starts working...\nCustomer 2 has just had his hair cut!\nBarber starts working...\nCustomer 3 has just had his hair cut!\nBarber is sleeping...\n4 customer entered, and 0 customers are waiting...\n4 customer sits at 0!\nSEAT0\tSEAT1\tSEAT2\tBARBERSEAT\n4\t0\t0\t0\nBarber starts working...\n5 customer entered, and 0 customers are waiting...\n5 customer sits at 0!\nSEAT0\tSEAT1\tSEAT2\tBARBERSEAT\n5\t0\t0\t4\n6 customer entered, and 1 customers are waiting...\n6 customer sits at 1!\nSEAT0\tSEAT1\tSEAT2\tBARBERSEAT\n5\t6\t0\t4\nCustomer 4 has just had his hair cut!\nBarber starts working...\n7 customer entered, and 1 customers are waiting...\n7 customer sits at 0!\nSEAT0\tSEAT1\tSEAT2\tBARBERSEAT\n7\t6\t0\t5\n8 customer entered, and 2 customers are waiting...\n8 customer sits at 2!\nSEAT0\tSEAT1\tSEAT2\tBARBERSEAT\n7\t6\t8\t5\nCustomer 5 has just had his hair cut!\nBarber starts working...\nCustomer 6 has just had his hair cut!\nBarber starts working...\n9 customer entered, and 1 customers are waiting...\n9 customer sits at 0!\nSEAT0\tSEAT1\tSEAT2\tBARBERSEAT\n9\t0\t8\t7\n10 customer entered, and 2 customers are waiting...\n10 customer sits at 1!\nSEAT0\tSEAT1\tSEAT2\tBARBERSEAT\n9\t10\t8\t7\nCustomer 7 has just had his hair cut!\nBarber starts working...\nCustomer 8 has just had his hair cut!\nBarber starts working...\nCustomer 9 has just had his hair cut!\nBarber starts working...\nCustomer 10 has just had his hair cut!\nBarber is sleeping...</pre>\n<p></p>", "created": "2017-05-06T15:22:06Z", "bucket_order": 161, "bucket_name": "Week 4/30 - 5/6", "type": "followup", "tag_good": [], "uid": "i5g31e12hcr27s", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "j2df429qerv2rf", "updated": "2017-05-06T15:22:06Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>我使用 nodejs 重新实现了一下这个问题.</p>\n<p></p>\n<p>nodejs 的好处在于原生支持异步, 但是实际上是单线程执行, 一个函数执行过程中不会因为时钟中断而挂起, 相当于每个函数自带了锁. 所以更方便研究同步问题. </p>\n<p></p>\n<p>我使用了 sempahore 这个库的信号量. 然后先写了一个能正常输出的版本.</p>\n<p></p>\n<pre>const chairs = 5;\nconst barbers = 1;\nconst comeTime = [ 1, 2, 3, 5, 5, 5, 5, 25 ];\nconst costTime = [ 1, 1, 1, 1, 1, 1, 4, 7 ];\n\nvar Semaphore = require(&#39;semaphore&#39;);\nvar waitingQue = new Semaphore(1);\nvar waitingCount = 0;\nvar barber = new Semaphore(barbers);\n\nvar beginTime = Date.now();\n\nvar clock = function() {\n    return Date.now() - beginTime;\n};\n\nvar customerCome = function(timeConsume, callback) {\n    if (waitingCount &gt;= chairs) {\n        return callback(0, clock());\n    }\n    &#43;&#43; waitingCount;\n    callback(-1, clock());\n    waitingQue.take(function() {\n        barber.take(function() {\n            waitingQue.leave();\n            callback(1, clock());\n            -- waitingCount;\n            setTimeout(function() {\n                barber.leave();\n                callback(2, clock());\n            }, timeConsume);\n        });\n    });\n};\n\n(function() {\n    var customers = {};\n    var actmap = {\n        &#39;-2&#39;: &#39; &#39;,\n        &#39;-1&#39;: &#39;.&#39;,\n        &#39;0&#39;: &#39; &#39;,\n        &#39;1&#39;: &#39;|&#39;,\n        &#39;2&#39;: &#39; &#39;\n    };\n    var formated = [];\n    var endMark = new Semaphore(1);\n    var n = comeTime.length;\n    for (var i = 0; i &lt; n; &#43;&#43; i) {\n        customers[i] = -2;\n        endMark.take(function() {});\n        (function(i) {\n            setTimeout(function() {\n                customerCome(costTime[i], function(stat, time) {\n                    customers[i] = stat;\n                    var line = [];\n                    for (var j = 0; j &lt; n; &#43;&#43; j) {\n                        line.push(actmap[customers[j]]);\n                    }\n                    var action = &#39;unknown&#39;;\n                    if (stat === -1) {\n                        action = &#39;starts waiting&#39;;\n                    } else if (stat === 0) {\n                        action = &#39;left with anger&#39;;\n                        line[i] = &#39;g&#39;;\n                    } else if (stat === 1) {\n                        action = &#39;starts being served&#39;;\n                        line[i] = &#39;v&#39;;\n                    } else if (stat === 2) {\n                        action = &#39;finishes his barber&#39;;\n                        line[i] = &#39;^&#39;;\n                    }\n                    console.log(&#39;Customer &#39; &#43; i &#43; &#39; &#39; &#43; action &#43; &#39; at &#39; &#43; time);\n                    formated.push(line.join(&#39; &#39;));\n                    if (stat === 0 || stat === 2) {\n                        endMark.leave();\n                    }\n                });\n            }, comeTime[i]);\n        })(i);\n    }\n    endMark.take(function() {\n        console.log(formated.join(&#39;\\n&#39;));\n    });\n})();</pre>\n<p></p>\n<p>这里可以在程序开头位置自定义测试用例. 经过各种例子的测试感觉没有问题.</p>\n<p></p>\n<p>其中我用了一个初值为 1 的信号量 waitingQueue. 它的第一个可以称作 &#34;活跃顾客&#34;, 这个人会作为唯一一个正在等理发师的顾客. 而另外几个人会乖乖坐在椅子上.</p>\n<p></p>\n<p>然后我发现没有必要为 &#34;椅子&#34; (即等待队列) 单独开一个信号量. 因为 &#34;理发师&#34; 这个信号量自带了一个队列, 如果不用或者像上面一样只放一个元素, 那就浪费了. 所以直接将 &#34;理发师&#34; 这个信号量的等待队列视作 5 把椅子, 只保留 waitingCount 就可以了.</p>\n<p></p>\n<p>新的 customerCome 代码如下.</p>\n<p></p>\n<pre>var customerCome = function(timeConsume, callback) {\n    if (waitingCount &gt;= chairs) {\n        return callback(0, clock());\n    }\n    &#43;&#43; waitingCount;\n    callback(-1, clock());\n    barber.take(function() {\n        callback(1, clock());\n        -- waitingCount;\n        setTimeout(function() {\n            barber.leave();\n            callback(2, clock());\n        }, timeConsume);\n    });\n};</pre>\n<p></p>\n<p>可能这样的逻辑没有使用两个信号量清楚, 但是实现的功能是完全一样的. 更进一步, 我认为原题作者就是想让我们用 &#34;理发师&#34; 和 &#34;椅子&#34; 来更加充分地理解信号量调度同步互斥进程的过程.</p>", "created": "2017-05-08T13:55:11Z", "bucket_order": 160, "bucket_name": "Week 5/7 - 5/13", "type": "followup", "tag_good": [], "uid": "izb0cbqbyzd6wf", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "j2g6vzs5en76uk", "updated": "2017-05-08T13:55:11Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>理发店理有m位理发师、m把理发椅和n把供等候理发的顾客坐的椅子。理发师为一位顾客理完发后&#xff0c;查看是否有顾客等待&#xff0c;如有则唤醒一位为其理发&#xff1b;如果没有顾客&#xff0c;理发师便在理发椅上睡觉。一个新顾客到来时&#xff0c;首先查看理发师在干什么&#xff0c;如果理发师在理发椅上睡觉&#xff0c;他必须叫醒理发师&#xff0c;然后理发师理发&#xff0c;顾客被理发&#xff1b;如果理发师正在理发&#xff0c;则新顾客会在有空椅子可坐时坐下来等待&#xff0c;否则就会离开。请用信号量机制实现理发师问题的正确且高效的同步与互斥活动&#xff1a;请说明所定义的信号量的含义和初始值&#xff0c;描述需要进行互斥处理的各种行为&#xff0c;描述需要进行同步处理的各种行为&#xff1b;要求用类C语言的伪代码实现&#xff0c;并给出必要的简明代码注释。</p>\n<p></p>\n<p>上面是期末考试的一个题目&#xff0c;今天有同学在查阅答卷时描述一些独特的解法。在此给出一种参考回答&#xff0c;希望有兴趣的同学回复你的独特解法。</p>\n<p></p>\n<pre>// Make command: g&#43;&#43; barber.cpp -o barber -pthread\n// Ref: https://piazza.com/class/i5j09fnsl7k5x0?cid=391\n//      http://suanfazu.com/t/sleeping-barber-algorithm-with-multiple-barbers/14580/2\n// Question: Sleeping barber algorithm with multiple barbers\n\n#include &lt;stdio.h&gt;\n#include &lt;pthread.h&gt;\n#include &lt;dispatch/dispatch.h&gt;\n#include &lt;cstring&gt;\n#include &lt;unistd.h&gt;\n#include &lt;string&gt;\n#include &lt;cstdlib&gt;\n\nusing namespace std;\n\nstruct arg_struct{\n  arg_struct(int _id, int _start, int _work, string _indent): id(_id), start(_start), work(_work), indent(_indent){}\n  arg_struct(int _id): id(_id), start(0), work(0), indent(string(&#34;&#34;)){}\n  int id;\n  int start;\n  int work;\n  string indent;  \n};\n\n#define WORK_SPAN 4\nint a_task_done = -1;\nint b_task_done = -1; \n\n// Synchronization Problem Parameters:\n#define MAX_CHAIRS 2        //No. of chairs in waiting room\n#define CUT_TIME 1           //Hair Cutting Time 1 second\n#define NUM_BARB 2           //No. of barbers\n#define MAX_CUST 10          //Maximum no. of customers for simulation\n\ndispatch_semaphore_t customers;                 //Semaphore\ndispatch_semaphore_t barbers;                   //Semaphore\ndispatch_semaphore_t mutex;                     //Semaphore for providing mutially exclusive access\nint numberOfFreeSeats = MAX_CHAIRS;   //Counter for Vacant seats in waiting room\nint seatPocket[MAX_CHAIRS];           //To exchange pid between customer and barber\nint sitHereNext = 0;                  //Index for next legitimate seat\nint serveMeNext = 0;                  //Index to choose a candidate for cutting hair\nint customer_count = 0;                 //Counter of No. of customers\n\n// Synchronization user thread: UserA--Barber\nvoid* UserA(void* argv){\n  arg_struct arg = *(arg_struct*)argv;\n  int id = arg.id;\n  const char* indent = arg.indent.c_str();\n\n  sleep(arg.start);\n\n  printf(&#34;%sARRIVAL\\n&#34;, indent);\n\n  int index = strlen(indent);\n  int myNext, C;\n\n  while(1)      /*Infinite loop*/ \n  { \n      printf(&#34;%sBarber-%d Gone To Sleep.\\n&#34;, indent, index);\n      dispatch_semaphore_wait(barbers, DISPATCH_TIME_FOREVER);  //Join queue of sleeping barbers\n      dispatch_semaphore_wait(mutex, DISPATCH_TIME_FOREVER);  //Lock mutex to protect seat changes\n        serveMeNext = (&#43;&#43;serveMeNext) % MAX_CHAIRS;  //Select next customer\n        myNext = serveMeNext;\n        C = seatPocket[myNext];                  //Get selected customer&#39;s PID\n        seatPocket[myNext] = index;     //Leave own PID for customer\n      dispatch_semaphore_signal(mutex);\n      dispatch_semaphore_signal(customers); //Call selected customer\n                /*Barber is cutting hair of customer &#39;C&#39;*/\n      printf(&#34;%sBarber-%d Wakes Up &amp; Is Cutting Hair Of Customer-%d.\\n&#34;, indent, index,C-1);\n      sleep(arg.work);\n      printf(&#34;%sBarber-%d Finishes.\\n&#34;, indent, index);\n  }\n\n  a_task_done&#43;&#43;;\n  printf(&#34;%sDONE\\n&#34;, indent);\n  \n  return NULL;\n}\n\n// Synchronization user thread: UserB--Customer\nvoid* UserB(void* argv){\n  arg_struct arg = *(arg_struct*)argv;\n  int id = arg.id;\n  const char* indent = arg.indent.c_str();\n\n  sleep(arg.start);\n\n  printf(&#34;%sARRIVAL\\n&#34;, indent);\n\n  int mySeat, B;\n    dispatch_semaphore_wait(mutex, DISPATCH_TIME_FOREVER);  //Lock mutex to protect seat changes\n    customer_count&#43;&#43;;           //Arrival of customer\n    int index = strlen(indent);\n    printf(&#34;%sCustomer-%d[Id:%d] Entered Shop.\\n&#34;, indent, customer_count,index);\n    if(numberOfFreeSeats &gt; 0) \n    {\n      --numberOfFreeSeats;           //Sit on chairs on waiting room\n      printf(&#34;%sCustomer-%d Sits In Waiting Room.\\n&#34;, indent, customer_count);\n      sitHereNext = (&#43;&#43;sitHereNext) % MAX_CHAIRS;  //Choose a vacant chair to sit\n      mySeat = sitHereNext;\n      seatPocket[mySeat] = customer_count;\n      dispatch_semaphore_signal(mutex); //Release the seat change mutex\n      dispatch_semaphore_signal(barbers); //Wake up one barber\n      dispatch_semaphore_wait(customers, DISPATCH_TIME_FOREVER);  //Join queue of sleeping customers\n      dispatch_semaphore_wait(mutex, DISPATCH_TIME_FOREVER);  //Lock mutex to protect seat changes\n        B = seatPocket[mySeat];    //Barber replaces customer PID with his own PID\n        numberOfFreeSeats&#43;&#43;;             //Stand Up and Go to Barber Room\n      dispatch_semaphore_signal(mutex); //Release the seat change mutex\n      /*Customer is having hair cut by barber &#39;B&#39;*/\n      printf(&#34;%sSTART\\n&#34;, indent);\n      sleep(arg.work);\n    } \n    else \n  {\n       dispatch_semaphore_signal(mutex);  //Release the mutex and customer leaves without haircut\n       printf(&#34;%sCustomer-%d Finds No Seat &amp; Leaves.\\n&#34;, indent, customer_count);\n  }\n\n  a_task_done&#43;&#43;;\n  printf(&#34;%sDONE\\n&#34;, indent);\n\n  pthread_exit(0);\n}\n\nint main(int argc, char** argv) {\n  srand((unsigned)time(NULL));\n\n  #define N MAX_CUST\n  pthread_t p_UserB[2 * N], p_UserA[2 * N];\n\n  int a_count = 0, b_count = 0;\n\n  #define USERA 0\n  #define USERB 1\n\n  // Synchronization initialization:\n  customers = dispatch_semaphore_create(0); // init with value of 0\n  barbers = dispatch_semaphore_create(0); // init with value of 0\n  mutex = dispatch_semaphore_create(1); // init with value of 1\n\n  /* For managed creation of 2 * N threads */\n\n  #define TEST 1\n  int st_time = 0;\n\n  #if TEST == 1\n  #define THREADNUM 7\n  int inst[2 * N][3] = {\n    /* { UserB or UserA to be create?, \n         When does it start to work after being created?, st_stime &#43;= N means it starts N seconcds later than the previous P/C\n         How long does it work after it enters critical zone? } */\n    {USERA, st_time &#43;= 0, rand()%WORK_SPAN}, \n    {USERA, st_time &#43;= 4, rand()%WORK_SPAN}, \n    {USERB, st_time &#43;= 0, rand()%WORK_SPAN}, \n    {USERB, st_time &#43;= 1, rand()%WORK_SPAN}, \n    {USERB, st_time &#43;= 0, rand()%WORK_SPAN}, \n    {USERB, st_time &#43;= 5, rand()%WORK_SPAN},\n    {USERB, st_time &#43;= 1, rand()%WORK_SPAN}\n  };\n\n  #elif TEST == 2\n  #define THREADNUM 6\n  int inst[2 * N][3] = {\n    /* { UserB or UserA to be create?, \n         When does it start to work after being created?, st_stime &#43;= N means it starts N seconcds later than the previous P/C\n         How long does it work after it enters critical zone? } */\n    {USERA, st_time &#43;= 0, rand()%WORK_SPAN}, \n    {USERA, st_time &#43;= 4, rand()%WORK_SPAN}, \n    {USERB, st_time &#43;= 0, rand()%WORK_SPAN}, \n    {USERB, st_time &#43;= 1, rand()%WORK_SPAN}, \n    {USERB, st_time &#43;= 0, rand()%WORK_SPAN}, \n    {USERB, st_time &#43;= 0, rand()%WORK_SPAN}\n  };\n  #else\n  #define THREADNUM 6\n  int inst[2 * N][3] = {\n    {USERA, st_time &#43;= 0, rand()%WORK_SPAN}, \n    {USERA, st_time &#43;= 1, rand()%WORK_SPAN}, \n    {USERA, st_time &#43;= 0, rand()%WORK_SPAN}, \n    {USERB, st_time &#43;= 4, rand()%WORK_SPAN}, \n    {USERB, st_time &#43;= 0, rand()%WORK_SPAN}, \n    {USERB, st_time &#43;= 0, rand()%WORK_SPAN}\n  };\n  #endif\n\n  /* Print the first line */\n  int tmp_a = 0, tmp_b = 0;\n  for (int i = 0; i &lt; THREADNUM; i&#43;&#43;){\n    if (inst[i][0] == USERA){\n      printf(&#34;A%d\\t&#34;, tmp_a&#43;&#43;);\n    } else if (inst[i][0] == USERB){\n      printf(&#34;B%d\\t&#34;, tmp_b&#43;&#43;);\n    }\n  }\n  printf(&#34;\\n&#34;);\n  printf(&#34;tmp_b:%d\\n&#34;,tmp_b);\n\n  /* Create UserAs and UserBs according to $inst*/\n  int rc;\n  string indent(&#34;&#34;);\n  for (int i = 0; i &lt; THREADNUM; i&#43;&#43;){\n    if (inst[i][0] == USERA){\n      rc = pthread_create(p_UserA &#43; a_count, NULL, UserA, new arg_struct(a_count, inst[i][1], inst[i][2], indent));\n      if (rc) printf(&#34;ERROR\\n&#34;);\n      a_count&#43;&#43;;\n    } else if (inst[i][0] == USERB){\n      rc = pthread_create(p_UserB &#43; b_count, NULL, UserB, new arg_struct(b_count, inst[i][1], inst[i][2], indent));\n      if (rc) printf(&#34;ERROR\\n&#34;);\n      b_count&#43;&#43;;\n    }\n    indent &#43;= &#39;\\t&#39;;\n  }\n\n  /* wait until every thread finishes*/\n  for (int i = 0; i &lt; a_count; i&#43;&#43;){\n    pthread_join(p_UserA[i], NULL);\n  }\n  for (int i = 0; i &lt; b_count; i&#43;&#43;){\n    pthread_join(p_UserB[i], NULL);  \n  }\n\n  dispatch_release(mutex);\n\n  return 0;\n}</pre>\n<p></p>", "created": "2017-06-01T16:18:33Z", "bucket_order": 157, "bucket_name": "Week 5/28 - 6/3", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>在向老师的理发师问题解答的基础上&#xff0c;编写了更多的测试样例。</p>\n<p><a href=\"https://github.com/Huangjinfan/os_ucore/blob/master/barber\" target=\"_blank\">https://github.com/Huangjinfan/os_ucore/blob/master/barber</a></p>", "created": "2017-06-22T16:05:53Z", "bucket_order": 154, "bucket_name": "Week 6/18 - 6/24", "type": "feedback", "tag_good": [], "uid": "i0fcjeg6hm4qw", "children": [], "tag_good_arr": [], "id": "j48mdecb9hs4jh", "updated": "2017-06-22T16:05:53Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p><p><b>在 2017年6月23日&#xff0c;上午10:39&#xff0c;xyong &lt;xyong&#64;mail.tsinghua.edu.cn&gt; 写道&#xff1a;</b></p>\n<p><b>你还需要补充如下内容&#xff1a;</b></p>\n<p><b></b></p>\n<p><b>1&#xff09;这些测试用例分别测试什么情况&#xff1f;</b></p>\n<p><b>2&#xff09;每个测试用例的运行结果如何解释&#xff1f;</b></p>\n<p><b></b></p>\n<p><b>--向勇</b></p>", "created": "2017-06-23T02:40:52Z", "bucket_order": 154, "bucket_name": "Week 6/18 - 6/24", "type": "feedback", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [], "tag_good_arr": [], "id": "j499208wa0v4cl", "updated": "2017-06-23T02:40:52Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "j3emkt14u42eb", "updated": "2017-06-01T16:18:33Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>关于理发师问题的一个基于ucore的管程实现。<br /><br /></p>\n<ul><li>mtp为管程的指针&#xff1b;</li><li>CHAIR_NUM为供顾客等候的椅子数&#xff1b;</li><li>CUT_TIME为理发所需的时间&#xff1b;</li><li>mtp-&gt;cv[0]为一条件变量&#xff0c;用于唤醒正在睡觉的理发师&#xff1b;</li><li>mtp-&gt;cv[1]为一条件变量&#xff0c;用于通知正在等待的顾客&#xff1b;</li><li>waiting_customer表示正在等待的顾客数量。</li></ul>\n<p></p>\n<p></p>\n<p>顾客的实现&#xff1a;</p>\n<pre>int customer_using_monitor(int id){\n    down(&amp;(mtp-&gt;mutex));\n    print(id, &#34;C_COME&#34;);  // 有顾客到达\n    if (waiting_customer == CHAIR_NUM){\n    \tprint(id, &#34;C_LEAVE&#34;); // 没有空椅子了&#xff0c;顾客离开\n    }else{\n        waiting_customer &#43;&#43;;\n        if (mtp-&gt;cv[0].count &gt; 0) { // 有理发师在睡觉\n            print(id, &#34;C_WAKEUP&#34;); \n            cond_signal(&amp;(mtp-&gt;cv[0])); // 顾客将理发师唤醒\n        }\n        else {\n            print(id, &#34;C_WAIT&#34;);\n            cond_wait(&amp;(mtp-&gt;cv[1])); // 顾客等待理发师\n        }\n        waiting_customer--;\n        print(id, &#34;C_CUTTING&#34;);\n    }\n    if(mtp-&gt;next_count&gt;0)\n        up(&amp;(mtp-&gt;next));\n    else\n        up(&amp;(mtp-&gt;mutex));\n}</pre>\n<p></p>\n<p>理发师的实现&#xff1a;</p>\n<pre>int barber_using_monitor(int id){\n    while(1){\n        down(&amp;(mtp-&gt;mutex));\n        if (waiting_customer == 0){ // 没有顾客在等待\n            print(id, &#34;B_SLEEP&#34;);\n            cond_wait(&amp;(mtp-&gt;cv[0]));  //等待顾客进来\n        }    \n        cond_signal(&amp;(mtp-&gt;cv[1])); //通知顾客\n        print(id, &#34;B_CUTTING&#34;);\n        if(mtp-&gt;next_count&gt;0)\n            up(&amp;(mtp-&gt;next));\n        else\n            up(&amp;(mtp-&gt;mutex));\n        do_sleep(CUT_TIME); // 理发\n        print(id, &#34;B_FINISH&#34;);    \n    }\n}</pre>\n<p></p>\n<p></p>\n<p></p>\n<p>其中print为用于测试的输出函数&#xff1a;</p>\n<pre>void print(int id, char *s) {\n  int i;\n  for (i = 0; i &lt; id; i&#43;&#43;)\n    cprintf(&#34;\\t\\t&#34;);\n  cprintf(&#34;%s\\n&#34;, s);\n}</pre>\n<p>各测试状态的说明&#xff1a;</p>\n<ul><li>C_COME表示有顾客到达&#xff1b;</li><li>C_WAKEUP表示顾客将理发师唤醒&#xff1b;</li><li>C_CUTTING表示顾客正在理发&#xff1b;</li><li>B_SLEEP表示当前没有顾客&#xff0c;理发师正在睡觉&#xff1b;</li><li>B_CUTTING表示理发师正在为顾客理发&#xff1b;</li><li>B_FINISH表示理发师完成理发。</li></ul>\n<p></p>\n<p>下面提供该问题的五个测试样例&#xff1a;</p>\n<p>统一的变量初始化&#xff1a;</p>\n<ul><li>理发师数量&#xff1a;2</li><li>CHAIR_NUM&#xff1a;1</li><li>CUT_TIME&#xff1a;50</li></ul>\n<p></p>\n<p>第一个测试样例&#xff1a;两个顾客按顺序到达&#xff0c;两位理发师依次为其理发。</p>\n<pre>void check_sync(void){\n    monitor_init(&amp;mt, 2);\n    cprintf(&#34;BARBER1\\t\\tBARBER2\\t\\tCUSTOMER1\\tCUSTOMER2\\n&#34;);\n    kernel_thread(barber_using_monitor, 0, 0);\n    kernel_thread(barber_using_monitor, 1, 0);\n    do_sleep(50);\n    kernel_thread(customer_using_monitor, 2, 0);\n    do_sleep(50);\n    kernel_thread(customer_using_monitor, 3, 0);\n}</pre>\n<p>程序输出&#xff1a;</p>\n<p><img src=\"/img/1069-16ddd8e58d1621ca.png\" alt=\"\" /></p>\n<p></p>\n<p>第二个测试样例&#xff1a;三个顾客依次到达&#xff0c;当理发师理完前两个顾客后&#xff0c;BARBER2发现有顾客在等待&#xff0c;故不睡觉&#xff0c;继续理发。</p>\n<pre>void check_sync(void){\n    monitor_init(&amp;mt, 2);\n    cprintf(&#34;BARBER1\\t\\tBARBER2\\t\\tCUSTOMER1\\tCUSTOMER2\\tCUSTOMER3\\n&#34;);\n    kernel_thread(barber_using_monitor, 0, 0);\n    kernel_thread(barber_using_monitor, 1, 0);\n    do_sleep(50);\n    kernel_thread(customer_using_monitor, 2, 0);\n    do_sleep(50);\n    kernel_thread(customer_using_monitor, 3, 0);\n    do_sleep(50);\n    kernel_thread(customer_using_monitor, 4, 0);</pre>\n<p><img src=\"/img/1069-72796b95442925a6.png\" alt=\"\" /></p>\n<p></p>\n<p></p>\n<p>第三个测试样例&#xff1a;三个顾客依次到达&#xff0c;当理发师理完前两个顾客后&#xff0c;发现没有顾客在等待&#xff0c;故开始睡觉&#xff0c;之后BARBER2被第三个顾客唤醒理发。</p>\n<pre>void check_sync(void){\n    monitor_init(&amp;mt, 2);\n    cprintf(&#34;BARBER1\\t\\tBARBER2\\t\\tCUSTOMER1\\tCUSTOMER2\\tCUSTOMER3\\n&#34;);\n    kernel_thread(barber_using_monitor, 0, 0);\n    kernel_thread(barber_using_monitor, 1, 0);\n    do_sleep(50);\n    kernel_thread(customer_using_monitor, 2, 0);\n    do_sleep(50);\n    kernel_thread(customer_using_monitor, 3, 0);\n    do_sleep(500);\n    kernel_thread(customer_using_monitor, 4, 0);\n}</pre>\n<p>程序输出&#xff1a;</p>\n<p><img src=\"/img/1069-89748fc4aca878d7.png\" alt=\"\" /></p>\n<p></p>\n<p>第四个测试样例&#xff1a;四位顾客依次到达&#xff0c;由于椅子数只有1。当第四位顾客到达时&#xff0c;理发师正在帮两位顾客理发&#xff0c;且没有空椅子&#xff0c;故第四位顾客离开。</p>\n<pre>void check_sync(void){\n    monitor_init(&amp;mt, 2);\n    cprintf(&#34;BARBER1\\t\\tBARBER2\\t\\tCUSTOMER1\\tCUSTOMER2\\tCUSTOMER3\\tCUSTOMER4\\n&#34;);\n    kernel_thread(barber_using_monitor, 0, 0);\n    kernel_thread(barber_using_monitor, 1, 0);\n    do_sleep(10);\n    kernel_thread(customer_using_monitor, 2, 0);\n    do_sleep(10);\n    kernel_thread(customer_using_monitor, 3, 0);\n    do_sleep(10);\n    kernel_thread(customer_using_monitor, 4, 0);\n    do_sleep(10);\n    kernel_thread(customer_using_monitor, 5, 0);\n}</pre>\n<p>程序输出&#xff1a;</p>\n<p><img src=\"/img/1069-666c63a6fe1c42eb.png\" alt=\"\" /></p>\n<p></p>\n<p>第五个测试样例&#xff1a;四位顾客依次到达&#xff0c;由于第四位顾客到达较晚&#xff0c;当第四位顾客到达时&#xff0c;理发师正在帮两位顾客理发&#xff0c;但有空椅子&#xff0c;故第四位顾客坐下等待。</p>\n<pre>void check_sync(void){\n    monitor_init(&amp;mt, 2);\n    cprintf(&#34;BARBER1\\t\\tBARBER2\\t\\tCUSTOMER1\\tCUSTOMER2\\tCUSTOMER3\\tCUSTOMER4\\n&#34;);\n    kernel_thread(barber_using_monitor, 0, 0);\n    kernel_thread(barber_using_monitor, 1, 0);\n    do_sleep(50);\n    kernel_thread(customer_using_monitor, 2, 0);\n    do_sleep(50);\n    kernel_thread(customer_using_monitor, 3, 0);\n    do_sleep(50);\n    kernel_thread(customer_using_monitor, 4, 0);\n    do_sleep(600);\n    kernel_thread(customer_using_monitor, 5, 0);\n}</pre>\n<p>程序输出&#xff1a;</p>\n<p><img src=\"/img/1069-169276e0fb6a946e.png\" alt=\"\" /></p>", "created": "2018-06-20T07:21:56Z", "bucket_order": 102, "bucket_name": "Week 6/17 - 6/23", "type": "followup", "tag_good": [], "uid": "isypo4jw2xg4de", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>这是一个很完整的实现和比较完善测试。点赞。</p>", "created": "2018-06-20T16:32:32Z", "bucket_order": 102, "bucket_name": "Week 6/17 - 6/23", "type": "feedback", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [], "tag_good_arr": [], "id": "jinc5w0l38h3if", "updated": "2018-06-20T16:32:32Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>    在mesa语义下&#xff0c;下面这种对于<strong>顾客函数的实现</strong>&#xff08;没有if (mtp-&gt;cv[0].count &gt; 0) 的判断&#xff09;是<strong>不影响正确性</strong>的。</p>\n<pre>int customer_using_monitor(int id){\n    down(&amp;(mtp-&gt;mutex));\n    print(id, &#34;C_COME&#34;);  // 有顾客到达\n    if (waiting_customer == CHAIR_NUM){\n    \tprint(id, &#34;C_LEAVE&#34;); // 没有空椅子了&#xff0c;顾客离开\n    }else{\n        waiting_customer &#43;&#43;;\n        cond_signal(&amp;(mtp-&gt;cv[0])); // 顾客唤醒理发师\n        cond_wait(&amp;(mtp-&gt;cv[1])); // 顾客等待理发师通知\n        waiting_customer--;\n        print(id, &#34;C_CUTTING&#34;);\n    }\n    if(mtp-&gt;next_count&gt;0)\n        up(&amp;(mtp-&gt;next));\n    else\n        up(&amp;(mtp-&gt;mutex));\n}</pre>\n<p>    不妨把有if (mtp-&gt;cv[0].count &gt; 0) 判断的实现记作<strong>实现0</strong>&#xff0c;没有if (mtp-&gt;cv[0].count &gt; 0) 判断的实现记作<strong>实现1</strong>。<br /><br />    (1). 当mtp-&gt;cv[0].count = 0时&#xff0c;即没有理发师在睡觉&#xff1a;<br />    实现0中顾客只会执行“cond_wait(&amp;(mtp-&gt;cv[1]));”&#xff1b;<br />    而实现1中顾客会执行“cond_signal(&amp;(mtp-&gt;cv[0]));”和“cond_wait(&amp;(mtp-&gt;cv[1])); ”。<br /><br />    但是结合条件变量的实现可知&#xff0c;顾客多执行的<strong>“cond_signal(&amp;(mtp-&gt;cv[0]))”实际上是个空操作</strong>&#xff0c;因为cv[0].count = 0。&#xff08;当条件变量的count为0时&#xff0c;signal为空操作&#xff09;<br />    故此时实现0和实现1等价。<br /><br /><br />    (2). 当mtp-&gt;cv[0].count &gt; 0时&#xff0c;即有理发师在睡觉&#xff1a;<br />    实现0中顾客只会执行“cond_signal(&amp;(mtp-&gt;cv[0])); ”&#xff1b;<br />    而实现1中顾客会执行“cond_signal(&amp;(mtp-&gt;cv[0]));”和“cond_wait(&amp;(mtp-&gt;cv[1])); ”。<br /><br />    但是顾客多执行的“cond_wait(&amp;(mtp-&gt;cv[1])); // 顾客等待理发师通知”并不会影响正确性&#xff0c;因为此时理发师已经被唤醒&#xff0c;而在理发师剪发前都会有“cond_signal(&amp;(mtp-&gt;cv[1])); // 理发师通知顾客”的操作。<br />    在ucore上&#xff0c;实现1会有问题&#xff0c;是因为<strong>在hoare语义下</strong>&#xff0c;顾客执行“cond_signal(&amp;(mtp-&gt;cv[0]));”后会发生<strong>进程切换</strong>&#xff0c;导致理发师的“cond_signal(&amp;(mtp-&gt;cv[1]));”实际上先于顾客的“cond_wait(&amp;(mtp-&gt;cv[1]));”的情况&#xff0c;即<strong>“理发师先signal&#xff0c;顾客再wait”的错误情况</strong>。<br />    <strong>但在mesa语义下</strong>&#xff0c;实现1没有问题。因为顾客执行“cond_signal(&amp;(mtp-&gt;cv[0]));”后不会发生进程切换&#xff0c;会等到顾客执行完“cond_wait(&amp;(mtp-&gt;cv[1]));”才会发生切换&#xff0c;<strong>确保了“顾客先wait&#xff0c;理发师再signal”</strong>。<br /><br />    故在mesa语义下&#xff0c;实现1也是正确的。</p>", "created": "2018-06-24T16:08:46Z", "bucket_order": 101, "bucket_name": "Week 6/24 - 6/30", "type": "feedback", "tag_good": [], "uid": "isypo4jw2xg4de", "children": [], "tag_good_arr": [], "id": "jit12qucen22hz", "updated": "2018-06-24T16:08:46Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p><strong>实现1</strong>在ucore下&#xff08;修改为<strong>mesa管程</strong>&#xff09;的测试结果&#xff1a;</p>\n<p></p>\n<p>各状态的说明&#xff1a;</p>\n<ul><li>C_COME表示有顾客到达&#xff1b;</li><li>C_LEAVE表示椅子已满&#xff0c;顾客离开&#xff1b;</li><li>C_CUTTING表示顾客正在理发&#xff1b;</li><li>B_SLEEP表示当前没有顾客&#xff0c;理发师正在睡觉&#xff1b;</li><li>B_WAKEUP表示理发师被顾客唤醒&#xff1b;</li><li>B_CUTTING表示理发师正在为顾客理发&#xff1b;</li><li>B_FINISH表示理发师完成理发。</li></ul>\n<p></p>\n<p></p>\n<p>第一个测试样例&#xff1a;两个顾客按顺序到达&#xff0c;两位理发师依次为其理发。</p>\n<p><img src=\"/img/1069-fd9a2ac1b298636b.png\" alt=\"\" /></p>\n<p></p>\n<p>第二个测试样例&#xff1a;三个顾客依次到达&#xff0c;当理发师理完前两个顾客后&#xff0c;BARBER2发现有顾客在等待&#xff0c;故不睡觉&#xff0c;继续理发。</p>\n<p><img src=\"/img/1069-add76605adb33f8f.png\" alt=\"\" /></p>\n<p></p>\n<p></p>\n<p>第三个测试样例&#xff1a;三个顾客依次到达&#xff0c;当理发师理完前两个顾客后&#xff0c;发现没有顾客在等待&#xff0c;故开始睡觉&#xff0c;之后BARBER2被第三个顾客唤醒理发。</p>\n<p><img src=\"/img/1069-f7e1dec823a53009.png\" alt=\"\" /></p>\n<p></p>\n<p>第四个测试样例&#xff1a;四位顾客依次到达&#xff0c;由于椅子数只有1。当第四位顾客到达时&#xff0c;理发师正在帮两位顾客理发&#xff0c;且没有空椅子&#xff0c;故第四位顾客离开。</p>\n<p><img src=\"/img/1069-65349d3bb1deca35.png\" alt=\"\" /></p>\n<p></p>\n<p></p>\n<p>第五个测试样例&#xff1a;四位顾客依次到达&#xff0c;由于第四位顾客到达较晚&#xff0c;当第四位顾客到达时&#xff0c;理发师正在帮两位顾客理发&#xff0c;但有空椅子&#xff0c;故第四位顾客坐下等待。</p>\n<p><img src=\"/img/1069-696cdca85aaac401.png\" alt=\"\" /></p>\n<p></p>\n<p></p>\n<p></p>\n<p>实现1、其余变量的初始化以及测例的输入同上。</p>\n<p>为了实现mesa语义的管程&#xff0c;我将ucore原有的hoare管程中的条件变量的signal函数注释了一行&#xff0c;因为在mesa语义下条件变量的signal操作不会引起进程切换。</p>\n<p></p>\n<pre>void cond_signal (condvar_t *cvp) {\n   if (cvp-&gt;count &gt; 0) {\n      cvp-&gt;owner-&gt;next_count&#43;&#43;;\n      up(&amp;(cvp-&gt;sem));\n      // down(&amp;(cvp-&gt;owner-&gt;next));\n      cvp-&gt;owner-&gt;next_count--;\n   }\n}</pre>\n<p>其余实现均未变动。</p>\n<p></p>\n<p>从上面的输出可知&#xff0c;在mesa语义下实现1也是正确的。我们通过实验验证了之前关于实现1的讨论&#xff0c;即理发师问题并不一定要维护正在睡觉&#xff0f;理发的理发师数量。</p>", "created": "2018-06-25T08:46:05Z", "bucket_order": 101, "bucket_name": "Week 6/24 - 6/30", "type": "feedback", "tag_good": [], "uid": "isypo4jw2xg4de", "children": [], "tag_good_arr": [], "id": "jiu0padlhe8dq", "updated": "2018-06-25T08:46:05Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p><p>按照你的思路&#xff0c;可能会出现一个顾客坐在椅子上等待后&#xff0c;起来重新排队时再次坐到椅子上。是这样吗&#xff1f;</p>", "created": "2018-06-26T01:29:31Z", "bucket_order": 101, "bucket_name": "Week 6/24 - 6/30", "type": "feedback", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [], "tag_good_arr": [], "id": "jiv0jqe0vfr1oc", "updated": "2018-06-26T01:29:31Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>补充三个实现1在ucore下&#xff08;修改为mesa管程&#xff09;的测试样例&#xff1a;</p>\n<p></p>\n<p>椅子数为2&#xff0c;其余变量及实现不变。</p>\n<p></p>\n<p>第六个测试样例&#xff1a;四个顾客依次到达&#xff0c;CUSTOMER3和CUSTOMER4到达后在椅子上等待。理发师按顾客到达顺序为四位顾客理发。</p>\n<pre>void check_sync(void){\n    monitor_init(&amp;mt, 2);\n    cprintf(&#34;BARBER1\\t\\tBARBER2\\t\\tCUSTOMER1\\tCUSTOMER2\\tCUSTOMER3\\tCUSTOMER4\\n&#34;);\n    kernel_thread(barber_using_monitor, 0, 0);\n    kernel_thread(barber_using_monitor, 1, 0);\n    do_sleep(10);\n    kernel_thread(customer_using_monitor, 2, 0);\n    do_sleep(10);\n    kernel_thread(customer_using_monitor, 3, 0);\n    do_sleep(10);\n    kernel_thread(customer_using_monitor, 4, 0);\n    do_sleep(10);\n    kernel_thread(customer_using_monitor, 5, 0);\n}</pre>\n<p>输出&#xff1a;</p>\n<p><img src=\"/img/1069-6b796ed23bcde084.png\" alt=\"\" /></p>\n<p></p>\n<p>第七个测试样例&#xff1a;五个顾客依次到达&#xff0c;CUSTOMER3和CUSTOMER4到达后在椅子上等待&#xff0c;CUSTOMER5到达后由于没有空椅子便离开。理发师按顾客到达顺序为四位顾客理发。</p>\n<pre>void check_sync(void){\n    monitor_init(&amp;mt, 2);\n    cprintf(&#34;BARBER1\\t\\tBARBER2\\t\\tCUSTOMER1\\tCUSTOMER2\\tCUSTOMER3\\tCUSTOMER4\\tCUSTOMER5\\n&#34;);\n    kernel_thread(barber_using_monitor, 0, 0);\n    kernel_thread(barber_using_monitor, 1, 0);\n    do_sleep(10);\n    kernel_thread(customer_using_monitor, 2, 0);\n    do_sleep(10);\n    kernel_thread(customer_using_monitor, 3, 0);\n    do_sleep(10);\n    kernel_thread(customer_using_monitor, 4, 0);\n    do_sleep(10);\n    kernel_thread(customer_using_monitor, 5, 0);\n    do_sleep(10);\n    kernel_thread(customer_using_monitor, 6, 0);\n}</pre>\n<p>输出&#xff1a;</p>\n<p><img src=\"/img/1069-ea0ef05d4df89b20.png\" alt=\"\" /></p>\n<p></p>\n<p>第八个测试样例&#xff1a;五个顾客依次到达&#xff0c;CUSTOMER3和CUSTOMER4到达后在椅子上等待。CUSTOMER5到达时&#xff0c;CUSTOMER3已经开始理发&#xff0c;故有一个空位&#xff0c;CUSTOMER4和CUSTOMER5在椅子上等待。理发师按顾客到达顺序为五位顾客理发。</p>\n<pre>void check_sync(void){\n    monitor_init(&amp;mt, 2);\n    cprintf(&#34;BARBER1\\t\\tBARBER2\\t\\tCUSTOMER1\\tCUSTOMER2\\tCUSTOMER3\\tCUSTOMER4\\tCUSTOMER5\\n&#34;);\n    kernel_thread(barber_using_monitor, 0, 0);\n    kernel_thread(barber_using_monitor, 1, 0);\n    do_sleep(10);\n    kernel_thread(customer_using_monitor, 2, 0);\n    do_sleep(10);\n    kernel_thread(customer_using_monitor, 3, 0);\n    do_sleep(10);\n    kernel_thread(customer_using_monitor, 4, 0);\n    do_sleep(10);\n    kernel_thread(customer_using_monitor, 5, 0);\n    do_sleep(500);\n    kernel_thread(customer_using_monitor, 6, 0);\n}</pre>\n<p><img src=\"/img/1069-c014ac27dfb69411.png\" alt=\"\" /></p>", "created": "2018-06-26T04:37:21Z", "bucket_order": 101, "bucket_name": "Week 6/24 - 6/30", "type": "feedback", "tag_good": [], "uid": "isypo4jw2xg4de", "children": [], "tag_good_arr": [], "id": "jiv79a59vrl2tn", "updated": "2018-06-26T04:37:21Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>提问&#xff1a;</p>\n<p>已看过你的描述。有一个问题&#xff0c;在实现1中不存在“C_WAIT”的状态了。这样对吗&#xff1f;如果存在&#xff0c;能在输出信息中进行标注吗&#xff1f;</p>\n<p></p>\n<p>回复&#xff1a;</p>\n<p>因为实现1没有if else了&#xff0c;故没有再输出“C_WAIT”。但我的理解是顾客“C_COME”来之后&#xff0c;如果是“C_LEAVE”&#xff0c;就表示顾客离开了&#xff1b;如果有“B_WAKEUP”表示一名理发师被唤醒&#xff0c;开始理发&#xff1b;否则都处于等待状态&#xff0c;直到“C_CUTTING”表示正在理发。</p>\n<p></p>\n<p>提问&#xff1a;</p>\n<p>顾客从“到达”到“理发”中间有两种不同的中间状态&#xff0c;一个是“唤醒理发师给他理发”&#xff0c;另一个是“在椅子上等待&#xff0c;等理发师叫他”。这两种中间状态在“实现1”中能区别吗&#xff1f;</p>", "created": "2018-06-26T05:59:24Z", "bucket_order": 101, "bucket_name": "Week 6/24 - 6/30", "type": "feedback", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [], "tag_good_arr": [], "id": "jiva6staglw4sf", "updated": "2018-06-26T05:59:24Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>回复&#xff1a;</p>\n<p>可以结合理发师有无输出“B_WAKEUP”&#xff08;理发师是否被唤起&#xff09;区别这两种中间状态。</p>\n<p>考题中并未对<strong>管程的语义</strong>、<strong>输出的方式</strong>、<strong>区分各状态的方式</strong>作出说明或限制。</p>\n<p>故我认为实现1符合题意对理发师问题的要求。</p>", "created": "2018-06-26T08:19:10Z", "bucket_order": 101, "bucket_name": "Week 6/24 - 6/30", "type": "feedback", "tag_good": [], "uid": "isypo4jw2xg4de", "children": [], "tag_good_arr": [], "id": "jivf6jh7vni191", "updated": "2018-06-26T08:19:10Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "jimshtfzamd3dn", "updated": "2018-06-20T07:21:56Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>这里选择了另一个经典的进程同步问题——三个烟鬼的故事。</p>\n<p>问题描述&#xff1a;假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟 并抽掉它&#xff0c;但是要卷起并抽掉一支烟&#xff0c;抽烟者需要有三种材料&#xff1a;烟草、纸和胶水。三个抽烟者中&#xff0c;第一个拥有烟草、第二个拥有纸&#xff0c;第三个拥有胶水。供应者进程无限地提供三种材料&#xff0c; 供应者每次将两种材料放到桌子上&#xff0c;拥有剩下那种材料的抽烟者卷一根烟并抽掉它&#xff0c;并给供应者一个信号告诉完成了&#xff0c;供应者就会放另外两种材料在桌上&#xff0c;这种过程一直重复&#xff08;让三个抽烟者轮流地抽烟)。</p>\n<pre>#include &lt;stdio.h&gt;\n#include &lt;pthread.h&gt;\n#include &lt;semaphore.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;assert.h&gt;\n#include &lt;fcntl.h&gt;\n\nsem_t offer1;    // 准备烟草和纸\nsem_t offer2;    // 准备烟草和胶水\nsem_t offer3;    // 准备纸和胶水\nsem_t finish;    // 抽烟是否完成\n\nint a[3] = {0, 1, 2};\nint n = 10;\nint offer_order[10] = {0, 1, 2, 2, 1, 0, 2, 2, 0, 1};\nvoid* provide(){\n    for(int i = 0; i &lt; n; i&#43;&#43;){\n        sem_wait(&amp;finish);\n        int b = offer_order[i];\n        if(b == 0){\n            printf(&#34;0 provide tobacco and paper\\n&#34;);\n            sem_post(&amp;offer1);\n        }\n        if(b == 1){\n            printf(&#34;1 provide tobacco and glue \\n&#34;);\n            sem_post(&amp;offer2);\n        }\n        if(b == 2){\n            printf(&#34;2 provide glue and paper   \\n&#34;);\n            sem_post(&amp;offer3);\n        }\n    }\n}\n\nvoid* smoger(void* args){\n    int arg = *((int *)args);\n    while(1) {\n        if (arg == 0) {\n            for(int i = 0; i &lt; 4 * arg &#43; 4; i&#43;&#43;){\n                printf(&#34;\\t&#34;);\n            }\n            printf(&#34;wait for tobacco and paper\\n&#34;);\n            sem_wait(&amp;offer1); // 拿起胶水&#xff0c;开始抽烟\n        }\n        if (arg == 1) {\n            for(int i = 0; i &lt; 4 * arg &#43; 4; i&#43;&#43;){\n                printf(&#34;\\t&#34;);\n            }\n            printf(&#34;wait for tobacco and glue \\n&#34;);\n            sem_wait(&amp;offer2); // 拿起纸&#xff0c;开始抽烟\n        }\n        if (arg == 2) {\n            for(int i = 0; i &lt; 4 * arg &#43; 4; i&#43;&#43;){\n                printf(&#34;\\t&#34;);\n            }\n            printf(&#34;wait for paper and glue   \\n&#34;);\n            sem_wait(&amp;offer3); // 拿起烟草&#xff0c;开始抽烟\n        }\n        for(int i = 0; i &lt; 4 * arg &#43; 4; i&#43;&#43;){\n            printf(&#34;\\t&#34;);\n        }\n        printf(&#34;I can&#39;t be more happy!\\n&#34;);\n        for(int i = 0; i &lt; 3; i&#43;&#43;){\n            printf(&#34;\\n&#34;);\n        }\n        // the process for smog\n        for(int i = 0; i &lt; 4 * arg &#43; 4; i&#43;&#43;){\n            printf(&#34;\\t&#34;);\n        }\n        printf(&#34;smog over!\\n&#34;);\n        sem_post(&amp;finish);\n    }\n}\n\nint main() {\n    sem_init(&amp;offer1, 0, 0);\n    sem_init(&amp;offer2, 0, 0);\n    sem_init(&amp;offer3, 0, 0);\n    sem_init(&amp;finish, 0, 1);\n    printf(&#34;provider\\t\\t\\t smoker who has glue\\t\\t smoker who has paper\\t\\tsmoker who has tobacco\\n&#34;);\n    pthread_t * provider = malloc(sizeof(pthread_t));\n    pthread_t * smoggid = malloc(3*sizeof(pthread_t));\n    for(int i = 0; i &lt; 3; i&#43;&#43;){\n        pthread_create(&amp;smoggid[i], NULL, smoger, &amp;a[i]);\n    }\n    pthread_create(provider, NULL, provide, NULL);\n    sleep(3);\n    sem_destroy(&amp;offer1);\n    sem_destroy(&amp;offer2);\n    sem_destroy(&amp;offer3);\n    sem_destroy(&amp;finish);\n    free(smoggid);\n    free(provider);\n    return 0;\n}</pre>\n<p>输出结果为&#xff1a;</p>\n<pre>provider\t\t\t smoker who has glue\t\t smoker who has paper\t\tsmoker who has tobacco<br />0 provide tobacco and paper<br />\t\t\t\t\t\t\t\t\t\t\t\twait for paper and glue   <br />\t\t\t\t\t\t\t\twait for tobacco and glue <br />\t\t\t\twait for tobacco and paper<br />\t\t\t\tI can&#39;t be more happy!<br /><br /><br /><br />\t\t\t\tsmog over!<br />\t\t\t\twait for tobacco and paper<br />1 provide tobacco and glue <br />\t\t\t\t\t\t\t\tI can&#39;t be more happy!<br /><br /><br /><br />\t\t\t\t\t\t\t\tsmog over!<br />\t\t\t\t\t\t\t\twait for tobacco and glue <br />2 provide glue and paper   <br />\t\t\t\t\t\t\t\t\t\t\t\tI can&#39;t be more happy!<br /><br /><br /><br />\t\t\t\t\t\t\t\t\t\t\t\tsmog over!<br />\t\t\t\t\t\t\t\t\t\t\t\twait for paper and glue   <br />2 provide glue and paper   <br />\t\t\t\t\t\t\t\t\t\t\t\tI can&#39;t be more happy!<br /><br /><br /><br />\t\t\t\t\t\t\t\t\t\t\t\tsmog over!<br />\t\t\t\t\t\t\t\t\t\t\t\twait for paper and glue   <br />1 provide tobacco and glue <br />\t\t\t\t\t\t\t\tI can&#39;t be more happy!<br /><br /><br /><br />\t\t\t\t\t\t\t\tsmog over!<br />\t\t\t\t\t\t\t\twait for tobacco and glue <br />0 provide tobacco and paper<br />\t\t\t\tI can&#39;t be more happy!<br /><br /><br /><br />\t\t\t\tsmog over!<br />\t\t\t\twait for tobacco and paper<br />2 provide glue and paper   <br />\t\t\t\t\t\t\t\t\t\t\t\tI can&#39;t be more happy!<br /><br /><br /><br />\t\t\t\t\t\t\t\t\t\t\t\tsmog over!<br />\t\t\t\t\t\t\t\t\t\t\t\twait for paper and glue   <br />2 provide glue and paper   <br />\t\t\t\t\t\t\t\t\t\t\t\tI can&#39;t be more happy!<br /><br /><br /><br />\t\t\t\t\t\t\t\t\t\t\t\tsmog over!<br />\t\t\t\t\t\t\t\t\t\t\t\twait for paper and glue   <br />0 provide tobacco and paper<br />\t\t\t\tI can&#39;t be more happy!<br /><br /><br /><br />\t\t\t\tsmog over!<br />\t\t\t\twait for tobacco and paper<br />1 provide tobacco and glue <br />\t\t\t\t\t\t\t\tI can&#39;t be more happy!<br /><br /><br /><br />\t\t\t\t\t\t\t\tsmog over!<br />\t\t\t\t\t\t\t\twait for tobacco and glue </pre>", "created": "2019-05-08T18:20:13Z", "bucket_order": 56, "bucket_name": "Week 5/5 - 5/11", "type": "followup", "tag_good": [], "uid": "jslfact6jvaN", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>如果可能&#xff0c;请给出你的完整测例和结果&#xff0c;以验证算法是否有错。</p>", "created": "2019-05-09T14:43:46Z", "bucket_order": 56, "bucket_name": "Week 5/5 - 5/11", "type": "feedback", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [], "tag_good_arr": [], "id": "jvgri60mamv61k", "updated": "2019-05-09T14:43:46Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "jvfjso7ex0269g", "updated": "2019-05-08T18:20:13Z", "config": {}}], "tag_good_arr": ["hdjonbiyfs62ie"], "id": "j2ddw43190u4eh", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 8, "num_favorites": 6, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169070719, "default_anonymity": "no"}, "error": null, "aid": "kyv0ftdrxzq21w"}