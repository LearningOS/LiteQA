{"result": {"history_size": 4, "folders": ["lecture2", "课堂问答", "2016"], "nr": 588, "data": {"embed_links": []}, "created": "2016-02-24T08:16:35Z", "bucket_order": 3, "no_answer_followup": 9, "change_log": [{"uid": "hdjonbiyfs62ie", "anon": "no", "when": "2016-02-24T08:16:35Z", "data": "il0khl0pgwv1er", "type": "create"}, {"to": "il0khl0me9l1eq", "uid": "hdjonbiyfs62ie", "anon": "no", "when": "2016-02-24T08:18:29Z", "type": "followup"}, {"to": "il0khl0me9l1eq", "uid": "hdjonbiyfs62ie", "anon": "no", "when": "2016-02-24T08:20:27Z", "type": "followup"}, {"to": "il0khl0me9l1eq", "uid": "i6vjwdpfniF", "anon": "no", "when": "2016-02-24T08:25:30Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0nan8i4g0o3s3", "anon": "no", "when": "2016-02-24T08:27:13Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "ie7xy71bn7b1s2", "anon": "no", "when": "2016-02-24T08:27:35Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0nuu5yhgno5tv", "anon": "no", "when": "2016-02-24T08:28:55Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0c1nsm3911wc", "anon": "no", "when": "2016-02-24T08:31:24Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0anp25rzjk2wt", "anon": "no", "when": "2016-02-24T08:32:13Z", "type": "followup"}, {"to": "il0khl0me9l1eq", "uid": "ikwht0mda9v4iu", "anon": "no", "when": "2016-02-24T08:33:13Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0b7d04pl3y6c0", "anon": "no", "when": "2016-02-24T08:33:48Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0c9nvk0xzc2n3", "anon": "no", "when": "2016-02-24T08:34:22Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i6uuj5n1v5y2t6", "anon": "no", "when": "2016-02-24T08:34:54Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0ccfx63sir1e", "anon": "no", "when": "2016-02-24T08:35:16Z", "type": "followup"}, {"to": "il0khl0me9l1eq", "uid": "i0ayxqk6wry734", "anon": "no", "when": "2016-02-24T08:35:55Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i28t9sj8bas79c", "anon": "no", "when": "2016-02-24T08:38:18Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i6u94pk3j2C", "anon": "no", "when": "2016-02-24T08:38:33Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i242q8ug7vw40x", "anon": "no", "when": "2016-02-24T08:39:46Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0brpl1lbyui6", "anon": "no", "when": "2016-02-24T08:40:07Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0ccfx63sir1e", "anon": "no", "when": "2016-02-24T08:40:31Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "ic226rac4j5jw", "anon": "no", "when": "2016-02-24T08:41:36Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0f9pvv0uxm6ko", "anon": "no", "when": "2016-02-24T08:41:51Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0eqqq6jvng408", "anon": "no", "when": "2016-02-24T08:42:44Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0es3v9jp0t1fd", "anon": "no", "when": "2016-02-24T08:43:36Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "ikvcvnzpzq7j7", "anon": "no", "when": "2016-02-24T08:43:57Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0f7v0qgfm61s6", "anon": "no", "when": "2016-02-24T08:44:06Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0eqqq6jvng408", "anon": "no", "when": "2016-02-24T08:44:17Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0minzvpea57bu", "anon": "no", "when": "2016-02-24T08:44:21Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i1bzj2xilgm4uk", "anon": "no", "when": "2016-02-24T08:44:30Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i11v1az5sf83l2", "anon": "no", "when": "2016-02-24T08:44:36Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0nu5by9l7v7of", "anon": "no", "when": "2016-02-24T08:44:53Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0hjdkesg9c5z7", "anon": "no", "when": "2016-02-24T08:45:00Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "ikvcvqnhm907lr", "anon": "no", "when": "2016-02-24T08:45:04Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0hjdkesg9c5z7", "anon": "no", "when": "2016-02-24T08:45:43Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i11dx198ive25r", "anon": "no", "when": "2016-02-24T08:46:10Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "ikvcvno79n07iu", "anon": "no", "when": "2016-02-24T08:47:18Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "ikwht0mda9v4iu", "anon": "no", "when": "2016-02-24T08:47:26Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0i7rzz9iau2gd", "anon": "no", "when": "2016-02-24T08:48:02Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i1oqryfapik22", "anon": "no", "when": "2016-02-24T08:48:26Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i6vjwdpfniF", "anon": "no", "when": "2016-02-24T08:49:39Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i701mss708y", "anon": "no", "when": "2016-02-24T08:50:02Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "ie7xy3iwuug1os", "anon": "no", "when": "2016-02-24T08:50:02Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "ikvcvq38pa7l6", "anon": "no", "when": "2016-02-24T08:50:32Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "ikvcvo2cckb7jb", "anon": "no", "when": "2016-02-24T08:50:35Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0em4o8wvj34lb", "anon": "no", "when": "2016-02-24T08:51:26Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "ie7xy6atuuc1re", "anon": "no", "when": "2016-02-24T08:51:35Z", "type": "followup"}, {"to": "il0khl0me9l1eq", "uid": "i0cb1385ni65l", "anon": "no", "when": "2016-02-24T08:52:02Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i1569mw0xp954u", "anon": "no", "when": "2016-02-24T08:52:27Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0dlq4m0wjn5eo", "anon": "no", "when": "2016-02-24T08:52:55Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0zaci5voig5h", "anon": "no", "when": "2016-02-24T08:52:57Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "ie7xy4gmt1p1pp", "anon": "no", "when": "2016-02-24T08:53:18Z", "type": "followup"}, {"to": "il0khl0me9l1eq", "uid": "ig297cbwqr11ej", "anon": "no", "when": "2016-02-24T08:54:15Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i6uaz437IKR", "anon": "no", "when": "2016-02-24T08:54:38Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i6vir34gLfK", "anon": "no", "when": "2016-02-24T08:54:43Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i17iy2ly5py3ad", "anon": "no", "when": "2016-02-24T08:54:50Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i6ugy67km5b", "anon": "no", "when": "2016-02-24T08:54:56Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0evrfcnckf5dt", "anon": "no", "when": "2016-02-24T08:55:07Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i3qk2vs65x276j", "anon": "no", "when": "2016-02-24T08:56:31Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i18riqkwrl225m", "anon": "no", "when": "2016-02-24T08:57:19Z", "type": "followup"}, {"to": "il0khl0me9l1eq", "uid": "i0f24oie8102cr", "anon": "no", "when": "2016-02-24T08:58:17Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0d4mr9tga62ki", "anon": "no", "when": "2016-02-24T08:58:24Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i6ub5at2geM", "anon": "no", "when": "2016-02-24T08:58:28Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "ibz6vywnw6g7nl", "anon": "no", "when": "2016-02-24T08:59:08Z", "type": "followup"}, {"to": "il0khl0me9l1eq", "uid": "i0f24oie8102cr", "anon": "no", "when": "2016-02-24T08:59:12Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0ayxqk6wry734", "anon": "no", "when": "2016-02-24T08:59:28Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "ikvcvno79n07iu", "anon": "no", "when": "2016-02-24T08:59:30Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "ie7xy4gmt1p1pp", "anon": "no", "when": "2016-02-24T08:59:47Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0dlq4m0wjn5eo", "anon": "no", "when": "2016-02-24T08:59:51Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0c90j8pjf56sn", "anon": "no", "when": "2016-02-24T09:02:34Z", "type": "followup"}, {"to": "il0khl0me9l1eq", "uid": "i0c90j8pjf56sn", "anon": "no", "when": "2016-02-24T09:02:58Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i6ugy67km5b", "anon": "no", "when": "2016-02-24T09:04:24Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i6vir34gLfK", "anon": "no", "when": "2016-02-24T09:05:15Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "ikvcvnzpzq7j7", "anon": "no", "when": "2016-02-24T09:11:04Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0boovu8sh63xb", "anon": "no", "when": "2016-02-24T09:35:54Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i11v1az5sf83l2", "anon": "no", "when": "2016-02-24T09:45:17Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i6uayuoumpw5ah", "anon": "no", "when": "2016-02-24T09:58:01Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0ccqbaxwdz75c", "anon": "no", "when": "2016-02-24T10:00:31Z", "type": "followup"}, {"to": "il0khl0me9l1eq", "uid": "ie7xy3iwuug1os", "anon": "no", "when": "2016-02-24T10:02:11Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0nu5by9l7v7of", "anon": "no", "when": "2016-02-24T10:06:23Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0gl5kctugw3xi", "anon": "no", "when": "2016-02-24T10:07:39Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0evrfcnckf5dt", "anon": "no", "when": "2016-02-24T10:07:58Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0ccqbaxwdz75c", "anon": "no", "when": "2016-02-24T10:08:17Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "ie7xy6atuuc1re", "anon": "no", "when": "2016-02-24T10:11:08Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i2olyyl8swl1we", "anon": "no", "when": "2016-02-24T10:11:09Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0gkdbms5ie20o", "anon": "no", "when": "2016-02-24T10:12:43Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i2om0jwie732m1", "anon": "no", "when": "2016-02-24T10:13:57Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "ikvcvqnhm907lr", "anon": "no", "when": "2016-02-24T10:13:58Z", "type": "followup"}, {"to": "il0khl0me9l1eq", "uid": "ikvcvonk6wj7k1", "anon": "no", "when": "2016-02-24T10:15:48Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i1bzj2xilgm4uk", "anon": "no", "when": "2016-02-24T10:16:36Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i2om0jwie732m1", "anon": "no", "when": "2016-02-24T10:23:34Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i11dx198ive25r", "anon": "no", "when": "2016-02-24T10:25:46Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "ikvcvr6di5i7ma", "anon": "no", "when": "2016-02-24T10:28:05Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "ic226rac4j5jw", "anon": "no", "when": "2016-02-24T10:31:32Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0ccqbaxwdz75c", "anon": "no", "when": "2016-02-24T10:32:09Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0gl5kctugw3xi", "anon": "no", "when": "2016-02-24T10:32:58Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i2olyyl8swl1we", "anon": "no", "when": "2016-02-24T10:35:13Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0cb1385ni65l", "anon": "no", "when": "2016-02-24T10:36:20Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "ibz6vywnw6g7nl", "anon": "no", "when": "2016-02-24T10:40:11Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i28skba6cd976f", "anon": "no", "when": "2016-02-24T10:40:15Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i2g664y8vve6h4", "anon": "no", "when": "2016-02-24T10:47:11Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "ikvcvq38pa7l6", "anon": "no", "when": "2016-02-24T10:49:24Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i2g664y8vve6h4", "anon": "no", "when": "2016-02-24T10:50:05Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0brpl1lbyui6", "anon": "no", "when": "2016-02-24T10:53:52Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i701mss708y", "anon": "no", "when": "2016-02-24T11:04:44Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0c9nvk0xzc2n3", "anon": "no", "when": "2016-02-24T11:04:46Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0c1nsm3911wc", "anon": "no", "when": "2016-02-24T11:13:51Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "ikx8y1dzPrM", "anon": "no", "when": "2016-02-24T11:14:58Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0nan8i4g0o3s3", "anon": "no", "when": "2016-02-24T11:16:43Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i28skba6cd976f", "anon": "no", "when": "2016-02-24T11:20:51Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0jauby0gkg76x", "anon": "no", "when": "2016-02-24T11:25:58Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0b7d04pl3y6c0", "anon": "no", "when": "2016-02-24T11:32:29Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "ierwkwbinsj2t8", "anon": "no", "when": "2016-02-24T11:34:42Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0em4o8wvj34lb", "anon": "no", "when": "2016-02-24T11:43:00Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "ikvcvmzbvlf7i6", "anon": "no", "when": "2016-02-24T11:45:25Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "ikvcvo2cckb7jb", "anon": "no", "when": "2016-02-24T11:46:20Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "ig297cbwqr11ej", "anon": "no", "when": "2016-02-24T11:47:49Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i6uuj5n1v5y2t6", "anon": "no", "when": "2016-02-24T11:52:01Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0zaci5voig5h", "anon": "no", "when": "2016-02-24T11:52:27Z", "type": "followup"}, {"to": "il0khl0me9l1eq", "uid": "i0f9pvv0uxm6ko", "anon": "no", "when": "2016-02-24T11:53:42Z", "type": "followup"}, {"to": "il0khl0me9l1eq", "uid": "i0f9pvv0uxm6ko", "anon": "no", "when": "2016-02-24T11:53:51Z", "type": "followup"}, {"to": "il0khl0me9l1eq", "uid": "i1569mw0xp954u", "anon": "no", "when": "2016-02-24T11:53:53Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "ierwkwbinsj2t8", "anon": "no", "when": "2016-02-24T11:54:35Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0minzvpea57bu", "anon": "no", "when": "2016-02-24T11:56:35Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i1oqryfapik22", "anon": "no", "when": "2016-02-24T11:56:55Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0i7rzz9iau2gd", "anon": "no", "when": "2016-02-24T11:57:18Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i18riqkwrl225m", "anon": "no", "when": "2016-02-24T11:58:51Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i242q8ug7vw40x", "anon": "no", "when": "2016-02-24T11:59:14Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i18riqkwrl225m", "anon": "no", "when": "2016-02-24T12:03:59Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0f9pvv0uxm6ko", "anon": "no", "when": "2016-02-24T12:06:04Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i3qk2vs65x276j", "anon": "no", "when": "2016-02-24T12:13:26Z", "type": "followup"}, {"to": "il0khl0me9l1eq", "uid": "i3qk2vs65x276j", "anon": "no", "when": "2016-02-24T12:21:13Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i70lz5f0QKm", "anon": "no", "when": "2016-02-24T12:37:00Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i6ub4vwhQXd", "anon": "no", "when": "2016-02-24T12:42:01Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i6ub4vwhQXd", "anon": "no", "when": "2016-02-24T13:39:28Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i3qk2vs65x276j", "anon": "no", "when": "2016-02-24T13:40:30Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i0jauby0gkg76x", "anon": "no", "when": "2016-02-24T14:16:22Z", "type": "feedback"}, {"to": "il0khl0me9l1eq", "uid": "i3qk2vs65x276j", "anon": "no", "when": "2016-02-24T14:39:12Z", "type": "feedback"}, {"uid": "hdjonbiyfs62ie", "anon": "no", "when": "2016-02-24T15:41:23Z", "data": "il10dlkstut362", "type": "update"}, {"to": "il0khl0me9l1eq", "uid": "ie7xy71bn7b1s2", "anon": "no", "when": "2016-02-25T01:31:44Z", "type": "followup"}, {"to": "il0khl0me9l1eq", "uid": "ibz6vywnw6g7nl", "anon": "no", "when": "2016-02-25T03:21:30Z", "type": "feedback"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "data": "izde3f798p056d", "type": "update", "when": "2017-02-20T00:54:30Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "data": "izde8gg3bnr4wi", "type": "update", "when": "2017-02-20T00:58:24Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "2016春季-第二讲课堂思考题回答-向勇班", "created": "2017-02-20T00:58:24Z", "content": "<p>请向勇班的同学把lec1-课堂思考题<br />https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/01-3-lab0-spoc-discussion.md<br />的回答结果写在此贴后面。<br />第二讲的回答的截止时间是今&#xff08;20160224&#xff09;晚20点前</p>\n<p></p>\n<p>优胜者&#xff1a;得labX加分1分<br />Tan Si Nan<br />Dichen Qian<br />Liu Xiaohong</p>\n<p></p>\n<p>计34 沈哲言 2013011371 计35 叶子鹏 2013011404<br />郑兆衡2013011389 &#xff0c; 张浩天 2013011416<br />朱俸民 2012011894 朱新瑞 2013011411</p>"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "2016春季-第二讲课堂思考题回答-向勇班", "created": "2017-02-20T00:54:30Z", "content": "<p>请向勇班的同学把lec1-课堂思考题<br />https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/01-3-lab0-spoc-discussion.md<br />的回答结果写在此贴后面。<br />第二讲的回答的截止时间是今&#xff08;20160224&#xff09;晚20点前</p>\n<p></p>\n<p>优胜者&#xff1a;得labX加分1分<br />Tan Si Nan<br />Dichen Qian<br />Liu Xiaohong</p>\n<p></p>\n<p>计34 沈哲言 2013011371 计35 叶子鹏 2013011404<br />郑兆衡2013011389 &#xff0c; 张浩天 2013011416<br />朱俸民 2012011894 朱新瑞 2013011411</p>"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "2016春季-第二讲课堂思考题回答-向勇班", "created": "2016-02-24T15:41:23Z", "content": "<p>请向勇班的同学把lec1-课堂思考题<br />https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/01-3-lab0-spoc-discussion.md<br />的回答结果写在此贴后面。<br />第二讲的回答的截止时间是今&#xff08;20160224&#xff09;晚20点前</p>\n<p></p>\n<p>优胜者&#xff1a;得labX加分1分<br />Tan Si Nan<br />Dichen Qian<br />Liu Xiaohong</p>\n<p></p>\n<p>计34 沈哲言 2013011371 计35 叶子鹏 2013011404<br />郑兆衡2013011389 &#xff0c; 张浩天 2013011416<br />朱俸民 2012011894 朱新瑞 2013011411</p>"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "2016春季-第二讲课堂思考题回答-向勇班", "created": "2016-02-24T08:16:35Z", "content": "<p>请向勇班的同学把lec1-课堂思考题<br />https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/01-3-lab0-spoc-discussion.md<br />的回答结果写在此贴后面。<br />第二讲的回答的截止时间是今&#xff08;20160224&#xff09;晚20点前</p>"}], "type": "note", "tags": ["2016", "instructor-note", "lecture2", "课堂问答"], "tag_good": [], "unique_views": 325, "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>题目&#xff1a;</p>\n<p></p>\n<p>队列数据结构有4个基本操作函数&#xff0c;如何基于这些函数来实现支持保存不同数据的多种队列&#xff1f;操作系统内核中的队列数据结构是如何实现的&#xff1f;</p>\n<p></p>\n<p>这个题目的回答在本贴后回复。</p>", "created": "2016-02-24T08:18:29Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>请参见related_info/lab0/lab0_ex4.c</p>\n<p></p>\n<p>构造结构体</p>\n<table><tbody><tr><td>struct entry {</td></tr><tr><td></td><td></td></tr><tr><td></td><td>list_entry_t node;</td></tr><tr><td></td><td>int num;</td></tr><tr><td></td><td>};</td></tr></tbody></table>\n<p>其中list_entry_t是在labcodes/lab8/libs/list.h里面实现&#xff0c;是一个裸的双线链表&#xff0c;实现了几个简单功能</p>\n<p>然后上面的int num就是我们实际使用的时候夹杂的私货</p>\n<p></p>\n<p></p>", "created": "2016-02-24T08:25:30Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i6vjwdpfniF", "children": [], "tag_good_arr": [], "id": "il0kt21oosk1jg", "updated": "2016-02-24T08:25:30Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>list_entry_t实现一个只维护链表本身结构的结构体</p>\n<p>[位于libs/list.h]</p>\n<p>struct list_entry {<br /> struct list_entry *prev, *next;<br />};</p>\n<p>队列本身的相关函数是使用__attribute__((always_inline)) 修饰的内联函数实现的&#xff0c;推测这样做可以强制编译器将这些函数优化掉&#xff0c;再不使用MACRO的情况下最大限度提高了性能。</p>\n<p>因为结构体中只包含prev和next&#xff0c;因此不承载任何实际的数据&#xff0c;具体的数据结构通常可以通过在外面再套一层结构来实现&#xff0c;具体的队列&#xff0c;例如</p>\n<p>[位于kern/schedule/sched.h]</p>\n<p>struct run_queue {<br /> list_entry_t run_list;<br /> unsigned int proc_num;<br /> int max_time_slice;<br /> // For LAB6 ONLY<br /> skew_heap_entry_t *lab6_run_pool;<br />};</p>\n<p>另外一个例子是wait_queue&#xff0c;wait_queue_t本身只包含一个list_entry_t成员&#xff0c;而wait_t再去扩展wait_queue_t&#xff0c;这样做可能是出于抽象和便于维护的角度考虑。</p>\n<p>[位于kern/sync/wait.h]</p>\n<p>typedef struct {<br /> list_entry_t wait_head;<br />} wait_queue_t;</p>\n<p>struct proc_struct;</p>\n<p>typedef struct {<br /> struct proc_struct *proc;<br /> uint32_t wakeup_flags;<br /> wait_queue_t *wait_queue;<br /> list_entry_t wait_link;<br />} wait_t;</p>", "created": "2016-02-24T08:27:13Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0nan8i4g0o3s3", "children": [], "tag_good_arr": [], "id": "il0kv9ju2ed6pj", "updated": "2016-02-24T08:27:13Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>队列数据结构本身是一个双向循环链表。</p>\n<p>对于不同的数据&#xff0c;定义了一个这样的结构&#xff1a;</p>\n<p>struct XXX {</p>\n<p>    list_entry_t list_node;</p>\n<p>    //whatever you want here...</p>\n<p>};</p>\n<p></p>\n<p>每个XXXstruct的list_node可以记录前后XXXstruct的list_node。</p>\n<p>在实际使用的时候通过XXX.list_node和一个to_struct宏实现struct和list_entry_t的相互转换</p>", "created": "2016-02-24T08:27:35Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "ie7xy71bn7b1s2", "children": [], "tag_good_arr": [], "id": "il0kvqmyqdv5f", "updated": "2016-02-24T08:27:35Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>头文件在libs/list.h中。<br />使用的几个函数&#xff1a;<br />list_init&#xff1a;将prev和next指向自己&#xff0c;表示空。<br />list_add&#xff0c;list_add_after调用__list_add。<br />__list_add&#xff08;加入的元素&#xff0c;加入之后的前一个元素&#xff0c;加入之后的后一个元素&#xff09;。<br />list_prev&#xff0c;list_next返回list_entry中的prev和next指针。<br />list_del删除一个元素&#xff0c;调用的函数就是__list_del(ele.prev, ele.next)。<br />list_del_init删除一个元素之后使用list_init初始化这个元素。<br />__list_del&#xff08;前一个元素&#xff0c;后一个元素&#xff09;中间的元素就被删除了。<br />list_empty比较next是否等于自己用来表示是否为空。</p>\n<p>这样遍历的话只需要<br />for (iter = list_next(list_header); iter != list_header; iter = list_next(iter))<br />加入和删除直接调用对应的函数。</p>\n<p>存储元素的时候&#xff0c;我们实际上仅仅需要的是知道存储的struct中&#xff0c;这个队列的指针在struct里面的位置&#xff0c;通过这个位置推算出整个struct的地址即可。<br />可以使用如下语句。<br />struct clss {<br /> ..........<br /> list_entry_t list_entry;<br />};<br />&amp;(((struct clss *)0))-&gt;list_entry</p>", "created": "2016-02-24T08:28:55Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0nuu5yhgno5tv", "children": [], "tag_good_arr": [], "id": "il0kxg5cpvw39s", "updated": "2016-02-24T08:28:55Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>list的实现位于lab8/lib/list.h&#xff0c;里面递归定义了list_entry的结构&#xff0c;实现了初始化、添加、删除、获取前驱、获取后继结点的功能。该结构未涉及每个结点的数据&#xff0c;从而可以利用指针转换的trick实现一个类似C&#43;&#43;的template。</p>\n<p></p>\n<p>假如我们实现一个包含类型t的list&#xff0c;定义</p>\n<p></p>\n<pre>struct {\n    list_entry_t entry;\n    t my_data;\n} my_node;</pre>\n<p>使用时我们用&#96;entry&#96;来调用实现好的接口&#xff0c;为了能访问到数据&#xff0c;我们取某个&#96;entry&#96;的地址&#xff0c;把它强制转换为&#96;my_node&#96;类型的指针。</p>\n<p></p>\n<p>需要注意的是&#xff0c;数据必须定义在&#96;entry&#96;之后&#xff0c;才能确保&#96;entry&#96;与&#96;mynode&#96;的起始地址一致。</p>", "created": "2016-02-24T08:31:24Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0c1nsm3911wc", "children": [], "tag_good_arr": [], "id": "il0l0n6jplj661", "updated": "2016-02-24T08:31:24Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>首先在libs/list.h中&#xff0c;定义了一个结构体list_entry_t&#xff0c;其中包含了prev和next指针.</p>\n<p>几个基本操作函数 list_init, list_add, list_del, list_empty</p>\n<p>实际使用的时候&#xff0c;可以在list_entry_t 套在外面</p>\n<p></p>\n<p>struct {</p>\n<p>list_entry_t entry;</p>\n<p>// data</p>\n<p>} data;</p>\n<p>可以通过entry-&gt;next / entry-&gt;prev来索引对应的位置&#xff0c;然后强制转换为data形式的指针就可以了</p>", "created": "2016-02-24T08:33:13Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "ikwht0mda9v4iu", "children": [], "tag_good_arr": [], "id": "il0l2ywi7qq6sy", "updated": "2016-02-24T08:33:13Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>以ucore_os_lab/labcodes/lab8/kern/sync/wait.h wait.c为例</p>\n<p></p>\n<p>typedef struct {<br />    list_entry_t wait_head;<br />} wait_queue_t;</p>\n<p>typedef struct {<br />    struct proc_struct *proc;<br />    uint32_t wakeup_flags;<br />    wait_queue_t *wait_queue;<br />    list_entry_t wait_link;<br />} wait_t;</p>\n<p>将list.h中的list_entry_t数据结构内嵌在新的结构体中&#xff0c;也把数据作为该结构体的变量。</p>\n<p></p>\n<p>对于队列的建立&#xff0c;编写新的函数&#xff0c;调用list.h中ist_entry_t数据结构的有关函数&#xff0c;</p>\n<p>如void wait_queue_add(...)调用list.h中的list_add_before(...)实现。</p>", "created": "2016-02-24T08:33:48Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0b7d04pl3y6c0", "children": [], "tag_good_arr": [], "id": "il0l3ptagzb1us", "updated": "2016-02-24T08:33:48Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>在libs/list.h中有相关的实现。</p>\n<p>实现一个基本的链表结构&#xff1a;</p>\n<p>struct list_entry {<br />    struct list_entry *prev, *next;<br />};</p>\n<p>要附加相应的信息&#xff0c;只需在外面再套一层结构&#xff0c;如</p>\n<p></p>\n<p>struct entry {<br />    list_entry *list;</p>\n<p>    Data data;<br />};</p>\n<p></p>\n<p></p>\n<p></p>", "created": "2016-02-24T08:34:22Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0c9nvk0xzc2n3", "children": [], "tag_good_arr": [], "id": "il0l4gibzbe7bq", "updated": "2016-02-24T08:34:22Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p><img src=\"/img/588-c336d57935284faf.png\" /></p>\n<p>list_entry_t是定义好的队列类型。在此之外再定义一个entry类型&#xff0c;包含list_entry_t。将entry中的list_entry_t加到队列中。访问的时候可以访问到某个list_entry_t&#xff0c;通过地址和类型转换可以得到这个结构体entry的地址&#xff0c;就可以访问其中的另一个变量num了。</p>\n<p></p>\n<p>小组</p>\n<p>高越 2012011379</p>\n<p>王智默 2012011355</p>", "created": "2016-02-24T08:34:54Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i6uuj5n1v5y2t6", "children": [], "tag_good_arr": [], "id": "il0l551g9wz5od", "updated": "2016-02-24T08:34:54Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>双向链表的结构定义在ucore_os_lab/labcodes/lab8/libs/list.h中</p>\n<pre>struct list_entry {\n    struct list_entry *prev, *next;\n};</pre>\n<p>这是一个抽象链表&#xff0c;本身没有数据</p>\n<p>这保证了不同的数据类型的节点可以链在一条链上</p>\n<p>只要不同的节点类型的结构体中间有一个公共的链表域list_entry_t就可以互相连接</p>\n<p>实例在ucore_os_lab/labcodes/lab8/kern/process/proc.h中</p>\n<pre>struct proc_struct {\n    enum proc_state state;                      // Process state\n    int pid;                                    // Process ID\n    int runs;                                   // the running times of Proces\n    uintptr_t kstack;                           // Process kernel stack\n    volatile bool need_resched;                 // bool value: need to be rescheduled to release CPU?\n    struct proc_struct *parent;                 // the parent process\n    struct mm_struct *mm;                       // Process&#39;s memory management field\n    struct context context;                     // Switch here to run process\n    struct trapframe *tf;                       // Trap frame for current interrupt\n    uintptr_t cr3;                              // CR3 register: the base addr of Page Directroy Table(PDT)\n    uint32_t flags;                             // Process flag\n    char name[PROC_NAME_LEN &#43; 1];               // Process name\n    list_entry_t list_link;                     // Process link list\n    list_entry_t hash_link;                     // Process hash list\n    int exit_code;                              // exit code (be sent to parent proc)\n    uint32_t wait_state;                        // waiting state\n    struct proc_struct *cptr, *yptr, *optr;     // relations between processes\n   <em><strong> struct run_queue *rq;                       // running queue contains Process\n    list_entry_t run_link;                      // the entry linked in run queue</strong></em>\n    int time_slice;                             // time slice for occupying the CPU\n    skew_heap_entry_t lab6_run_pool;            // FOR LAB6 ONLY: the entry in the run pool\n    uint32_t lab6_stride;                       // FOR LAB6 ONLY: the current stride of the process\n    uint32_t lab6_priority;                     // FOR LAB6 ONLY: the priority of process, set by lab6_set_priority(uint32_t)\n    struct files_struct *filesp;                // the file related info(pwd, files_count, files_array, fs_semaphore) of process\n};</pre>\n<p>这是一个进程队列&#xff0c;其中有一个域是链表域&#xff0c;其余是宿主数据结构的数据域</p>", "created": "2016-02-24T08:35:55Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0ayxqk6wry734", "children": [], "tag_good_arr": [], "id": "il0l6fzxujb63t", "updated": "2016-02-24T08:35:55Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>list的实现在libs/list.h中&#xff0c;代码为&#xff1a;</p>\n<p>struct    {<br />    struct list_entry *prev, *next;<br />};</p>\n<p>其中实现了</p>\n<p>static inline void list_init(list_entry_t *elm) __attribute__((always_inline));<br />static inline void list_add(list_entry_t *listelm, list_entry_t *elm) __attribute__((always_inline));<br />static inline void list_add_before(list_entry_t *listelm, list_entry_t *elm) __attribute__((always_inline));<br />static inline void list_add_after(list_entry_t *listelm, list_entry_t *elm) __attribute__((always_inline));<br />static inline void list_del(list_entry_t *listelm) __attribute__((always_inline));<br />static inline void list_del_init(list_entry_t *listelm) __attribute__((always_inline));<br />static inline bool list_empty(list_entry_t *list) __attribute__((always_inline));<br />static inline list_entry_t *list_next(list_entry_t *listelm) __attribute__((always_inline));<br />static inline list_entry_t *list_prev(list_entry_t *listelm) __attribute__((always_inline));</p>\n<p>等操作</p>\n<p></p>\n<p>这个list只包含了指针而不包含具体的数据&#xff0c;包含数据的例子如下&#xff1a;</p>\n<p>typedef struct {<br />    struct proc_struct *proc;<br />    uint32_t wakeup_flags;<br />    wait_queue_t *wait_queue;<br />    list_entry_t wait_link;<br />} wait_t;</p>\n<p>即在list之外再套一个struct</p>", "created": "2016-02-24T08:38:18Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i28t9sj8bas79c", "children": [], "tag_good_arr": [], "id": "il0l9ikyu0i55x", "updated": "2016-02-24T08:38:18Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>当需要某个结构的链表时&#xff0c;在这个结构体中添加一项list_entry_t类型的成员&#xff1b;用list_init, list_add等函数对这个结构体的list_entry_t类型的成员进行操作。需要根据list_entry_t访问对应的数据时根据list_entry_t在结构体中的位置推出结构体的地址&#xff0c;从而得到相应的数据。</p>\n<p></p>", "created": "2016-02-24T08:38:33Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i6u94pk3j2C", "children": [], "tag_good_arr": [], "id": "il0l9uaepx159b", "updated": "2016-02-24T08:38:33Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "// 这里可以使用通用数据结构的双向链表\n// 通用数据的双向链表在/libs/list.h\n\n// 如果要实现一个通用数据队列\ntypedef struct my_queue{\n\tstruct list_entry *list;\n\t//.... Data here\n}queue;\n\n// 至于如何从list_entry得到持有它的结构的首地址, \n// 可以参看学堂在线视频中&#34;ucore部分编程技巧&#34;&#34;", "created": "2016-02-24T08:39:46Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i242q8ug7vw40x", "children": [], "tag_good_arr": [], "id": "il0lbe1msqg5ua", "updated": "2016-02-24T08:39:46Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>定义结构体list_entry&#xff0c;为一链表&#xff0c;包括两个指针&#xff0c;分别指向之前元素和之后的元素。</p>\n<table><tbody><tr><td></td></tr><tr><td></td><td>struct list_entry {</td></tr><tr><td></td><td>struct list_entry *prev, *next;</td></tr><tr><td></td><td>};</td></tr></tbody></table>\n<p>它是队列关联关系的抽象&#xff0c;根据不同的队列&#xff0c;将list_entry与数据项一起封装为新的队列类型。</p>", "created": "2016-02-24T08:40:07Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0brpl1lbyui6", "children": [], "tag_good_arr": [], "id": "il0lbu8dj0l4t1", "updated": "2016-02-24T08:40:07Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p><pre>list.h<br />    实现了抽象的双向链表结构&#xff0c;可通过修改实现栈、队列结构等其它线性结构。<br /><br />    节点结构<br />        struct list_entry {<br />            struct list_entry *prev, *next;<br />        };<br /><br />    初始化&#xff0c;添加&#xff0c;删除操作<br />        static inline void list_init(list_entry_t *elm) __attribute__((always_inline));<br />        static inline void list_add(list_entry_t *listelm, list_entry_t *elm) __attribute__((always_inline));<br />        static inline void list_del(list_entry_t *listelm) __attribute__((always_inline));<br /><br />具体实现<br />    结构<br />        struct queue_node {<br />            list_entry_t node;<br />            T value;<br />        }<br />        struct queue {<br />            queue_node head;<br />            queue_node tail;<br />        }<br />    方法<br />        给list.h里的方法包一层queue的接口。</pre>\n<p></p>", "created": "2016-02-24T08:40:31Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0ccfx63sir1e", "children": [], "tag_good_arr": [], "id": "il0lcd88gg566d", "updated": "2016-02-24T08:40:31Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>链表的实现在libs/list.h中</p>\n<p>struct list_entry {<br /> struct list_entry *prev, *next;<br />};</p>\n<p>typedef struct list_entry list_entry_t;</p>\n<p>并且定义了list_init, list_add, list_del, list_next等函数。</p>\n<p>如果要实现不同数据还需要套一层&#xff0c;例如</p>\n<p>struct entry {<br />    list_entry *list;</p>\n<p>    Data data;<br />};</p>", "created": "2016-02-24T08:41:36Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "ic226rac4j5jw", "children": [], "tag_good_arr": [], "id": "il0ldqzhyqha4", "updated": "2016-02-24T08:41:36Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>由于手速慢了&#xff0c;大部分内容其他同学都说好了&#xff0c;我补充一下类指针和队列指针转换的过程吧。</p>\n<p>主要通过defs.h中的</p>\n<p>#define to_struct(ptr, type, member) ((type *)((char *)(ptr) - offsetof(type, member)))</p>\n<p>其中ptr是当前的队列指针&#xff0c;type是当前队列中需要找到指针的类&#xff0c;member是队列指针在类中的名字&#xff0c;offsetof是队列指针在类中的偏移量。</p>\n<p></p>\n<p>具体来说&#xff0c;</p>\n<p>#define offsetof(type, member) ((size_t)(&amp;((type *)0)-&gt;member))来转换。</p>\n<p>其中的0只是用来被强制转换为type类型&#xff0c;整个这一句话会被翻译为队列在类中的偏移量&#xff0c;减去了就是类指针了</p>\n<p></p>", "created": "2016-02-24T08:41:51Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0f9pvv0uxm6ko", "children": [], "tag_good_arr": [], "id": "il0le2vmsu26p6", "updated": "2016-02-24T08:41:51Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "在libs/list.h中有相关的实现。\n实现一个基本的链表结构&#xff1a;\nstruct list_entry {\n    struct list_entry *prev, *next;\n};\n要附加相应的信息&#xff0c;只需在外面再套一层结构&#xff0c;如\n \nstruct entry {\n    list_entry *list;\n    Data data;\n};", "created": "2016-02-24T08:42:44Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0eqqq6jvng408", "children": [], "tag_good_arr": [], "id": "il0lf7xolaz3zd", "updated": "2016-02-24T08:42:44Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>代码在labcodes/lab8/libs/list.h中&#xff0c;实现了抽象的链表。</p>\n<pre>struct list_entry {\n    struct list_entry *prev, *next;\n};</pre>\n<p>要支持具体的list可以在list_entry外面套一个结构体&#xff0c;里面有存自己想要的内容&#xff0c;并通过list_entry来找到前后节点即可。</p>", "created": "2016-02-24T08:43:36Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0es3v9jp0t1fd", "children": [], "tag_good_arr": [], "id": "il0lgbxzwjz7dt", "updated": "2016-02-24T08:43:36Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>其他例子&#xff1a;ucore_os_lab/labcodes_answer/lab2_result/kern/mm/memlayout.h</p>\n<pre>struct Page {\n\tint ref;\n\tuint32_t flags;\n\tunsigned int property;\n\tlist_entry_t page_link;\n};</pre>\n<p></p>", "created": "2016-02-24T08:43:57Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "ikvcvnzpzq7j7", "children": [], "tag_good_arr": [], "id": "il0lgs2s2g54g1", "updated": "2016-02-24T08:43:57Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>在libs/list.h中定义了一个基本的双向链表&#xff0c;即不包含数据&#xff0c;只有基本的add和del函数&#xff1b;</p>\n<p>实现队列时只需要对该struct再做一层封装&#xff0c;即</p>\n<p>struct Queue {<br />    list_entry_t run_list;<br />    // data<br />};</p>\n<p>这样可以依照list_entry_t来获取到队列中的一个节点&#xff0c;并通过强制转换来读取该节点的数据。</p>\n<p></p>", "created": "2016-02-24T08:44:06Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0f7v0qgfm61s6", "children": [], "tag_good_arr": [], "id": "il0lgyz0bop7mo", "updated": "2016-02-24T08:44:06Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<p>链表的定义在libs/list.h中</p>\n<pre>struct list_entry {\n    struct list_entry *prev, *next;\n};</pre>\n<p>这一定义为链表的向前和向后指针。</p>\n<p>如果需要自己的数据结构的话&#xff0c;做如下的定义</p>\n<pre>struct my_queue {\n    struct list_entry_t list_node;\n    Data data;\n    // add other things you want;\n};</pre>\n<p>这样就可以支持不同的数据类型。实际上这里通过C语言的强制类型转换来实现了C&#43;&#43;里面的类似多态的功能。</p>", "created": "2016-02-24T08:44:21Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0minzvpea57bu", "children": [], "tag_good_arr": [], "id": "il0lhasiq446t8", "updated": "2016-02-24T08:44:21Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>struct list_entry {<br /> struct list_entry *prev, *next;<br />};</p>\n<p>这里ucore实现了双向链表&#xff0c;实现队列的时候只需要将list_entry和data封装到一个结构体里即可&#xff0c;</p>\n<p>具体队列的插入删除只需要调用list_entry的相应的函数接口即可。</p>", "created": "2016-02-24T08:44:30Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i1bzj2xilgm4uk", "children": [], "tag_good_arr": [], "id": "il0lhhdeajz4nz", "updated": "2016-02-24T08:44:30Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>队列的数据结构可以参考libs/list.h中的代码</p>\n<p>通过</p>\n<pre>struct list_entry {\n    struct list_entry *prev, *next;\n};</pre>\n<p>新建了抽象类</p>\n<p>然后在使用的时候创建自己的类&#xff0c;然后用组合的方式让list_entry变成成员比如&#xff1a;</p>\n<pre>struct my_queue{\n \tlist_entry a;\n\tmydata x;\n};</pre>\n<p>基于四个函数init,add_after,add_before以及del函数链接list_entry。通过le2page能够得到list_entry所在的头。</p>", "created": "2016-02-24T08:44:36Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i11v1az5sf83l2", "children": [], "tag_good_arr": [], "id": "il0lhm2q2m76h", "updated": "2016-02-24T08:44:36Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>队列数据结构库是libs/list.h&#xff0c;里面定义抽象的队列类list_entry_t。</p>\n<p></p>\n<p>struct list_entry {<br /> struct list_entry *prev, *next;<br />};</p>\n<p>typedef struct list_entry list_entry_t;</p>\n<p></p>\n<p>当需要支持保存某种数据类型some_data_t的时候&#xff0c;只需定义some_data_list_t如下&#xff1a;</p>\n<p></p>\n<p>struct some_data_list {</p>\n<p>list_entry_t list;</p>\n<p>some_data_t data;</p>\n<p>};</p>\n<p>typedef struct some_data_list some_data_list_t;</p>\n<p></p>\n<p>王启圣 2013011409</p>\n<p>马志明 2013011395</p>", "created": "2016-02-24T08:44:53Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0nu5by9l7v7of", "children": [], "tag_good_arr": [], "id": "il0lhyxqk4g718", "updated": "2016-02-24T08:44:53Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>在ucore_os_lab/ucore_os_lab/related_info/lab0/list.h中定义了双向链表结构list_entry&#xff0c;在第17行开始&#xff1a;</p>\n<pre>struct list_entry {<br />    struct list_entry *prev, *next;<br />};</pre>\n<p>可见这是一个抽象链表&#xff0c;没有保存数据。为了实现支持保存不同数据的多种队列&#xff0c;只需定义一以下结构体即可</p>\n<pre>struct data_list {<br />list_entry *list;<br />DataType data;<br />};</pre>\n<p></p>\n<p></p>", "created": "2016-02-24T08:45:00Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0hjdkesg9c5z7", "children": [], "tag_good_arr": [], "id": "il0li4vro3772s", "updated": "2016-02-24T08:45:00Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>在list.h中实际上只是一个维护结构而不维护对应数据的一个抽象数据结构&#xff0c;在实现对应不同数据类型的具体的链表时&#xff0c;只需要自定义一个struct, 在其中包含这个抽象的链表struct作为成员&#xff0c;将自己需要附加的数据信息作为其他域即可。看起来就像是继承一样。</p>", "created": "2016-02-24T08:45:04Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "ikvcvqnhm907lr", "children": [], "tag_good_arr": [], "id": "il0li7xy4g3ki", "updated": "2016-02-24T08:45:04Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>在libs/list.h中定义了list_entry结构&#xff0c;负责维持连表结构&#xff1a;</p>\n<pre>struct list_entry {<br />    struct list_entry *prev, *next;<br />};</pre>\n<p>使用时可以定义一个结构包裹住list_entry&#xff0c;</p>\n<pre>struct entry {<br />    list_entry_t node;\n    int num;\n};</pre>\n<p></p>\n<p>访问相邻entry时可以从node.next/node.prev获得前一个/后一个entry的起始地址&#xff0c;再通过指针类型强转获得完整的entry结构体信息&#xff0c;从而访问num这类实际包含的数据。</p>", "created": "2016-02-24T08:46:10Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i11dx198ive25r", "children": [], "tag_good_arr": [], "id": "il0ljmowlr77j2", "updated": "2016-02-24T08:46:10Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>队列使用双向链表实现的&#xff0c;具体代码是在lab8/libs/list.h:17</p>\n<pre>struct list_entry {\n    struct list_entry *prev, *next;\n};</pre>\n<p>这个结构体只负责维护链表&#xff0c;要想附带其他数据还需要定义其他结构体&#xff0c;例如&#xff1a;</p>\n<p>lab8/kern/fs/sfs/sfs.h:83</p>\n<pre>/* filesystem for sfs */\nstruct sfs_fs {\n    struct sfs_super super;                         /* on-disk superblock */\n    struct device *dev;                             /* device mounted on */\n    struct bitmap *freemap;                         /* blocks in use are mared 0 */\n    bool super_dirty;                               /* true if super/freemap modified */\n    void *sfs_buffer;                               /* buffer for non-block aligned io */\n    semaphore_t fs_sem;                             /* semaphore for fs */\n    semaphore_t io_sem;                             /* semaphore for io */\n    semaphore_t mutex_sem;                          /* semaphore for link/unlink and rename */\n    list_entry_t inode_list;                        /* inode linked-list */\n    list_entry_t *hash_list;                        /* inode hash linked-list */\n};</pre>\n<p></p>", "created": "2016-02-24T08:47:18Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "ikvcvno79n07iu", "children": [], "tag_good_arr": [], "id": "il0ll3eeimcgt", "updated": "2016-02-24T08:47:18Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>在libs/list.h中</p>\n<pre>struct list_entry {<br />    struct list_entry *prev, *next;<br />};<br />typedef struct list_entry list_entry_t;</pre>\n<p>通过这个作为node间的双向连接&#xff0c;在存储其他数据时:</p>\n<pre>struct dataList{\n    list_entry_t node;<br />    T data;\n};</pre>\n<p>即可&#xff0c;通过node来进行链表中的移动&#xff0c;通过data访问该节点内数据&#xff0c;可以为任意类型。</p>", "created": "2016-02-24T08:48:02Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0i7rzz9iau2gd", "children": [], "tag_good_arr": [], "id": "il0lm173iyl3vh", "updated": "2016-02-24T08:48:02Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>队列的数据结构位于lab8/lib/list.h里面</p>\n<pre>struct list_entry {\n    struct list_entry *prev, *next;\n};</pre>\n<p>需要自己封装一下</p>\n<pre>struct queue {\n    struct list_entry_t list_node;\n    // 自己定义的数据\n};</pre>", "created": "2016-02-24T08:48:26Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i1oqryfapik22", "children": [], "tag_good_arr": [], "id": "il0lmjcbocx1r4", "updated": "2016-02-24T08:48:26Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>list.h中实现了维护列表本身&#xff0c;并不存储数据的结构体&#xff1a;</p>\n<p></p>\n<p>struct list_entry {<br />    struct list_entry *prev, *next;<br />};</p>\n<p></p>\n<p>可以把list_entry和数据结构data封装到一个结构体中维护访问&#xff1a;</p>\n<p></p>\n<p>struct entry {<br />    list_entry *list;</p>\n<p>    Data data;<br />};</p>\n<p></p>\n<p>访问数据时根据data在结构体中的位置计算出地址访问即可。</p>", "created": "2016-02-24T08:50:02Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i701mss708y", "children": [], "tag_good_arr": [], "id": "il0lolhvbpf1og", "updated": "2016-02-24T08:50:02Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>在/libs/list.h中定义的结构list_entry&#xff1a;</p>\n<p>struct list_entry {</p>\n<p>    struct list_entry *prev, *next;</p>\n<p>}<br />typedef struct list_entry list_entry_t;</p>\n<p>实现了双向链表&#xff0c;通过4个基本函数</p>\n<p>static inline list_entry_t *list_next(list_entry_t *listelm) __attribute__((always_inline));<br />static inline list_entry_t *list_prev(list_entry_t *listelm) __attribute__((always_inline));</p>\n<p>static inline void __list_add(list_entry_t *elm, list_entry_t *prev, list_entry_t *next) __attribute__((always_inline));<br />static inline void __list_del(list_entry_t *prev, list_entry_t *next) __attribute__((always_inline));</p>\n<p>分别实现在双向链表中取后继、取前趋、插入结点、删除结点的功能。</p>\n<p></p>\n<p>在实现需要包含具体数据的队列时&#xff0c;只需在队列结构体内嵌入双向链表结点&#xff0c;再加上队列所需的数据即可&#xff0c;访问队列中的结点时先访问双向链表结点&#xff0c;根据其地址索引到相应队列结点的地址。队列结构示例&#xff1a;</p>\n<p>struct queue_t {</p>\n<p>     list_entry_t head;</p>\n<p>     T data;</p>\n<p>}</p>\n<p></p>\n<p>这也是操作系统内核中队列结构的实现方式。</p>", "created": "2016-02-24T08:50:02Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "ie7xy3iwuug1os", "children": [], "tag_good_arr": [], "id": "il0lolvxi5g39g", "updated": "2016-02-24T08:50:02Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>队列数据结构是一个双向循环链表&#xff0c;定义在lab8/lib/list.h中&#xff0c;结构中定义了list_init&#xff0c;list_add&#xff0c;list_del&#xff0c;list_empty四个内联函数来提供基本操作&#xff0c;结构体中不保存任何的数据&#xff0c;所以想实现保存不同数据结构的多种队列只需要外包一层结构体即可。<br />比如&#xff1a;<br />struct extraList {<br />    list_entry * _list;<br />    // your data<br />};</p>", "created": "2016-02-24T08:50:32Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "ikvcvq38pa7l6", "children": [], "tag_good_arr": [], "id": "il0lp8obr1s6sz", "updated": "2016-02-24T08:50:32Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>struct list_entry {<br />    struct list_entry *prev, *next;<br />};</p>\n<p>//代码在lab8/libs/list.h</p>\n<p>//实现双向&#xff0c;没有保存数据&#xff0c;要实现不同队列需要在此基础上继续定义结构</p>\n<p></p>\n<p></p>", "created": "2016-02-24T08:50:35Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "ikvcvo2cckb7jb", "children": [], "tag_good_arr": [], "id": "il0lpbdnic91vt", "updated": "2016-02-24T08:50:35Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>通用数据的双向链表结构在libs/list,h中</p>\n<p></p>\n<p>数据队列实现如下</p>\n<p>struct node{<br /> list_entry_t entry;<br /> T data;<br />};</p>\n<p>struct queue{<br /> node head;<br /> node tail;<br />};</p>\n<p></p>\n<p>通过node进行链表移动&#xff0c;通过强制转换访问需求的数据</p>\n<p></p>", "created": "2016-02-24T08:51:26Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0em4o8wvj34lb", "children": [], "tag_good_arr": [], "id": "il0lqe9q6qb3sr", "updated": "2016-02-24T08:51:26Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>队列的数据结构位于 lab7/lib/list.h中。在lab7/kern/sync/wait.c中有具体的使用&#xff1a;</p>\n<p>11行&#xff1a;list_init(&amp;(wait-&gt;wait_link));</p>\n<p>23行&#xff1a;list_add_before(&amp;(queue-&gt;wait_head), &amp;(wait-&gt;wait_link));</p>\n<p>29行&#xff1a;list_del_init(&amp;(wait-&gt;wait_link));</p>\n<p>35行&#xff1a;list_entry_t *le = list_next(&amp;(wait-&gt;wait_link));</p>", "created": "2016-02-24T08:52:02Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0cb1385ni65l", "children": [], "tag_good_arr": [], "id": "il0lr683ljl5ew", "updated": "2016-02-24T08:52:02Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>lab0/list.h中定义了双向链表</p>\n<pre>struct list_entry {\n    struct list_entry *prev, *next;\n};</pre>\n<p>为了支持保存各种不同数据的队列&#xff0c;还需要一个结构体。</p>\n<pre>struct data{\n\tlist_entry_t node;\n\tT datanode;\n};\n\t</pre>\n<p>程凯 2013011303</p>", "created": "2016-02-24T08:52:27Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i1569mw0xp954u", "children": [], "tag_good_arr": [], "id": "il0lrpv7k1i66b", "updated": "2016-02-24T08:52:27Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>在libs/list.h中有相关的实现&#xff0c;其中实现了一个抽象的链表</p>\n<pre>struct list_entry {<br />    struct list_entry *prev, *next;<br />};</pre>\n<p>支持的相关基本操作有&#xff1a;</p>\n<pre>static inline void list_init(list_entry_t *elm) __attribute__((always_inline));<br />static inline void list_add(list_entry_t *listelm, list_entry_t *elm) __attribute__((always_inline));<br />static inline void list_add_before(list_entry_t *listelm, list_entry_t *elm) __attribute__((always_inline));<br />static inline void list_add_after(list_entry_t *listelm, list_entry_t *elm) __attribute__((always_inline));<br />static inline void list_del(list_entry_t *listelm) __attribute__((always_inline));<br />static inline void list_del_init(list_entry_t *listelm) __attribute__((always_inline));</pre>\n<p>这里只定义了一个抽象的双向链表&#xff0c;内部没有数据&#xff0c;如果要保存特定的数据&#xff0c;则用一个新的struct中包含一个list_entry_t即可</p>\n<pre>struct data_entry<br />{<br />\tlist_entry_t node;<br />\tdata my_data;<br />}</pre>\n<p>然后通过强制类型转换来进行链表的访问。</p>\n<p>具体的实例在kern\\fs\\sfs\\sfs.h中&#xff0c;从第69-77行定义了一个链表</p>\n<pre>struct sfs_inode {\n    struct sfs_disk_inode *din;                     /* on-disk inode */\n    uint32_t ino;                                   /* inode number */\n    bool dirty;                                     /* true if inode modified */\n    int reclaim_count;                              /* kill inode if it hits zero */\n    semaphore_t sem;                                /* semaphore for din */\n    list_entry_t inode_link;                        /* entry for linked-list in sfs_fs */\n    list_entry_t hash_link;                         /* entry for hash linked-list in sfs_fs */\n};</pre>\n<p>在这个数据结构内部定义了两个link_entry_t用以实现队列的数据结构</p>", "created": "2016-02-24T08:52:55Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0dlq4m0wjn5eo", "children": [], "tag_good_arr": [], "id": "il0lsbd8vhk34d", "updated": "2016-02-24T08:52:55Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p><pre>list_entry_t结构体主要实现的是队列单元以链表形式进行的前后链接<br />struct list_entry {\n    struct list_entry *prev, *next;\n};<br />即该队列只保存了前后的“地址”指针。<br />在此基础上&#xff0c;我们可以在外面增加一层带有数据的结构体。<br />比如说:<br />struct list_entry_with_data{<br />    struct list_entry list;<br />    DataTpye data; <br />};<br />主要是通过datatype的设定来实现保存数据&#xff0c;已经在datatype里声明各种类型的转化<br />计35 朱新瑞 2013011411</pre>", "created": "2016-02-24T08:52:57Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0zaci5voig5h", "children": [], "tag_good_arr": [], "id": "il0lscc0iyu6cf", "updated": "2016-02-24T08:52:57Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>通过struct封装</p>\n<p>struct foo{</p>\n<p>list_entry_t list_entry;</p>\n<p>T data;</p>\n<p>};</p>", "created": "2016-02-24T08:54:15Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "ig297cbwqr11ej", "children": [], "tag_good_arr": [], "id": "il0lu15be9f3iy", "updated": "2016-02-24T08:54:15Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "struct list_entry {\n    struct list_entry *prev, *next;\n}\ntypedef struct list_entry list_entry_t;\n实现了双向链表。\nstatic inline list_entry_t *list_next(list_entry_t *listelm) __attribute__((always_inline));\nstatic inline list_entry_t *list_prev(list_entry_t *listelm) __attribute__((always_inline));\nstatic inline void __list_add(list_entry_t *elm, list_entry_t *prev, list_entry_t *next) __attribute__((always_inline));\nstatic inline void __list_del(list_entry_t *prev, list_entry_t *next) __attribute__((always_inline));\n用4个函数分别实现在双向链表中取next、prev、insert、delete的功能。", "created": "2016-02-24T08:54:38Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i6uaz437IKR", "children": [], "tag_good_arr": [], "id": "il0luie38vj6rr", "updated": "2016-02-24T08:54:38Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>在lab8/libs/list.h中结构体list_entry的定义为</p>\n<p>struct list_entry_t {<br /> struct list_entry_t *prev, *next;<br />};</p>\n<p>其中只包含前后节点指针&#xff0c;不包含数据。</p>\n<p></p>\n<p>因此&#xff0c;可定义新的结构体</p>\n<p>struct entry {</p>\n<p>list_entry_t node;</p>\n<p>Data data; // node data here</p>\n<p>};</p>\n<p>data存放节点数据&#xff0c;对队列的操作可调用4个基本函数。</p>", "created": "2016-02-24T08:54:43Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i6vir34gLfK", "children": [], "tag_good_arr": [], "id": "il0lum4ss313pa", "updated": "2016-02-24T08:54:43Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>list_entry数据结构定义在libs/list.h文件中&#xff0c;是一个不含有数据&#xff0c;只存相邻节点指针的数据结构&#xff0c;其中定义了一系列内联函数&#xff1b;</p>\n<p>struct list_entry {<br /> struct list_entry *prev, *next;<br />};</p>\n<p>实际存有数据的队列节点数据结构包含了list_entry成员和存储的数据</p>\n<pre>struct entry {<br /><br />    list_entry_t node;<br />    int num;<br />};</pre>", "created": "2016-02-24T08:54:50Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i17iy2ly5py3ad", "children": [], "tag_good_arr": [], "id": "il0lurp7tvdof", "updated": "2016-02-24T08:54:50Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>libs/list.h中实现了以下数据结构</p>\n<pre>struct list_entry {\n    struct list_entry *prev, *next;\n};</pre>\n<p>该结构能够维护一个双向列表&#xff0c;但本身不包含数据。 需要承载数据是将改结构封装到结构体内即可。</p>\n<pre>struct data_list {\n    struct list_entry list;<br />    Data data;\n};</pre>\n<p>通过list获得索引&#xff0c;利用强制类型转换获得数据。</p>", "created": "2016-02-24T08:54:56Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i6ugy67km5b", "children": [], "tag_good_arr": [], "id": "il0luwnhjrc3t2", "updated": "2016-02-24T08:54:56Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>该队列数据结构的实现在libs/list.h中。</p>\n<p>其中定义了一个通用双向链表。</p>\n<pre>struct list_entry {\n    struct list_entry *prev, *next;\n};<br />\ntypedef struct list_entry list_entry_t;</pre>\n<p>其中包含两个指针用于指向前后链表。</p>\n<p>链表操作函数为&#xff1a;</p>\n<pre>static inline void list_init(list_entry_t *elm) __attribute__((always_inline));<br />static inline void list_add(list_entry_t *listelm, list_entry_t *elm) __attribute__((always_inline));<br />static inline void list_del(list_entry_t *listelm) __attribute__((always_inline));</pre>\n<p>三个函数实现的功能分别为&#xff1a;初始化、插入、删除元素。</p>\n<p>在需要实现包含具体数据时&#xff0c;只需在所需的队列结构体内嵌入双向链表结点&#xff0c;再在其中增添需要包含的数据即可&#xff0c;如下所示&#xff1a;</p>\n<pre>struct some_queue_t {<br />     list_entry_t head;         //双向链表节点<br />     XXX data;                    //所需包含的数据<br />}</pre>\n<p></p>\n<p></p>", "created": "2016-02-24T08:55:07Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0evrfcnckf5dt", "children": [], "tag_good_arr": [], "id": "il0lv54pmuasd", "updated": "2016-02-24T08:55:07Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>比如struct datalist {<br />list_entry_t entry; //双向指针<br />t data; //数据<br />};<br />可以用entry的prev和next来访问前后的节点。<br />entry的地址即为datalist类型的地址&#xff0c;可用强制类型转换来访问data。</p>", "created": "2016-02-24T08:56:31Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i3qk2vs65x276j", "children": [], "tag_good_arr": [], "id": "il0lwxtzssk62z", "updated": "2016-02-24T08:56:31Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>在libs/list.h中定义了一个与类型无关只含有指针的结构&#xff1a;</p>\n<p>struct list_entry {<br /> struct list_entry *prev, *next;<br />};</p>\n<p>这个结构作为一个类似于<strong>基类结构指针</strong>(在C中没有继承&#xff0c;但是如果把它放在结构的第一位也可以拥有类似的性质)拥有可扩展成各种不同数据结构的功能。</p>\n<p>对于这种具有基类性质的结构&#xff0c;我们定义了许多方法&#xff08;list.h中23~29行&#xff09;&#xff0c;这些方法不仅仅能操作list_entry&#xff0c;也能操作所有第一个成员是它的扩展结构。</p>\n<p>这些都是用内联函数实现的&#xff0c;所以不会由于嵌套过多导致花费过多资源&#xff0c;又可以在代码层面封装的很好。</p>\n<p></p>\n<p>在kern/sync/wait.h中line6有&#xff1a;</p>\n<p>typedef struct {<br /> list_entry_t wait_head;<br />} wait_queue_t;</p>\n<p>struct proc_struct;</p>\n<p>typedef struct {<br /> struct proc_struct *proc;<br /> uint32_t wakeup_flags;<br /> wait_queue_t *wait_queue;<br /> list_entry_t wait_link;<br />} wait_t;</p>\n<p></p>\n<p>其中wait_queue_t是对上述裸结构的封装&#xff0c;统一了接口。</p>\n<p>wait_t是加上一系列数据之后的封装&#xff0c;第一个成员是list_entry&#xff0c;使用的时候可以定义类似于list_entry的同样的方法。由于C语言的特性&#xff0c;第一个成员具有的性质第二个成员同样也会具有。</p>\n<p></p>", "created": "2016-02-24T08:58:17Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0f24oie8102cr", "children": [], "tag_good_arr": [], "id": "il0lz7r0b1y2lg", "updated": "2016-02-24T08:58:17Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>lab8/libs/list.h中</p>\n<p>struct list_entry {</p>\n<p>struct list_entry *prev, *next;</p>\n<p>};</p>\n<p>可以支持不同数据结构</p>\n<p>struct T {</p>\n<p>  struct list_entry h;</p>\n<p>  data t;</p>\n<p>}</p>", "created": "2016-02-24T08:58:24Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0d4mr9tga62ki", "children": [], "tag_good_arr": [], "id": "il0lzdboojtyp", "updated": "2016-02-24T08:58:24Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>队列数据结构有4个基本操作函数&#xff0c;如何基于这些函数来实现支持保存不同数据的多种队列&#xff1f;操作系统内核中的队列数据结构是如何实现的&#xff1f;</p>\n<p> </p>\n<p>由于C中像面向对象语言完成继承&#xff0c;libs/list.h第17-21行中定义了无数据list_entry_t抽象的双向列表&#xff0c;</p>\n<p>struct list_entry {<br /> struct list_entry *prev, *next;<br />};</p>\n<p></p>\n<p>在实现一个数据队列时&#xff0c;建立包含数据和抽象列表的struct。在schedule/schedule.h中&#xff0c;</p>\n<p>typedef struct {<br /> unsigned int expires;<br /> struct proc_struct *proc;<br /> list_entry_t timer_link;<br />} timer_t;</p>\n<p>定义了timer的list&#xff0c;通过list.h中的若干个函数可以管理列表&#xff0c;通过相对位置可以对数据进行访问。</p>\n<p></p>", "created": "2016-02-24T08:58:28Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i6ub5at2geM", "children": [], "tag_good_arr": [], "id": "il0lzgftvnd10y", "updated": "2016-02-24T08:58:28Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>lab2/libs/list.h定义结构体 list_entry</p>\n<pre>struct list_entry {\n    struct list_entry *prev, *next;\n};</pre>\n<p></p>", "created": "2016-02-24T09:35:54Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0boovu8sh63xb", "children": [], "tag_good_arr": [], "id": "il0nbkzcv624xd", "updated": "2016-02-24T09:35:54Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>libs/list.h中实现了简单双向表项结构list_entry:</p>\n<p></p>\n<pre>struct list_entry_t {<br />    struct list_entry_t *prev, *next;<br />};</pre>\n<p><br />可以使用这个数据结构实现包含具体数据的结构&#xff1a;</p>\n<pre>struct my_list_t {<br />    list_entry_t head;<br />    Data data;<br />};</pre>\n<p></p>", "created": "2016-02-24T09:58:01Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i6uayuoumpw5ah", "children": [], "tag_good_arr": [], "id": "il0o40qecc72tt", "updated": "2016-02-24T09:58:01Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>在lab8/libs/list.h中&#xff0c;定义了一个双向链表结构&#xff0c;作为实现队列的基础。其中只包括指针&#xff0c;而不包括数据本身。其定义如下&#xff1a;</p>\n<pre>struct list_entry {\n    struct list_entry *prev, *next;\n};</pre>\n<p>在同一文件中&#xff0c;以内联函数的方式实现了双向链表的初始化、插入结点和删除结点等操作。这些内联函数之间有相互“调用”关系&#xff08;实际上是通过内联方式进行了嵌套&#xff09;。使用内联函数可以达到使用宏的效果。</p>\n<p></p>\n<p>实现队列时&#xff0c;只需要把该结构体作为成员即可&#xff08;相当于手工实现了继承&#xff09;&#xff0c;即&#xff1a;</p>\n<pre>struct my_queue_entry {\n     list_entry_t node;         \n     DataType data;\n}</pre>\n<p>使用中&#xff0c;通过强制类型转换&#xff0c;用list_entry_t中的指针访问相邻的&#xff08;含有数据的&#xff09;结点。</p>", "created": "2016-02-24T10:07:39Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0gl5kctugw3xi", "children": [], "tag_good_arr": [], "id": "il0ogf97xoa6fb", "updated": "2016-02-24T10:07:39Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>利用在list.h定义的双向链表&#xff08;支持前加、后加、删除、清空&#xff09;可以实现队列&#xff0c;如&#xff1a;</p>\n<p>typedef struct my_queue{<br /> struct list_entry *list;<br /> //.... Data here<br />}queue;</p>", "created": "2016-02-24T10:08:17Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0ccqbaxwdz75c", "children": [], "tag_good_arr": [], "id": "il0oh8or1186gf", "updated": "2016-02-24T10:08:17Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>在lab8\\libs\\list.h中有一个只有prev和next指针&#xff0c;没有数据的抽象链表&#xff1a;</p>\n<pre>struct list_entry {<br />    struct list_entry *prev, *next;<br />};</pre>\n<p>基本操作函数定义如下&#xff1a;</p>\n<pre>static inline void list_init(list_entry_t *elm) __attribute__((always_inline));<br />static inline void list_add(list_entry_t *listelm, list_entry_t *elm) __attribute__((always_inline));<br />static inline void list_add_before(list_entry_t *listelm, list_entry_t *elm) __attribute__((always_inline));<br />static inline void list_add_after(list_entry_t *listelm, list_entry_t *elm) __attribute__((always_inline));<br />static inline void list_del(list_entry_t *listelm) __attribute__((always_inline));<br />static inline void list_del_init(list_entry_t *listelm) __attribute__((always_inline));</pre>\n<p>对于不同的数据&#xff0c;用list_entry_t来维护链表的形态&#xff0c;例如lab8\\kern\\sync\\wait.h里面的&#xff1a;</p>\n<pre>typedef struct {<br />    struct proc_struct *proc;<br />    uint32_t wakeup_flags;<br />    wait_queue_t *wait_queue;<br />    list_entry_t wait_link;<br />} wait_t;</pre>\n<p>具体实现采用inline&#xff0c;实现代码如&#xff1a;</p>\n<pre>static inline void<br />list_add_after(list_entry_t *listelm, list_entry_t *elm) {<br />    __list_add(elm, listelm, listelm-&gt;next);<br />}\nstatic inline void<br />__list_add(list_entry_t *elm, list_entry_t *prev, list_entry_t *next) {<br />    prev-&gt;next = next-&gt;prev = elm;<br />    elm-&gt;next = next;<br />    elm-&gt;prev = prev;<br />}</pre>\n<p></p>", "created": "2016-02-24T10:11:09Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i2olyyl8swl1we", "children": [], "tag_good_arr": [], "id": "il0okwue4vm5yi", "updated": "2016-02-24T10:11:09Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>乔奕 2013011324</p>\n<p>struct list_entry {<br />    struct list_entry *prev, *next;<br />};</p>\n<p>是一个双向链表&#xff0c;为了使用这个双向链表&#xff0c;可以定义一种结构体&#xff0c;包含一个双向链表的结点&#xff0c;就可以了。</p>\n<p></p>\n<p>struct entry {<br />    list_entry *list;</p>\n<p>    //……<br />};</p>\n<p></p>\n<p>另外&#xff0c;ucore中还提供了从某个链表结点获得包含它的结构体的方法&#xff0c;即使用to_struct宏</p>", "created": "2016-02-24T10:12:43Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0gkdbms5ie20o", "children": [], "tag_good_arr": [], "id": "il0omxefgno4p", "updated": "2016-02-24T10:12:43Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>在libs/list.h 中 实现了一个 不含数据的双向链表&#xff1a;</p>\n<pre>struct list_entry {<br />    struct list_entry *prev, *next;<br />};</pre>\n<p>而该链表的多种方法由内联函数实现&#xff0c;避免函数嵌消耗过多资源</p>\n<p>而 当使用队列时&#xff0c;因为 C中无继承&#xff0c;所以只能使用一些强制转换等方法来打到C&#43;&#43;中继承的效果&#xff1b;</p>", "created": "2016-02-24T10:13:57Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i2om0jwie732m1", "children": [], "tag_good_arr": [], "id": "il0ooiwtohfmc", "updated": "2016-02-24T10:13:57Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p><p>在libs/list.h中&#xff0c;定义了一个抽象的双向链表如下&#xff1a;</p>\n<p>struct list_entry {<br />    struct list_entry *prev, *next;<br />};</p>\n<p>而在实现队列时&#xff0c;只需要在队列结构体内包含list_entry和所需数据即可。</p>", "created": "2016-02-24T10:15:48Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "ikvcvonk6wj7k1", "children": [], "tag_good_arr": [], "id": "il0oqw77cyl1uf", "updated": "2016-02-24T10:15:48Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>在libs/list.h中实现了抽象的双向链表</p>\n<table><tbody><tr></tr><tr><td>struct list_entry {</td></tr><tr><td></td><td>struct list_entry *prev, *next;</td></tr><tr><td></td><td>};</td></tr><tr><td></td></tr></tbody></table>\n<p>只有prev和next指针而无具体存储的数据&#xff0c;并有一系列操作list_entry结构体类型的内联函数用以实现双向链表的功能。实际使用时将list_entry与要存储的数据装到一个结构体中&#xff0c;就可以在链表中存储数据了。</p>\n<p>为了通过一个指向list_entry类型的指针访问到它对应的外层结构体&#xff0c;在libs/defs.h定义了to_struct(ptr, type, member)这个宏&#xff0c;ptr为上文所述的指针&#xff0c;type为外层结构体的类型&#xff0c;member为type类型结构体中list_entry这项的名字。该宏求出list_entry项关于整个结构体地址的偏移量&#xff0c;将ptr减去该偏移量就得到指向外层结构体的指针。</p>\n<p>举例&#xff1a;</p>\n<p>在kern/schedule/sched.h中&#xff0c;定义了一个包含list_entry_t的struct</p>\n<table><tbody><tr></tr><tr><td>typedef struct {</td></tr><tr><td></td><td>unsigned int expires; //the expire time</td></tr><tr><td></td><td>struct proc_struct *proc; //the proc wait in this timer. If the expire time is end, then this proc will be scheduled</td></tr><tr><td></td><td>list_entry_t timer_link; //the timer list</td></tr><tr><td></td><td>} timer_t;</td></tr><tr><td></td></tr></tbody></table>\n<p>为通过指向timer_link成员的指针ptr获得它外层指向timer_t类型的指针&#xff0c;定义了一个宏</p>\n<table><tbody><tr></tr><tr><td>#define le2timer(le, member) \\</td></tr><tr><td></td><td>to_struct((le), timer_t, member)</td></tr><tr><td></td></tr></tbody></table>\n<p>这样调用le2timer(ptr, timer_link)就可以达到这一要求了。</p>", "created": "2016-02-24T10:28:05Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "ikvcvr6di5i7ma", "children": [], "tag_good_arr": [], "id": "il0p6p352ow5vn", "updated": "2016-02-24T10:28:05Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>保存同一数据的一种队列&#xff1a;</p>\n<p>struct node_list {</p>\n<p>  list_entry le;</p>\n<p>  int data;</p>\n<p>};</p>\n<p>这样保证了list_entry与node_list的【基地址一致】&#xff0c;le中的prev和next可视为node_list的prev和next。</p>\n<p>============================================================================</p>\n<p>保存不同数据的一种队列&#xff1a;</p>\n<p>struct node_list {</p>\n<p>  list_entry le;</p>\n<p>  int data_type_id;</p>\n<p>  void* data;</p>\n<p>};</p>\n<p>对队列中数据的操作需要判断data_type_id的值。</p>\n<p>============================================================================</p>\n<p>保存同一数据的多种队列&#xff1a;</p>\n<p>list.h只实现了双向链表&#xff0c;举以下两种队列作为例子</p>\n<p>静态队列&#xff1a;</p>\n<p>struct static_node_list {</p>\n<p>  int n_len;</p>\n<p>  int* datas;</p>\n<p>};</p>\n<p>其中插入&#xff0c;删除等操作需要整体位移</p>\n<p>有序跳表&#xff1a;</p>\n<p>struct jump_node_list {</p>\n<p>  list_entry le;</p>\n<p>  int data;</p>\n<p>  jump_node_list** jps;</p>\n<p>  int jps_len;</p>\n<p>};</p>\n<p>插入新节点时需检查相邻的jps长度大于一定值并添加, 删除时检查小于一定值并删除</p>\n<p>============================================================================</p>\n<p>保存不同数据的多种队列&#xff1a;</p>\n<p>用type_id表示不同数据的种类。</p>\n<p>============================================================================</p>\n<p>操作系统内核的队列数据结构实现&#xff1a;</p>\n<p>举用于malloc的block list为例&#xff0c;大体上为以下结构&#xff1a;</p>\n<p>struct block_t {</p>\n<p>  int size; // 块大小</p>\n<p>  block_t* next; // 下一个块</p>\n<p>  int free; // 块是否空闲</p>\n<p>  ... // 最终空间大小可能为4的整数倍</p>\n<p>};</p>\n<p></p>", "created": "2016-02-24T10:40:11Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "ibz6vywnw6g7nl", "children": [], "tag_good_arr": [], "id": "il0pm9797cg23i", "updated": "2016-02-24T10:40:11Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>在libs/list.h中定义了抽象的双向链表</p>\n<p>truct list_entry {<br />    struct list_entry *prev, *next;<br />};</p>\n<p>基本操作函数</p>\n<p>static inline void list_init(list_entry_t *elm) __attribute__((always_inline));<br />static inline void list_add(list_entry_t *listelm, list_entry_t *elm) __attribute__((always_inline));<br />static inline void list_add_before(list_entry_t *listelm, list_entry_t *elm) __attribute__((always_inline));<br />static inline void list_add_after(list_entry_t *listelm, list_entry_t *elm) __attribute__((always_inline));<br />static inline void list_del(list_entry_t *listelm) __attribute__((always_inline));<br />static inline void list_del_init(list_entry_t *listelm) __attribute__((always_inline));</p>\n<p></p>\n<p>实现时&#xff0c;在外层套一个struct&#xff0c;包括list_entry和数据类型。</p>\n<p></p>\n<p></p>", "created": "2016-02-24T10:40:15Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i28skba6cd976f", "children": [], "tag_good_arr": [], "id": "il0pmc1yrd72m", "updated": "2016-02-24T10:40:15Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>相关的实现在libs/list.h中。</p>\n<p>基本的链表结构&#xff1a;</p>\n<p>struct list_entry {<br />    struct list_entry *prev, *next;<br />};</p>\n<p> 相应信息附加&#xff1a;</p>\n<p>struct entry {<br />    list_entry *list;</p>\n<p>    //在*list之外需要添加的数据<br />};</p>\n<p></p>", "created": "2016-02-24T10:47:11Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i2g664y8vve6h4", "children": [], "tag_good_arr": [], "id": "il0pv928i7p7av", "updated": "2016-02-24T10:47:11Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>在/lab8/libs/list.h中定义了双向链表&#xff0c;该结构不包含数据</p>\n<p></p>\n<p>struct list_entry{</p>\n<p>  struct list_entry *prev, *next;</p>\n<p>};</p>\n<p></p>\n<p>在使用过程中&#xff0c;可以在list_entry外再套一个数据结构&#xff0c;在这</p>\n<p>个结构中可以包含数据.</p>\n<p>struct entry{</p>\n<p>  struct list_entry* l_entry;</p>\n<p>  //data</p>\n<p>  ...</p>\n<p>};</p>\n<p>访问数据时强制转换指针就可以获得entry结构体</p>\n<p>中的数据。</p>", "created": "2016-02-24T11:14:58Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "ikx8y1dzPrM", "children": [], "tag_good_arr": [], "id": "il0quzn9ft56ff", "updated": "2016-02-24T11:14:58Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<pre>// lab8/libs/list.h\n\nstruct list_entry{\n  struct list_entry *prev, *next;\n};</pre>\n<p>这是不包含任何数据的双向链表。要使用他&#xff0c;只需定义类似</p>\n<pre>struct my_entry {\n  struct list_entry node;\n  // data goes here\n};</pre>\n<p>的结构即可。如果list_entry成员在新的结构体的开头&#xff0c;则可以在拿到prev/next之后直接强制类型转换&#xff0c;否则就需要使用offsetof或者更简便的container_of宏来获得包含这一entry_list的新的结构体的指针。</p>", "created": "2016-02-24T11:34:42Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "ierwkwbinsj2t8", "children": [], "tag_good_arr": [], "id": "il0rkd5s3ke206", "updated": "2016-02-24T11:34:42Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>程序用list_entry结构体单纯表示链表的链接关系,指明该节点前后的节点地址.</p>\n<p>然后通过外包一层结构体来实现表示不同数据,在外结构体内可以携带很多信息,来对携带的数据进行翻译,由于结构体地址连续,这些信息以及数据可以通过在结构体头地址偏移一些位置后获得</p>", "created": "2016-02-24T11:45:25Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "ikvcvmzbvlf7i6", "children": [], "tag_good_arr": [], "id": "il0ry53k2ff4qp", "updated": "2016-02-24T11:45:25Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>虽然时间晚了但也来提交一下吧&#xff1a;</p>\n<p>在<a href=\"https://github.com/chyyuu/ucore_os_lab/blob/master/labcodes/lab8/libs/list.h\" target=\"_blank\">list.h</a>中有了一个双向链表的实现&#xff0c;</p>\n<pre>struct list_entry {\n    struct list_entry *prev, *next;\n};</pre>\n<p></p>\n<p>基于这个双向链表&#xff0c;可以将一个list_entry以及所需的数据封装在同一个struct中&#xff0c;从而形成操作系统内核中的支持保存不同类型数据的队列数据结构&#xff0c;例子如下&#xff1a;</p>\n<p>在<a href=\"https://github.com/chyyuu/ucore_os_lab/blob/master/labcodes/lab8/kern/sync/wait.h\" target=\"_blank\">lab8/kern/sync/wait.h</a>中&#xff1a;<br /><br /></p>\n<pre>typedef struct {<br />    list_entry_t wait_head;<br />} wait_queue_t;<br /><br />typedef struct {<br />    struct proc_struct *proc;<br />    uint32_t wakeup_flags;<br />    wait_queue_t *wait_queue;<br />    list_entry_t wait_link;<br />} wait_t;</pre>", "created": "2016-02-24T12:37:00Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i70lz5f0QKm", "children": [], "tag_good_arr": [], "id": "il0tshamyxm6t5", "updated": "2016-02-24T12:37:00Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>链表结构是:</p>\n<p>struct list_entry {<br />    struct list_entry *prev, *next;<br />};</p>\n<p>这种双向链表可以把不同的数据类型封装成同样的struct&#xff0c;从而方便实现和管理。在指针外面包一个结构体&#xff0c;然后当需要从指针获取数据时强转就可以了。</p>", "created": "2016-02-24T12:42:01Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i6ub4vwhQXd", "children": [], "tag_good_arr": [], "id": "il0tyxb2eaa369", "updated": "2016-02-24T12:42:01Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p><pre>struct list_entry {<br />    struct list_entry *prev, *next;<br />};</pre>\n<p>list.h, line17处定义了链表的结构</p>\n<p></p>\n<pre>static inline void list_init(list_entry_t *elm) __attribute__((always_inline));\nstatic inline void list_add(list_entry_t *listelm, list_entry_t *elm) __attribute__((always_inline));\nstatic inline void list_add_before(list_entry_t *listelm, list_entry_t *elm) __attribute__((always_inline));\nstatic inline void list_add_after(list_entry_t *listelm, list_entry_t *elm) __attribute__((always_inline));\nstatic inline void list_del(list_entry_t *listelm) __attribute__((always_inline));\nstatic inline void list_del_init(list_entry_t *listelm) __attribute__((always_inline));\nstatic inline bool list_empty(list_entry_t *list) __attribute__((always_inline));\nstatic inline list_entry_t *list_next(list_entry_t *listelm) __attribute__((always_inline));\nstatic inline list_entry_t *list_prev(list_entry_t *listelm) __attribute__((always_inline));</pre>\n<p>list.h, line 23处定义了以上方法&#xff0c;提供了链表的添加删除前驱后继功能。</p>\n<p></p>\n<p>实际使用时&#xff0c;通常是在链表节点外包一个结构体&#xff0c;然后使用to_struct宏强转&#xff0c;来取得跟c&#43;&#43;中继承相类似的功能。</p>", "created": "2016-02-24T14:16:22Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0jauby0gkg76x", "children": [], "tag_good_arr": [], "id": "il0xc9qiupi4yv", "updated": "2016-02-24T14:16:22Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "il0kk0ybpqsl2", "updated": "2016-02-24T08:18:29Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>题目&#xff1a;<b>v9-cpu相关题目</b></p>\n<p></p>\n<p><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/01-3-lab0-spoc-discussion.md#v9-cpu相关题目\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/01-3-lab0-spoc-discussion.md#v9-cpu相关题目</a></p>\n<p></p>\n<p>只要求回答与v9-cpu相关的问题。</p>\n<p></p>\n<p>这个题目的回答在本贴后回复。</p>", "created": "2016-02-24T08:20:27Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "#include \nint ret;\nout(port, val)\n{\n  asm(LL,8);   // load register a with port\n  asm(LBL,16); // load register b with val\n  asm(BOUT);   // output byte to console\n}\n\nint write(int f, char *s, int n)\n{\n  int i;\n  ret = 1;\n  i=n;\n  while (i--)\n    out(f, *s&#43;&#43;);\n  return i;\n}  \n\nmain()\n{\n\n  //Change S1/S2 ID to your student ID, and change 12 to new str length\n  ret = write(1, &#34;2013011376 2013011377&#34;,22);\n  asm(HALT);\n}", "created": "2016-02-24T08:44:17Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0eqqq6jvng408", "children": [], "tag_good_arr": [], "id": "il0lh7apy5j6rw", "updated": "2016-02-24T08:44:17Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<p><strong>小组成员</strong></p>\n<p>王苏 2013011301</p>\n<p>王哲 2013012443</p>\n<p></p>\n<p><strong>1. 修改代码&#xff0c;可正常显示小组两位同学的学号&#xff08;用字符串&#xff09;</strong></p>\n<p></p>\n<p>在 /root/usr/funcall.c 中的main函数中修改write语句如下&#xff1a;</p>\n<pre>ret = write(1, &#34;2013012443 2013011301&#34;, 22);</pre>\n<p>即可完成输出。</p>\n<p></p>\n<p><strong>2.生成funcall.c的汇编码&#xff0c;理解其实现并给汇编码写注释</strong></p>\n<p><strong><a href=\"https://github.com/wangsu13/OS/blob/master/1_1.md\" target=\"_blank\">汇编代码注释</a></strong></p>\n<p></p>\n<p><b>3.回答以下问题</b></p>\n<p><b><a href=\"https://github.com/wangsu13/OS/blob/master/1-2.md\" target=\"_blank\">题目答案</a></b></p>\n<p></p>", "created": "2016-02-24T08:45:43Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0hjdkesg9c5z7", "children": [], "tag_good_arr": [], "id": "il0lj1mxe2138v", "updated": "2016-02-24T08:45:43Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<pre>// In root/usr/funcall.c line 24:\nret = write(1, &#34;2012011271 2012011284&#34;, 22);</pre>\n<p>运行 ./build-funcall.sh 会得到 ./funcall.txt 是一个源代码和汇编混起来的文件。</p>\n<p>在funcall.txt中&#xff0c;汇编指令前面有两个十六进制数字&#xff0c;第一个表示地址&#xff0c;第二个表示指令的内容。比如&#xff1a;</p>\n<pre>0000001c  0000200e  LL    0x20 (D 32)</pre>\n<p>和</p>\n<pre>00000028  0000180e  LL    0x18 (D 24)</pre>", "created": "2016-02-24T08:47:26Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "ikwht0mda9v4iu", "children": [], "tag_good_arr": [], "id": "il0ll9ch5vik", "updated": "2016-02-24T08:47:26Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>ret = write(1, &#34;2012011383 2012011383&#34;, 22);</p>", "created": "2016-02-24T08:49:39Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i6vjwdpfniF", "children": [], "tag_good_arr": [], "id": "il0lo3y7qt4gb", "updated": "2016-02-24T08:49:39Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>和楼下Zheyan Shen(沈哲言)一组&#xff0c;详见他的链接</p>", "created": "2016-02-24T08:59:12Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0f24oie8102cr", "children": [], "tag_good_arr": [], "id": "il0m0e45zel7n", "updated": "2016-02-24T08:59:12Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>组员&#xff1a;计34 沈哲言 2013011371 计35 叶子鹏 2013011404</p>\n<p>&#xff08;1&#xff09;修改代码显示学号</p>\n<pre>main()\n{\n  //Change S1/S2 ID to your student ID, and change 12 to new str length\n  ret = write(1, &#34;2013011371 2013011404&#34;,22);\n  asm(HALT);\n}</pre>\n<p>&#xff08;2&#xff09;<a href=\"https://github.com/Silver-Shen/v9-cpu/blob/master/funcall.txt\" target=\"_blank\">汇编码及注释</a>&#xff08;点击链接&#xff09;</p>\n<p>&#xff08;3&#xff09;<a href=\"https://github.com/qq775193759/OS_ANSWER/blob/master/v9_answer.md\" target=\"_blank\">v9_cpu思考题</a></p>\n<p>&#xff08;4&#xff09;<a href=\"https://github.com/Silver-Shen/v9-cpu/blob/master/os0.txt\" target=\"_blank\">os0.c汇编码和注释</a></p>\n<p>&#xff08;5&#xff09;<a href=\"https://github.com/qq775193759/OS_ANSWER/blob/master/os0_answer.md\" target=\"_blank\">os0.c思考题</a></p>", "created": "2016-02-24T08:59:28Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0ayxqk6wry734", "children": [], "tag_good_arr": [], "id": "il0m0qf28z03bk", "updated": "2016-02-24T08:59:28Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>任务&#xff1a;修改代码&#xff0c;可正常显示小组两位同学的学号&#xff08;用字符串&#xff09;</p>\n<p>修改代码:v9-cpu/root/usr/emhello.c:16</p>\n<pre>main()\n{\n  write(1, &#34;2015011343 2015011343\\n&#34;, 22);\n  asm(HALT);\n}</pre>\n<p></p>", "created": "2016-02-24T08:59:30Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "ikvcvno79n07iu", "children": [], "tag_good_arr": [], "id": "il0m0s6krmx1dh", "updated": "2016-02-24T08:59:30Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>组员&#xff1a;郑兆衡2013011389 &#xff0c; 张浩天 2013011416</p>\n<p>funcall修改的代码在如下链接&#xff1a;</p>\n<p><a href=\"https://github.com/ZhengZhaoHeng/os_2016/blob/master/spoc_0/funcall.c\">https://github.com/ZhengZhaoHeng/os_2016/blob/master/spoc_0/funcall.c</a></p>\n<p>汇编代码注释在如下链接&#xff1a;</p>\n<p><a href=\"https://github.com/ZhengZhaoHeng/os_2016/blob/master/spoc_0/funcall.txt\" target=\"_blank\">https://github.com/ZhengZhaoHeng/os_2016/blob/master/spoc_0/funcall.txt</a></p>\n<p>思考题答案在如下链接&#xff1a;</p>\n<p><a href=\"https://github.com/ZhengZhaoHeng/os_2016/blob/master/spoc_0/funcall_ans.txt\">https://github.com/ZhengZhaoHeng/os_2016/blob/master/spoc_0/funcall_ans.txt</a></p>\n<p>os0汇编代码注释在如下链接&#xff1a;</p>\n<p><a href=\"https://github.com/ZhengZhaoHeng/os_2016/blob/master/spoc_0/os0.s\">https://github.com/ZhengZhaoHeng/os_2016/blob/master/spoc_0/os0.s</a></p>\n<p>思考题答案在如下链接&#xff1a;</p>\n<p><a href=\"https://github.com/ZhengZhaoHeng/os_2016/blob/master/spoc_0/os0_ans.txt\" target=\"_blank\">https://github.com/ZhengZhaoHeng/os_2016/blob/master/spoc_0/os0_ans.txt</a></p>\n<p></p>", "created": "2016-02-24T08:59:51Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0dlq4m0wjn5eo", "children": [], "tag_good_arr": [], "id": "il0m184p4403h4", "updated": "2016-02-24T08:59:51Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>将 funcall.c 24行修改为</p>\n<p>ret = write(1, &#34;2012011309 2012080059&#34;,22);</p>", "created": "2016-02-24T09:04:24Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i6ugy67km5b", "children": [], "tag_good_arr": [], "id": "il0m72u9c031r", "updated": "2016-02-24T09:04:24Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>root/usr/funcall.c 24行<br />ret = write(1, &#34;2012011302 2012011321&#34;, 22);</p>", "created": "2016-02-24T09:05:15Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i6vir34gLfK", "children": [], "tag_good_arr": [], "id": "il0m85u6uxj3cd", "updated": "2016-02-24T09:05:15Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<p>2012011308  陆喆</p>\n<p><a href=\"https://github.com/lbx6z/os_course_spoc_exercises/blob/master/all/01-3-lab0-spoc-discussion.md\" target=\"_blank\">思考题</a></p>", "created": "2016-02-24T09:11:04Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "ikvcvnzpzq7j7", "children": [], "tag_good_arr": [], "id": "il0mfnryd9n2v3", "updated": "2016-02-24T09:11:04Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<p>2013011310 余翔</p>\n<p>2013011308 林婕茵</p>\n<p><a href=\"https://github.com/yxfish13/v9-cpu/blob/master/readme.md\" target=\"_blank\">思考题</a></p>\n<p></p>", "created": "2016-02-24T09:45:17Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i11v1az5sf83l2", "children": [], "tag_good_arr": [], "id": "il0nnnqe3ck5v2", "updated": "2016-02-24T09:45:17Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>【未完待续】</p>\n<p></p>\n<p>/root/usr/funcall.c line 24:</p>\n<pre>ret = write(1, &#34;2014011381&#34;, 11);</pre>\n<p></p>\n<p>关于funcall的问题&#xff1a;</p>\n<p>堆栈大小为128&#xff0c;为内核态堆栈&#xff1b;</p>\n<p>ret地址为0x00&#xff0c;直接寻址&#xff1b;</p>\n<p>字符串地址为0x90&#xff0c;相对sp寻址&#xff1b;</p>\n<p>局部变量i地址为0x07bfffd8&#xff0c;相对sp寻址&#xff1b;</p>\n<p>不处与中断使能状态&#xff1b;</p>\n<p>函数参数使用堆栈传递方式&#xff0c;返回值使用寄存器传递方式&#xff1b;</p>\n<p></p>", "created": "2016-02-24T10:02:11Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "ie7xy3iwuug1os", "children": [], "tag_good_arr": [], "id": "il0o9e66z2m47f", "updated": "2016-02-24T10:02:11Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>把root/usr/funcall.c第24行</p>\n<p>ret = write(1, &#34;S1_ID S2_ID&#34;,12);</p>\n<p>改为</p>\n<p>ret = write(1, &#34;2013011409 2013011395\\n&#34;,23);</p>\n<p>即可。</p>\n<p></p>\n<p>问答题</p>\n<p>1 funcall中的堆栈的大小为124MB&#xff0c;实际上在调试的过程中一开始可以看到rd&#xff08;cur sp&#xff09;为07c0 0000<br /> 处于内核态<br />2 ret存在字符串后<br />3 <br />4<br />5 不是<br />6 参数的传递是 调用函数是将所有参数从右向左依次压入栈中&#xff1b;函数的返回值会保存在a寄存器中<br />7 执行文件为二进制文件</p>\n<p></p>\n<p>王启圣 2013011409</p>\n<p>马志明 2013011395</p>", "created": "2016-02-24T10:06:23Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0nu5by9l7v7of", "children": [], "tag_good_arr": [], "id": "il0oese6lsv5t2", "updated": "2016-02-24T10:06:23Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>【占坑】</p>\n<p>将v9-cpu/root/usr/funcall.c main修改为</p>\n<pre>main()\n{\n\n  //Change S1/S2 ID to your student ID, and change 12 to new str length\n  ret = write(1, &#34;2013011307 2013011308&#34;,22);\n  asm(HALT);\n}</pre>\n<p>之后./build-funcall.sh编译执行。得到funcall.txt</p>\n<p><a href=\"https://github.com/hexuan1994/OS/tree/master/hw2\" target=\"_blank\">问答题及文件</a></p>", "created": "2016-02-24T10:07:58Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0evrfcnckf5dt", "children": [], "tag_good_arr": [], "id": "il0ogtkzh7u6bl", "updated": "2016-02-24T10:07:58Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p><pre>//funcall.c line 24\nret = write(1, &#34;2013011355, 2013011339&#34;, 24);</pre>\n<p><a href=\"https://github.com/orangexuhan/os_spoc_answer/blob/master/lec02.md\" target=\"_blank\">第一题解答</a></p>", "created": "2016-02-24T10:16:36Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i1bzj2xilgm4uk", "children": [], "tag_good_arr": [], "id": "il0orwyv4ra4s7", "updated": "2016-02-24T10:16:36Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>1. v9-cpu-master\\root\\usr\\funcall.c line 24: 修改为</p>\n<pre>ret = write(1, &#34;2013011334 2013011334&#34;, 22);</pre>\n<p>2.运行 <em>./build-funcall.sh</em>&#xff0c;得到汇编代码<em>funcall.txt</em></p>\n<p></p>\n<p>3. &#xff08;1&#xff09;funcall中的堆栈有多大&#xff1f;是内核态堆栈还是用户态堆栈&#xff1f;</p>\n<p>             24MB&#xff0c;总共的内存大小为128&#xff0c;其中4MB为FS_SZ&#xff1b;内核态</p>\n<p>    &#xff08;2&#xff09;funcall中的全局变量ret放在内存中何处&#xff1f;如何对它寻址&#xff1f;</p>\n<p>             地址为0xA8&#xff1b;SG 0x8c</p>\n<p>    &#xff08;3&#xff09;funcall中的字符串放在内存中何处&#xff1f;如何对它寻址&#xff1f;</p>\n<p>             放在内存地址中&#xff0c;从0x90开始</p>\n<p>     &#xff08;4&#xff09;局部变量i在内存中的何处&#xff1f;如何对它寻址&#xff1f;</p>\n<p>             0x07bfffdc      SL 0x04</p>\n<p>     &#xff08;5&#xff09; 当前系统是处于中断使能状态吗&#xff1f;</p>\n<p>             不处于</p>\n<p>     &#xff08;6&#xff09;funcall中的函数参数是如何传递的&#xff1f;函数返回值是如何传递的&#xff1f;</p>\n<p>            堆栈功能&#xff1b;存入变量a中</p>", "created": "2016-02-24T10:23:34Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i2om0jwie732m1", "children": [], "tag_good_arr": [], "id": "il0p0vqynjb4tv", "updated": "2016-02-24T10:23:34Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p><a href=\"https://github.com/fkye/os-spoc-answer/blob/master/01-3.md\" target=\"_blank\">https://github.com/fkye/os-spoc-answer/blob/master/01-3.md</a></p>", "created": "2016-02-24T10:25:46Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i11dx198ive25r", "children": [], "tag_good_arr": [], "id": "il0p3pi01yw551", "updated": "2016-02-24T10:25:46Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>分析和实验funcall.c:</p>\n<p>把root/usr/funcall.c第24行</p>\n<p>ret = write(1, &#34;S1_ID S2_ID&#34;,12);</p>\n<p>改为</p>\n<p>ret = write(1, &#34;2012012139 2012012139&#34;,22);</p>\n<p></p>\n<p>运行./build-funcall.sh后&#xff0c;得到文件funcall.txt即为汇编代码</p>\n<p></p>\n<p></p>\n<p>os0:</p>\n<p>在STI处设置的中断使能。</p>\n<p>系统何时处于中断屏蔽状态&#xff1f; 从开始到STI, 从进入alltrap到终端处理器中从RTI返回</p>\n<p>如果系统处于中断屏蔽状态&#xff0c;如何让其中断使能&#xff1f; ass(STI)</p>\n<p>系统产生中断后&#xff0c;CPU会做哪些事情&#xff1f;&#xff08;在没有软件帮助的情况下&#xff09; 保存pc、sp&#xff0c;跳转至中断程序入口</p>\n<p>CPU执行RTI指令的具体完成工作是哪些&#xff1f;恢复pc和sp&#xff0c;可能会从核心态切换回用户态&#xff0c;执行终断之前的程序</p>\n<p></p>", "created": "2016-02-24T10:31:32Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "ic226rac4j5jw", "children": [], "tag_good_arr": [], "id": "il0pb4y8n5450m", "updated": "2016-02-24T10:31:32Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>main()<br />{</p>\n<p>  //Change S1/S2 ID to your student ID, and change 12 to new str length<br />  //ret = write(1, &#34;S1_ID S2_ID&#34;,12);//origin code</p>\n<p>  ret = write(1, &#34;2013011351 2013011352&#34;, 22);<br />  asm(HALT);<br />}</p>\n<p>输出两个学号</p>\n<p>代码偏长&#xff0c;正在加注释。</p>\n<p>1.124MB&#xff0c;总共的内存大小为128M&#xff0c;其中4MB为FS_SZ&#xff0c;内核态堆栈</p>\n<p>2.地址为0xA8&#xff0c;从指令地址0x18的地方看到&#xff0c;对应的机器码为8c45&#xff0c;所以对应的操作为SG 0x8c&#xff0c;所以ret的地址就为 8c&#43;1c=A8</p>\n<p>3.放在内存中&#xff0c;从0x90开始里面的内容对应的字符串的符号</p>\n<p>4.0x07bfffdc</p>\n<p>5.不处于中断使能状态</p>\n<p>6.使用的是堆栈&#xff0c;在调用函数前将函数参数压入栈中&#xff0c;返回值存入变量a中</p>\n<p>7.magic数、bss、entry、flags&#xff0c;然后程序指令&#xff0c;最后是程序数据</p>", "created": "2016-02-24T10:32:09Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0ccqbaxwdz75c", "children": [], "tag_good_arr": [], "id": "il0pbx4zhhj73z", "updated": "2016-02-24T10:32:09Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>同组成员&#xff1a;钱迪晨&#xff08;2013011402&#xff09;</p>\n<p></p>\n<p>&#xff08;1&#xff09;显示学号&#xff1a;把funcall.c第24行改为</p>\n<pre>ret = write(1, &#34;2013011413 2013011402\\n&#34;, 23);</pre>\n<p>&#xff08;2&#xff09;注释后的汇编代码 <a href=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i0gl5kctugw3xi/il0t8m6blim2/funcall.txt\" target=\"_blank\">funcall.txt</a></p>\n<p>&#xff08;3&#xff09;用xem调试&#xff1a;</p>\n<pre>./xem -g funcall\n\nh:\tprint help commands.\nq:\tquit.\nc:\tcontinue.\ns:\tsingle step for one instruction.\ni:\tdisplay registers.\nx:\tdisplay memory, the input address is hex number (e.g x 10000)</pre>\n<p>&#xff08;4&#xff09;问题回答&#xff1a;<a href=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i0gl5kctugw3xi/il0tkkhekulq/简答题.txt\" target=\"_blank\">简答题.txt</a></p>\n<p></p>\n<p>os0系列问题&#xff1a;</p>\n<p>&#xff08;1&#xff09;注释后的代码&#xff1a;<a href=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i0gl5kctugw3xi/il0uby73e00v/test.txt\" target=\"_blank\">test.txt</a></p>\n<p>&#xff08;2&#xff09;问题回答&#xff1a;<a href=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i0gl5kctugw3xi/il0v3a37ghco/os0问答题.txt\" target=\"_blank\">os0问答题.txt</a></p>", "created": "2016-02-24T10:32:58Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0gl5kctugw3xi", "children": [], "tag_good_arr": [], "id": "il0pcyva8jf314", "updated": "2016-02-24T10:32:58Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>funcall.c<br />修改代码&#xff1a;</p>\n<pre>main()<br />{<br />  //Change S1/S2 ID to your student ID, and change 12 to new str length<br />  ret = write(1, &#34;2013011353 2013011353&#34;,22);<br />  asm(HALT);<br />}</pre>\n<p>1.128MB&#xff0c;内核态&#xff1b;<br />2.PC加上一个数值&#xff1b;<br />3.PC加上一个数值&#xff1b;<br />4.i在0x4处&#xff0c;SP相对寻址<br />5.不是<br />6.采用堆栈&#xff0c;调用前将函数参数入栈&#xff0c;函数中从站里面取参数&#xff0c;返回值存在变量a中&#xff1b;<br />7.格式是二进制码&#xff0c;内容是机器码&#xff0c;包括magic、bss、entry、flags、text和data。</p>", "created": "2016-02-24T10:35:13Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i2olyyl8swl1we", "children": [], "tag_good_arr": [], "id": "il0pfv1b90k1hp", "updated": "2016-02-24T10:35:13Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>一、</p>\n<p>代码修改:</p>\n<p>funcall.c的24行&#xff1a;ret = write(1, &#34;2013011345 2013011345&#34;, 22);</p>\n<p>&#xff08;1&#xff09;124MB&#xff1b;内核态。</p>\n<p>&#xff08;2&#xff09;在指令地址0x18处可以看到&#xff0c;对应的机器码为8c45&#xff0c;则相应的操作是SG 0x8c&#xff0c;所以ret的地址就为 8c&#43;1c 为A8。</p>\n<p>&#xff08;3&#xff09;放在内存地址中&#xff0c;从0x90开始&#xff0c;里面的内容对应的字符串的符号。</p>\n<p>&#xff08;4&#xff09;0x07bfffdc&#xff1b;使用的是SL命令&#xff0c;从指令地址0x20处可以看到&#xff0c;相应的机器码为0440&#xff0c;所以操作为SL 0x04&#xff0c;而i的地址就是07bfffd8&#43;04 = 07bfffdc。</p>\n<p>&#xff08;5&#xff09;不处于中断使能状态。</p>\n<p>&#xff08;6&#xff09;使用堆栈功能&#xff0c;在调用函数前将函数参数压入栈中&#xff0c;函数过程中从栈调用即可&#xff1b;返回值存入变量a中。</p>", "created": "2016-02-24T10:36:20Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0cb1385ni65l", "children": [], "tag_good_arr": [], "id": "il0phb5cx71sl", "updated": "2016-02-24T10:36:20Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>陆禹2013011320 孟凡航 2013011312</p>\n<p>funcall</p>\n<p>修改funcall.c的24行&#xff1a;ret = write(1, &#34;2013011312 2013011320&#34;, 22);</p>\n<p>1    124MB 内核态<br />2    ret置于代码区和字符串之后,用立即数寻址<br />3    字符串通过立即数寻址<br />4    0x07bfffdc 地址sp&#43;4<br />5    不处于中断态<br />6    压栈 返回值通过寄存器<br />7    格式二进制码<br />    内容机器码<br />内容先后为外部数据 程序指令 程序数据</p>\n<p>os0:</p>\n<p>回答如下问题&#xff1a;</p>\n<ul><li>何处设置的中断使能&#xff1f;</li></ul>\n<p>在asm(STI);处设置的中断使能</p>\n<ul><li>系统何时处于中断屏蔽状态&#xff1f;</li></ul>\n<p>在执行asm(STI);之前&#xff0c;以及在执行alltraps的过程中</p>\n<p> </p>\n<ul><li>如果系统处于中断屏蔽状态&#xff0c;如何让其中断使能&#xff1f;</li></ul>\n<p>在cpu下执行asm(STI);</p>\n<ul><li>系统产生中断后&#xff0c;CPU会做哪些事情&#xff1f;&#xff08;在没有软件帮助的情况下&#xff09;</li></ul>\n<p>将A,B寄存器的值压入栈中。</p>\n<ul><li>CPU执行RTI指令的具体完成工作是哪些&#xff1f;</li></ul>\n<p>return from interrupt, set pc, sp, may switch user/kernel mode; if has pending interrupt, process the interrupt</p>\n<p></p>", "created": "2016-02-24T10:49:24Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "ikvcvq38pa7l6", "children": [], "tag_good_arr": [], "id": "il0py418xod2po", "updated": "2016-02-24T10:49:24Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>输出学号&#xff1a;</p>\n<p>将funcall.c, line24改为如下内容&#xff1a;</p>\n<pre>ret = write(1, &#34;2013011336 2013011354\\n&#34;, 23);</pre>\n<p>funcall中的堆栈有多大&#xff1f;是内核态堆栈还是用户态堆栈&#xff1f;<br />128M&#xff0c;内核态堆栈 </p>\n<p>funcall中的全局变量ret放在内存中何处&#xff1f;如何对它寻址&#xff1f;</p>\n<p>在pc&#43;0的位置 </p>\n<p>funcall中的字符串放在内存中何处&#xff1f;如何对它寻址&#xff1f;</p>\n<p>0x90 </p>\n<p>局部变量i在内存中的何处&#xff1f;如何对它寻址&#xff1f;</p>\n<p>sp&#43;4 </p>\n<p>当前系统是处于中断使能状态吗&#xff1f;</p>\n<p>不是 </p>\n<p>funcall中的函数参数是如何传递的&#xff1f;函数返回值是如何传递的&#xff1f;</p>\n<p>函数调用前参数压栈&#xff0c;进入函数后从栈中读取</p>", "created": "2016-02-24T10:50:05Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i2g664y8vve6h4", "children": [], "tag_good_arr": [], "id": "il0pyzjc1l15yd", "updated": "2016-02-24T10:50:05Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>杨明2013011412&#43;谢琛睿2013011406</p>\n<p>第一题</p>\n<p>//Change S1/S2 ID to your student ID, and change 12 to new str length<br />  ret = write(1, &#34;2013011406 2013011412&#34;,22);</p>\n<p>如上改即可</p>\n<p>root/usr/funcall.c  1: #include &lt;u.h&gt;<br />root/usr/funcall.c  2: int ret;<br />root/usr/funcall.c  3: out(port, val)      <br />root/usr/funcall.c  4: {<br />root/usr/funcall.c  5:   asm(LL,8);   // load register a with port<br />00000000  0000080e  LL    0x8 (D 8)      // 取out(port, val)函数到第一个参数<br />root/usr/funcall.c  6:   asm(LBL,16); // load register b with val<br />00000004  00001026  LBL   0x10 (D 16)   // 取out(port, val)函数到第二个参数<br />root/usr/funcall.c  7:   asm(BOUT);   // output byte to console<br />00000008  0000009a  BOUT      // 输出寄存器b中内容&#xff0c;保证是内核态进行到系统调用<br />root/usr/funcall.c  8: }<br />root/usr/funcall.c  9: <br />root/usr/funcall.c  10: int write(int f, char *s, int n)<br />0000000c  00000002  LEV   0x0 (D 0)    // out(port, val)到return<br />root/usr/funcall.c  11: {<br />root/usr/funcall.c  12:   int i;<br />root/usr/funcall.c  13:   ret = 1;<br />00000010  fffff801  ENT   0xfffffff8 (D -8)   // 分配 i的内存单元<br />00000014  00000123  LI    0x1 (D 1)<br />00000018  00000045  SG    0x0 (D 0)   // 把1赋值给ret<br />root/usr/funcall.c  14:   i=n;<br />0000001c  0000200e  LL    0x20 (D 32)<br />00000020  00000440  SL    0x4 (D 4)<br />root/usr/funcall.c  15:   while (i--)<br />00000024  00000003  JMP   &lt;fwd&gt;<br />root/usr/funcall.c  16:     out(f, *s&#43;&#43;);<br />00000028  0000180e  LL    0x18 (D 24)<br />0000002c  ffffff57  SUBI  0xffffffff (D -1)<br />00000030  00001840  SL    0x18 (D 24)<br />00000034  ffffff1f  LXC   0xffffffff (D -1)<br />00000038  0000009d  PSHA   // out函数从左到右第二个参数压栈<br />0000003c  0000180e  LL    0x18 (D 24)<br />00000040  0000009d  PSHA   // out函数从左到右第一个参数压栈<br />00000044  ffffb805  JSR   0xffffffb8 (TO 0x0)   // 调用out<br />00000048  00001001  ENT   0x10 (D 16)   // 函数调用完毕&#xff0c; 退出参数到栈顶<br />root/usr/funcall.c  17:   return i;<br />0000004c  0000040e  LL    0x4 (D 4)<br />00000050  00000157  SUBI  0x1 (D 1)<br />00000054  00000440  SL    0x4 (D 4)<br />00000058  00000154  ADDI  0x1 (D 1)<br />0000005c  00000086  BNZ   &lt;fwd&gt;<br />00000060  0000040e  LL    0x4 (D 4)<br />00000064  00000802  LEV   0x8 (D 8)  // write()函数的return<br />root/usr/funcall.c  18: }  <br />root/usr/funcall.c  19: <br />root/usr/funcall.c  20: main()<br />00000068  00000802  LEV   0x8 (D 8)<br />root/usr/funcall.c  21: {<br />root/usr/funcall.c  22: <br />root/usr/funcall.c  23:   //Change S1/S2 ID to your student ID, and change 12 to new str length<br />root/usr/funcall.c  24:   ret = write(1, &#34;2013011406 2013011412&#34;,22);<br />0000006c  0000169e  PSHI  0x16 (D 22)<br />00000070  00000008  LEAG  0x0 (D 0)<br />00000074  0000009d  PSHA<br />00000078  0000019e  PSHI  0x1 (D 1)<br />0000007c  ffff9005  JSR   0xffffff90 (TO 0x10)<br />00000080  00001801  ENT   0x18 (D 24)<br />00000084  00000045  SG    0x0 (D 0)<br />root/usr/funcall.c  25:   asm(HALT);<br />00000088  00000000  HALT<br />root/usr/funcall.c  26: }<br />root/usr/funcall.c  27: <br />0000008c  00000002  LEV   0x0 (D 0)<br />1. 124M堆栈大小 内核态</p>\n<p>2. pc&#43;0的位置。使用LG与SG指令对该内存进行读写。</p>\n<p>3.</p>\n<p>4.存在栈中sp&#43;4的位置。使用SL与LL访问该内存。</p>\n<p>5.不是。</p>\n<p>6.参数从右到左依次压栈。返回值存在a寄存器中。</p>\n<p>7.</p>\n<p></p>\n<p></p>\n<p>第二题</p>\n<p>root/usr/os/os0.c  1: // os0.c -- simple timer isr test<br />root/usr/os/os0.c  2: <br />root/usr/os/os0.c  3: #include &lt;u.h&gt;<br />root/usr/os/os0.c  4: <br />root/usr/os/os0.c  5: int current;<br />root/usr/os/os0.c  6: <br />root/usr/os/os0.c  7: out(port, val)  { asm(LL,8); asm(LBL,16); asm(BOUT); }<br />00000000  0000080e  LL    0x8 (D 8)<br />00000004  00001026  LBL   0x10 (D 16)<br />00000008  0000009a  BOUT<br />root/usr/os/os0.c  8: ivec(void *isr) { asm(LL,8); asm(IVEC); }<br />0000000c  00000002  LEV   0x0 (D 0)<br />00000010  0000080e  LL    0x8 (D 8)<br />00000014  000000a4  IVEC   // <br />root/usr/os/os0.c  9: stmr(int val)   { asm(LL,8); asm(TIME); }<br />00000018  00000002  LEV   0x0 (D 0)<br />0000001c  0000080e  LL    0x8 (D 8)<br />00000020  000000a7  TIME<br />root/usr/os/os0.c  10: halt(val)       { asm(LL,8); asm(HALT); }<br />00000024  00000002  LEV   0x0 (D 0)<br />00000028  0000080e  LL    0x8 (D 8)<br />0000002c  00000000  HALT<br />root/usr/os/os0.c  11: <br />root/usr/os/os0.c  12: alltraps()<br />00000030  00000002  LEV   0x0 (D 0)<br />root/usr/os/os0.c  13: {<br />root/usr/os/os0.c  14:   asm(PSHA);<br />00000034  0000009d  PSHA<br />root/usr/os/os0.c  15:   asm(PSHB);<br />00000038  000000a0  PSHB<br />root/usr/os/os0.c  16: <br />root/usr/os/os0.c  17:   current&#43;&#43;;<br />0000003c  00000015  LG    0x0 (D 0)<br />00000040  ffffff57  SUBI  0xffffffff (D -1)<br />00000044  00000045  SG    0x0 (D 0)<br />root/usr/os/os0.c  18: <br />root/usr/os/os0.c  19:   asm(POPB);<br />00000048  000000a1  POPB<br />root/usr/os/os0.c  20:   asm(POPA);<br />0000004c  000000a3  POPA<br />root/usr/os/os0.c  21:   asm(RTI);<br />00000050  00000098  RTI <br />root/usr/os/os0.c  22: }<br />root/usr/os/os0.c  23: <br />root/usr/os/os0.c  24: main()<br />00000054  00000002  LEV   0x0 (D 0)<br />root/usr/os/os0.c  25: {<br />root/usr/os/os0.c  26:   current = 0;<br />00000058  00000023  LI    0x0 (D 0)<br />0000005c  00000045  SG    0x0 (D 0)<br />root/usr/os/os0.c  27: <br />root/usr/os/os0.c  28:   stmr(1000);<br />00000060  0003e89e  PSHI  0x3e8 (D 1000)<br />00000064  ffffb405  JSR   0xffffffb4 (TO 0x1c)<br />00000068  00000801  ENT   0x8 (D 8)<br />root/usr/os/os0.c  29:   ivec(alltraps);<br />0000006c  ffffc408  LEAG  0xffffffc4 (D -60)<br />00000070  0000009d  PSHA<br />00000074  ffff9805  JSR   0xffffff98 (TO 0x10)<br />00000078  00000801  ENT   0x8 (D 8)<br />root/usr/os/os0.c  30:   <br />root/usr/os/os0.c  31:   asm(STI);<br />0000007c  00000097  STI <br />root/usr/os/os0.c  32:   <br />root/usr/os/os0.c  33:   while (current &lt; 10) {<br />00000080  00000003  JMP   &lt;fwd&gt;<br />root/usr/os/os0.c  34:     if (current &amp; 1) out(1, &#39;1&#39;); else out(1, &#39;0&#39;);<br />00000084  00000015  LG    0x0 (D 0)<br />00000088  00000169  ANDI  0x1 (D 1)<br />0000008c  00000084  BZ    &lt;fwd&gt;<br />00000090  0000319e  PSHI  0x31 (D 49)<br />00000094  0000019e  PSHI  0x1 (D 1)<br />00000098  ffff6405  JSR   0xffffff64 (TO 0x0)<br />0000009c  00001001  ENT   0x10 (D 16)<br />000000a0  00000003  JMP   &lt;fwd&gt;<br />000000a4  0000309e  PSHI  0x30 (D 48)<br />000000a8  0000019e  PSHI  0x1 (D 1)<br />000000ac  ffff5005  JSR   0xffffff50 (TO 0x0)<br />000000b0  00001001  ENT   0x10 (D 16)<br />root/usr/os/os0.c  35:   }<br />root/usr/os/os0.c  36: <br />root/usr/os/os0.c  37:   halt(0);<br />000000b4  00000015  LG    0x0 (D 0)<br />000000b8  00000a3b  LBI   0xa (D 10)<br />000000bc  0000008c  BLT   &lt;fwd&gt;<br />000000c0  0000009e  PSHI  0x0 (D 0)<br />000000c4  ffff6005  JSR   0xffffff60 (TO 0x28)<br />000000c8  00000801  ENT   0x8 (D 8)<br />root/usr/os/os0.c  38: }<br />root/usr/os/os0.c  39: <br />000000cc  00000002  LEV   0x0 (D 0)<br /><br /></p>\n<p></p>", "created": "2016-02-24T10:53:52Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0brpl1lbyui6", "children": [], "tag_good_arr": [], "id": "il0q3uvjtpa4ax", "updated": "2016-02-24T10:53:52Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>修改root/usr/funcall.c 24行为</p>\n<pre>ret = write(1, &#34;2012011302 2012011321&#34;, 22);</pre>\n<p></p>", "created": "2016-02-24T11:04:44Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i701mss708y", "children": [], "tag_good_arr": [], "id": "il0qhtjk7h73jc", "updated": "2016-02-24T11:04:44Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>姚炫容 龚拓宇</p>\n<p></p>\n<p><a href=\"https://github.com/suanrong/os/blob/master/ex1.md\" target=\"_blank\">funcall</a></p>\n<p><a href=\"https://github.com/suanrong/os/blob/master/ex2.md\" target=\"_blank\">os0</a></p>\n<p></p>\n<p>os1/3</p>\n<ul><li><strong>os1中的task1和task2的堆栈的起始和终止地址是什么&#xff1f;</strong>task0是使用正常的堆栈&#xff0c;task1堆栈是 &amp;task1_stack &#43; 50 ~ &amp;task1_stack</li><li><strong>os1是如何实现任务切换的&#xff1f;</strong>从task0切换到task1时&#xff0c;先将寄存器保存到栈上&#xff0c;然后将当前&#xff08;task0&#xff09;的sp保存到变量task0_sp中&#xff0c;然后从变量task1_sp中读出task1的栈顶&#xff0c;将其赋值给sp&#xff0c;然后读各寄存器的值&#xff0c;反之亦然。</li></ul>", "created": "2016-02-24T11:04:46Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0c9nvk0xzc2n3", "children": [], "tag_good_arr": [], "id": "il0qhv47xjy396", "updated": "2016-02-24T11:04:46Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>朱俸民 2012011894   朱新瑞 2013011411</p>\n<p></p>\n<p>fungal的答案见<a href=\"https://github.com/Naiselim/os_2016/blob/master/funcall答案.txt\" target=\"_blank\">https://github.com/Naiselim/os_2016/blob/master/funcall答案.txt</a>。</p>\n<p></p>\n<p>os0的汇编代码见<a href=\"https://github.com/paulzfm/v9-cpu-spoc/blob/master/os0.s\">https://github.com/paulzfm/v9-cpu-spoc/blob/master/os0.s</a>。</p>\n<ul><li><strong>何处设置的中断使能&#xff1f;</strong>STI (set trap, and process the interrupt)</li><li><strong>系统何时处于中断屏蔽状态&#xff1f;</strong>STI之前&#xff0c;以及进入alltrap到从中退出的过程中</li><li><strong>如果系统处于中断屏蔽状态&#xff0c;如何让其中断使能&#xff1f;</strong>还是STI</li><li><strong>系统产生中断后&#xff0c;CPU会做哪些事情&#xff1f;&#xff08;在没有软件帮助的情况下&#xff09;</strong>保护现场&#xff08;暂存pc、sp&#xff09;&#xff0c;跳转至中断程序入口</li><li><strong>CPU执行RTI指令的具体完成工作是哪些&#xff1f;</strong>恢复pc、sp&#xff0c;可能会从核心态切换回用户态&#xff08;若当前执行的是中断程序&#xff09;&#xff0c;可能会执行挂起的中断&#xff08;如果有&#xff09;</li></ul>\n<p></p>\n<p>os1/3</p>\n<ul><li><strong>os1中的task1和task2的堆栈的起始和终止地址是什么&#xff1f;</strong>&amp;task1_stack &#43; 38 ~ &amp;task1_stack &#43; 50</li><li><strong>os1是如何实现任务切换的&#xff1f;</strong>从task0切换到task1时&#xff0c;先将当前&#xff08;task0&#xff09;的sp保存到变量task0_sp中&#xff0c;然后从变量task1_sp中读出task1的栈顶&#xff0c;将其赋值给sp&#xff0c;反之亦然。</li><li><strong>os3中的task1和task2的堆栈的起始和终止地址是什么&#xff1f;</strong>&amp;task0_kstack &#43; 986 ~ &amp;task0_kstack &#43; 1000&#xff0c;&amp;task1_kstack &#43; 986 ~ &amp;task1_kstack &#43; 1000</li><li><strong>os3是如何实现任务切换的&#xff1f;</strong>与os1类似。</li></ul>", "created": "2016-02-24T11:13:51Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0c1nsm3911wc", "children": [], "tag_good_arr": [], "id": "il0qtjt697u63f", "updated": "2016-02-24T11:13:51Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<p>只有一个人T^T……修改/root/usr/funcall.c Line 24 为</p>\n<pre>  ret = write(1, &#34;2013011720&#34;,10);</pre>\n<p>root/usr/funcall.c 2: int ret;<br />root/usr/funcall.c 3: out(port, val)<br />root/usr/funcall.c 4: {<br />root/usr/funcall.c 5: asm(LL,8); //寄存器A中写入port<br />00000000 0000080e LL 0x8 (D 8)<br />root/usr/funcall.c 6: asm(LBL,16); //寄存器B中写入val<br />00000004 00001026 LBL 0x10 (D 16)<br />root/usr/funcall.c 7: asm(BOUT); //输出字符<br />00000008 0000009a BOUT<br />root/usr/funcall.c 8: }<br />root/usr/funcall.c 9: <br />root/usr/funcall.c 10: int write(int f, char *s, int n)<br />0000000c 00000002 LEV 0x0 (D 0)<br />root/usr/funcall.c 11: {<br />root/usr/funcall.c 12: int i;<br />root/usr/funcall.c 13: ret = 1;<br />00000010 fffff801 ENT 0xfffffff8 (D -8) <br />00000014 00000123 LI 0x1 (D 1)<br />00000018 00000045 SG 0x0 (D 0)<br />root/usr/funcall.c 14: i=n;<br />0000001c 0000200e LL 0x20 (D 32)<br />00000020 00000440 SL 0x4 (D 4)<br />root/usr/funcall.c 15: while (i--)<br />00000024 00000003 JMP &lt;fwd&gt;<br />root/usr/funcall.c 16: out(f, *s&#43;&#43;);<br />00000028 0000180e LL 0x18 (D 24)<br />0000002c ffffff57 SUBI 0xffffffff (D -1)<br />00000030 00001840 SL 0x18 (D 24)<br />00000034 ffffff1f LXC 0xffffffff (D -1)<br />00000038 0000009d PSHA //略有困惑&#xff0c;但功能是s的自增和out函数的第二个参数入栈<br />0000003c 0000180e LL 0x18 (D 24)<br />00000040 0000009d PSHA //从栈中读取out函数的第一个参数&#xff0c;并再次入栈<br />00000044 ffffb805 JSR 0xffffffb8 (TO 0x0) //调用out函数<br />00000048 00001001 ENT 0x10 (D 16) //恢复栈帧<br />root/usr/funcall.c 17: return i;<br />0000004c 0000040e LL 0x4 (D 4)<br />00000050 00000157 SUBI 0x1 (D 1)<br />00000054 00000440 SL 0x4 (D 4)<br />00000058 00000154 ADDI 0x1 (D 1)<br />0000005c 00000086 BNZ &lt;fwd&gt;<br />00000060 0000040e LL 0x4 (D 4)<br />00000064 00000802 LEV 0x8 (D 8) //有所困惑&#xff0c;功能应该是返回<br />root/usr/funcall.c 18: }<br />root/usr/funcall.c 19: <br />root/usr/funcall.c 20: main()<br />00000068 00000802 LEV 0x8 (D 8)<br />root/usr/funcall.c 21: {<br />root/usr/funcall.c 22: <br />root/usr/funcall.c 23: //Change S1/S2 ID to your student ID, and change 12 to new str length<br />root/usr/funcall.c 24: ret = write(1, &#34;2013011720&#34;,10);<br />0000006c 00000a9e PSHI 0xa (D 10) //第三个参数入栈<br />00000070 00000008 LEAG 0x0 (D 0)<br />00000074 0000009d PSHA //以上两行略有困惑&#xff0c;但可以推测出是第二个参数入栈<br />00000078 0000019e PSHI 0x1 (D 1) //第一个参数入栈<br />0000007c ffff9005 JSR 0xffffff90 (TO 0x10) //调用write函数<br />00000080 00001801 ENT 0x18 (D 24) //恢复栈帧<br />00000084 00000045 SG 0x0 (D 0) //Store Global A&#xff0c;推测与函数返回值有关&#xff1f;<br />root/usr/funcall.c 25: asm(HALT);<br />00000088 00000000 HALT //终止程序<br />root/usr/funcall.c 26: }<br />root/usr/funcall.c 27: <br />0000008c 00000002 LEV 0x0 (D 0)</p>\n<p></p>\n<p>问答题如下&#xff1a;</p>\n<p>1. 堆栈是内核态堆栈&#xff0c;内存总大小为128M&#xff0c;有一个FS_SIZE是4M&#xff0c;cpu初始化时xsp=sp=124M的&#xff0c;而push的时候xsp是-=8的&#xff0c;再参考之前同学的回答&#xff0c;我倾向于认为是124MB……</p>\n<p>2. ret放在内存中指令部分的后面。我觉得虽然SG的代码里面用了xpc和tpc&#xff0c;但我觉得说那是PC相对寻址太牵强了</p>\n<p>3. 字符串也放在内存中指令部分的后面</p>\n<p>4. 局部变量位于栈中</p>\n<p>5. 系统中断没有开启</p>\n<p>6. 通过栈传递参数&#xff0c;通过A寄存器传递返回值</p>", "created": "2016-02-24T11:16:43Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0nan8i4g0o3s3", "children": [], "tag_good_arr": [], "id": "il0qx8upyoe6yf", "updated": "2016-02-24T11:16:43Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>/root/user/funcall.c  24行</p>\n<p> ret = write(1, &#34;2013011328 2013011340&#34;,22);</p>\n<p></p>\n<p>funcall<br />1.128MB-4MB-代码长度-数据区大小;内核态。<br />2.字符串后&#xff0c;用xpc-tpc&#43;&#xff08;ir&gt;&gt;8&#xff09;寻址。<br />3.代码后&#xff0c;用xpc-tpc&#43;&#xff08;ir&gt;&gt;8&#xff09;寻址。<br />4.local_addr&#43;4处&#xff0c;用*&#xff08;sp &#43; 4&#xff09;寻址。<br />5.不在。<br />6.从右向左依次压栈。返回值装入a寄存器。<br />7.分为四部分&#xff1a;magic/bss/entry/flags。</p>\n<p></p>\n<p>2013011328 张殿炎</p>", "created": "2016-02-24T11:20:51Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i28skba6cd976f", "children": [], "tag_good_arr": [], "id": "il0r2jtuljp7r", "updated": "2016-02-24T11:20:51Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>回答见<a href=\"https://github.com/nyunyunyunyu/v9-cpu\" target=\"_blank\">这个仓库</a>的ans.md文件</p>", "created": "2016-02-24T11:25:58Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0jauby0gkg76x", "children": [], "tag_good_arr": [], "id": "il0r950sjpy1rv", "updated": "2016-02-24T11:25:58Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p> 成员 刘晓鸿 2013010949 杨晓成 2013011383</p>\n<p></p>\n<p>一&#xff0c;分析和实验funcall.c</p>\n<p>1. 修改代码&#xff0c;可正常显示小组两位同学的学号&#xff08;用字符串&#xff09;</p>\n<p>https://github.com/Yangxc13/v9-cpu/blob/master/01-3-lab0-spoc-discussion/funcall.c</p>\n<p>2. 生成funcall.c的汇编码&#xff0c;理解其实现并给汇编码写注释</p>\n<p>https://github.com/Yangxc13/v9-cpu/blob/master/01-3-lab0-spoc-discussion/funcall.s</p>\n<p>3. 回答如下问题</p>\n<p><a href=\"https://github.com/Yangxc13/v9-cpu/blob/master/01-3-lab0-spoc-discussion/funcall_questions.txt\">https://github.com/Yangxc13/v9-cpu/blob/master/01-3-lab0-spoc-discussion/funcall_questions.txt</a></p>\n<p></p>\n<p>二&#xff0c;分析和实验os0.c</p>\n<p>1. 生成os0.c的汇编码&#xff0c;理解其实现并给汇编码写注释</p>\n<p><a href=\"https://github.com/Yangxc13/v9-cpu/blob/master/01-3-lab0-spoc-discussion/os0.s\">https://github.com/Yangxc13/v9-cpu/blob/master/01-3-lab0-spoc-discussion/os0.s</a></p>\n<p>2. 回答如下问题</p>\n<p><a href=\"https://github.com/Yangxc13/v9-cpu/blob/master/01-3-lab0-spoc-discussion/os0_questions.txt\">https://github.com/Yangxc13/v9-cpu/blob/master/01-3-lab0-spoc-discussion/os0_questions.txt</a></p>\n<p></p>\n<p>三&#xff0c;分析和实验os1/os3.c</p>\n<p>https://github.com/Yangxc13/v9-cpu/blob/master/01-3-lab0-spoc-discussion/os1os3_questions.txt</p>", "created": "2016-02-24T11:32:29Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0b7d04pl3y6c0", "children": [], "tag_good_arr": [], "id": "il0rhiohneqjz", "updated": "2016-02-24T11:32:29Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p> 一</p>\n<p>1.</p>\n<p>  //Change S1/S2 ID to your student ID, and change 12 to new str length<br />  ret = write(1, &#34;2013011354 2013011336&#34;, 22);</p>\n<p>2.</p>\n<p>root/usr/funcall.c  5:   asm(LL,8);   // load register a with port<br />00000000  0000080e  LL    0x8 (D 8)   // a = port<br />root/usr/funcall.c  6:   asm(LBL,16); // load register b with val<br />00000004  00001026  LBL   0x10 (D 16) // b = val<br />root/usr/funcall.c  7:   asm(BOUT);   // output byte to console<br />00000008  0000009a  BOUT<br />root/usr/funcall.c  8: }<br />root/usr/funcall.c  9: <br />root/usr/funcall.c  10: int write(int f, char *s, int n)<br />0000000c  00000002  LEV   0x0 (D 0)    // pc = *sp, sp = sp &#43; 8<br />root/usr/funcall.c  11: {<br />root/usr/funcall.c  12:   int i;<br />root/usr/funcall.c  13:   ret = 1;<br />00000010  fffff801  ENT   0xfffffff8 (D -8) //sp = sp - 8<br />00000014  00000123  LI    0x1 (D 1)  // a = 1<br />00000018  00000045  SG    0x0 (D 0)  //*pc = a  global_ret = a<br />root/usr/funcall.c  14:   i=n;<br />0000001c  0000200e  LL    0x20 (D 32)// a = n<br />00000020  00000440  SL    0x4 (D 4)  // i = a<br />root/usr/funcall.c  15:   while (i--)<br />00000024  00000003  JMP   &lt;fwd&gt;<br />root/usr/funcall.c  16:     out(f, *s&#43;&#43;); <br />00000028  0000180e  LL    0x18 (D 24) // a = s<br />0000002c  ffffff57  SUBI  0xffffffff (D -1) // a&#43;&#43;<br />00000030  00001840  SL    0x18 (D 24) // *(sp &#43; 24) = a<br />00000034  ffffff1f  LXC   0xffffffff (D -1) // a = *(a-1)<br />00000038  0000009d  PSHA              // sp = sp - 8, *sp = a a压栈<br />0000003c  0000180e  LL    0x18 (D 24) // a = *(sp &#43; 24)<br />00000040  0000009d  PSHA              // sp = sp - 8, *sp = a a压栈<br />00000044  ffffb805  JSR   0xffffffb8 (TO 0x0) // 调用out函数 sp = sp - 8, *sp = pc<br />00000048  00001001  ENT   0x10 (D 16) // sp = sp &#43; 16; 取消退栈操作<br />root/usr/funcall.c  17:   return i;<br />0000004c  0000040e  LL    0x4 (D 4)   // a = *(sp &#43; 4)<br />00000050  00000157  SUBI  0x1 (D 1)   // a--<br />00000054  00000440  SL    0x4 (D 4)   // i = a<br />00000058  00000154  ADDI  0x1 (D 1)   // a&#43;&#43;<br />0000005c  00000086  BNZ   &lt;fwd&gt;       // if a == 0<br />00000060  0000040e  LL    0x4 (D 4)   // a = *(sp &#43; 4)<br />00000064  00000802  LEV   0x8 (D 8)   // pc = *(sp &#43; 8), sp = sp &#43; 16<br />root/usr/funcall.c  18: }  <br />root/usr/funcall.c  19: <br />root/usr/funcall.c  20: main()<br />00000068  00000802  LEV   0x8 (D 8)  <br />root/usr/funcall.c  21: {<br />root/usr/funcall.c  22:   <br />root/usr/funcall.c  23:   //Change S1/S2 ID to your student ID, and change 12 to new str length<br />root/usr/funcall.c  24:   ret = write(1, &#34;2013011354 2013011336&#34;,22);<br />0000006c  0000169e  PSHI  0x16 (D 22)  // sp = sp -8, *sp = 22 22压栈<br />00000070  00000008  LEAG  0x0 (D 0)    // a = pc<br />00000074  0000009d  PSHA               // sp = sp -8, *sp = a a压栈<br />00000078  0000019e  PSHI  0x1 (D 1)    // sp = sp -8, *sp = 1 1压栈<br />0000007c  ffff9005  JSR   0xffffff90 (TO 0x10) // 调用write函数<br />00000080  00001801  ENT   0x18 (D 24)  // sp = sp &#43; 24<br />00000084  00000045  SG    0x0 (D 0)    // ret = a <br />root/usr/funcall.c  25:   asm(HALT);<br />00000088  00000000  HALT<br />root/usr/funcall.c  26: }<br />root/usr/funcall.c  27: <br />0000008c  00000002  LEV   0x0 (D 0)</p>\n<p> </p>", "created": "2016-02-24T11:43:00Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0em4o8wvj34lb", "children": [], "tag_good_arr": [], "id": "il0rv1pejqw748", "updated": "2016-02-24T11:43:00Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>更改funcall.c</p>\n<p>ret = write(1, &#34;2013011302&#34;,10);</p>\n<p>按题目要求输出两个学号的话就 ret = write(1, &#34;2013011302 2013011302&#34;,21);</p>\n<p>堆栈是内核态堆栈&#xff0c;大小128M。</p>\n<p>全局变量ret放在字符串后。寻址操作为SG。</p>\n<p>字符串放在内存中。</p>\n<p>局部变量放在栈中。</p>\n<p>当前系统不处于中断状态。</p>\n<p>传递参数是通过栈&#xff0c;返回值储存在寄存器a中。</p>\n<p>系统函数指针&#43;本地函数内容&#43;全局变量、字符串。</p>", "created": "2016-02-24T11:46:20Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "ikvcvo2cckb7jb", "children": [], "tag_good_arr": [], "id": "il0rzbzqftw5zf", "updated": "2016-02-24T11:46:20Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>main()</p>\n<p>{</p>\n<p>  //Change S1/S2 ID to your student ID, and change 12 to new str length</p>\n<p>  ret = write(1, &#34;2015012843 2015012844&#34;,22);</p>\n<p>  asm(HALT);</p>\n<p>}</p>\n<p></p>\n<p>汇编&#xff1a;</p>\n<p>root/lib/u.h  35: typedef unsigned char uchar;</p>\n<p>root/lib/u.h  36: typedef unsigned short ushort;</p>\n<p>root/lib/u.h  37: typedef unsigned int uint;</p>\n<p>root/lib/u.h  38: </p>\n<p>root/usr/funcall.c  2: int ret;</p>\n<p>root/usr/funcall.c  3: out(port, val)</p>\n<p>root/usr/funcall.c  4: {</p>\n<p>root/usr/funcall.c  5:   asm(LL,8);   // load register a with port</p>\n<p>00000000  0000080e  LL    0x8 (D 8)</p>\n<p>root/usr/funcall.c  6:   asm(LBL,16); // load register b with val</p>\n<p>00000004  00001026  LBL   0x10 (D 16)</p>\n<p>root/usr/funcall.c  7:   asm(BOUT);   // output byte to console</p>\n<p>00000008  0000009a  BOUT</p>\n<p>root/usr/funcall.c  8: }</p>\n<p>root/usr/funcall.c  9: </p>\n<p>root/usr/funcall.c  10: int write(int f, char *s, int n)</p>\n<p>0000000c  00000002  LEV   0x0 (D 0) //程序计数器存放栈顶指针所存地址&#xff0c;修改栈顶指针</p>\n<p>root/usr/funcall.c  11: {</p>\n<p>root/usr/funcall.c  12:   int i;</p>\n<p>root/usr/funcall.c  13:   ret = 1;</p>\n<p>00000010  fffff801  ENT   0xfffffff8 (D -8) //00000010存放i</p>\n<p>00000014  00000123  LI    0x1 (D 1) //a=1</p>\n<p>00000018  00000045  SG    0x0 (D 0) //ret=a</p>\n<p>root/usr/funcall.c  14:   i=n;</p>\n<p>0000001c  0000200e  LL    0x20 (D 32) //a=n</p>\n<p>00000020  00000440  SL    0x4 (D 4) //i=a</p>\n<p>root/usr/funcall.c  15:   while (i--)</p>\n<p>00000024  00000003  JMP   &lt;fwd&gt;</p>\n<p>root/usr/funcall.c  16:     out(f, *s&#43;&#43;);</p>\n<p>00000028  0000180e  LL    0x18 (D 24)</p>\n<p>0000002c  ffffff57  SUBI  0xffffffff (D -1)</p>\n<p>00000030  00001840  SL    0x18 (D 24)</p>\n<p>00000034  ffffff1f  LXC   0xffffffff (D -1)</p>\n<p>00000038  0000009d  PSHA //第二个参数s入栈</p>\n<p>0000003c  0000180e  LL    0x18 (D 24)//寄存器a存放f值</p>\n<p>00000040  0000009d  PSHA //第一个参数f入栈</p>\n<p>00000044  ffffb805  JSR   0xffffffb8 (TO 0x0)//跳转至0x0&#xff0c;调用out函数</p>\n<p>00000048  00001001  ENT   0x10 (D 16)//栈顶指针归位</p>\n<p>root/usr/funcall.c  17:   return i;</p>\n<p>0000004c  0000040e  LL    0x4 (D 4)</p>\n<p>00000050  00000157  SUBI  0x1 (D 1)</p>\n<p>00000054  00000440  SL    0x4 (D 4)</p>\n<p>00000058  00000154  ADDI  0x1 (D 1)</p>\n<p>0000005c  00000086  BNZ   &lt;fwd&gt;</p>\n<p>00000060  0000040e  LL    0x4 (D 4)</p>\n<p>00000064  00000802  LEV   0x8 (D 8) //函数返回</p>\n<p>root/usr/funcall.c  18: }  </p>\n<p>root/usr/funcall.c  19: </p>\n<p>root/usr/funcall.c  20: main()</p>\n<p>00000068  00000802  LEV   0x8 (D 8)////程序计数器存放栈顶指针所存地址&#xff0c;修改栈顶指针</p>\n<p>root/usr/funcall.c  21: {</p>\n<p>root/usr/funcall.c  22: </p>\n<p>root/usr/funcall.c  23:   //Change S1/S2 ID to your student ID, and change 12 to new str length</p>\n<p>root/usr/funcall.c  24:   ret = write(1, &#34;2015012843 2015012844&#34;,22);</p>\n<p>0000006c  0000179e  PSHI  0x17 (D 22) //首先将str length(立即数23)压入栈中</p>\n<p>00000070  00000008  LEAG  0x0 (D 0)//指向寄存器a</p>\n<p>00000074  0000009d  PSHA //a存放内容入栈&#xff0c;即第二个参数s入栈</p>\n<p>00000078  0000019e  PSHI  0x1 (D 1) //最后将第一个参数&#xff08;立即数1&#xff09;压入战中</p>\n<p>0000007c  ffff9005  JSR   0xffffff90 (TO 0x10) //函数调用:write</p>\n<p>00000080  00001801  ENT   0x18 (D 24)//栈顶指针归位</p>\n<p>00000084  00000045  SG    0x0 (D 0)</p>\n<p>root/usr/funcall.c  25:   asm(HALT);</p>\n<p>00000088  00000000  HALT</p>\n<p>root/usr/funcall.c  26: }</p>\n<p>root/usr/funcall.c  27: </p>\n<p>0000008c  00000002  LEV   0x0 (D 0)</p>\n<p> </p>", "created": "2016-02-24T11:47:49Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "ig297cbwqr11ej", "children": [], "tag_good_arr": [], "id": "il0s18iwd3313p", "updated": "2016-02-24T11:47:49Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<p>高越 2012011379  王智默 2012011355</p>\n<p></p>\n<p><a href=\"https://github.com/marcusgao94/v9-cpu/blob/master/root/usr/funcall.c\" target=\"_blank\">修改代码&#xff0c;可正常显示小组两位同学的学号</a></p>\n<p></p>\n<p><a href=\"https://github.com/marcusgao94/v9-cpu/blob/master/hw/2/funcall.s\" target=\"_blank\">生成funcall.c的汇编码&#xff0c;理解其实现并给汇编码写注释</a></p>\n<p>执行build_funcall.sh即可&#xff0c;生成的汇编代码在funcall.txt中</p>\n<p></p>\n<p>funcall中的堆栈有多大&#xff1f;是内核态堆栈还是用户态堆栈<br />大小为128M&#xff0c;为内核态堆栈</p>\n<p></p>\n<p>funcall中的全局变量ret放在内存中何处&#xff1f;如何对它寻址&#xff1f;</p>\n<p>ret放在pc&#43;0的位置</p>\n<p></p>\n<p>funcall中的字符串放在内存中何处&#xff1f;如何对它寻址&#xff1f;</p>\n<p>0x90</p>\n<p></p>\n<p>局部变量i在内存中的何处&#xff1f;如何对它寻址&#xff1f;</p>\n<p>sp &#43; 4</p>\n<p></p>\n<p>当前系统是处于中断使能状态吗&#xff1f;</p>\n<p>不是</p>\n<p></p>\n<p>funcall中的函数参数是如何传递的&#xff1f;函数返回值是如何传递的&#xff1f;</p>\n<p>函数调用前参数压栈&#xff0c;进入函数后从栈中读取</p>\n<p></p>", "created": "2016-02-24T11:52:01Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i6uuj5n1v5y2t6", "children": [], "tag_good_arr": [], "id": "il0s6mg7qzh6h", "updated": "2016-02-24T11:52:01Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>修改代码&#xff1a;</p>\n<pre>main()\n{\n  write(1, &#34;2013011303 2013012213\\n&#34;, 22);\n  asm(HALT);\n}<br /></pre>\n<p>问答题&#xff1a;<a href=\"https://github.com/suoyita/os_course_spoc_exercises/blob/master/all/01-3-lab0-spoc-discussion.md\">https://github.com/suoyita/os_course_spoc_exercises/blob/master/all/01-3-lab0-spoc-discussion.md</a></p>\n<p></p>\n<p>程凯 2013011303</p>\n<p>张明钊 2013012213</p>", "created": "2016-02-24T11:53:53Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i1569mw0xp954u", "children": [], "tag_good_arr": [], "id": "il0s918b9r3gt", "updated": "2016-02-24T11:53:53Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>funcall.c相关练习&#xff1a;</p>\n<ul><li>修改代码&#xff0c;可正常显示小组两位同学的学号&#xff08;用字符串&#xff09;&#xff1a;没有听说要分小组&#xff0c;所以不知道该正常显示什么。但只需将funcall.c第24行的字符串参数修改成想要输出的内容&#xff0c;再将其后的参数修改为字符串长度&#xff08;考虑进\\0&#xff09;即可。</li><li>生成funcall.c的汇编码&#xff0c;理解其实现并给汇编码写注释&#xff1a;生成汇编码的方法已在build-funcall.sh当中有&#xff0c;即./xc -s。</li><li>\n<ul><li>funcall中的全局变量ret放在内存中何处&#xff1f;如何对它寻址&#xff1f; </li><li>    用SG, LG进行读写&#xff0c;偏移量为0</li><li>局部变量i在内存中的何处&#xff1f;如何对它寻址&#xff1f;</li><li>    sp &#43; 4的位置</li><li>funcall中的函数参数是如何传递的&#xff1f;函数返回值是如何传递的&#xff1f;</li><li>    通过栈</li></ul>\n</li></ul>\n<p></p>\n<p>os0.txt相关练习&#xff1a;</p>\n<ul><li>何处设置的中断使能&#xff1f;   asm(STI)</li><li>系统何时处于中断屏蔽状态&#xff1f;  运行asm(STI)前&#xff0c;在ivec&#xff08;即alltraps&#xff09;当中应该也是。</li><li>如果系统处于中断屏蔽状态&#xff0c;如何让其中断使能&#xff1f;  asm(STI)&#xff0c;如果完成了一个中断处理则acm(RTI)</li><li>系统产生中断后&#xff0c;CPU会做哪些事情&#xff1f;&#xff08;在没有软件帮助的情况下&#xff09;  保存当前执行状态并跳转至通过asm(IVEC)设置的中断处理函数</li></ul>", "created": "2016-02-24T11:54:35Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "ierwkwbinsj2t8", "children": [], "tag_good_arr": [], "id": "il0s9xc7zfu7x", "updated": "2016-02-24T11:54:35Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<p>将funcall.c line 24改为</p>\n<pre>ret = write(1, &#34;2012010548 2012010548&#34;,22);</pre>\n<p>build-funcall.sh脚本运行过后&#xff0c;得到的funcall.txt中就是汇编代码&#xff0c;这个可以由</p>\n<pre>./xc -s -Iroot/lib root/usr/funcall.c &gt;funcall.txt</pre>\n<p>推断出来。</p>\n<p></p>\n<p>funcall中的堆栈大小为128M&#xff0c;内核态</p>\n<p>ret在0xA6&#xff0c;可以立即数寻址</p>\n<p>字符串位于0x90&#xff0c;立即数寻址</p>\n<p>i在栈中&#xff0c;SP&#43;4</p>\n<p>函数参数第一个通过堆栈传递的&#xff0c;之后的参数通过内存地址传递的&#xff0c;函数返回值通过寄存器传递</p>", "created": "2016-02-24T11:56:35Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0minzvpea57bu", "children": [], "tag_good_arr": [], "id": "il0sci4nj4m3e7", "updated": "2016-02-24T11:56:35Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>// root/usr/funcall.c line 24:<br />ret = write(1, &#34;2013010617 2012012231&#34;, 22);</p>", "created": "2016-02-24T11:56:55Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i1oqryfapik22", "children": [], "tag_good_arr": [], "id": "il0scxdledxm", "updated": "2016-02-24T11:56:55Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p> /root/user/funcall.c</p>\n<p>第24行&#xff1a;</p>\n<p> ret = write(1, &#34;2013011328 2013011340&#34;,12);</p>\n<p>反编译的结果存在funccall.txt中</p>\n<p>1.堆栈大小128M&#xff0c;为内核态</p>\n<p>6.参数为自右向左压栈&#xff0c;函数返回值在寄存器a</p>\n<p></p>", "created": "2016-02-24T11:57:18Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0i7rzz9iau2gd", "children": [], "tag_good_arr": [], "id": "il0sdf2q5n212v", "updated": "2016-02-24T11:57:18Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>王豪2012010981 杨青霖2013011297</p>\n<p>注释&#xff1a;<a href=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i18riqkwrl225m/il0sfz4bjsec/funcall_asm.txt\" target=\"_blank\">funcall_asm.txt</a></p>\n<p><a href=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i18riqkwrl225m/il0ts87e42ta/os0_asm.txt\" target=\"_blank\">os0_asm.txt</a></p>\n<p>问答题&#xff1a;<a href=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i18riqkwrl225m/il0u92xoivd4/v9.pdf\" target=\"_blank\">v9.pdf</a></p>\n<p></p>", "created": "2016-02-24T11:58:51Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i18riqkwrl225m", "children": [], "tag_good_arr": [], "id": "il0sffgdh331jd", "updated": "2016-02-24T11:58:51Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>", "created": "2016-02-24T12:03:59Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i18riqkwrl225m", "children": [], "tag_good_arr": [], "id": "il0sm0pshxi49q", "updated": "2016-02-24T12:03:59Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>2012011371&#xff1a;徐捷&#xff0c;2012011372&#xff1a;赖国堃</p>\n<p>一、funcall</p>\n<p>1. <a href=\"https://github.com/EternalAnswer/v9-cpu/blob/master/hw/2/funcall.c\" target=\"_blank\">修改代码&#xff0c;显示学号</a></p>\n<p>2. <a href=\"https://github.com/EternalAnswer/v9-cpu/blob/master/hw/2/funcall.txt\" target=\"_blank\">funcall.c汇编代码及注释</a></p>\n<p>3. funcall中的堆栈有多大&#xff1f;是内核态堆栈还是用户态堆栈<br />    内存大小有128MB&#xff0c;去掉快表4MB&#xff0c;去掉代码长度&#xff0c;再去掉数据区大小&#xff0c;即为堆栈大小。funcall运行在内核态。<br />4. funcall中的全局变量ret放在内存中何处&#xff1f;如何对它寻址&#xff1f;<br />    ret内存位置为0xa8&#xff0c;可以用sg命令&#xff0c;并做立即数运算。<br />5. funcall中的字符串放在内存中何处&#xff1f;如何对它寻址&#xff1f;<br />    字符串存在内存0x90位置&#xff0c;可以通过立即数寻址。<br />6. 局部变量i在内存中的何处&#xff1f;如何对它寻址&#xff1f;<br />    查看汇编码&#xff0c;可知局部变量i在一个栈中&#xff0c;可用寄存器进行寻址为sp&#43;4。<br />7. 当前系统是处于中断使能状态吗&#xff1f;<br />    由iena变量可知&#xff0c;系统不处于中断使能状态。<br />8. funcall中的函数参数是如何传递的&#xff1f;函数返回值是如何传递的&#xff1f;<br />    参数从右至左压栈&#xff0c;返回值通过寄存器传递。<br />9. 分析并说明funcall执行文件的格式和内容&#xff1f;<br />    系统函数指针&#43;程序指令&#43;程序数据。</p>\n<p><br />二、OS0<br />1. 何处设置的中断使能&#xff1f;<br />    asm(STI); 开启中断。<br />2. 系统何时处于中断屏蔽状态&#xff1f;<br />    执行sti命令之前。<br />3. 如果系统处于中断屏蔽状态&#xff0c;如何让其中断使能&#xff1f;<br />    执行sti命令。<br />4. 系统产生中断后&#xff0c;CPU会做哪些事情&#xff1f;<br />    跳转至中断地址&#xff0c;开始中断成立程序。<br />5. CPU执行RTI指令的具体完成工作是哪些&#xff1f;<br />    恢复pc和sp&#xff0c;可能切换运行态&#xff0c;执行处理过程。</p>", "created": "2016-02-24T13:39:28Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i6ub4vwhQXd", "children": [], "tag_good_arr": [], "id": "il0w0t5nuhp1rg", "updated": "2016-02-24T13:39:28Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>分析和实验funcall.c&#xff0c;需要完成的内容包括&#xff1a;-[X]</p>\n<p>修改代码&#xff0c;可正常显示小组两位同学的学号&#xff08;用字符串&#xff09;</p>\n<p>ret = write(1, &#34;2013011296&#34;,11);</p>\n<p>生成funcall.c的汇编码&#xff0c;理解其实现并给汇编码写注释 尝试用xem的简单调试功能单步调试代码</p>\n<p>./xem -g funcall</p>\n<p>h: print help commands.</p>\n<p>q: quit. c: continue.</p>\n<p>s: single step for one instruction.</p>\n<p>i: display registers.</p>\n<p>x: display memory, the input address is hex number</p>\n<p>回答如下问题&#xff1a; funcall中的堆栈有多大&#xff1f;是内核态堆栈还是用户态堆栈</p>\n<p>MEM_SZ-FS_SZ-(Size of the file)=124MB-184B 是内核态堆栈 user: 0 [user mode or not]</p>\n<p>funcall中的全局变量ret放在内存中何处&#xff1f;如何对它寻址&#xff1f;</p>\n<p>SG 0x0 (D 0), ret在内存0xb8处 相对pc寻址</p>\n<p>funcall中的字符串放在内存中何处&#xff1f;如何对它寻址&#xff1f;</p>\n<p>LEAG 0x0 (D 0), s在内存0xa0处 相对于sp寻址</p>\n<p>局部变量i在内存中的何处&#xff1f;如何对它寻址&#xff1f;</p>\n<p>通过LL 0x4 (D 4)和SL 0x4 (D 4)读写变量i 相对于sp寻址</p>\n<p>当前系统是处于中断使能状态吗&#xff1f;</p>\n<p>no iena:0[interrupt flag]</p>\n<p>funcall中的函数参数是如何传递的&#xff1f;函数返回值是如何传递的&#xff1f;</p>\n<p>使用堆栈传递&#xff0c;从右往左压入 通过寄存器a传递</p>\n<p>分析并说明funcall执行文件的格式和内容 　</p>\n<p>hdr数据 程序指令text 程序数据data　</p>\n<p> </p>\n<p>分析和实验os0.c&#xff0c;需要完成的内容包括&#xff1a; -[X]</p>\n<p>生成os0.c的汇编码&#xff0c;理解其实现并给汇编码写注释 尝试用xem的简单调试功能单步调试代码</p>\n<p>回答如下问题&#xff1a;</p>\n<p>何处设置的中断使能&#xff1f; STI (set trap, and process the interrupt)</p>\n<p>系统何时处于中断屏蔽状态&#xff1f;STI之前&#xff0c;以及进入alltrap到从中退出的过程中</p>\n<p>如果系统处于中断屏蔽状态&#xff0c;如何让其中断使能&#xff1f;STI</p>\n<p>系统产生中断后&#xff0c;CPU会做哪些事情&#xff1f; 保存中断的地址到kkernel mode的sp中&#xff0c;pc会跳到中断向量的地址ivec处执行</p>\n<p>CPU执行RTI指令的具体完成工作是哪些&#xff1f; return from interrupt, set pc, sp, may switch user/kernel mode; if has pending interrupt, process the interrupt</p>", "created": "2016-02-24T13:40:30Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i3qk2vs65x276j", "children": [], "tag_good_arr": [], "id": "il0w24vz6bx2ck", "updated": "2016-02-24T13:40:30Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>之前发错了&#xff0c;</p>", "created": "2016-02-24T14:39:12Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i3qk2vs65x276j", "children": [], "tag_good_arr": [], "id": "il0y5n2wd5i3zw", "updated": "2016-02-24T14:39:12Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>分析和实验funcall.c&#xff0c;需要完成的内容包括&#xff1a; <br />-[X]<br />=============================================================================<br /> - 修改代码&#xff0c;可正常显示小组两位同学的学号&#xff08;用字符串&#xff09; <br /> 在代码funcall.c的main()函数中修改如下&#xff1a;<br /> ret = write(1, &#34;2012011285&#34;, 10);<br /> asm(HALT);<br />-----------------------------------------------------------------------------<br /> - 生成funcall.c的汇编码&#xff0c;理解其实现并给汇编码写注释<br /> 运行根目录下的build-funcall.sh&#xff0c;批处理会用xc自动生成汇编指令在funcall.txt中&#xff0c;生成可执行文件funcall&#xff0c;并用xem来模拟运行funcall。在funcall.txt中&#xff0c;去掉源码部分&#xff0c;并对汇编指令添加注释。<br /> // function out(port, val)<br /> 00000000 LL 0x8 (D 8) // load port to reg_a<br /> 00000004 LBL 0x10 (D 16) // load val to reg_b<br /> 00000008 BOUT // write reg_b(val)<br /> 0000000c LEV 0x0 (D 0) // return<br /> // function int write(int f, char* s, int n)<br /> 00000010 ENT 0xfffffff8 (D -8) // stack space for local variable<br /> 00000014 LI 0x1 (D 1) // reg_a = 1<br /> 00000018 SG 0x0 (D 0) // save reg_a(1) to reg<br /> 0000001c LL 0x20 (D 32) // load n to reg_a<br /> 00000020 SL 0x4 (D 4) // save reg_a(n) to i<br /> 00000024 JMP &lt;fwd&gt; // jump to &#34;check part&#34;<br /> 00000028 LL 0x18 (D 24) // load s to reg_a<br /> 0000002c SUBI 0xffffffff (D -1) // reg_a = reg_a &#43; 1<br /> 00000030 SL 0x18 (D 24) // save reg_a to s (s=s&#43;1&#xff09;<br /> 00000034 LXC 0xffffffff (D -1) // reg_a = *((char*)(reg_a-1))<br /> 00000038 PSHA // push reg_a(*s) to stack<br /> 0000003c LL 0x18 (D 24) // load f to reg_a<br /> 00000040 PSHA // push reg_a(f) to stack<br /> 00000044 JSR 0xffffffb8 (TO 0x0) // call out<br /> 00000048 ENT 0x10 (D 16) // pop reguments<br /> 0000004c LL 0x4 (D 4) // load i to reg_a<br /> 00000050 SUBI 0x1 (D 1) // reg_a = reg_a - 1<br /> 00000054 SL 0x4 (D 4) // save reg_a to i (i=i-1)<br /> 00000058 ADDI 0x1 (D 1) // i-- seem as i <br /> 0000005c BNZ &lt;fwd&gt; // continue loop if i-- != 0 <br /> 00000060 LL 0x4 (D 4) // load i to reg_a<br /> 00000064 LEV 0x8 (D 8) // return reg_a(i) (sp&#43;=16)<br /> 00000068 LEV 0x8 (D 8) // return<br /> // function main<br /> 0000006c PSHI 0xa (D 10) // push 10(n) to stack<br /> 00000070 LEAG 0x0 (D 0) // reg_a = data_addr[0]<br /> 00000074 PSHA // push &#34;2012011285&#34; to stack<br /> 00000078 PSHI 0x1 (D 1) // push 1(f) to stack<br /> 0000007c JSR 0xffffff90 (TO 0x10) // call write<br /> 00000080 ENT 0x18 (D 24) // pop reguments<br /> 00000084 SG 0x0 (D 0) // save reg_a(result of write) to ret<br /> 00000088 HALT // halt<br /> 0000008c LEV 0x0 (D 0) // return<br />-----------------------------------------------------------------------------<br /> - 尝试用xem的简单调试功能单步调试代码<br /> ./xem -g funcall &#xff1a;调试模式运行funcall<br /> xem =&gt; s &#xff1a;单步运行一条指令<br />-----------------------------------------------------------------------------<br /> - 回答如下问题&#xff1a;<br /> - funcall中的堆栈有多大&#xff1f;是内核态堆栈还是用户态堆栈<br /> 124MB的可用栈空间&#xff0c;内核态堆栈<br /> - funcall中的全局变量ret放在内存中何处&#xff1f;如何对它寻址&#xff1f;<br /> BSS区域&#xff0c;BSS base &#43; offset&#xff0c;指令LG读取至寄存器a<br /> - funcall中的字符串放在内存中何处&#xff1f;如何对它寻址&#xff1f;<br /> Data区域&#xff0c;Data base &#43; offset&#xff0c;指令LEAG读取地址至寄存器a<br /> - 局部变量i在内存中的何处&#xff1f;如何对它寻址&#xff1f;<br /> Stack区域&#xff0c;sp寄存器 &#43; offset&#xff0c;指令LL读取至寄存器a<br /> - 当前系统是处于中断使能状态吗&#xff1f;<br /> 处于iena状态&#xff0c;iena初始为1&#xff0c;且不存在CLI指令<br /> - funcall中的函数参数是如何传递的&#xff1f;函数返回值是如何传递的&#xff1f;<br /> 参数传递&#xff1a;<br /> 1.将参数push入栈。<br /> 2.调用函数。<br /> 3.将参数pop出栈<br /> 返回值传递&#xff1a;<br /> 1.将返回值存于寄存器a。<br /> 2.返回至EPC。<br /> - 分析并说明funcall执行文件的格式和内容<br />　 执行文件格式&#xff1a;<br /> header<br /> text segment<br /> data segment<br /> header :<br /> magic : 0xC0DEF00D<br /> bss : BSS区域空间大小<br /> entry : PC入口<br /> flags : 0<br /> text segment<br /> 代码区域<br /> data segment<br /> data区域</p>", "created": "2016-02-25T03:21:30Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "ibz6vywnw6g7nl", "children": [], "tag_good_arr": [], "id": "il1pdysvq716bq", "updated": "2016-02-25T03:21:30Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "il0kmjrp8n13w7", "updated": "2016-02-24T08:20:27Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>发错地方了&#xff0c;请无视我。</p>", "created": "2016-02-24T08:32:13Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "followup", "tag_good": [], "uid": "i0anp25rzjk2wt", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "il0l1okz2jh2l6", "updated": "2016-02-24T08:32:13Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p></p>", "created": "2016-02-24T08:35:16Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "followup", "tag_good": [], "uid": "i0ccfx63sir1e", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "il0l5lo5yql7md", "updated": "2016-02-24T08:35:16Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "1、堆栈最大&#xff1a;128M - FS_SZ(RAM 文件系统大小) - 程序代码占用的空间&#xff08;不到124M&#xff09;\n   内核态堆栈\n2、 存在PC&#43;x中&#xff0c;指令所在内存后\n用PC指针相对寻址\n3、 存在PC&#43;x中&#xff0c;指令所在内存后\n用PC指针相对寻址\n4、i&#xff1a;0x4 &#xff0c; sp指针相对寻址\n5、不是\n6、压入栈中&#xff0c;返回值通过寄存器a传递\n7、格式&#xff1a;二进制码\n   内容&#xff1a;机器码\n\n\n代码题&#xff1a;\nhttps://github.com/zhengyk11/v9-cpu.git", "created": "2016-02-24T08:51:35Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "followup", "tag_good": [], "uid": "ie7xy6atuuc1re", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "发错了&#xff0c;请无视。。。", "created": "2016-02-24T10:11:08Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "ie7xy6atuuc1re", "children": [], "tag_good_arr": [], "id": "il0okwjnyts6rh", "updated": "2016-02-24T10:11:08Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "il0lqllevv3uh", "updated": "2016-02-24T08:51:35Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>王奥丞 2014011367</p>\n<p>https://github.com/a1exwang/v9-cpu</p>\n<p>答案直接写在问题下面在spoc3.md, 汇编代码注释写在funcall.txt和os0.txt中</p>", "created": "2016-02-24T08:53:18Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "followup", "tag_good": [], "uid": "ie7xy4gmt1p1pp", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>发错地方了</p>", "created": "2016-02-24T08:59:47Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "ie7xy4gmt1p1pp", "children": [], "tag_good_arr": [], "id": "il0m14od45xfu", "updated": "2016-02-24T08:59:47Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "il0lssr4f6d4h7", "updated": "2016-02-24T08:53:18Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>list.h中提供了双向链表&#xff0c;只需将该结构体包一层即可支持不同数据类型&#xff0c;即&#xff1a;</p>\n<p>struct node{<br />list_entry_t entry;<br />T data;<br />};</p>", "created": "2016-02-24T08:57:19Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "followup", "tag_good": [], "uid": "i18riqkwrl225m", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "il0lxym4jos6d0", "updated": "2016-02-24T08:57:19Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>1. 能否读懂ucore中的AT&amp;T格式的X86-32汇编语言&#xff1f;请列出你不理解的汇编语言。</p>\n<p>答&#xff1a;基本上能读懂</p>\n<p>2. 虽然学过计算机原理和x86汇编&#xff08;根据THU-CS的课程设置&#xff09;&#xff0c;但对ucore中涉及的哪些硬件设计或功能细节不够了解&#xff1f;</p>\n<p>答&#xff1a;关于中断嵌套的处理方式&#xff0c;ucore是如何在软件层上处理的</p>\n<p>3. 哪些困难&#xff08;请分优先级&#xff09;会阻碍你自主完成lab实验&#xff1f;</p>\n<p>答&#xff1a;有时候找不到问题的出发点</p>\n<p>4.如何把一个在gdb中或执行过程中出现的物理/线性地址与你写的代码源码位置对应起来&#xff1f;</p>\n<p>答&#xff1a;在每个源码的函数的开头设置breakpoint&#xff0c;触发断点时读取物理地址</p>\n<p>5.了解函数调用栈对lab实验有何帮助&#xff1f;</p>\n<p>答&#xff1a;了解并跟踪ucore程序运行的trace&#xff0c;用于debug。</p>\n<p>6.你希望从lab中学到什么知识&#xff1f;</p>\n<p>答&#xff1a;熟练运用ubuntu终端。</p>\n<p></p>\n<p>1.搭建好实验环境&#xff0c;请描述碰到的困难和解决的过程。</p>\n<p>答&#xff1a;1.在Ubuntu上搭建实验环境时&#xff0c;需要安装相关组件&#xff0c;有时候通过apt-get install方法找不到软件源&#xff0c;需要在网上查找链接并wget软件包。</p>\n<p>2.熟悉基本的git命令行操作命令&#xff0c;从github上 的 <a href=\"http://www.github.com/chyyuu/ucore_lab\">http://www.github.com/chyyuu/ucore_lab</a> 下载 ucore lab实验</p>\n<p>答&#xff1a;git init&#xff0c;git clone ...。</p>\n<p>3.尝试用qemu&#43;gdb&#xff08;or ECLIPSE-CDT&#xff09;调试lab1</p>\n<p>答&#xff1a;先用make clean清除之前的make&#xff0c;然后用make来编译&#xff0c;最后用make debug来调试。</p>\n<p>4.对于如下的代码段&#xff0c;请说明”&#xff1a;“后面的数字是什么含义</p>\n<p>答&#xff1a;每个number在struct里所占的空间大小&#xff08;bit为单位&#xff09;</p>\n<p>5.请问执行上述指令后&#xff0c; intr的值是多少&#xff1f;</p>\n<p>答&#xff1a;0x10002</p>\n<p>6.请分析 <a href=\"https://github.com/chyyuu/ucore_lab/blob/master/labcodes/lab2/libs/list.h\">list.h</a>内容中大致的含义&#xff0c;并能include这个文件&#xff0c;利用其结构和功能编写一个数据结构链表操作的小C程序</p>\n<p>答&#xff1a;</p>\n<p>#include &#34;list.h&#34;</p>\n<p>struct myList : public list {</p>\n<p>  int data;</p>\n<p>}</p>\n<p>void sort(myList* l, myList* r) {</p>\n<p>  myList *l2 = l, *r2 = r;</p>\n<p>  int midData=l-&gt;data;</p>\n<p>  while (r2-&gt;next != l2 &amp;&amp; r2 != l2) {</p>\n<p>    while (l2-&gt;data &lt; midData) l2 = l2-&gt;next;</p>\n<p>    while (r2-&gt;data &gt; midData) r2 = r2-&gt;prev;</p>\n<p>    if (r2-&gt;next != l2 &amp;&amp; r2 != l2) {</p>\n<p>      swap(l2-&gt;data, r2-&gt;data); l2 = l2-&gt;next; r2 = r2-&gt;prev;</p>\n<p>    } </p>\n<p>  }</p>\n<p>  if (l != r2 &amp;&amp; r2-&gt;next != l) sort(l, r2);</p>\n<p>  if (r != l2 &amp;&amp; r-&gt;next != l2) sort(l2, r);</p>\n<p>}</p>\n<h2></h2>", "created": "2016-02-24T08:59:08Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "followup", "tag_good": [], "uid": "ibz6vywnw6g7nl", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "il0m0b1box45x6", "updated": "2016-02-24T08:59:08Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "手抖贴错了", "created": "2016-02-24T09:02:34Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "followup", "tag_good": [], "uid": "i0c90j8pjf56sn", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "手抖贴错了", "created": "2016-02-24T09:02:58Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0c90j8pjf56sn", "children": [], "tag_good_arr": [], "id": "il0m58axu444kt", "updated": "2016-02-24T09:02:58Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "il0m4q0c6084g6", "updated": "2016-02-24T09:02:34Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>抱歉发错</p>", "created": "2016-02-24T10:00:31Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "followup", "tag_good": [], "uid": "i0ccqbaxwdz75c", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "il0o78sk57t3xk", "updated": "2016-02-24T10:00:31Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>在 /root/usr/funcall.c 中的main函数中修改write语句如下&#xff1a;</p>\n<pre>ret = write(1, &#34;2013012443 2013011301&#34;, 22);</pre>\n<p>即可完成输出。</p>", "created": "2016-02-24T10:13:58Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "followup", "tag_good": [], "uid": "ikvcvqnhm907lr", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "il0oojlykd5744", "updated": "2016-02-24T10:13:58Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>计35 朱俸民 朱新瑞 </p>\n<p>关于funcall的答案在以下链接</p>\n<p><a href=\"https://github.com/Naiselim/os_2016/blob/master/funcall答案.txt\">https://github.com/Naiselim/os_2016/blob/master/funcall答案.txt</a></p>\n<p>第二个的答案在之前朱俸民回答里</p>", "created": "2016-02-24T11:52:27Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "followup", "tag_good": [], "uid": "i0zaci5voig5h", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "il0s775wh5c2wb", "updated": "2016-02-24T11:52:27Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>2013011349 李宇轩</p>\n<p>2013011356 董豪宇</p>\n<p>两问答案通过回复给出</p>", "created": "2016-02-24T11:53:42Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "followup", "tag_good": [], "uid": "i0f9pvv0uxm6ko", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "第二问:\n\n1. asm(STI)设置的中断使能\n\n2. 在中断使能打开前(即asm(STI)前), 在处理中断时(即alltraps()运行时, 以及前面的一些准备阶段)的时候处于中断屏蔽状态\n\n3. 如果是因为处理中断而导致的中断屏蔽, 可以使用RTI(类似于MIPS中的eret); 要使能中断, 可以使用STI\n\n4. a)如果没有进入核心态, 就进入核心态, 在进入核心态的时候, 会从用户态下的栈转移到核心态下的栈, 更换快表, 记录trap信息, 屏蔽中断\n    b)记录trap信息\n    c)更改PC的值\n    \n5. 切换栈和快表, 从栈中获取之前的trap信息以及PC的值, 打开中断使能, 返回应返回的PC", "created": "2016-02-24T11:59:14Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i242q8ug7vw40x", "children": [], "tag_good_arr": [], "id": "il0sfwk9i2a50b", "updated": "2016-02-24T11:59:14Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>第一问&#xff1a;</p>\n<ul><li>修改代码&#xff0c;可正常显示小组两位同学的学号&#xff08;用字符串&#xff09;\n<ul><li>答&#xff1a; 代码修改ret = write(1, &#34;2012011349 2012011356&#34;,21)</li></ul>\n</li><li>\n<p>尝试用xem的简单调试功能单步调试代码</p>\n<p>      答&#xff1a;./xem -g funcall进入debuger 模式,通过输入h知道其使用方法</p>\n</li><li>\n<p>回答如下问题&#xff1a;</p>\n<ul><li>funcall中的堆栈有多大&#xff1f;是内核态堆栈还是用户态堆栈\n<ul><li>答&#xff1a;从em.c中可知&#xff0c;内存有128M&#xff0c;FS_SZ占了4M&#xff0c;funcall程序和数据占了8&#xff0c;堆栈有124M-184bytes。       为内核态&#xff0c;通过debug可以知道</li></ul>\n</li><li>funcall中的全局变量ret放在内存中何处&#xff1f;如何对它寻址&#xff1f;\n<ul><li>答&#xff1a;阅读代码可以知道&#xff0c;00000084 00000045 SG 0x0 (D 0)&#xff0c;其中0x0并不是真实偏移量&#xff1b;通过debug运行可知&#xff0c;偏移量为8c&#xff0c;[00000018] 8c45&#xff0c; 可知存于<code>pc&#43;8c</code>处。使用相对寻址。</li></ul>\n</li><li>funcall中的字符串放在内存中何处&#xff1f;如何对它寻址&#xff1f;\n<ul><li>答&#xff1a;类似上题&#xff0c;通过debug运行可知存于<code>pc&#43;1c</code>处</li></ul>\n</li><li>局部变量i在内存中的何处&#xff1f;如何对它寻址&#xff1f;\n<ul><li>答&#xff1a;由00000020 00000440 SL 0x4 (D 4)&#xff0c;可知存于<code>*(local_addr) local_addr = sp &#43; 4</code>。</li></ul>\n</li><li>当前系统是处于中断使能状态吗&#xff1f;\n<ul><li>答&#xff1a;通过debug可以知道&#xff0c;不处于中断使能。</li></ul>\n</li><li>funcall中的函数参数是如何传递的&#xff1f;函数返回值是如何传递的&#xff1f;\n<ul><li>答&#xff1a;从右向左依次压栈。</li></ul>\n</li><li>分析并说明funcall执行文件的格式和内容\n<ul><li>答&#xff1a;首先是hdr数据&#xff08;外存数据&#xff0c;含magic数、bss、entry、flags&#xff09;&#xff0c;然后是text&#xff08;程序指令&#xff09;&#xff0c;最后是data&#xff08;程序数据&#xff09;</li></ul>\n</li></ul>\n</li></ul>", "created": "2016-02-24T12:06:04Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i0f9pvv0uxm6ko", "children": [], "tag_good_arr": [], "id": "il0sopmc8dy675", "updated": "2016-02-24T12:06:04Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "il0s8snguij7lt", "updated": "2016-02-24T11:53:42Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>2013011349 李宇轩</p>\n<p>2013011356 董豪宇</p>\n<p>两问答案通过回复给出</p>", "created": "2016-02-24T11:53:51Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "followup", "tag_good": [], "uid": "i0f9pvv0uxm6ko", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "il0s8zutr447oz", "updated": "2016-02-24T11:53:51Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p></p>", "created": "2016-02-24T12:13:26Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "followup", "tag_good": [], "uid": "i3qk2vs65x276j", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>", "created": "2016-02-24T12:21:13Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "feedback", "tag_good": [], "uid": "i3qk2vs65x276j", "children": [], "tag_good_arr": [], "id": "il0t86jvu2q3qx", "updated": "2016-02-24T12:21:13Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "il0sy6biiab77o", "updated": "2016-02-24T12:13:26Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>郭嘉丞2013011509</p>\n<p>https://github.com/gjc13/v9-cpu/tree/master/answers</p>\n<p>os0 funcall注释在os0.txt funcall.txt中</p>\n<p>问题答案在1-1.md到1-4.md中</p>", "created": "2016-02-25T01:31:44Z", "bucket_order": 302, "bucket_name": "Week 2/21 - 2/27", "type": "followup", "tag_good": [], "uid": "ie7xy71bn7b1s2", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "il1lgsaub257fx", "updated": "2016-02-25T01:31:44Z", "config": {}}], "tag_good_arr": [], "id": "il0khl0me9l1eq", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 77, "num_favorites": 0, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643168101807, "default_anonymity": "no"}, "error": null, "aid": "kyuzv1rjr9s5b0"}