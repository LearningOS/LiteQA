{"result": {"folders": ["课堂问答"], "nr": 413, "data": {"embed_links": []}, "created": "2015-05-11T06:21:41Z", "bucket_order": 3, "no_answer_followup": 13, "change_log": [{"uid": "hdjonbiyfs62ie", "anon": "no", "when": "2015-05-11T06:21:41Z", "data": "i9ji4n4r7jr6p4", "type": "create"}, {"to": "i9ji4n4o57c6p3", "uid": "i71i9b92nrr7n4", "anon": "no", "when": "2015-05-11T06:41:16Z", "type": "followup"}, {"to": "i9ji4n4o57c6p3", "uid": "i6sl02qfUgI", "anon": "no", "when": "2015-05-11T06:53:12Z", "type": "followup"}, {"to": "i9ji4n4o57c6p3", "uid": "i6uunp7jxDb", "anon": "no", "when": "2015-05-11T06:57:49Z", "type": "followup"}, {"to": "i9ji4n4o57c6p3", "uid": "i6roqnlkmtw", "anon": "no", "when": "2015-05-11T06:58:10Z", "type": "followup"}, {"to": "i9ji4n4o57c6p3", "uid": "i7bg4v1keqE", "anon": "no", "when": "2015-05-11T07:01:14Z", "type": "followup"}, {"to": "i9ji4n4o57c6p3", "uid": "i6vuv0mi6uU", "anon": "no", "when": "2015-05-11T07:05:32Z", "type": "followup"}, {"to": "i9ji4n4o57c6p3", "uid": "i7bfq2txxyw689", "anon": "no", "when": "2015-05-11T07:07:18Z", "type": "followup"}, {"to": "i9ji4n4o57c6p3", "uid": "i6tz0qianu33p3", "anon": "no", "when": "2015-05-11T07:07:26Z", "type": "followup"}, {"to": "i9ji4n4o57c6p3", "uid": "i6t1w87gRBD", "anon": "no", "when": "2015-05-11T07:53:33Z", "type": "followup"}, {"to": "i9ji4n4o57c6p3", "uid": "i6vkh2uqu3V", "anon": "no", "when": "2015-05-11T08:05:03Z", "type": "followup"}, {"to": "i9ji4n4o57c6p3", "uid": "i718aanx0OS", "anon": "no", "when": "2015-05-11T09:11:44Z", "type": "followup"}, {"to": "i9ji4n4o57c6p3", "uid": "i6t6y9snjx2", "anon": "no", "when": "2015-05-11T09:55:57Z", "type": "followup"}, {"to": "i9ji4n4o57c6p3", "uid": "i7w0q2p8Cmz", "anon": "no", "when": "2015-05-11T12:29:41Z", "type": "followup"}, {"to": "i9ji4n4o57c6p3", "uid": "i6uaz13iyeM", "anon": "no", "when": "2015-05-12T10:48:21Z", "type": "followup"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "第20讲课堂练习", "created": "2015-05-11T06:21:41Z", "content": "<p>实现银行家算法</p>\n<p></p>\n<p>问题描述&#xff1a;</p>\n<p><a href=\"https://github.com/xuyongjiande/os_exercises/blob/master/all/08-1-spoc-discussion.md#%E5%B0%8F%E7%BB%84%E6%80%9D%E8%80%83%E9%A2%98\">https://github.com/xuyongjiande/os_exercises/blob/master/all/08-1-spoc-discussion.md#%E5%B0%8F%E7%BB%84%E6%80%9D%E8%80%83%E9%A2%98</a></p>\n<p></p>\n<p>请参与课堂讨论的同学回复自己的回答和测试用例。</p>"}], "type": "note", "tags": ["instructor-note", "课堂问答"], "tag_good": [], "unique_views": 106, "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>計22 2012011290 梁錫豪</p>\n<p></p>\n<pre>import os<br />import random<br />import numpy as np<br />import itertools<br /><br />class Bankers(object):<br />    def __init__(self, totalResource):<br />        #initiating<br />        self.RESOURCE = totalResource<br /><br />    def SignProcesses(self, max_, allocated_):<br />        self.max = max_<br />        self.allocated = allocated_<br />        self.need = self.CalcNeed()<br />        self.avaliable = self.CalcAvaliable()<br />        self.finished = [False]*len(self.allocated)<br /><br />    def Difference(self,a,b):<br />        #return matrix subtracted from a by b<br />        res = []<br />        for i in range(len(a)):<br />            tmp = []<br />            for j in range(len(a[i])):<br />                tmp.append(a[i][j]-b[i][j])<br />            res.append(tmp)<br />        return res<br /><br />    def CalcNeed(self):<br />        #calc request by subtracting signed matrix from max matrix<br />        return self.Difference(self.max,self.allocated)<br /><br />    def CalcAvaliable(self):<br />        &#34;&#34;&#34;Calc Avaliable Resource&#34;&#34;&#34;<br />        a = self.allocated<br />        res = []<br />        for j in range(len(a[0])):<br />            tmp = 0<br />            for i in range(len(a)):<br />                tmp &#43;= a[i][j]<br />            res.append(self.RESOURCE[j] - tmp)<br />        return res<br /><br />    def ExecuteProcess(self,index):<br /><br />        #check if less avaliable than Request<br />        # YOUR CODE, 2012011290<br />\t<br />\tflag = True;<br />\tfor i in range(len(self.need[index])):<br />\t\tif self.need[index][i] &gt; self.avaliable[i]:<br />\t\t\tflag = False<br />\t\t\tbreak;\t<br />        #check END here<br /><br />        #allocating what they need.<br />        # YOUR CODE, 2012011290<br /><br />\tif not flag:<br />\t\treturn False<br /><br />\tfor i in range(len(self.need[index])):<br />\t\tself.allocated[index][i] &#43;= self.need[index][i];<br />\t\tself.avaliable[i] -= self.need[index][i]<br />\t\tself.need[index][i] = 0<br /><br />\treturn True<br /><br />        #allocating END here<br /><br /><br />    def TempSafeCheckAfterRelease(self):<br />        #check if at least one request can be done after previous process done. not check whole sequances.<br />        #if every element of Requests can&#39;t accepted after previous process done, this mean it is not safe state<br />        # YOUR CODE, 2012011290<br /><br />\tnot_finished_count = len(self.max)<br /><br />\tfor idx in range(len(self.max)):<br />\t\tif self.finished[idx] == True:<br />\t\t\tnot_finished_count -= 1<br />\t\t\tcontinue<br /><br />\t\tflag = True;<br />\t\tfor i in range(len(self.max[idx])):<br />\t\t\tif (self.need[idx][i] &gt; self.avaliable[i]):<br />\t\t\t\tflag = False<br />\t\t\t\tbreak;<br />\t\tif flag:<br />\t\t\treturn True<br />\t<br />\tif not_finished_count == 0:<br />\t\treturn True<br />\telse:<br />\t        return False<br /><br />    def print_matrixes(self):<br />        print &#34;_____________________________________________&#34;<br />        print &#34;MAX\\t\\tAllocated\\tNeed&#34;<br />        for idx in range(len(self.max)):<br />            print &#34;%s\\t%s\\t%s&#34; % (self.max[idx],self.allocated[idx], self.need[idx])<br />        print &#34;_____________________________________________&#34;<br />        print &#34;Resources:&#34;<br />        print &#34;Total: %s\\tAvailable: %s\\n&#34; % (self.RESOURCE, self.avaliable)<br /><br />    def ReleasingProcess(self,index):<br />        for i in range(0,len(self.RESOURCE)):<br />            self.finished[index] = True<br />            self.allocated[index][i] = 0<br />        self.avaliable = self.CalcAvaliable()<br /><br />    def Execute(self):<br />        i = 0<br />        # get all permutation of processes<br />        perm = itertools.permutations(range(procnum), procnum)<br />        permArray = np.asarray(list(perm))<br /><br />        for arr in permArray:<br />            for i in arr:<br />                if self.finished[i] == False:<br />                    print &#34;Executing...&#34;<br />                    print &#34;Request: &#34;<br />                    print self.need[i]<br />                    #check if less avaliable than Request<br />                    if self.ExecuteProcess(i):<br />                        print &#34;Dispatching Done...&#34;<br /><br />                        self.print_matrixes()<br /><br />                        print &#34;-----Releasing Process------&#34;<br /><br />                        self.ReleasingProcess(i)<br /><br />                        self.print_matrixes()<br /><br />                        #check if at least one request can be done after previous process done. not check whole sequances.<br />                        #if every element of Requests can&#39;t accepted after previous process done, this mean it is not safe state<br />                        if not (self.TempSafeCheckAfterRelease()):<br />                            print &#34;SAFE STATE: NOT SAFE - There are no sequances can avoid Deadlock&#34;<br />                            return False<br />                        processes.append(i)<br />                    else:<br />                        print &#34;HOLD: not enough Resource&#34;<br /><br />                if i == len(self.allocated)-1:<br />                    i = 0<br />                else:<br />                    i &#43;= 1<br /><br />                check = True<br />                for k in range(0,len(self.allocated)):<br />                    if self.finished[k] == False:<br />                        check = False<br />                        break<br />                if check == True:<br />                    return True<br />                    break<br />        #every permutation of processes is false<br />        return False<br /><br />def getmax():<br />    res = []<br />    for j in range(procnum):<br />        tmp = []<br />        for i in range(len(total_resources)):<br />            randnum=random.random()<br />            remain_max=0<br />            if j &gt;0:<br />                remain_max=total_resources[i]<br />                for k in range(j):<br />                    remain_max=remain_max-res[k][i]<br />                if remain_max &lt; 0:<br />                    remain_max=0<br />            else:<br />                remain_max=total_resources[i]<br />            tmp.append((int)(randnum*remain_max*0.8))<br />        res.append(tmp)<br />    return res<br /><br />def getallocated():<br />    res = []<br />    for j in range(procnum):<br />        tmp = []<br />        for i in range(len(total_resources)):<br />            randnum=random.random()<br />            remain=0<br />            if j &gt;0:<br />                remain=max[j][i]<br />                for k in range(j):<br />                    remain=remain-res[k][i]<br />                if remain &lt; 0:<br />                    remain=0<br />            else:<br />                remain=max[j][i]<br />            tmp.append((int)(randnum*remain))<br />        res.append(tmp)<br />    return res<br /><br />print &#34;start here&#34;<br /># random seed<br />seed = 2<br />random.seed(seed)<br /># the number of process list<br />procnum = 3<br /># the number of type of resource<br />resnum =  4<br /># the max total value of resource<br />restotalval = 30<br /># the total resources list<br />total_resources=[]<br /># the total processes<br />processes=[]<br /># set the real total value of resource in total_resources<br />for i in range(resnum):<br />    total_resources.append((int)(restotalval*random.random()))<br /># init the Banker<br />b = Bankers(total_resources)<br /># get the max request values of resources from process<br />max=getmax()<br /># get the already gotted values of resources from process<br />allocated=getallocated()<br /># init need matrix, available vector<br />b.SignProcesses(max, allocated)<br /># print all theses matrixes<br />b.print_matrixes()<br /># executing Banker algorithm<br />result=b.Execute()<br /># show results<br />if result:<br />    print &#34;SUCCESS proc lists &#34;,processes<br />else:<br />    print &#34;Failed&#34;<br /><br /># total_resources = [6, 5, 7, 6]<br /># processes=[]<br /># b = Bankers(total_resources)<br />#<br /># max = [<br />#     [3, 3, 2, 2],<br />#     [1, 2, 3, 4],<br />#     [1, 3, 5, 0],<br /># ]<br /># allocated = [<br />#     [1, 2, 2, 1],<br />#     [1, 0, 3, 3],<br />#     [1, 2, 1, 0],<br /># ]<br />#<br /># b.SignProcesses(max, allocated)<br /># b.print_matrixes()<br /># result=b.Execute()<br /># if result:<br />#     print &#34;SUCCESS proc lists &#34;,processes<br /># else:<br />#     print &#34;Failed&#34;<br />#<br />#<br /># total_resources = [10, 10, 8, 5]<br /># processes=[]<br /># b = Bankers(total_resources)<br /># max = [<br />#         [10, 8, 2,5],<br />#         [6, 1, 3,1],<br />#         [3, 1, 4,2],<br />#         [5, 4, 2,1]<br />#     ]<br /># allocated = [<br />#         [3, 0, 0,3],<br />#         [1, 1, 2,0],<br />#         [2, 1, 2,1],<br />#         [0, 0, 2,0]<br />#     ]<br /># b.SignProcesses(max, allocated)<br /># b.print_matrixes()<br /># result=b.Execute()<br /># if result:<br />#     print &#34;SUCCESS proc lists &#34;,processes<br /># else:<br />#     print &#34;Failed&#34;</pre>\n<p></p>", "created": "2015-05-11T06:41:16Z", "bucket_order": 261, "bucket_name": "Week 5/10 - 5/16", "type": "followup", "tag_good": [], "uid": "i71i9b92nrr7n4", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "i9jittthwkq4ln", "updated": "2015-05-11T06:41:16Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>计22 黄杰 2012011272</p>\n<p>计22 袁源 2012011294</p>\n<p>计24 杜鹃 2012011354</p>\n<p>https://github.com/THUHJ/os_exercises/blob/master/all/08-1-spoc-discussion.md</p>", "created": "2015-05-11T06:53:12Z", "bucket_order": 261, "bucket_name": "Week 5/10 - 5/16", "type": "followup", "tag_good": [], "uid": "i6sl02qfUgI", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i9jj962iqkp3zk", "updated": "2015-05-11T06:53:12Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>计22 沈光耀</p>\n<pre>import os<br />import random<br />import numpy as np<br />import itertools<br /><br />class Bankers(object):<br />    def __init__(self, totalResource):<br />        #initiating<br />        self.RESOURCE = totalResource<br /><br />    def SignProcesses(self, max_, allocated_):<br />        self.max = max_<br />        self.allocated = allocated_<br />        self.need = self.CalcNeed()<br />        self.avaliable = self.CalcAvaliable()<br />        self.finished = [False]*len(self.allocated)<br /><br />    def Difference(self,a,b):<br />        #return matrix subtracted from a by b<br />        res = []<br />        for i in range(len(a)):<br />            tmp = []<br />            for j in range(len(a[i])):<br />                tmp.append(a[i][j]-b[i][j])<br />            res.append(tmp)<br />        return res<br /><br />    def CalcNeed(self):<br />        #calc request by subtracting signed matrix from max matrix<br />        return self.Difference(self.max,self.allocated)<br /><br />    def CalcAvaliable(self):<br />        &#34;&#34;&#34;Calc Avaliable Resource&#34;&#34;&#34;<br />        a = self.allocated<br />        res = []<br />        for j in range(len(a[0])):<br />            tmp = 0<br />            for i in range(len(a)):<br />                tmp &#43;= a[i][j]<br />            res.append(self.RESOURCE[j] - tmp)<br />        return res<br /><br />    def ExecuteProcess(self,index):<br /><br />        #check if less avaliable than Request<br />        # YOUR CODE, YOUR ID<br />        a = self.need[index]<br />        for j in range(len(a)):<br />            if a[j] &gt; self.avaliable[j]:<br />                return False<br />        #check END here<br /><br />        #allocating what they need.<br />        # YOUR CODE, YOUR ID<br />        for j in range(len(a)):<br />            self.allocated[index][j] = self.allocated[index][j]&#43;a[j]<br />            self.avaliable[j] = self.avaliable[j]-a[j]<br />            self.need[index][j] = 0<br />        return True<br />        #allocating END here<br /><br />    def TempSafeCheckAfterRelease(self):<br />        #check if at least one request can be done after previous process done. not check whole sequances.<br />        #if every element of Requests can&#39;t accepted after previous process done, this mean it is not safe state<br />        # YOUR CODE, YOU ID<br />        <br />        flag = True<br />        for j in range(len(self.max)):<br />            if(self.finished[j] == False):<br />                flag = False<br /><br />        if flag == True:<br />            return True<br /><br />        a = self.need<br />        flag = True<br /><br />        for j in range(len(a)):<br />            if self.finished[j] == False:<br />                for i in range(len(a[j])):<br />                    if a[j][i] &gt; self.avaliable[i]:<br />                        flag = False<br />                        break<br />                if flag:<br />                    return True<br />        #check END here<br /><br />    def print_matrixes(self):<br />        print &#34;_____________________________________________&#34;<br />        print &#34;MAX\\t\\tAllocated\\tNeed&#34;<br />        for idx in range(len(self.max)):<br />            print &#34;%s\\t%s\\t%s&#34; % (self.max[idx],self.allocated[idx], self.need[idx])<br />        print &#34;_____________________________________________&#34;<br />        print &#34;Resources:&#34;<br />        print &#34;Total: %s\\tAvailable: %s\\n&#34; % (self.RESOURCE, self.avaliable)<br /><br />    def ReleasingProcess(self,index):<br />        for i in range(0,len(self.RESOURCE)):<br />            self.finished[index] = True<br />            self.allocated[index][i] = 0<br />        self.avaliable = self.CalcAvaliable()<br /><br />    def Execute(self):<br />        i = 0<br />        # get all permutation of processes<br />        perm = itertools.permutations(range(procnum), procnum)<br />        permArray = np.asarray(list(perm))<br /><br />        for arr in permArray:<br />            for i in arr:<br />                if self.finished[i] == False:<br />                    print &#34;Executing...&#34;<br />                    print &#34;Request: &#34;<br />                    print self.need[i]<br />                    #check if less avaliable than Request<br />                    if self.ExecuteProcess(i):<br />                        print &#34;Dispatching Done...&#34;<br /><br />                        self.print_matrixes()<br /><br />                        print &#34;-----Releasing Process------&#34;<br /><br />                        self.ReleasingProcess(i)<br /><br />                        self.print_matrixes()<br /><br />                        #check if at least one request can be done after previous process done. not check whole sequances.<br />                        #if every element of Requests can&#39;t accepted after previous process done, this mean it is not safe state<br />                        if not (self.TempSafeCheckAfterRelease()):<br />                            print &#34;SAFE STATE: NOT SAFE - There are no sequances can avoid Deadlock&#34;<br />                            return False<br />                        processes.append(i)<br />                    else:<br />                        print &#34;HOLD: not enough Resource&#34;<br /><br />                if i == len(self.allocated)-1:<br />                    i = 0<br />                else:<br />                    i &#43;= 1<br /><br />                check = True<br />                for k in range(0,len(self.allocated)):<br />                    if self.finished[k] == False:<br />                        check = False<br />                        break<br />                if check == True:<br />                    return True<br />                    break<br />        #every permutation of processes is false<br />        return False<br /><br />def getmax():<br />    res = []<br />    for j in range(procnum):<br />        tmp = []<br />        for i in range(len(total_resources)):<br />            randnum=random.random()<br />            remain_max=0<br />            if j &gt;0:<br />                remain_max=total_resources[i]<br />                for k in range(j):<br />                    remain_max=remain_max-res[k][i]<br />                if remain_max &lt; 0:<br />                    remain_max=0<br />            else:<br />                remain_max=total_resources[i]<br />            tmp.append((int)(randnum*remain_max*0.8))<br />        res.append(tmp)<br />    return res<br /><br />def getallocated():<br />    res = []<br />    for j in range(procnum):<br />        tmp = []<br />        for i in range(len(total_resources)):<br />            randnum=random.random()<br />            remain=0<br />            if j &gt;0:<br />                remain=max[j][i]<br />                for k in range(j):<br />                    remain=remain-res[k][i]<br />                if remain &lt; 0:<br />                    remain=0<br />            else:<br />                remain=max[j][i]<br />            tmp.append((int)(randnum*remain))<br />        res.append(tmp)<br />    return res<br /><br />print &#34;start here&#34;<br /># random seed<br />seed = 2<br />random.seed(seed)<br /># the number of process list<br />procnum = 3<br /># the number of type of resource<br />resnum =  4<br /># the max total value of resource<br />restotalval = 30<br /># the total resources list<br />total_resources=[]<br /># the total processes<br />processes=[]<br /># set the real total value of resource in total_resources<br />for i in range(resnum):<br />    total_resources.append((int)(restotalval*random.random()))<br /># init the Banker<br />b = Bankers(total_resources)<br /># get the max request values of resources from process<br />max=getmax()<br /># get the already gotted values of resources from process<br />allocated=getallocated()<br /># init need matrix, available vector<br />b.SignProcesses(max, allocated)<br /># print all theses matrixes<br />b.print_matrixes()<br /># executing Banker algorithm<br />result=b.Execute()<br /># show results<br />if result:<br />    print &#34;SUCCESS proc lists &#34;,processes<br />else:<br />    print &#34;Failed&#34;<br /><br /># total_resources = [6, 5, 7, 6]<br /># processes=[]<br /># b = Bankers(total_resources)<br />#<br /># max = [<br />#     [3, 3, 2, 2],<br />#     [1, 2, 3, 4],<br />#     [1, 3, 5, 0],<br /># ]<br /># allocated = [<br />#     [1, 2, 2, 1],<br />#     [1, 0, 3, 3],<br />#     [1, 2, 1, 0],<br /># ]<br />    #<br /># b.SignProcesses(max, allocated)<br /># b.print_matrixes()<br /># result=b.Execute()<br /># if result:<br />#     print &#34;SUCCESS proc lists &#34;,processes<br /># else:<br />#     print &#34;Failed&#34;<br />#<br />#<br /># total_resources = [10, 10, 8, 5]<br /># processes=[]<br /># b = Bankers(total_resources)<br /># max = [<br />#         [10, 8, 2,5],<br />#         [6, 1, 3,1],<br />#         [3, 1, 4,2],<br />#         [5, 4, 2,1]<br />#     ]<br /># allocated = [<br />#         [3, 0, 0,3],<br />#         [1, 1, 2,0],<br />#         [2, 1, 2,1],<br />#         [0, 0, 2,0]<br />#     ]<br /># b.SignProcesses(max, allocated)<br /># b.print_matrixes()<br /># result=b.Execute()<br /># if result:<br />#     print &#34;SUCCESS proc lists &#34;,processes<br /># else:<br />#     print &#34;Failed&#34;</pre>", "created": "2015-05-11T06:57:49Z", "bucket_order": 261, "bucket_name": "Week 5/10 - 5/16", "type": "followup", "tag_good": [], "uid": "i6uunp7jxDb", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i9jjf428p01428", "updated": "2015-05-11T06:57:49Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p></p><pre>import os\nimport random\nimport numpy as np\nimport itertools\n\nclass Bankers(object):\n    def __init__(self, totalResource):\n        #initiating\n        self.RESOURCE = totalResource\n\n    def SignProcesses(self, max_, allocated_):\n        self.max = max_\n        self.allocated = allocated_\n        self.need = self.CalcNeed()\n        self.avaliable = self.CalcAvaliable()\n        self.finished = [False]*len(self.allocated)\n\n    def Difference(self,a,b):\n        #return matrix subtracted from a by b\n        res = []\n        for i in range(len(a)):\n            tmp = []\n            for j in range(len(a[i])):\n                tmp.append(a[i][j]-b[i][j])\n            res.append(tmp)\n        return res\n\n    def CalcNeed(self):\n        #calc request by subtracting signed matrix from max matrix\n        return self.Difference(self.max,self.allocated)\n\n    def CalcAvaliable(self):\n        &#34;&#34;&#34;Calc Avaliable Resource&#34;&#34;&#34;\n        a = self.allocated\n        res = []\n        for j in range(len(a[0])):\n            tmp = 0\n            for i in range(len(a)):\n                tmp &#43;= a[i][j]\n            res.append(self.RESOURCE[j] - tmp)\n        return res\n\n    def ExecuteProcess(self,index):\n\n        #check if less avaliable than Request\n        can = True\n        for i in range(0, len(self.need[index])):\n            if self.need[index][i] &gt; self.avaliable[i]:\n                can = False\n                break\n\n        if can == False:\n            return False\n\n        #allocating what they need.\n        for i in range(0, len(self.need[index])):\n            self.avaliable[i] -= self.need[index][i]\n            self.allocated[index][i] = self.need[index][i]\n            self.need[index][i] = 0\n        #allocating END here\n        return True\n\n    def TempSafeCheckAfterRelease(self):\n        #check if at least one request can be done after previous process done. not check whole sequances.\n        #if every element of Requests can&#39;t accepted after previous process done, this mean it is not safe state\n        can = False\n        for i in range(0, len(self.max)):\n            can = False\n            for j in range(0, len(self.max[i])):\n                if self.allocated[i][j] &lt; self.max[i][j]:\n                    can = True\n                    break\n            if can:\n                break\n        return can\n\n    def print_matrixes(self):\n        print &#34;_____________________________________________&#34;\n        print &#34;MAX\\t\\tAllocated\\tNeed&#34;\n        for idx in range(len(self.max)):\n            print &#34;%s\\t%s\\t%s&#34; % (self.max[idx],self.allocated[idx], self.need[idx])\n        print &#34;_____________________________________________&#34;\n        print &#34;Resources:&#34;\n        print &#34;Total: %s\\tAvailable: %s\\n&#34; % (self.RESOURCE, self.avaliable)\n\n    def ReleasingProcess(self,index):\n        for i in range(0,len(self.RESOURCE)):\n            self.finished[index] = True\n            self.allocated[index][i] = 0\n        self.avaliable = self.CalcAvaliable()\n\n    def Execute(self):\n        i = 0\n        # get all permutation of processes\n        perm = itertools.permutations(range(procnum), procnum)\n        permArray = np.asarray(list(perm))\n\n        for arr in permArray:\n            for i in arr:\n                if self.finished[i] == False:\n                    print &#34;Executing...&#34;\n                    print &#34;Request: &#34;\n                    print self.need[i]\n                    #check if less avaliable than Request\n                    if self.ExecuteProcess(i):\n                        print &#34;Dispatching Done...&#34;\n\n                        self.print_matrixes()\n\n                        print &#34;-----Releasing Process------&#34;\n\n                        self.ReleasingProcess(i)\n\n                        self.print_matrixes()\n\n                        #check if at least one request can be done after previous process done. not check whole sequances.\n                        #if every element of Requests can&#39;t accepted after previous process done, this mean it is not safe state\n                        if not (self.TempSafeCheckAfterRelease()):\n                            print &#34;SAFE STATE: NOT SAFE - There are no sequances can avoid Deadlock&#34;\n                            return False\n                        processes.append(i)\n                    else:\n                        print &#34;HOLD: not enough Resource&#34;\n\n                if i == len(self.allocated)-1:\n                    i = 0\n                else:\n                    i &#43;= 1\n\n                check = True\n                for k in range(0,len(self.allocated)):\n                    if self.finished[k] == False:\n                        check = False\n                        break\n                if check == True:\n                    return True\n                    break\n        #every permutation of processes is false\n        return False\n\ndef getmax():\n    res = []\n    for j in range(procnum):\n        tmp = []\n        for i in range(len(total_resources)):\n            randnum=random.random()\n            remain_max=0\n            if j &gt;0:\n                remain_max=total_resources[i]\n                for k in range(j):\n                    remain_max=remain_max-res[k][i]\n                if remain_max &lt; 0:\n                    remain_max=0\n            else:\n                remain_max=total_resources[i]\n            tmp.append((int)(randnum*remain_max*0.8))\n        res.append(tmp)\n    return res\n\ndef getallocated():\n    res = []\n    for j in range(procnum):\n        tmp = []\n        for i in range(len(total_resources)):\n            randnum=random.random()\n            remain=0\n            if j &gt;0:\n                remain=max[j][i]\n                for k in range(j):\n                    remain=remain-res[k][i]\n                if remain &lt; 0:\n                    remain=0\n            else:\n                remain=max[j][i]\n            tmp.append((int)(randnum*remain))\n        res.append(tmp)\n    return res\n\nprint &#34;start here&#34;\n# random seed\nseed = 2\nrandom.seed(seed)\n# the number of process list\nprocnum = 3\n# the number of type of resource\nresnum =  4\n# the max total value of resource\nrestotalval = 30\n# the total resources list\ntotal_resources=[]\n# the total processes\nprocesses=[]\n# set the real total value of resource in total_resources\nfor i in range(resnum):\n    total_resources.append((int)(restotalval*random.random()))\n# init the Banker\nb = Bankers(total_resources)\n# get the max request values of resources from process\nmax=getmax()\n# get the already gotted values of resources from process\nallocated=getallocated()\n# init need matrix, available vector\nb.SignProcesses(max, allocated)\n# print all theses matrixes\nb.print_matrixes()\n# executing Banker algorithm\nresult=b.Execute()\n# show results\nif result:\n    print &#34;SUCCESS proc lists &#34;,processes\nelse:\n    print &#34;Failed&#34;\n\n# total_resources = [6, 5, 7, 6]\n# processes=[]\n# b = Bankers(total_resources)\n#\n# max = [\n#     [3, 3, 2, 2],\n#     [1, 2, 3, 4],\n#     [1, 3, 5, 0],\n# ]\n# allocated = [\n#     [1, 2, 2, 1],\n#     [1, 0, 3, 3],\n#     [1, 2, 1, 0],\n# ]\n#\n# b.SignProcesses(max, allocated)\n# b.print_matrixes()\n# result=b.Execute()\n# if result:\n#     print &#34;SUCCESS proc lists &#34;,processes\n# else:\n#     print &#34;Failed&#34;\n#\n#\n# total_resources = [10, 10, 8, 5]\n# processes=[]\n# b = Bankers(total_resources)\n# max = [\n#         [10, 8, 2,5],\n#         [6, 1, 3,1],\n#         [3, 1, 4,2],\n#         [5, 4, 2,1]\n#     ]\n# allocated = [\n#         [3, 0, 0,3],\n#         [1, 1, 2,0],\n#         [2, 1, 2,1],\n#         [0, 0, 2,0]\n#     ]\n# b.SignProcesses(max, allocated)\n# b.print_matrixes()\n# result=b.Execute()\n# if result:\n#     print &#34;SUCCESS proc lists &#34;,processes\n# else:\n#     print &#34;Failed&#34;</pre>\n<p></p>", "created": "2015-05-11T06:58:10Z", "bucket_order": 261, "bucket_name": "Week 5/10 - 5/16", "type": "followup", "tag_good": [], "uid": "i6roqnlkmtw", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i9jjfkagjaj5jh", "updated": "2015-05-11T06:58:10Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>计24 王妍 2012011352</p>\n<p></p>\n<p>代码请见&#xff1a;</p>\n<p><a href=\"https://github.com/yanwang9411/os_exercises/blob/master/all/banker.py\">https://github.com/yanwang9411/os_exercises/blob/master/all/banker.py</a></p>\n<p></p>", "created": "2015-05-11T07:01:14Z", "bucket_order": 261, "bucket_name": "Week 5/10 - 5/16", "type": "followup", "tag_good": [], "uid": "i7bg4v1keqE", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i9jjjhtamqy319", "updated": "2015-05-11T07:01:14Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>鲁逸沁 2012011314</p>\n<p>谢晓晖 2012011315</p>\n<p>林子钏 2012011322</p>\n<p>史佳欣 2012011299</p>\n<p></p>\n<pre>import os\nimport random\nimport numpy as np\nimport itertools\n\nclass Bankers(object):\n    def __init__(self, totalResource):\n        #initiating\n        self.RESOURCE = totalResource\n\n    def SignProcesses(self, max_, allocated_):\n        self.max = max_\n        self.allocated = allocated_\n        self.need = self.CalcNeed()\n        self.avaliable = self.CalcAvaliable()\n        self.finished = [False]*len(self.allocated)\n\n    def Difference(self,a,b):\n        #return matrix subtracted from a by b\n        res = []\n        for i in range(len(a)):\n            tmp = [] \n            for j in range(len(a[i])):\n                tmp.append(a[i][j]-b[i][j]) \n            res.append(tmp)\n        return res\n\n    def CalcNeed(self):\n        #calc request by subtracting signed matrix from max matrix\n        return self.Difference(self.max,self.allocated)\n\n    def CalcAvaliable(self):\n        &#34;&#34;&#34;Calc Avaliable Resource&#34;&#34;&#34;\n        a = self.allocated\n        res = []\n        for j in range(len(a[0])):\n            tmp = 0\n            for i in range(len(a)):\n                tmp &#43;= a[i][j]\n            res.append(self.RESOURCE[j] - tmp)\n        return res\n\n    def ExecuteProcess(self,index):\n\n        #check if less avaliable than Request\n        # YOUR CODE, YOUR ID\n        for i in range(len(self.need[index])):\n            if self.need[index][i] &gt; self.avaliable[i]:\n                return False\n        #check END here\n\n        #allocating what they need.\n        # YOUR CODE, YOUR ID\n        for i in range(len(self.allocated[index])):\n            self.allocated[index][i] &#43;= self.need[index][i]\n            self.avaliable[i] -= self.need[index][i]\n            self.need[index][i] = 0\n        return True\n        #allocating END here\n        #pass\n\n    def TempSafeCheckAfterRelease(self):\n        #check if at least one request can be done after previous process done. not check whole sequances.\n        #if every element of Requests can&#39;t accepted after previous process done, this mean it is not safe state\n        # YOUR CODE, YOU ID\n        for i in range(3):\n            find = True\n            for j in range(4):\n                if self.need[i][j] &gt; self.avaliable[j]:\n                    find = False\n            if find :\n                return True\n        return False\n        #check END here\n        #pass\n\n    def print_matrixes(self):\n        print &#34;_____________________________________________&#34;\n        print &#34;MAX\\t\\tAllocated\\tNeed&#34;\n        for idx in range(len(self.max)):\n            print &#34;%s\\t%s\\t%s&#34; % (self.max[idx],self.allocated[idx], self.need[idx])\n        print &#34;_____________________________________________&#34;\n        print &#34;Resources:&#34;\n        print &#34;Total: %s\\tAvailable: %s\\n&#34; % (self.RESOURCE, self.avaliable)\n\n    def ReleasingProcess(self,index):\n        for i in range(0,len(self.RESOURCE)):\n            self.finished[index] = True\n            self.allocated[index][i] = 0\n        self.avaliable = self.CalcAvaliable()\n\n    def Execute(self):\n        i = 0\n        # get all permutation of processes\n        perm = itertools.permutations(range(procnum), procnum)\n        permArray = np.asarray(list(perm))\n\n        for arr in permArray:\n            for i in arr:\n                if self.finished[i] == False:\n                    print &#34;Executing...&#34;\n                    print &#34;Request: &#34;\n                    print self.need[i]\n                    #check if less avaliable than Request\n                    if self.ExecuteProcess(i):\n                        print &#34;Dispatching Done...&#34;\n\n                        self.print_matrixes()\n\n                        print &#34;-----Releasing Process------&#34;\n\n                        self.ReleasingProcess(i)\n\n                        self.print_matrixes()\n\n                        #check if at least one request can be done after previous process done. not check whole sequances.\n                        #if every element of Requests can&#39;t accepted after previous process done, this mean it is not safe state\n                        if not (self.TempSafeCheckAfterRelease()):\n                            print &#34;SAFE STATE: NOT SAFE - There are no sequances can avoid Deadlock&#34;\n                            return False\n                        processes.append(i)\n                    else:\n                        print &#34;HOLD: not enough Resource&#34;\n\n                if i == len(self.allocated)-1:\n                    i = 0\n                else:\n                    i &#43;= 1\n\n                check = True\n                for k in range(0,len(self.allocated)):\n                    if self.finished[k] == False:\n                        check = False\n                        break\n                if check == True:\n                    return True\n                    break\n        #every permutation of processes is false\n        return False\n\ndef getmax():\n    res = []\n    for j in range(procnum):\n        tmp = []\n        for i in range(len(total_resources)):\n            randnum=random.random()\n            remain_max=0\n            if j &gt;0:\n                remain_max=total_resources[i]\n                for k in range(j):\n                    remain_max=remain_max-res[k][i]\n                if remain_max &lt; 0:\n                    remain_max=0\n            else:\n                remain_max=total_resources[i]\n            tmp.append((int)(randnum*remain_max*0.8))\n        res.append(tmp)\n    return res\n\ndef getallocated():\n    res = []\n    for j in range(procnum):\n        tmp = []\n        for i in range(len(total_resources)):\n            randnum=random.random()\n            remain=0\n            if j &gt;0:\n                remain=max[j][i]\n                for k in range(j):\n                    remain=remain-res[k][i]\n                if remain &lt; 0:\n                    remain=0\n            else:\n                remain=max[j][i]\n            tmp.append((int)(randnum*remain))\n        res.append(tmp)\n    return res\n\nprint &#34;start here&#34;\n# random seed\nseed = 2\nrandom.seed(seed)\n# the number of process list\nprocnum = 3\n# the number of type of resource\nresnum =  4\n# the max total value of resource\nrestotalval = 30\n# the total resources list\ntotal_resources=[]\n# the total processes\nprocesses=[]\n# set the real total value of resource in total_resources\nfor i in range(resnum):\n    total_resources.append((int)(restotalval*random.random()))\n# init the Banker\nb = Bankers(total_resources)\n# get the max request values of resources from process\nmax=getmax()\n# get the already gotted values of resources from process\nallocated=getallocated()\n# init need matrix, available vector\nb.SignProcesses(max, allocated)\n# print all theses matrixes\nb.print_matrixes()\n# executing Banker algorithm\nresult=b.Execute()\n# show results\nif result:\n    print &#34;SUCCESS proc lists &#34;,processes\nelse:\n    print &#34;Failed&#34;\n\n# total_resources = [6, 5, 7, 6]\n# processes=[]\n# b = Bankers(total_resources)\n#\n# max = [\n#     [3, 3, 2, 2],\n#     [1, 2, 3, 4],\n#     [1, 3, 5, 0],\n# ]\n# allocated = [\n#     [1, 2, 2, 1],\n#     [1, 0, 3, 3],\n#     [1, 2, 1, 0],\n# ]\n#\n# b.SignProcesses(max, allocated)\n# b.print_matrixes()\n# result=b.Execute()\n# if result:\n#     print &#34;SUCCESS proc lists &#34;,processes\n# else:\n#     print &#34;Failed&#34;\n#\n#\n# total_resources = [10, 10, 8, 5]\n# processes=[]\n# b = Bankers(total_resources)\n# max = [\n#         [10, 8, 2,5],\n#         [6, 1, 3,1],\n#         [3, 1, 4,2],\n#         [5, 4, 2,1]\n#     ]\n# allocated = [\n#         [3, 0, 0,3],\n#         [1, 1, 2,0],\n#         [2, 1, 2,1],\n#         [0, 0, 2,0]\n#     ]\n# b.SignProcesses(max, allocated)\n# b.print_matrixes()\n# result=b.Execute()\n# if result:\n#     print &#34;SUCCESS proc lists &#34;,processes\n# else:\n#     print &#34;Failed&#34;</pre>\n<p></p>", "created": "2015-05-11T07:05:32Z", "bucket_order": 261, "bucket_name": "Week 5/10 - 5/16", "type": "followup", "tag_good": [], "uid": "i6vuv0mi6uU", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i9jjp19orye7d", "updated": "2015-05-11T07:05:32Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>覃伟 计22 2012011278</p>\n<p></p>\n<pre>import os\nimport random\nimport numpy as np\nimport itertools\n\nclass Bankers(object):\n    def __init__(self, totalResource):\n        #initiating\n        self.RESOURCE = totalResource\n\n    def SignProcesses(self, max_, allocated_):\n        self.max = max_\n        self.allocated = allocated_\n        self.need = self.CalcNeed()\n        self.avaliable = self.CalcAvaliable()\n        self.finished = [False]*len(self.allocated)\n\n    def Difference(self,a,b):\n        #return matrix subtracted from a by b\n        res = []\n        for i in range(len(a)):\n            tmp = []\n            for j in range(len(a[i])):\n                tmp.append(a[i][j]-b[i][j])\n            res.append(tmp)\n        return res\n\n    def CalcNeed(self):\n        #calc request by subtracting signed matrix from max matrix\n        return self.Difference(self.max,self.allocated)\n\n    def CalcAvaliable(self):\n        &#34;&#34;&#34;Calc Avaliable Resource&#34;&#34;&#34;\n        a = self.allocated\n        res = []\n        for j in range(len(a[0])):\n            tmp = 0\n            for i in range(len(a)):\n                tmp &#43;= a[i][j]\n            res.append(self.RESOURCE[j] - tmp)\n        return res\n\n    def ExecuteProcess(self,index):\n\n        #check if less avaliable than Request\n        # 2012011278\n        for i in range(len(self.avaliable)):\n            if self.avaliable[i] &lt; self.need[index][i]:\n                return False\n        #check END here\n\n        #allocating what they need.\n        # 2012011278\n        for i in range(len(self.avaliable)):\n            self.avaliable[i] -= self.need[index][i]\n            self.allocated[index][i] &#43;= self.need[index][i]\n            self.need[index][i] = 0\n        return True\n        #allocating END here\n        # pass\n\n    def TempSafeCheckAfterRelease(self):\n        #check if at least one request can be done after previous process done. not check whole sequances.\n        #if every element of Requests can&#39;t accepted after previous process done, this mean it is not safe state\n        # 2012011278\n        qwSafe = True\n        qwfinishNum = 0\n        for i in range(len(self.max)):\n            #print &#39;qw... finish? %d&#39; % self.finished[i]\n            if self.finished[i] == True:\n                qwfinishNum &#43;= 1\n                continue\n            qwSafe = True\n            for j in range(len(self.avaliable)):\n                if self.avaliable[j] &lt; self.need[i][j]:\n                    qwSafe = False\n                    break\n            if qwSafe == True:\n                return True\n        if qwfinishNum == len(self.max):\n            return True\n        return False\n        #check END here\n        # pass\n\n    def print_matrixes(self):\n        print &#34;_____________________________________________&#34;\n        print &#34;MAX\\t\\tAllocated\\tNeed&#34;\n        for idx in range(len(self.max)):\n            print &#34;%s\\t%s\\t%s&#34; % (self.max[idx],self.allocated[idx], self.need[idx])\n        print &#34;_____________________________________________&#34;\n        print &#34;Resources:&#34;\n        print &#34;Total: %s\\tAvailable: %s\\n&#34; % (self.RESOURCE, self.avaliable)\n\n    def ReleasingProcess(self,index):\n        for i in range(0,len(self.RESOURCE)):\n            self.finished[index] = True\n            self.allocated[index][i] = 0\n        self.avaliable = self.CalcAvaliable()\n\n    def Execute(self):\n        i = 0\n        # get all permutation of processes\n        perm = itertools.permutations(range(procnum), procnum)\n        permArray = np.asarray(list(perm))\n\n        for arr in permArray:\n            for i in arr:\n                if self.finished[i] == False:\n                    print &#34;Executing...&#34;\n                    print &#34;Request: &#34;\n                    print self.need[i]\n                    #check if less avaliable than Request\n                    if self.ExecuteProcess(i):\n                        print &#34;Dispatching Done...&#34;\n\n                        self.print_matrixes()\n\n                        print &#34;-----Releasing Process------&#34;\n\n                        self.ReleasingProcess(i)\n\n                        self.print_matrixes()\n\n                        #check if at least one request can be done after previous process done. not check whole sequances.\n                        #if every element of Requests can&#39;t accepted after previous process done, this mean it is not safe state\n                        if not (self.TempSafeCheckAfterRelease()):\n                            print &#34;SAFE STATE: NOT SAFE - There are no sequances can avoid Deadlock&#34;\n                            return False\n                        processes.append(i)\n                    else:\n                        print &#34;HOLD: not enough Resource&#34;\n\n                if i == len(self.allocated)-1:\n                    i = 0\n                else:\n                    i &#43;= 1\n\n                check = True\n                for k in range(0,len(self.allocated)):\n                    if self.finished[k] == False:\n                        check = False\n                        break\n                if check == True:\n                    return True\n                    break\n        #every permutation of processes is false\n        return False\n\ndef getmax():\n    res = []\n    for j in range(procnum):\n        tmp = []\n        for i in range(len(total_resources)):\n            randnum=random.random()\n            remain_max=0\n            if j &gt;0:\n                remain_max=total_resources[i]\n                for k in range(j):\n                    remain_max=remain_max-res[k][i]\n                if remain_max &lt; 0:\n                    remain_max=0\n            else:\n                remain_max=total_resources[i]\n            tmp.append((int)(randnum*remain_max*0.8))\n        res.append(tmp)\n    return res\n\ndef getallocated():\n    res = []\n    for j in range(procnum):\n        tmp = []\n        for i in range(len(total_resources)):\n            randnum=random.random()\n            remain=0\n            if j &gt;0:\n                remain=max[j][i]\n                for k in range(j):\n                    remain=remain-res[k][i]\n                if remain &lt; 0:\n                    remain=0\n            else:\n                remain=max[j][i]\n            tmp.append((int)(randnum*remain))\n        res.append(tmp)\n    return res\n\nprint &#34;start here&#34;\n# random seed\nseed = 2\nrandom.seed(seed)\n# the number of process list\nprocnum = 3\n# the number of type of resource\nresnum =  4\n# the max total value of resource\nrestotalval = 30\n# the total resources list\ntotal_resources=[]\n# the total processes\nprocesses=[]\n\n# set the real total value of resource in total_resources\nfor i in range(resnum):\n    total_resources.append((int)(restotalval*random.random()))\n# init the Banker\nb = Bankers(total_resources)\n# get the max request values of resources from process\nmax=getmax()\n# get the already gotted values of resources from process\nallocated=getallocated()\n# init need matrix, available vector\nb.SignProcesses(max, allocated)\n# print all theses matrixes\nb.print_matrixes()\n# executing Banker algorithm\nresult=b.Execute()\n# show results\nif result:\n    print &#34;SUCCESS proc lists &#34;,processes\nelse:\n    print &#34;Failed&#34;\n\n&#39;&#39;&#39;\ntotal_resources = [6, 5, 7, 6]\nprocesses=[]\nb = Bankers(total_resources)\nmax = [\n     [3, 3, 2, 2],\n     [1, 2, 3, 4],\n     [1, 3, 5, 0],\n]\nallocated = [\n     [1, 2, 2, 1],\n     [1, 0, 3, 3],\n     [1, 2, 1, 0],\n]\n\nb.SignProcesses(max, allocated)\nb.print_matrixes()\nresult=b.Execute()\nif result:\n    print &#34;SUCCESS proc lists &#34;,processes\nelse:\n    print &#34;Failed&#34;\n&#39;&#39;&#39;\n&#39;&#39;&#39;\ntotal_resources = [10, 10, 8, 5]\nprocesses=[]\nb = Bankers(total_resources)\nmax = [\n        [10, 8, 2,5],\n        [6, 1, 3,1],\n        [3, 1, 4,2],\n        [5, 4, 2,1]\n    ]\nallocated = [\n        [3, 0, 0,3],\n        [1, 1, 2,0],\n        [2, 1, 2,1],\n        [0, 0, 2,0]\n   ]\nb.SignProcesses(max, allocated)\nb.print_matrixes()\nresult=b.Execute()\nif result:\n    print &#34;SUCCESS proc lists &#34;,processes\nelse:\n    print &#34;Failed&#34;\n&#39;&#39;&#39;</pre>\n<p></p>", "created": "2015-05-11T07:07:18Z", "bucket_order": 261, "bucket_name": "Week 5/10 - 5/16", "type": "followup", "tag_good": [], "uid": "i7bfq2txxyw689", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i9jjraiwur6id", "updated": "2015-05-11T07:07:18Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>2012011342 周圣凯</p>\n<p>2012011392 韦福超</p>\n<p>2012011397 王振</p>\n<p>2012011401 张梦豪</p>\n<pre>import os\nimport random\nimport numpy as np\nimport itertools\n\nclass Bankers(object):\n    def __init__(self, totalResource):\n        #initiating\n        self.RESOURCE = totalResource\n\n    def SignProcesses(self, max_, allocated_):\n        self.max = max_\n        self.allocated = allocated_\n        self.need = self.CalcNeed()\n        self.avaliable = self.CalcAvaliable()\n        self.finished = [False]*len(self.allocated)\n\n    def Difference(self,a,b):\n        #return matrix subtracted from a by b\n        res = []\n        for i in range(len(a)):\n            tmp = []\n            for j in range(len(a[i])):\n                tmp.append(a[i][j]-b[i][j])\n            res.append(tmp)\n        return res\n\n    def CalcNeed(self):\n        #calc request by subtracting signed matrix from max matrix\n        return self.Difference(self.max,self.allocated)\n\n    def CalcAvaliable(self):\n        &#34;&#34;&#34;Calc Avaliable Resource&#34;&#34;&#34;\n        a = self.allocated\n        res = []\n        for j in range(len(a[0])):\n            tmp = 0\n            for i in range(len(a)):\n                tmp &#43;= a[i][j]\n            res.append(self.RESOURCE[j] - tmp)\n        return res\n\n    def ExecuteProcess(self,index):\n\n        #check if less avaliable than Request\n        # 2012011342, zsk12\n        if any(a&lt;n for a, n in zip(self.avaliable, self.need[index])):\n            return False\n        #check END here\n\n        #allocating what they need.\n        # 2012011342, zsk12\n        self.avaliable = [a-n for a, n in zip(self.avaliable, self.need[index])]\n        self.need[index] = [0 for n in self.need[index]]\n        self.finished[index] = True\n        return True\n        #allocating END here\n        #pass\n\n    def TempSafeCheckAfterRelease(self):\n        #check if at least one request can be done after previous process done. not check whole sequances.\n        #if every element of Requests can&#39;t accepted after previous process done, this mean it is not safe state\n        # 2012011342, zsk12\n        return any(\n                all(a&gt;=n for a, n in zip(self.avaliable, need1))\n                for i, need1 in zip(range(len(self.need)), self.need)\n                if self.finished[i]\n        )\n        #check END here\n        #pass\n\n    def print_matrixes(self):\n        print &#34;_____________________________________________&#34;\n        print &#34;MAX\\t\\tAllocated\\tNeed&#34;\n        for idx in range(len(self.max)):\n            print &#34;%s\\t%s\\t%s&#34; % (self.max[idx],self.allocated[idx], self.need[idx])\n        print &#34;_____________________________________________&#34;\n        print &#34;Resources:&#34;\n        print &#34;Total: %s\\tAvailable: %s\\n&#34; % (self.RESOURCE, self.avaliable)\n\n    def ReleasingProcess(self,index):\n        for i in range(0,len(self.RESOURCE)):\n            self.finished[index] = True\n            self.allocated[index][i] = 0\n        self.avaliable = self.CalcAvaliable()\n\n    def Execute(self):\n        i = 0\n        # get all permutation of processes\n        perm = itertools.permutations(range(procnum), procnum)\n        permArray = np.asarray(list(perm))\n\n        for arr in permArray:\n            for i in arr:\n                if self.finished[i] == False:\n                    print &#34;Executing...&#34;\n                    print &#34;Request: &#34;\n                    print self.need[i]\n                    #check if less avaliable than Request\n                    if self.ExecuteProcess(i):\n                        print &#34;Dispatching Done...&#34;\n\n                        self.print_matrixes()\n\n                        print &#34;-----Releasing Process------&#34;\n\n                        self.ReleasingProcess(i)\n\n                        self.print_matrixes()\n\n                        #check if at least one request can be done after previous process done. not check whole sequances.\n                        #if every element of Requests can&#39;t accepted after previous process done, this mean it is not safe state\n                        if not (self.TempSafeCheckAfterRelease()):\n                            print &#34;SAFE STATE: NOT SAFE - There are no sequances can avoid Deadlock&#34;\n                            return False\n                        processes.append(i)\n                    else:\n                        print &#34;HOLD: not enough Resource&#34;\n\n                if i == len(self.allocated)-1:\n                    i = 0\n                else:\n                    i &#43;= 1\n\n                check = True\n                for k in range(0,len(self.allocated)):\n                    if self.finished[k] == False:\n                        check = False\n                        break\n                if check == True:\n                    return True\n                    break\n        #every permutation of processes is false\n        return False\n\ndef getmax():\n    res = []\n    for j in range(procnum):\n        tmp = []\n        for i in range(len(total_resources)):\n            randnum=random.random()\n            remain_max=0\n            if j &gt;0:\n                remain_max=total_resources[i]\n                for k in range(j):\n                    remain_max=remain_max-res[k][i]\n                if remain_max &lt; 0:\n                    remain_max=0\n            else:\n                remain_max=total_resources[i]\n            tmp.append((int)(randnum*remain_max*0.8))\n        res.append(tmp)\n    return res\n\ndef getallocated():\n    res = []\n    for j in range(procnum):\n        tmp = []\n        for i in range(len(total_resources)):\n            randnum=random.random()\n            remain=0\n            if j &gt;0:\n                remain=max[j][i]\n                for k in range(j):\n                    remain=remain-res[k][i]\n                if remain &lt; 0:\n                    remain=0\n            else:\n                remain=max[j][i]\n            tmp.append((int)(randnum*remain))\n        res.append(tmp)\n    return res\n\nprint &#34;start here&#34;\n# random seed\nseed = 2\nrandom.seed(seed)\n# the number of process list\nprocnum = 3\n# the number of type of resource\nresnum =  4\n# the max total value of resource\nrestotalval = 30\n# the total resources list\ntotal_resources=[]\n# the total processes\nprocesses=[]\n# set the real total value of resource in total_resources\nfor i in range(resnum):\n    total_resources.append((int)(restotalval*random.random()))\n# init the Banker\nb = Bankers(total_resources)\n# get the max request values of resources from process\nmax=getmax()\n# get the already gotted values of resources from process\nallocated=getallocated()\n# init need matrix, available vector\nb.SignProcesses(max, allocated)\n# print all theses matrixes\nb.print_matrixes()\n# executing Banker algorithm\nresult=b.Execute()\n# show results\nif result:\n    print &#34;SUCCESS proc lists &#34;,processes\nelse:\n    print &#34;Failed&#34;\n\n# total_resources = [6, 5, 7, 6]\n# processes=[]\n# b = Bankers(total_resources)\n#\n# max = [\n#     [3, 3, 2, 2],\n#     [1, 2, 3, 4],\n#     [1, 3, 5, 0],\n# ]\n# allocated = [\n#     [1, 2, 2, 1],\n#     [1, 0, 3, 3],\n#     [1, 2, 1, 0],\n# ]\n#\n# b.SignProcesses(max, allocated)\n# b.print_matrixes()\n# result=b.Execute()\n# if result:\n#     print &#34;SUCCESS proc lists &#34;,processes\n# else:\n#     print &#34;Failed&#34;\n#\n#\n# total_resources = [10, 10, 8, 5]\n# processes=[]\n# b = Bankers(total_resources)\n# max = [\n#         [10, 8, 2,5],\n#         [6, 1, 3,1],\n#         [3, 1, 4,2],\n#         [5, 4, 2,1]\n#     ]\n# allocated = [\n#         [3, 0, 0,3],\n#         [1, 1, 2,0],\n#         [2, 1, 2,1],\n#         [0, 0, 2,0]\n#     ]\n# b.SignProcesses(max, allocated)\n# b.print_matrixes()\n# result=b.Execute()\n# if result:\n#     print &#34;SUCCESS proc lists &#34;,processes\n# else:\n#     print &#34;Failed&#34;</pre>\n<p></p>", "created": "2015-05-11T07:07:26Z", "bucket_order": 261, "bucket_name": "Week 5/10 - 5/16", "type": "followup", "tag_good": [], "uid": "i6tz0qianu33p3", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i9jjrh8ib9t6yn", "updated": "2015-05-11T07:07:26Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>计24 王昊 2012011341</p>\n<pre>import os\nimport random\nimport numpy as np\nimport itertools\n\nclass Bankers(object):\n    def __init__(self, totalResource):\n        #initiating\n        self.RESOURCE = totalResource\n\n    def SignProcesses(self, max_, allocated_):\n        self.max = max_\n        self.allocated = allocated_\n        self.need = self.CalcNeed()\n        self.avaliable = self.CalcAvaliable()\n        self.finished = [False]*len(self.allocated)\n\n    def Difference(self,a,b):\n        #return matrix subtracted from a by b\n        res = []\n        for i in range(len(a)):\n            tmp = []\n            for j in range(len(a[i])):\n                tmp.append(a[i][j]-b[i][j])\n            res.append(tmp)\n        return res\n\n    def CalcNeed(self):\n        #calc request by subtracting signed matrix from max matrix\n        return self.Difference(self.max,self.allocated)\n\n    def CalcAvaliable(self):\n        &#34;&#34;&#34;Calc Avaliable Resource&#34;&#34;&#34;\n        a = self.allocated\n        res = []\n        for j in range(len(a[0])):\n            tmp = 0\n            for i in range(len(a)):\n                tmp &#43;= a[i][j]\n            res.append(self.RESOURCE[j] - tmp)\n        return res\n\n    def ExecuteProcess(self,index):\n\n        #check if less avaliable than Request\n        # YOUR CODE, YOUR ID\n        canDo = True\n        for i in range(len(self.allocated)) :\n            if (self.need[index][i] &gt; self.available[i]) :\n                canDo = False\n                print(&#34;process %d need RESOURCE %d %d, but we only have %d&#34;, index, i, self.need[index][i], self.available[i])\n                break\n        #check END here\n\n        #allocating what they need.\n        # YOUR CODE, YOUR ID\n        if (canDo) :\n            for i in range(len(self.available)) :\n                self.available[i] = self.available[i] - self.need[index]\n                self.need[index] = 0\n        return canDo\n        #allocating END here\n        pass\n\n    def TempSafeCheckAfterRelease(self):\n        #check if at least one request can be done after previous process done. not check whole sequances.\n        #if every element of Requests can&#39;t accepted after previous process done, this mean it is not safe state\n        # YOUR CODE, YOU ID\n        oneCanDo = True\n        for index in range(len(self.available)) :\n            canDo = True\n            for i in range(len(self.allocated)) :\n                if (self.need[index][i] &gt; self.available[i]) :\n                    canDo = False\n                    print(&#34;process %d need RESOURCE %d %d, but we only have %d&#34;, index, i, self.need[index][i], self.available[i])\n                    break\n            if (not canDo) :\n                oneCanDo = False\n                break\n        return oneCanDo\n        #check END here\n        pass\n\n    def print_matrixes(self):\n        print &#34;_____________________________________________&#34;\n        print &#34;MAX\\t\\tAllocated\\tNeed&#34;\n        for idx in range(len(self.max)):\n            print &#34;%s\\t%s\\t%s&#34; % (self.max[idx],self.allocated[idx], self.need[idx])\n        print &#34;_____________________________________________&#34;\n        print &#34;Resources:&#34;\n        print &#34;Total: %s\\tAvailable: %s\\n&#34; % (self.RESOURCE, self.avaliable)\n\n    def ReleasingProcess(self,index):\n        for i in range(0,len(self.RESOURCE)):\n            self.finished[index] = True\n            self.allocated[index][i] = 0\n        self.avaliable = self.CalcAvaliable()\n\n    def Execute(self):\n        i = 0\n        # get all permutation of processes\n        perm = itertools.permutations(range(procnum), procnum)\n        permArray = np.asarray(list(perm))\n\n        for arr in permArray:\n            for i in arr:\n                if self.finished[i] == False:\n                    print &#34;Executing...&#34;\n                    print &#34;Request: &#34;\n                    print self.need[i]\n                    #check if less avaliable than Request\n                    if self.ExecuteProcess(i):\n                        print &#34;Dispatching Done...&#34;\n\n                        self.print_matrixes()\n\n                        print &#34;-----Releasing Process------&#34;\n\n                        self.ReleasingProcess(i)\n\n                        self.print_matrixes()\n\n                        #check if at least one request can be done after previous process done. not check whole sequances.\n                        #if every element of Requests can&#39;t accepted after previous process done, this mean it is not safe state\n                        if not (self.TempSafeCheckAfterRelease()):\n                            print &#34;SAFE STATE: NOT SAFE - There are no sequances can avoid Deadlock&#34;\n                            return False\n                        processes.append(i)\n                    else:\n                        print &#34;HOLD: not enough Resource&#34;\n\n                if i == len(self.allocated)-1:\n                    i = 0\n                else:\n                    i &#43;= 1\n\n                check = True\n                for k in range(0,len(self.allocated)):\n                    if self.finished[k] == False:\n                        check = False\n                        break\n                if check == True:\n                    return True\n                    break\n        #every permutation of processes is false\n        return False\n\ndef getmax():\n    res = []\n    for j in range(procnum):\n        tmp = []\n        for i in range(len(total_resources)):\n            randnum=random.random()\n            remain_max=0\n            if j &gt;0:\n                remain_max=total_resources[i]\n                for k in range(j):\n                    remain_max=remain_max-res[k][i]\n                if remain_max &lt; 0:\n                    remain_max=0\n            else:\n                remain_max=total_resources[i]\n            tmp.append((int)(randnum*remain_max*0.8))\n        res.append(tmp)\n    return res\n\ndef getallocated():\n    res = []\n    for j in range(procnum):\n        tmp = []\n        for i in range(len(total_resources)):\n            randnum=random.random()\n            remain=0\n            if j &gt;0:\n                remain=max[j][i]\n                for k in range(j):\n                    remain=remain-res[k][i]\n                if remain &lt; 0:\n                    remain=0\n            else:\n                remain=max[j][i]\n            tmp.append((int)(randnum*remain))\n        res.append(tmp)\n    return res\n\nprint &#34;start here&#34;\n# random seed\nseed = 2\nrandom.seed(seed)\n# the number of process list\nprocnum = 3\n# the number of type of resource\nresnum =  4\n# the max total value of resource\nrestotalval = 30\n# the total resources list\ntotal_resources=[]\n# the total processes\nprocesses=[]\n# set the real total value of resource in total_resources\nfor i in range(resnum):\n    total_resources.append((int)(restotalval*random.random()))\n# init the Banker\nb = Bankers(total_resources)\n# get the max request values of resources from process\nmax=getmax()\n# get the already gotted values of resources from process\nallocated=getallocated()\n# init need matrix, available vector\nb.SignProcesses(max, allocated)\n# print all theses matrixes\nb.print_matrixes()\n# executing Banker algorithm\nresult=b.Execute()\n# show results\nif result:\n    print &#34;SUCCESS proc lists &#34;,processes\nelse:\n    print &#34;Failed&#34;\n\ntotal_resources = [6, 5, 7, 6]\nprocesses=[]\nb = Bankers(total_resources)\n\nmax = [\n    [3, 3, 2, 2],\n    [1, 2, 3, 4],\n    [1, 3, 5, 0],\n]\nallocated = [\n    [1, 2, 2, 1],\n    [1, 0, 3, 3],\n    [1, 2, 1, 0],\n]\n\nb.SignProcesses(max, allocated)\nb.print_matrixes()\nresult=b.Execute()\nif result:\n    print &#34;SUCCESS proc lists &#34;,processes\nelse:\n    print &#34;Failed&#34;\n\n\ntotal_resources = [10, 10, 8, 5]\nprocesses=[]\nb = Bankers(total_resources)\nmax = [\n        [10, 8, 2,5],\n        [6, 1, 3,1],\n        [3, 1, 4,2],\n        [5, 4, 2,1]\n    ]\nallocated = [\n        [3, 0, 0,3],\n        [1, 1, 2,0],\n        [2, 1, 2,1],\n        [0, 0, 2,0]\n    ]\nb.SignProcesses(max, allocated)\nb.print_matrixes()\nresult=b.Execute()\nif result:\n    print &#34;SUCCESS proc lists &#34;,processes\nelse:\n    print &#34;Failed&#34;</pre>\n<p></p>", "created": "2015-05-11T07:53:33Z", "bucket_order": 261, "bucket_name": "Week 5/10 - 5/16", "type": "followup", "tag_good": [], "uid": "i6t1w87gRBD", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i9jlermbv375o8", "updated": "2015-05-11T07:53:33Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>计22 滕爽 2012011270</p>\n<pre>import os\nimport random\nimport numpy as np\nimport itertools\n\nclass Bankers(object):\n    def __init__(self, totalResource):\n        #initiating\n        self.RESOURCE = totalResource\n\n    def SignProcesses(self, max_, allocated_):\n        self.max = max_\n        self.allocated = allocated_\n        self.need = self.CalcNeed()\n        self.avaliable = self.CalcAvaliable()\n        self.finished = [False]*len(self.allocated)\n\n    def Difference(self,a,b):\n        #return matrix subtracted from a by b\n        res = []\n        for i in range(len(a)):\n            tmp = []\n            for j in range(len(a[i])):\n                tmp.append(a[i][j]-b[i][j])\n            res.append(tmp)\n        return res\n\n    def CalcNeed(self):\n        #calc request by subtracting signed matrix from max matrix\n        return self.Difference(self.max,self.allocated)\n\n    def CalcAvaliable(self):\n        &#34;&#34;&#34;Calc Avaliable Resource&#34;&#34;&#34;\n        a = self.allocated\n        res = []\n        for j in range(len(a[0])):\n            tmp = 0\n            for i in range(len(a)):\n                tmp &#43;= a[i][j]\n            res.append(self.RESOURCE[j] - tmp)\n        return res\n\n    def ExecuteProcess(self,index):\n\n        #check if less avaliable than Request\n        # YOUR CODE, 2012011270\n        #check END here\n\tlength = len(self.avaliable)\n\tfor i in range(len):\n\t\tif(self.need[index][i] &gt; self.avaliable[i]): #\n\t\t\tprint &#39;resource &#39; &#43; i &#43; &#39; of process &#39;  &#43; index &#43; &#39;need &gt; available&#39; \n\t\t\treturn False\n\t\t\n        #allocating what they need.\n        # YOUR CODE, 2012011270\n        #allocating END here\n\tprint &#39;process &#39;&#43;index &#43; &#39; sucess&#39;\n\tfor i in range(len):\n\t\tself.allocated[index][i] &#43;=  self.need[index][i]\n\t\tself.avaliable[i] -= self.need[index][i]\n\t\tself.need[index][i] = 0\t\t\n\t\treturn True\n\n    def TempSafeCheckAfterRelease(self):\n        #check if at least one request can be done after previous process done. not check whole sequances.\n        #if every element of Requests can&#39;t accepted after previous process done, this mean it is not safe state\n        # YOUR CODE, 2012011270\n        #check END here\n\tflag = True\n\tlength = len(self.max)\n\tfor j in range(length):\n\t\tif(self.finished[j] == False):\n\t\t\tflag = False\n\t\t\n\tif flag == True:\n\t\tprint &#39;all process finished&#39;\n\t\treturn True\n\n\tflag = True\n\tn = len(self.need)\n\tm = len(self.available)\n\tfor indx in range(n):\n\t\tif self.finished[indx] == False: #find process\n\t\t\tfor i in range(m):\n\t\t\t\tif self.need[indx][i] &gt; self.avaliable[i]:\n\t\t\t\t\tflag = False\n\t\t\t\t\tbreak\n\t\t\tif flag:\n\t\t\t\treturn True\n\treturn False\n\n    def print_matrixes(self):\n        print &#34;_____________________________________________&#34;\n        print &#34;MAX\\t\\tAllocated\\tNeed&#34;\n        for idx in range(len(self.max)):\n            print &#34;%s\\t%s\\t%s&#34; % (self.max[idx],self.allocated[idx], self.need[idx])\n        print &#34;_____________________________________________&#34;\n        print &#34;Resources:&#34;\n        print &#34;Total: %s\\tAvailable: %s\\n&#34; % (self.RESOURCE, self.avaliable)\n\n    def ReleasingProcess(self,index):\n        for i in range(0,len(self.RESOURCE)):\n            self.finished[index] = True\n            self.allocated[index][i] = 0\n        self.avaliable = self.CalcAvaliable()\n\n    def Execute(self):\n        i = 0\n        # get all permutation of processes\n        perm = itertools.permutations(range(procnum), procnum)\n        permArray = np.asarray(list(perm))\n\n        for arr in permArray:\n            for i in arr:\n                if self.finished[i] == False:\n                    print &#34;Executing...&#34;\n                    print &#34;Request: &#34;\n                    print self.need[i]\n                    #check if less avaliable than Request\n                    if self.ExecuteProcess(i):\n                        print &#34;Dispatching Done...&#34;\n\n                        self.print_matrixes()\n\n                        print &#34;-----Releasing Process------&#34;\n\n                        self.ReleasingProcess(i)\n\n                        self.print_matrixes()\n\n                        #check if at least one request can be done after previous process done. not check whole sequances.\n                        #if every element of Requests can&#39;t accepted after previous process done, this mean it is not safe state\n                        if not (self.TempSafeCheckAfterRelease()):\n                            print &#34;SAFE STATE: NOT SAFE - There are no sequances can avoid Deadlock&#34;\n                            return False\n                        processes.append(i)\n                    else:\n                        print &#34;HOLD: not enough Resource&#34;\n\n                if i == len(self.allocated)-1:\n                    i = 0\n                else:\n                    i &#43;= 1\n\n                check = True\n                for k in range(0,len(self.allocated)):\n                    if self.finished[k] == False:\n                        check = False\n                        break\n                if check == True:\n                    return True\n                    break\n        #every permutation of processes is false\n        return False\n\ndef getmax():\n    res = []\n    for j in range(procnum):\n        tmp = []\n        for i in range(len(total_resources)):\n            randnum=random.random()\n            remain_max=0\n            if j &gt;0:\n                remain_max=total_resources[i]\n                for k in range(j):\n                    remain_max=remain_max-res[k][i]\n                if remain_max &lt; 0:\n                    remain_max=0\n            else:\n                remain_max=total_resources[i]\n            tmp.append((int)(randnum*remain_max*0.8))\n        res.append(tmp)\n    return res\n\ndef getallocated():\n    res = []\n    for j in range(procnum):\n        tmp = []\n        for i in range(len(total_resources)):\n            randnum=random.random()\n            remain=0\n            if j &gt;0:\n                remain=max[j][i]\n                for k in range(j):\n                    remain=remain-res[k][i]\n                if remain &lt; 0:\n                    remain=0\n            else:\n                remain=max[j][i]\n            tmp.append((int)(randnum*remain))\n        res.append(tmp)\n    return res\n\nprint &#34;start here&#34;\n# random seed\nseed = 2\nrandom.seed(seed)\n# the number of process list\nprocnum = 3\n# the number of type of resource\nresnum =  4\n# the max total value of resource\nrestotalval = 30\n# the total resources list\ntotal_resources=[]\n# the total processes\nprocesses=[]\n# set the real total value of resource in total_resources\nfor i in range(resnum):\n    total_resources.append((int)(restotalval*random.random()))\n# init the Banker\nb = Bankers(total_resources)\n# get the max request values of resources from process\nmax=getmax()\n# get the already gotted values of resources from process\nallocated=getallocated()\n# init need matrix, available vector\nb.SignProcesses(max, allocated)\n# print all theses matrixes\nb.print_matrixes()\n# executing Banker algorithm\nresult=b.Execute()\n# show results\nif result:\n    print &#34;SUCCESS proc lists &#34;,processes\nelse:\n    print &#34;Failed&#34;\n\n# total_resources = [6, 5, 7, 6]\n# processes=[]\n# b = Bankers(total_resources)\n#\n# max = [\n#     [3, 3, 2, 2],\n#     [1, 2, 3, 4],\n#     [1, 3, 5, 0],\n# ]\n# allocated = [\n#     [1, 2, 2, 1],\n#     [1, 0, 3, 3],\n#     [1, 2, 1, 0],\n# ]\n#\n# b.SignProcesses(max, allocated)\n# b.print_matrixes()\n# result=b.Execute()\n# if result:\n#     print &#34;SUCCESS proc lists &#34;,processes\n# else:\n#     print &#34;Failed&#34;\n#\n#\n# total_resources = [10, 10, 8, 5]\n# processes=[]\n# b = Bankers(total_resources)\n# max = [\n#         [10, 8, 2,5],\n#         [6, 1, 3,1],\n#         [3, 1, 4,2],\n#         [5, 4, 2,1]\n#     ]\n# allocated = [\n#         [3, 0, 0,3],\n#         [1, 1, 2,0],\n#         [2, 1, 2,1],\n#         [0, 0, 2,0]\n#     ]\n# b.SignProcesses(max, allocated)\n# b.print_matrixes()\n# result=b.Execute()\n# if result:\n#     print &#34;SUCCESS proc lists &#34;,processes\n# else:\n#     print &#34;Failed&#34;</pre>\n<p></p>", "created": "2015-05-11T08:05:03Z", "bucket_order": 261, "bucket_name": "Week 5/10 - 5/16", "type": "followup", "tag_good": [], "uid": "i6vkh2uqu3V", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i9jltk2og2h2j1", "updated": "2015-05-11T08:05:03Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>计25 路云飞 2012011359</p>\n<p>https://github.com/december/os_data/blob/master/banker.py</p>", "created": "2015-05-11T09:11:44Z", "bucket_order": 261, "bucket_name": "Week 5/10 - 5/16", "type": "followup", "tag_good": [], "uid": "i718aanx0OS", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i9jo7bdhv4k3a5", "updated": "2015-05-11T09:11:44Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>计25 矣晓沅 2012011364</p>\n<p>https://github.com/MtMoon/os_exercises/blob/master/all/Banker/bankers.py</p>", "created": "2015-05-11T09:55:57Z", "bucket_order": 261, "bucket_name": "Week 5/10 - 5/16", "type": "followup", "tag_good": [], "uid": "i6t6y9snjx2", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i9jps6jhuo23zx", "updated": "2015-05-11T09:55:57Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>丁延卓 2012011395</p>\n<p>马晓彬 2012011402</p>\n<pre>import os\nimport random\nimport numpy as np\nimport itertools\n\nclass Bankers(object):\n    def __init__(self, totalResource):\n        #initiating\n        self.RESOURCE = totalResource\n\n    def SignProcesses(self, max_, allocated_):\n        self.max = max_\n        self.allocated = allocated_\n        self.need = self.CalcNeed()\n        self.avaliable = self.CalcAvaliable()\n        self.finished = [False]*len(self.allocated)\n\n    def Difference(self,a,b):\n        #return matrix subtracted from a by b\n        res = []\n        for i in range(len(a)):\n            tmp = []\n            for j in range(len(a[i])):\n                tmp.append(a[i][j]-b[i][j])\n            res.append(tmp)\n        return res\n\n    def CalcNeed(self):\n        #calc request by subtracting signed matrix from max matrix\n        return self.Difference(self.max,self.allocated)\n\n    def CalcAvaliable(self):\n        &#34;&#34;&#34;Calc Avaliable Resource&#34;&#34;&#34;\n        a = self.allocated\n        res = []\n        for j in range(len(a[0])):\n            tmp = 0\n            for i in range(len(a)):\n                tmp &#43;= a[i][j]\n            res.append(self.RESOURCE[j] - tmp)\n        return res\n\n    def ExecuteProcess(self,index):\n\n        #check if less avaliable than Request\n        # YOUR CODE, 2012011395\n        ok = True\n        for i in range(len(self.avaliable)):\n            if self.need[index][i] &gt; self.avaliable[i]:\n                ok = False\n                break\n        #check END here\n        if ok == False:\n            return False\n        else:\n            for i in range(len(self.avaliable)):\n                self.allocated[index][i] &#43;= self.need[index][i]\n                self.avaliable[i] -= self.need[index][i]\n                self.need[index][i] = 0\n            return True\n        #allocating what they need.\n        # YOUR CODE, 2012011395\n        #allocating END here\n        #pass\n\n    def TempSafeCheckAfterRelease(self):\n        #check if at least one request can be done after previous process done. not check whole sequances.\n        #if every element of Requests can&#39;t accepted after previous process done, this mean it is not safe state\n        # YOUR CODE, 2012011395\n        #for i in range(len(self.allocated)):\n        #print(len(self.allocated))\n        for i in range(len(self.max)):\n            ok = True\n            for j in range(len(self.max[i])):\n                if self.need[i][j] &lt; self.avaliable[j]:\n                    ok = False\n                    break\n            if ok == True:\n                return True\n                \n        return False\n        #check END here\n        #pass\n\n    def print_matrixes(self):\n        print &#34;_____________________________________________&#34;\n        print &#34;MAX\\t\\tAllocated\\tNeed&#34;\n        for idx in range(len(self.max)):\n            print &#34;%s\\t%s\\t%s&#34; % (self.max[idx],self.allocated[idx], self.need[idx])\n        print &#34;_____________________________________________&#34;\n        print &#34;Resources:&#34;\n        print &#34;Total: %s\\tAvailable: %s\\n&#34; % (self.RESOURCE, self.avaliable)\n\n    def ReleasingProcess(self,index):\n        for i in range(0,len(self.RESOURCE)):\n            self.finished[index] = True\n            self.allocated[index][i] = 0\n        self.avaliable = self.CalcAvaliable()\n\n    def Execute(self):\n        i = 0\n        # get all permutation of processes\n        perm = itertools.permutations(range(procnum), procnum)\n        permArray = np.asarray(list(perm))\n\n        for arr in permArray:\n            for i in arr:\n                if self.finished[i] == False:\n                    print &#34;Executing...&#34;\n                    print &#34;Request: &#34;\n                    print self.need[i]\n                    #check if less avaliable than Request\n                    if self.ExecuteProcess(i):\n                        print &#34;Dispatching Done...&#34;\n\n                        self.print_matrixes()\n\n                        print &#34;-----Releasing Process------&#34;\n\n                        self.ReleasingProcess(i)\n\n                        self.print_matrixes()\n\n                        #check if at least one request can be done after previous process done. not check whole sequances.\n                        #if every element of Requests can&#39;t accepted after previous process done, this mean it is not safe state\n                        if not (self.TempSafeCheckAfterRelease()):\n                            print &#34;SAFE STATE: NOT SAFE - There are no sequances can avoid Deadlock&#34;\n                            return False\n                        processes.append(i)\n                    else:\n                        print &#34;HOLD: not enough Resource&#34;\n\n                if i == len(self.allocated)-1:\n                    i = 0\n                else:\n                    i &#43;= 1\n\n                check = True\n                for k in range(0,len(self.allocated)):\n                    if self.finished[k] == False:\n                        check = False\n                        break\n                if check == True:\n                    return True\n                    break\n        #every permutation of processes is false\n        return False\n\ndef getmax():\n    res = []\n    for j in range(procnum):\n        tmp = []\n        for i in range(len(total_resources)):\n            randnum=random.random()\n            remain_max=0\n            if j &gt;0:\n                remain_max=total_resources[i]\n                for k in range(j):\n                    remain_max=remain_max-res[k][i]\n                if remain_max &lt; 0:\n                    remain_max=0\n            else:\n                remain_max=total_resources[i]\n            tmp.append((int)(randnum*remain_max*0.8))\n        res.append(tmp)\n    return res\n\ndef getallocated():\n    res = []\n    for j in range(procnum):\n        tmp = []\n        for i in range(len(total_resources)):\n            randnum=random.random()\n            remain=0\n            if j &gt;0:\n                remain=max[j][i]\n                for k in range(j):\n                    remain=remain-res[k][i]\n                if remain &lt; 0:\n                    remain=0\n            else:\n                remain=max[j][i]\n            tmp.append((int)(randnum*remain))\n        res.append(tmp)\n    return res\n\nprint &#34;start here&#34;\n# random seed\nseed = 2\nrandom.seed(seed)\n# the number of process list\nprocnum = 3\n# the number of type of resource\nresnum =  4\n# the max total value of resource\nrestotalval = 30\n# the total resources list\ntotal_resources=[]\n# the total processes\nprocesses=[]\n# set the real total value of resource in total_resources\nfor i in range(resnum):\n    total_resources.append((int)(restotalval*random.random()))\n# init the Banker\nb = Bankers(total_resources)\n# get the max request values of resources from process\nmax=getmax()\n# get the already gotted values of resources from process\nallocated=getallocated()\n# init need matrix, available vector\nb.SignProcesses(max, allocated)\n# print all theses matrixes\nb.print_matrixes()\n# executing Banker algorithm\nresult=b.Execute()\n# show results\nif result:\n    print &#34;SUCCESS proc lists &#34;,processes\nelse:\n    print &#34;Failed&#34;\n\n# total_resources = [6, 5, 7, 6]\n# processes=[]\n# b = Bankers(total_resources)\n#\n# max = [\n#     [3, 3, 2, 2],\n#     [1, 2, 3, 4],\n#     [1, 3, 5, 0],\n# ]\n# allocated = [\n#     [1, 2, 2, 1],\n#     [1, 0, 3, 3],\n#     [1, 2, 1, 0],\n# ]\n#\n# b.SignProcesses(max, allocated)\n# b.print_matrixes()\n# result=b.Execute()\n# if result:\n#     print &#34;SUCCESS proc lists &#34;,processes\n# else:\n#     print &#34;Failed&#34;\n#\n#\n# total_resources = [10, 10, 8, 5]\n# processes=[]\n# b = Bankers(total_resources)\n# max = [\n#         [10, 8, 2,5],\n#         [6, 1, 3,1],\n#         [3, 1, 4,2],\n#         [5, 4, 2,1]\n#     ]\n# allocated = [\n#         [3, 0, 0,3],\n#         [1, 1, 2,0],\n#         [2, 1, 2,1],\n#         [0, 0, 2,0]\n#     ]\n# b.SignProcesses(max, allocated)\n# b.print_matrixes()\n# result=b.Execute()\n# if result:\n#     print &#34;SUCCESS proc lists &#34;,processes\n# else:\n#     print &#34;Failed&#34;</pre>\n<p></p>", "created": "2015-05-11T12:29:41Z", "bucket_order": 261, "bucket_name": "Week 5/10 - 5/16", "type": "followup", "tag_good": [], "uid": "i7w0q2p8Cmz", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i9jv9w5yp0b7ko", "updated": "2015-05-11T12:29:41Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>计25  董欣  2012011361</p>\n<pre>import os<br />import random<br />import numpy as np<br />import itertools<br /><br />class Bankers(object):<br />    def __init__(self, totalResource):<br />        #initiating<br />        self.RESOURCE = totalResource<br /><br />    def SignProcesses(self, max_, allocated_):<br />        self.max = max_<br />        self.allocated = allocated_<br />        self.need = self.CalcNeed()<br />        self.avaliable = self.CalcAvaliable()<br />        self.finished = [False]*len(self.allocated)<br /><br />    def Difference(self,a,b):<br />        #return matrix subtracted from a by b<br />        res = []<br />        for i in range(len(a)):<br />            tmp = []<br />            for j in range(len(a[i])):<br />                tmp.append(a[i][j]-b[i][j])<br />            res.append(tmp)<br />        return res<br /><br />    def CalcNeed(self):<br />        #calc request by subtracting signed matrix from max matrix<br />        return self.Difference(self.max,self.allocated)<br /><br />    def CalcAvaliable(self):<br />        &#34;&#34;&#34;Calc Avaliable Resource&#34;&#34;&#34;<br />        a = self.allocated<br />        res = []<br />        for j in range(len(a[0])):<br />            tmp = 0<br />            for i in range(len(a)):<br />                tmp &#43;= a[i][j]<br />            res.append(self.RESOURCE[j] - tmp)<br />        return res<br /><br />    def ExecuteProcess(self,index):<br />        #check if less avaliable than Request<br />        # YOUR CODE, 2012011361<br />        #check END here<br />        Need = self.need[index]<br />        Avaliable = self.avaliable<br />        flag = True<br />        for i in range(len(Avaliable)):<br />            if Avaliable[i] &lt; Need[i]:<br />                falg = False<br />                break<br />        #allocating what they need.<br />        # YOUR CODE, 2012011361<br />        #allocating END here<br />        if flag == True:<br />            for j in range(len(Need)):<br />                self.allocated[index][j] &#43;= Need[j]<br />                self.avaliable[j] -= Need[j]<br />                Need[j] = 0<br />            self.need[index] = Need;<br />        if flag:<br />            return True<br />        if not flag:<br />            return False<br />        #pass<br /><br />    def TempSafeCheckAfterRelease(self):<br />        #check if at least one request can be done after previous process done. not check whole sequances.<br />        #if every element of Requests can&#39;t accepted after previous process done, this mean it is not safe state<br />        # YOUR CODE, 2012011361<br />        #check END here<br />        flag = True<br />        Finish = self.finished<br />        Avaliable = self.avaliable<br />       <br />        for t in range(len(self.max)):<br />            if Finish[t] == False:<br />                flag = False<br />        if flag == True:<br />            return True<br />        flag = True<br />        for i in range(len(self.need)):<br />            if Finish[i] == False:<br />                for j in range(len(self.need[i])):<br />                    if (Avaliable[j] &lt; self.need[i][j]):<br />                        flag = False<br />                        break<br />                if flag == True:<br />                    return True<br />        return False<br /><br />    def print_matrixes(self):<br />        print &#34;_____________________________________________&#34;<br />        print &#34;MAX\\t\\tAllocated\\tNeed&#34;<br />        for idx in range(len(self.max)):<br />            print &#34;%s\\t%s\\t%s&#34; % (self.max[idx],self.allocated[idx], self.need[idx])<br />        print &#34;_____________________________________________&#34;<br />        print &#34;Resources:&#34;<br />        print &#34;Total: %s\\tAvailable: %s\\n&#34; % (self.RESOURCE, self.avaliable)<br /><br />    def ReleasingProcess(self,index):<br />        for i in range(0,len(self.RESOURCE)):<br />            self.finished[index] = True<br />            self.allocated[index][i] = 0<br />        self.avaliable = self.CalcAvaliable()<br /><br />    def Execute(self):<br />        i = 0<br />        # get all permutation of processes<br />        perm = itertools.permutations(range(procnum), procnum)<br />        permArray = np.asarray(list(perm))<br /><br />        for arr in permArray:<br />            for i in arr:<br />                if self.finished[i] == False:<br />                    print &#34;Executing...&#34;<br />                    print &#34;Request: &#34;<br />                    print self.need[i]<br />                    #check if less avaliable than Request<br />                    if self.ExecuteProcess(i):<br />                        print &#34;Dispatching Done...&#34;<br /><br />                        self.print_matrixes()<br /><br />                        print &#34;-----Releasing Process------&#34;<br /><br />                        self.ReleasingProcess(i)<br /><br />                        self.print_matrixes()<br /><br />                        #check if at least one request can be done after previous process done. not check whole sequances.<br />                        #if every element of Requests can&#39;t accepted after previous process done, this mean it is not safe state<br />                        if not (self.TempSafeCheckAfterRelease()):<br />                            print &#34;SAFE STATE: NOT SAFE - There are no sequances can avoid Deadlock&#34;<br />                            return False<br />                        processes.append(i)<br />                    else:<br />                        print &#34;HOLD: not enough Resource&#34;<br /><br />                if i == len(self.allocated)-1:<br />                    i = 0<br />                else:<br />                    i &#43;= 1<br /><br />                check = True<br />                for k in range(0,len(self.allocated)):<br />                    if self.finished[k] == False:<br />                        check = False<br />                        break<br />                if check == True:<br />                    return True<br />                    break<br />        #every permutation of processes is false<br />        return False<br /><br />def getmax():<br />    res = []<br />    for j in range(procnum):<br />        tmp = []<br />        for i in range(len(total_resources)):<br />            randnum=random.random()<br />            remain_max=0<br />            if j &gt;0:<br />                remain_max=total_resources[i]<br />                for k in range(j):<br />                    remain_max=remain_max-res[k][i]<br />                if remain_max &lt; 0:<br />                    remain_max=0<br />            else:<br />                remain_max=total_resources[i]<br />            tmp.append((int)(randnum*remain_max*0.8))<br />        res.append(tmp)<br />    return res<br /><br />def getallocated():<br />    res = []<br />    for j in range(procnum):<br />        tmp = []<br />        for i in range(len(total_resources)):<br />            randnum=random.random()<br />            remain=0<br />            if j &gt;0:<br />                remain=max[j][i]<br />                for k in range(j):<br />                    remain=remain-res[k][i]<br />                if remain &lt; 0:<br />                    remain=0<br />            else:<br />                remain=max[j][i]<br />            tmp.append((int)(randnum*remain))<br />        res.append(tmp)<br />    return res<br /><br />print &#34;start here&#34;<br /># random seed<br />seed = 2<br />random.seed(seed)<br /># the number of process list<br />procnum = 3<br /># the number of type of resource<br />resnum =  4<br /># the max total value of resource<br />restotalval = 30<br /># the total resources list<br />total_resources=[]<br /># the total processes<br />processes=[]<br /># set the real total value of resource in total_resources<br />for i in range(resnum):<br />    total_resources.append((int)(restotalval*random.random()))<br /># init the Banker<br />b = Bankers(total_resources)<br /># get the max request values of resources from process<br />max=getmax()<br /># get the already gotted values of resources from process<br />allocated=getallocated()<br /># init need matrix, available vector<br />b.SignProcesses(max, allocated)<br /># print all theses matrixes<br />b.print_matrixes()<br /># executing Banker algorithm<br />result=b.Execute()<br /># show results<br />if result:<br />    print &#34;SUCCESS proc lists &#34;,processes<br />else:<br />    print &#34;Failed&#34;<br /><br /># total_resources = [6, 5, 7, 6]<br /># processes=[]<br /># b = Bankers(total_resources)<br />#<br /># max = [<br />#     [3, 3, 2, 2],<br />#     [1, 2, 3, 4],<br />#     [1, 3, 5, 0],<br /># ]<br /># allocated = [<br />#     [1, 2, 2, 1],<br />#     [1, 0, 3, 3],<br />#     [1, 2, 1, 0],<br /># ]<br />#<br /># b.SignProcesses(max, allocated)<br /># b.print_matrixes()<br /># result=b.Execute()<br /># if result:<br />#     print &#34;SUCCESS proc lists &#34;,processes<br /># else:<br />#     print &#34;Failed&#34;<br />#<br />#<br /># total_resources = [10, 10, 8, 5]<br /># processes=[]<br /># b = Bankers(total_resources)<br /># max = [<br />#         [10, 8, 2,5],<br />#         [6, 1, 3,1],<br />#         [3, 1, 4,2],<br />#         [5, 4, 2,1]<br />#     ]<br /># allocated = [<br />#         [3, 0, 0,3],<br />#         [1, 1, 2,0],<br />#         [2, 1, 2,1],<br />#         [0, 0, 2,0]<br />#     ]<br /># b.SignProcesses(max, allocated)<br /># b.print_matrixes()<br /># result=b.Execute()<br /># if result:<br />#     print &#34;SUCCESS proc lists &#34;,processes<br /># else:<br />#     print &#34;Failed&#34;</pre>\n<p></p>", "created": "2015-05-12T10:48:21Z", "bucket_order": 261, "bucket_name": "Week 5/10 - 5/16", "type": "followup", "tag_good": [], "uid": "i6uaz13iyeM", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "i9l73f921hjz2", "updated": "2015-05-12T10:48:21Z", "config": {}}], "tag_good_arr": [], "id": "i9ji4n4o57c6p3", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 16, "num_favorites": 0, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643167760578, "default_anonymity": "no"}, "error": null, "aid": "kyuznqgyuew5l4"}