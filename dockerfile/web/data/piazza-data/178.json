{"result": {"history_size": 1, "folders": ["lab2"], "nr": 178, "data": {"embed_links": []}, "created": "2015-03-25T13:42:59Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "stud", "when": "2015-03-25T13:42:59Z", "data": "i7os73vu9vtgo", "type": "create", "uid_a": "a_0"}, {"to": "i7os73vrfq0gn", "uid": "hdjoucuyb836fq", "anon": "no", "when": "2015-03-26T00:27:10Z", "data": "i7pf7jevfpo7mr", "type": "i_answer"}, {"uid": "hdjoucuyb836fq", "anon": "no", "when": "2015-03-26T00:40:14Z", "data": "i7pfoc7gy315z9", "type": "i_answer_update"}], "bucket_name": "Today", "history": [{"anon": "stud", "uid_a": "a_0", "subject": "逻辑/线性/物理地址  实在太太太难懂了", "created": "2015-03-25T13:42:59Z", "content": "<p>请教几个问题&#xff1a;</p>\n<p></p>\n<p></p>\n<p>1。为什么要有KERNBASE = C0000000&#xff1f; 这个数有什么特殊意义吗&#xff1f;</p>\n<p></p>\n<p>2。既然&#xff1a;virt addr = linear addr = phy addr &#43; 0xC0000000&#xff0c;那么为什么ucore还需要页表和段表&#xff1f;想转的时候直接做一下加减法不就ok了&#xff1f;这个映射关系应该以后会随着页的alloc和free而变吧&#xff1f;</p>\n<p></p>\n<p>3。 实验指导书上写了lab2的实验过程&#xff1a;</p>\n<p></p>\n<ol><li>初始化物理内存页管理器框架pmm_manager&#xff1b;</li><li>建立空闲的page链表&#xff0c;这样就可以分配以页&#xff08;4KB&#xff09;为单位的空闲内存了&#xff1b;</li><li>检查物理内存页分配算法&#xff1b;</li><li>为确保切换到分页机制后&#xff0c;代码能够正常执行&#xff0c;先建立一个临时二级页表&#xff1b;</li><li>建立一一映射关系的二级页表&#xff1b;</li><li>使能分页机制&#xff1b;</li><li>从新设置全局段描述符表&#xff1b;</li><li>取消临时二级页表&#xff1b;</li><li>检查页表建立是否正确</li></ol>\n<p></p>\n<p>     求解释&#xff1a;</p>\n<p>     &#xff08;1&#xff09;第4、5步的临时页表和一一映射的页表&#xff0c;是同一个吗&#xff1f;</p>\n<p></p>\n<p>      &#xff08;2&#xff09;第7步的目的是什么&#xff1f;</p>\n<p></p>\n<p>      &#xff08;3&#xff09;第8步的目的是什么&#xff1f;</p>\n<p></p>\n<p>      &#xff08;4&#xff09;第8步取消了临时二级页表&#xff0c;那第9步检查的是啥&#xff1f;</p>"}], "type": "question", "tags": ["lab2", "student"], "tag_good": [], "unique_views": 221, "children": [{"history_size": 2, "folders": [], "data": {"embed_links": []}, "created": "2015-03-26T00:27:10Z", "bucket_order": 3, "tag_endorse": [{"role": "", "name": "Object Ho", "endorser": {}, "admin": false, "photo": null, "id": "hsfa0sawctb6v4", "photo_url": null, "published": true, "us": false, "class_sections": ["课程设计_i5j09fnsl7k5x0", "清华学生_i5j09fnsl7k5x0"], "facebook_id": null}, {"role": "", "name": "郭子雷", "endorser": {}, "admin": false, "photo": null, "id": "i78odcf1aiM", "photo_url": null, "us": false, "facebook_id": null}, {"role": "student", "name": "MoXiGeTuFei", "endorser": {}, "admin": false, "photo": null, "id": "i71i9kso8Gp", "photo_url": null, "published": true, "us": false, "class_sections": ["清华学生_i5j09fnsl7k5x0"], "facebook_id": null}, {"role": "student", "name": "sihouzi21c", "endorser": {}, "admin": false, "photo": null, "id": "k5s907llk4y3g6", "photo_url": null, "published": true, "us": false, "facebook_id": null}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hdjoucuyb836fq", "subject": "", "created": "2015-03-26T00:40:14Z", "content": "<p>1、KERNBASE只是人为规定而已。内核需要将所有内存映射到所有进程的虚拟地址空间&#xff0c;这样进程在发起系统调用进入内核时不需要更换页表。ucore选择将内存映射到虚拟地址空间的高位&#xff08;KERNBASE以上&#xff09;&#xff0c;使得应用程序可用的虚拟地址空间仍然从0开始。至于选择0xC0000000还是0xDEADBEEF&#xff0c;只是实现时的一个取值而已。</p>\n<p></p>\n<p>2、virt addr = phy addr &#43; 0xC0000000只对内存的一一映射成立&#xff0c;每个进程所用的物理内存则是按需分配&#xff0c;虚拟地址和物理地址之间没有固定的规则&#xff0c;因此仍然需要页表进行地址转换&#xff0c;更何况页表还有权限管理的功能。至于段表&#xff0c;由于页表在内存管理上已提供了足够的能力&#xff0c;很少有系统再使用段表了&#xff1b;但是x86系统上没有办法在使能页表的同时禁用段表&#xff0c;所以段表被设置成永远进行一一映射&#xff0c;也就是virt addr = linear addr。</p>\n<p></p>\n<p>3、关于这个过程&#xff0c;首先需要清楚“页表”和“二级页表”指的是不同的东西&#xff0c;“临时二级页表”不是“二级页表”&#xff0c;“检查页表”也不是“检查二级页表”&#xff0c;混淆这两个概念的话&#xff0c;很多步骤是看不明白的。其次&#xff0c;是清楚ucore最终使用x86 CPU段页式内存管理的方式&#xff0c;是virt addr = linear addr = phy addr &#43; 0xC0000000&#xff08;也就是只用页表&#xff09;。由于CPU刚进入保护模式时的状态是启用了段表&#xff0c;没有启用页表&#xff0c;所以ucore需要对CPU的内存管理进行细致的配置&#xff0c;才能达到virt addr = linear addr = phy addr &#43; 0xC0000000的目标&#xff0c;而这些配置就是lab2中所涉及的内容。</p>\n<p></p>\n<p>另外附上<a href=\"https://www.cs.rutgers.edu/~pxk/416/notes/10-paging.html\">https://www.cs.rutgers.edu/~pxk/416/notes/10-paging.html</a>里找到的x86_32段页式管理的图示。</p>\n<p></p>\n<p><img src=\"/img/178-3949ce3660b73f4c.png\" /></p>"}, {"anon": "no", "uid": "hdjoucuyb836fq", "subject": "", "created": "2015-03-26T00:27:10Z", "content": "<p>1、KERNBASE只是人为规定而已。内核需要将所有内存映射到所有进程的虚拟地址空间&#xff0c;这样进程在发起系统调用进入内核时不需要更换页表。ucore选择将内存映射到虚拟地址空间的高位&#xff08;KERNBASE以上&#xff09;&#xff0c;使得应用程序可用的虚拟地址空间仍然从0开始。至于选择0xC0000000还是0xDEADBEEF&#xff0c;只是实现时的一个取值而已。</p>\n<p></p>\n<p>2、virt addr = phy addr &#43; 0xC0000000只对内存的一一映射成立&#xff0c;每个进程所用的物理内存则是按需分配&#xff0c;虚拟地址和物理地址之间没有固定的规则&#xff0c;因此仍然需要页表进行地址转换&#xff0c;更何况页表还有权限管理的功能。至于段表&#xff0c;由于页表在内存管理上已提供了足够的能力&#xff0c;很少有系统再使用段表了&#xff1b;但是x86系统上没有办法在使能页表的同时禁用段表&#xff0c;所以段表被设置成永远进行一一映射&#xff0c;也就是virt addr = linear addr。</p>\n<p></p>\n<p>3、关于这个过程&#xff0c;首先需要清楚“页表”和“二级页表”指的是不同的东西&#xff0c;“临时二级页表”不是“二级页表”&#xff0c;“检查页表”也不是“检查二级页表”&#xff0c;混淆这两个概念的话&#xff0c;很多步骤是看不明白的。其次&#xff0c;是清楚ucore最终使用x86 CPU段页式内存管理的方式&#xff0c;是virt addr = linear addr = phy addr &#43; 0xC0000000&#xff08;也就是只用页表&#xff09;。由于CPU刚进入保护模式时的状态是启用了段表&#xff0c;没有启用页表&#xff0c;所以ucore需要对CPU的内存管理进行细致的配置&#xff0c;才能达到virt addr = linear addr = phy addr &#43; 0xC0000000的目标&#xff0c;而这些配置就是lab2中所涉及的内容。</p>"}], "type": "i_answer", "tag_endorse_arr": ["hsfa0sawctb6v4", "i78odcf1aiM", "i71i9kso8Gp", "k5s907llk4y3g6"], "children": [], "id": "i7pf7jeembn7mq", "config": {}, "is_tag_endorse": false}], "tag_good_arr": [], "no_answer": 0, "id": "i7os73vrfq0gn", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 5, "num_favorites": 6, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643167430363, "default_anonymity": "no"}, "error": null, "aid": "kyuzgnobli06bu"}