{"result": {"folders": ["q&amp;a"], "nr": 661, "data": {"embed_links": []}, "created": "2016-03-07T05:17:48Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"uid": "i6ub4vwhQXd", "anon": "no", "when": "2016-03-07T05:17:48Z", "data": "ilhjdvy0dlp2cd", "type": "create"}, {"to": "ilhjdvxo6ck2cc", "anon": "full", "when": "2016-03-07T06:52:47Z", "type": "followup", "uid_a": "a_0"}, {"to": "ilhjdvxo6ck2cc", "uid": "i0dlq4m0wjn5eo", "anon": "no", "when": "2016-03-07T11:29:16Z", "type": "feedback"}, {"to": "ilhjdvxo6ck2cc", "anon": "full", "when": "2016-03-07T11:54:05Z", "type": "feedback", "uid_a": "a_0"}, {"to": "ilhjdvxo6ck2cc", "anon": "full", "when": "2016-03-07T12:10:30Z", "type": "feedback", "uid_a": "a_0"}, {"to": "ilhjdvxo6ck2cc", "uid": "i6ub4vwhQXd", "anon": "no", "when": "2016-03-07T12:21:34Z", "type": "feedback"}, {"to": "ilhjdvxo6ck2cc", "uid": "i6uqzf449em3ex", "anon": "no", "when": "2016-03-08T06:39:57Z", "data": "ilj1re0tgsm1vn", "type": "s_answer"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "i6ub4vwhQXd", "subject": "Buddy System需要找到满足条件的最小空闲内存么&#xff1f;", "created": "2016-03-07T05:17:48Z", "content": "<p>在用Buddy System进行内存分配时&#xff0c;如果有一个128K的空闲块在一个64K的空闲块前&#xff0c;此时需要分配一个64K的内存&#xff0c;那么会分割128K那个空闲块&#xff0c;还是直接使用后面那个64K的空闲块&#xff1f;如果需要满足最优的方案(直接用64K的那块)的话&#xff0c;貌似LogN的时间内出不来结果&#xff1f;</p>"}], "type": "question", "tags": ["q&amp;a", "student"], "tag_good": [], "unique_views": 127, "children": [{"anon": "full", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>根据我对buddy system的理解, 如果需要分配64K的内存块, 应该会先从不小于64K的内存块链表上查找有没有空闲块吧? </p>\n<p>而不会出现&#34;有一个128K的空闲块在一个64K的空闲块前&#34;吧?</p>", "created": "2016-03-07T06:52:47Z", "bucket_order": 214, "bucket_name": "Week 3/6 - 3/12", "type": "followup", "tag_good": [], "uid_a": "a_0", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>会的啊&#xff0c;用线段树实现的话&#xff0c;如果128K的空闲在左子树&#xff0c;64K的空闲在右子树&#xff0c;那么根据一般的遍历逻辑&#xff0c;就会把左边的128K分割成两个64K&#xff0c;并将其中一个分配出去。</p>", "created": "2016-03-07T11:29:16Z", "bucket_order": 214, "bucket_name": "Week 3/6 - 3/12", "type": "feedback", "tag_good": [], "uid": "i0dlq4m0wjn5eo", "children": [], "tag_good_arr": [], "id": "ilhwnl7jqbl5gx", "updated": "2016-03-07T11:29:16Z", "config": {}}, {"anon": "full", "folders": [], "data": {"embed_links": null}, "subject": "<p>为什么要用线段树呢, 用链表不就行了吗? 而且时间常数更小?</p>", "created": "2016-03-07T11:54:05Z", "bucket_order": 214, "bucket_name": "Week 3/6 - 3/12", "type": "feedback", "tag_good": [], "uid_a": "a_0", "children": [], "tag_good_arr": [], "id": "ilhxjirgay6zn", "updated": "2016-03-07T11:54:05Z", "config": {}}, {"anon": "full", "folders": [], "data": {"embed_links": null}, "subject": "<p>抱歉, 上一句说的不太对, 看了老师给的这个链接<a href=\"http://coolshell.cn/articles/10427.html,\">http://coolshell.cn/articles/10427.html,</a> 貌似的确是要分割128K的块</p>", "created": "2016-03-07T12:10:30Z", "bucket_order": 214, "bucket_name": "Week 3/6 - 3/12", "type": "feedback", "tag_good": [], "uid_a": "a_0", "children": [], "tag_good_arr": [], "id": "ilhy4m5qgte6i0", "updated": "2016-03-07T12:10:30Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>感觉还是比较模糊&#xff0c;这个链接里面的图示样例是分割64k那块的&#xff0c;但是代码是分割了128K那块&#xff0c;单纯用链表可以做到logN么&#xff1f;</p>", "created": "2016-03-07T12:21:34Z", "bucket_order": 214, "bucket_name": "Week 3/6 - 3/12", "type": "feedback", "tag_good": [], "uid": "i6ub4vwhQXd", "children": [], "tag_good_arr": [], "id": "ilhyiuvvmwk6ce", "updated": "2016-03-07T12:21:34Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "ilhms13fe667id", "updated": "2016-03-07T06:52:47Z", "config": {}}, {"folders": [], "data": {"embed_links": []}, "children": [], "created": "2016-03-08T06:39:57Z", "bucket_order": 3, "tag_endorse": [{"role": "student", "name": "Alex Wang", "endorser": {}, "admin": false, "photo": null, "id": "ie7xy4gmt1p1pp", "photo_url": null, "published": true, "us": false, "class_sections": ["课程设计_i5j09fnsl7k5x0", "清华学生_i5j09fnsl7k5x0"], "facebook_id": null}], "bucket_name": "Today", "id": "ilj1re0pn8t1vm", "history": [{"anon": "no", "uid": "i6uqzf449em3ex", "subject": "", "created": "2016-03-08T06:39:57Z", "content": "<p>参考 <a href=\"http://blog.tek-life.com/%E8%AE%A4%E8%AF%86linux%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-buddy-system/\">http://blog.tek-life.com/%E8%AE%A4%E8%AF%86linux%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-buddy-system/</a></p>\n<p></p>\n<pre>buddy system根据参数order&#xff0c;在要求的zone中查找对应的链表。若该order的双向链表非空&#xff0c;则把该双向链表上的第一个block从buddy system中脱链&#xff0c;同时更新该双向链表上的block的数量&#xff0c;完成内存分配。若该order的双向链表为空&#xff0c;则查找order&#43;1的双向链表&#xff0c;如果order&#43;1的双向链表为空&#xff0c;则查找order&#43;2的双向链表&#xff0c;直到查找到。</pre>\n<p>所以应该会试用64K的空闲块&#xff0c;由于是链表所以不存在128K在64K内存块前的问题&#xff0c;因为两个block不在一个链表里。</p>\n<p></p>\n<p>复杂度分析的话&#xff0c;如果是你说的这种情况&#xff0c;应该是O(1)的&#xff0c;因为直接从64K对应的链表里取了一个block。</p>\n<p>最坏情况是在一个最大order为$$M=log_2 N$$的系统中取一个最小的block&#xff0c;需要分裂O(M)次。&#xff08;每次操作为分裂order K的block为两个order K-1的block&#xff0c;一个插入链表&#xff0c;另一个继续分裂&#xff09;</p>"}], "type": "s_answer", "tag_endorse_arr": ["ie7xy4gmt1p1pp"], "config": {}, "is_tag_endorse": false}], "tag_good_arr": [], "no_answer": 0, "id": "ilhjdvxo6ck2cc", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 6, "num_favorites": 0, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643168266025, "default_anonymity": "no"}, "error": null, "aid": "kyuzykh5k1p4rc"}