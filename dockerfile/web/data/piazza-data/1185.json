{"result": {"folders": ["2018", "课堂问答", "lecture11"], "nr": 1185, "data": {"embed_links": []}, "created": "2018-04-02T03:24:13Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "hdjonbiyfs62ie", "data": "jfho7tmhtd757y", "type": "create", "when": "2018-04-02T03:24:13Z"}, {"anon": "no", "uid": "isvxeq6bspf1vn", "to": "jfho7tmc5az57x", "type": "followup", "when": "2018-04-03T01:40:53Z"}, {"anon": "no", "uid": "ietb1e89azd2e8", "to": "jfho7tmc5az57x", "type": "followup", "when": "2018-04-03T01:42:12Z"}, {"anon": "no", "uid": "isvxeq6bspf1vn", "to": "jfho7tmc5az57x", "type": "feedback", "when": "2018-04-08T05:47:06Z"}, {"anon": "no", "uid": "ietb1e89azd2e8", "to": "jfho7tmc5az57x", "type": "feedback", "when": "2018-04-09T16:39:56Z"}, {"anon": "no", "uid": "jsn9fs59DCSn", "to": "jfho7tmc5az57x", "type": "followup", "when": "2019-04-01T03:31:04Z"}, {"anon": "no", "uid": "jsld0u9sp4k3", "to": "jfho7tmc5az57x", "type": "followup", "when": "2019-04-03T14:25:53Z"}, {"anon": "no", "uid": "jsld0u9sp4k3", "to": "jfho7tmc5az57x", "type": "feedback", "when": "2019-04-03T14:27:20Z"}, {"anon": "no", "uid": "jsn9fs59DCSn", "to": "jfho7tmc5az57x", "type": "feedback", "when": "2019-04-03T15:05:50Z"}, {"anon": "no", "uid": "jsk4iwnsAnmZ", "to": "jfho7tmc5az57x", "type": "followup", "when": "2019-04-10T09:45:01Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "2018春季-第十一讲课堂实践练习", "created": "2018-04-02T03:24:13Z", "content": "<p>设计一个简化的进程管理子系统&#xff0c;可以管理并调度如下简化进程。在理解参考代码的基础上&#xff0c;完成&#xff02;YOUR CODE&#34;部分的内容。然后通过测试用例和比较自己的实现与往届同学的结果&#xff0c;评价自己的实现是否正确。可&#xff12;个人一组。</p>\n<p></p>\n<p>题目&#xff1a;<br /><a href=\"https://github.com/chyyuu/os_course_exercises/blob/2018spring/all/05-1-spoc-discussion.md#%E5%B0%8F%E7%BB%84%E6%80%9D%E8%80%83%E9%A2%98\">https://github.com/chyyuu/os_course_exercises/blob/2018spring/all/05-1-spoc-discussion.md#%E5%B0%8F%E7%BB%84%E6%80%9D%E8%80%83%E9%A2%98</a></p>\n<p></p>\n<p>往届同学的参考实现&#xff1a;<br /><a href=\"https://www.piazza.com/class/i5j09fnsl7k5x0?cid=1022\">https://piazza.com/class/i5j09fnsl7k5x0?cid=1022</a></p>\n<p></p>"}], "type": "note", "tags": ["2018", "instructor-note", "lecture11", "课堂问答"], "tag_good": [], "unique_views": 143, "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>魏钧宇 2015011263</p>", "created": "2018-04-03T01:40:53Z", "bucket_order": 107, "bucket_name": "Week 4/1 - 4/7", "type": "followup", "tag_good": [], "uid": "isvxeq6bspf1vn", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p><pre>#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\n\n# process states\nSTATE_RUNNING = &#39;RUNNING&#39;\nSTATE_READY = &#39;READY&#39;\nSTATE_DONE = &#39;DONE&#39;\n\n# members of process structure\nPROC_CODE = &#39;code_&#39;\nPROC_PC = &#39;pc_&#39;\nPROC_ID = &#39;pid_&#39;\nPROC_STATE = &#39;proc_state_&#39;\n\n# things a process can do\nDO_COMPUTE = &#39;cpu&#39;\nDO_YIELD = &#39;yld&#39;\n\n\nclass scheduler:\n    def __init__(self):\n        # keep set of instructions for each of the processes\n        self.proc_info = {}\n        return\n\n    def new_process(self):\n        proc_id = len(self.proc_info)\n        self.proc_info[proc_id] = {}\n        self.proc_info[proc_id][PROC_PC] = 0\n        self.proc_info[proc_id][PROC_ID] = proc_id\n        self.proc_info[proc_id][PROC_CODE] = []\n        self.proc_info[proc_id][PROC_STATE] = STATE_READY\n        return proc_id\n\n    def load(self, program_description):\n        proc_id = self.new_process()\n        tmp = program_description.split(&#39;:&#39;)\n        if len(tmp) != 2:\n            print &#39;Bad description (%s): Must be number &lt;x:y&gt;&#39;\n            print &#39;  where X is the number of instructions&#39;\n            print &#39;  and Y is the percent change that an instruction is CPU not YIELD&#39;\n            exit(1)\n\n        num_instructions, chance_cpu = int(tmp[0]), float(tmp[1])/100.0\n        for i in range(num_instructions):\n            if random.random() &lt; chance_cpu:\n                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)\n            else:\n                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)\n        return\n\n    #change to READY STATE, the current proc&#39;s state should be expected\n    #if pid==-1, then pid=self.curr_proc\n    def move_to_ready(self, expected, pid=-1):\n        #YOUR CODE\n        now_id = pid\n        if now_id == -1:\n            now_id = self.curr_proc\n        assert(self.proc_info[now_id][PROC_STATE] == expected)\n        self.proc_info[now_id][PROC_STATE] = STATE_READY\n        return\n\n    #change to RUNNING STATE, the current proc&#39;s state should be expected\n    def move_to_running(self, expected):\n        #YOUR CODE\n        now_id = self.curr_proc\n        assert(self.proc_info[now_id][PROC_STATE] == expected)\n        self.proc_info[now_id][PROC_STATE] = STATE_RUNNING\n        return\n\n    #change to DONE STATE, the current proc&#39;s state should be expected\n    def move_to_done(self, expected):\n        #YOUR CODE\n        now_id = self.curr_proc\n        assert(self.proc_info[now_id][PROC_STATE] == expected)\n        self.proc_info[now_id][PROC_STATE] = STATE_DONE\n\n        return\n\n    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc\n    def next_proc(self, pid=-1):\n        #YOUR CODE\n        now_id = pid\n        if now_id == -1:\n            now_id = self.curr_proc\n            \n        end = len(self.proc_info)\n        begin = 0\n        \n        for i in range(now_id&#43;1, end):\n            if (self.proc_info[i][PROC_STATE] == STATE_READY):\n                self.curr_proc = i\n                self.move_to_running(STATE_READY)\n                return\n        \n        for i in range(begin, now_id):\n            if (self.proc_info[i][PROC_STATE] == STATE_READY):\n                self.curr_proc = i\n                self.move_to_running(STATE_READY)\n                return\n        \n        if self.proc_info[self.curr_proc][PROC_STATE] == STATE_READY:\n            self.move_to_running(STATE_READY)\n\n        return\n\n    def get_num_processes(self):\n        return len(self.proc_info)\n\n    def get_num_instructions(self, pid):\n        return len(self.proc_info[pid][PROC_CODE])\n\n    def get_instruction(self, pid, index):\n        return self.proc_info[pid][PROC_CODE][index]\n\n    def get_num_active(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] != STATE_DONE:\n                num_active &#43;= 1\n        return num_active\n\n    def get_num_runnable(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] == STATE_READY or self.proc_info[pid][PROC_STATE] == STATE_RUNNING:\n                num_active &#43;= 1\n        return num_active\n\n    def space(self, num_columns):\n        for i in range(num_columns):\n            print &#39;%10s&#39; % &#39; &#39;,\n\n    def check_if_done(self):\n        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n                self.move_to_done(STATE_RUNNING)\n                self.next_proc()\n        return\n\n    def run(self):\n        clock_tick = 0\n\n        if len(self.proc_info) == 0:\n            return\n\n        # make first one active\n        self.curr_proc = 0\n        self.move_to_running(STATE_READY)\n\n        # OUTPUT: heade&#96;[rs for each column\n        print &#39;%s&#39; % &#39;Time&#39;, \n        for pid in range(len(self.proc_info)):\n            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),\n\n        print &#39;&#39;\n\n        # init statistics\n        cpu_busy = 0\n\n        while self.get_num_active() &gt; 0:\n            clock_tick &#43;= 1\n            \n            # if current proc is RUNNING and has an instruction, execute it\n            # statistics clock_tick\n            instruction_to_execute = &#39;&#39;\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                #YOUR CODE\n                instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE][0]\n                del self.proc_info[self.curr_proc][PROC_CODE][0]\n\n            # OUTPUT: print what everyone is up to\n            print &#39;%3d &#39; % clock_tick,\n            for pid in range(len(self.proc_info)):\n                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n                    print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),\n                else:\n                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),\n\n            print &#39;&#39;\n\n            # if this is an YIELD instruction, switch to ready state\n            # and add an io completion in the future\n            if instruction_to_execute == DO_YIELD:\n                self.move_to_ready(STATE_RUNNING)\n                self.next_proc()\n\n            # ENDCASE: check if currently running thing is out of instructions\n            self.check_if_done()\n        return (clock_tick)\n        \n#\n# PARSE ARGUMENTS\n#\n\nparser = OptionParser()\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0, help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)\nparser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,\n                  help=&#39;a comma-separated list of processes to run, in the form X1:Y1,X2:Y2,... where X is the number of instructions that process should run, and Y the chances (from 0 to 100) that an instruction will use the CPU or issue an YIELD&#39;,\n                  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)\nparser.add_option(&#39;-p&#39;, &#39;--printstats&#39;, help=&#39;print statistics at end; only useful with -c flag (otherwise stats are not printed)&#39;, action=&#39;store_true&#39;, default=False, dest=&#39;print_stats&#39;)\n\n(options, args) = parser.parse_args()\n\nrandom.seed(options.seed)\n\ns = scheduler()\n\n# example process description (10:100,10:100)\nfor p in options.process_list.split(&#39;,&#39;):\n    s.load(p)\n\n\nprint &#39;Produce a trace of what would happen when you run these processes:&#39;\nfor pid in range(s.get_num_processes()):\n    print &#39;Process %d&#39; % pid\n    for inst in range(s.get_num_instructions(pid)):\n        print &#39;  %s&#39; % s.get_instruction(pid, inst)\n    print &#39;&#39;\n\nprint &#39;Important behaviors:&#39;\nprint &#39;  System will switch when the current process is FINISHED or ISSUES AN YIELD&#39;\n\n(clock_tick) = s.run()\n\nif options.print_stats:\n    print &#39;&#39;\n    print &#39;Stats: Total Time %d&#39; % clock_tick\n    print &#39;&#39;</pre>\n<p></p>", "created": "2018-04-08T05:47:06Z", "bucket_order": 106, "bucket_name": "Week 4/8 - 4/14", "type": "feedback", "tag_good": [], "uid": "isvxeq6bspf1vn", "children": [], "tag_good_arr": [], "id": "jfqdyoswztz5iv", "updated": "2018-04-08T05:47:06Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "jfizysdss7w5rw", "updated": "2018-04-03T01:40:53Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>樊立杰 2014011546</p>", "created": "2018-04-03T01:42:12Z", "bucket_order": 107, "bucket_name": "Week 4/1 - 4/7", "type": "followup", "tag_good": [], "uid": "ietb1e89azd2e8", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p><pre>#! /usr/bin/env python<br /><br />import sys<br />from optparse import OptionParser<br />import random<br /><br /># process states<br />STATE_RUNNING = &#39;RUNNING&#39;<br />STATE_READY = &#39;READY&#39;<br />STATE_DONE = &#39;DONE&#39;<br /><br /># members of process structure<br />PROC_CODE = &#39;code_&#39;<br />PROC_PC = &#39;pc_&#39;<br />PROC_ID = &#39;pid_&#39;<br />PROC_STATE = &#39;proc_state_&#39;<br /><br /># things a process can do<br />DO_COMPUTE = &#39;cpu&#39;<br />DO_YIELD = &#39;yld&#39;<br /><br /><br />class scheduler:<br />    def __init__(self):<br />        # keep set of instructions for each of the processes<br />        self.proc_info = {}<br />        return<br /><br />    def new_process(self):<br />        proc_id = len(self.proc_info)<br />        self.proc_info[proc_id] = {}<br />        self.proc_info[proc_id][PROC_PC] = 0<br />        self.proc_info[proc_id][PROC_ID] = proc_id<br />        self.proc_info[proc_id][PROC_CODE] = []<br />        self.proc_info[proc_id][PROC_STATE] = STATE_READY<br />        return proc_id<br /><br />    def load(self, program_description):<br />        proc_id = self.new_process()<br />        tmp = program_description.split(&#39;:&#39;)<br />        if len(tmp) != 2:<br />            print &#39;Bad description (%s): Must be number &lt;x:y&gt;&#39;<br />            print &#39;  where X is the number of instructions&#39;<br />            print &#39;  and Y is the percent change that an instruction is CPU not YIELD&#39;<br />            exit(1)<br /><br />        num_instructions, chance_cpu = int(tmp[0]), float(tmp[1]) / 100.0<br />        for i in range(num_instructions):<br />            if random.random() &lt; chance_cpu:<br />                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)<br />            else:<br />                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)<br />        return<br /><br />    # change to READY STATE, the current proc&#39;s state should be expected<br />    # if pid==-1, then pid=self.curr_proc<br />    def move_to_ready(self, expected, pid=-1):<br />        # YOUR CODE<br />        if pid == -1:<br />            pid = self.curr_proc<br />        assert (self.proc_info[pid][PROC_STATE] == expected)<br />        self.proc_info[pid][PROC_STATE] = STATE_READY<br />        return<br /><br />    # change to RUNNING STATE, the current proc&#39;s state should be expected<br />    def move_to_running(self, expected):<br />        # YOUR CODE<br />        assert (self.proc_info[self.curr_proc][PROC_STATE] == expected)<br />        self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING<br />        return<br /><br />    # change to DONE STATE, the current proc&#39;s state should be expected<br />    def move_to_done(self, expected):<br />        # YOUR CODE<br />        assert (self.proc_info[self.curr_proc][PROC_STATE] == expected)<br />        self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE<br />        return<br /><br />    # choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc<br />    def next_proc(self, pid=-1):<br />        # YOUR CODE<br />        if pid != -1:<br />            self.curr_proc = pid<br />            self.move_to_running(STATE_READY)<br />            self.check_if_done()<br />            return<br />        for pid in range(self.curr_proc &#43; 1, len(self.proc_info)):<br />            if self.proc_info[pid][PROC_STATE] == STATE_READY:<br />                self.curr_proc = pid<br />                self.move_to_running(STATE_READY)<br />                self.check_if_done()<br />                return<br />        for pid in range(0, self.curr_proc &#43; 1):<br />            if self.proc_info[pid][PROC_STATE] == STATE_READY:<br />                self.curr_proc = pid<br />                self.move_to_running(STATE_READY)<br />                self.check_if_done()<br />                return<br />        return<br /><br />    def get_num_processes(self):<br />        return len(self.proc_info)<br /><br />    def get_num_instructions(self, pid):<br />        return len(self.proc_info[pid][PROC_CODE])<br /><br />    def get_instruction(self, pid, index):<br />        return self.proc_info[pid][PROC_CODE][index]<br /><br />    def get_num_active(self):<br />        num_active = 0<br />        for pid in range(len(self.proc_info)):<br />            if self.proc_info[pid][PROC_STATE] != STATE_DONE:<br />                num_active &#43;= 1<br />        return num_active<br /><br />    def get_num_runnable(self):<br />        num_active = 0<br />        for pid in range(len(self.proc_info)):<br />            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\<br />                            self.proc_info[pid][PROC_STATE] == STATE_RUNNING:<br />                num_active &#43;= 1<br />        return num_active<br /><br />    def space(self, num_columns):<br />        for i in range(num_columns):<br />            print &#39;%10s&#39; % &#39; &#39;,<br /><br />    def check_if_done(self):<br />        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:<br />            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:<br />                self.move_to_done(STATE_RUNNING)<br />                self.next_proc()<br />        return<br /><br />    def run(self):<br />        clock_tick = 0<br /><br />        if len(self.proc_info) == 0:<br />            return<br /><br />        # make first one active<br />        self.curr_proc = 0<br />        self.move_to_running(STATE_READY)<br /><br />        # OUTPUT: heade&#96;[rs for each column<br />        print &#39;%s&#39; % &#39;Time&#39;,<br />        for pid in range(len(self.proc_info)):<br />            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),<br /><br />        print &#39;&#39;<br /><br />        # init statistics<br />        cpu_busy = 0<br /><br />        while self.get_num_active() &gt; 0:<br />            clock_tick &#43;= 1<br /><br />            # if current proc is RUNNING and has an instruction, execute it<br />            # statistics clock_tick<br />            instruction_to_execute = &#39;&#39;<br />            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\<br />                            len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:<br />            # YOUR CODE<br />                instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)<br />                cpu_busy &#43;= 1<br /><br />            # OUTPUT: print what everyone is up to<br />            print &#39;%3d &#39; % clock_tick,<br />            for pid in range(len(self.proc_info)):<br />                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:<br />                    print &#39;%10s&#39; % (&#39;RUN:&#39; &#43; instruction_to_execute),<br />                else:<br />                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),<br /><br />            print &#39;&#39;<br /><br />            # if this is an YIELD instruction, switch to ready state<br />            # and add an io completion in the future<br />            if instruction_to_execute == DO_YIELD:<br />            # YOUR CODE<br />                self.move_to_ready(STATE_RUNNING)<br />                self.next_proc()<br /><br />            # ENDCASE: check if currently running thing is out of instructions<br />            self.check_if_done()<br />        return (clock_tick)<br /><br /><br />#<br /># PARSE ARGUMENTS<br />#<br /><br />parser = OptionParser()<br />parser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0, help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)<br />parser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,<br />                  help=&#39;a comma-separated list of processes to run, in the form X1:Y1,X2:Y2,... where X is the number of instructions that process should run, and Y the chances (from 0 to 100) that an instruction will use the CPU or issue an YIELD&#39;,<br />                  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)<br />parser.add_option(&#39;-p&#39;, &#39;--printstats&#39;,<br />                  help=&#39;print statistics at end; only useful with -c flag (otherwise stats are not printed)&#39;,<br />                  action=&#39;store_true&#39;, default=False, dest=&#39;print_stats&#39;)<br />(options, args) = parser.parse_args()<br /><br />random.seed(options.seed)<br /><br />s = scheduler()<br /><br /># example process description (10:100,10:100)<br />for p in options.process_list.split(&#39;,&#39;):<br />    s.load(p)<br /><br />print &#39;Produce a trace of what would happen when you run these processes:&#39;<br />for pid in range(s.get_num_processes()):<br />    print &#39;Process %d&#39; % pid<br />    for inst in range(s.get_num_instructions(pid)):<br />        print &#39;  %s&#39; % s.get_instruction(pid, inst)<br />    print &#39;&#39;<br />print &#39;Important behaviors:&#39;<br />print &#39;  System will switch when the current process is FINISHED or ISSUES AN YIELD&#39;<br /><br />(clock_tick) = s.run()<br /><br />if options.print_stats:<br />    print &#39;&#39;<br />    print &#39;Stats: Total Time %d&#39; % clock_tick<br />    print &#39;&#39;</pre>", "created": "2018-04-09T16:39:56Z", "bucket_order": 106, "bucket_name": "Week 4/8 - 4/14", "type": "feedback", "tag_good": [], "uid": "ietb1e89azd2e8", "children": [], "tag_good_arr": [], "id": "jfsgq2ovxr07nr", "updated": "2018-04-09T16:39:56Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "jfj00h2iart6u3", "updated": "2018-04-03T01:42:12Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>康鸿博 2016011314</p>", "created": "2019-04-01T03:31:04Z", "bucket_order": 55, "bucket_name": "Week 3/31 - 4/6", "type": "followup", "tag_good": [], "uid": "jsn9fs59DCSn", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<pre>#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\n\n# process states\nSTATE_RUNNING = &#39;RUNNING&#39;\nSTATE_READY = &#39;READY&#39;\nSTATE_DONE = &#39;DONE&#39;\n\n# members of process structure\nPROC_CODE = &#39;code_&#39;\nPROC_PC = &#39;pc_&#39;\nPROC_ID = &#39;pid_&#39;\nPROC_STATE = &#39;proc_state_&#39;\n\n# things a process can do\nDO_COMPUTE = &#39;cpu&#39;\nDO_YIELD = &#39;yld&#39;\n\n\nclass scheduler:\n    def __init__(self):\n        # keep set of instructions for each of the processes\n        self.proc_info = {}\n        return\n\n    def new_process(self):\n        proc_id = len(self.proc_info)\n        self.proc_info[proc_id] = {}\n        self.proc_info[proc_id][PROC_PC] = 0\n        self.proc_info[proc_id][PROC_ID] = proc_id\n        self.proc_info[proc_id][PROC_CODE] = []\n        self.proc_info[proc_id][PROC_STATE] = STATE_READY\n        return proc_id\n\n    def load(self, program_description):\n        proc_id = self.new_process()\n        tmp = program_description.split(&#39;:&#39;)\n        if len(tmp) != 2:\n            print &#39;Bad description (%s): Must be number &lt;x:y&gt;&#39;\n            print &#39;  where X is the number of instructions&#39;\n            print &#39;  and Y is the percent change that an instruction is CPU not YIELD&#39;\n            exit(1)\n\n        num_instructions, chance_cpu = int(tmp[0]), float(tmp[1])/100.0\n        for i in range(num_instructions):\n            if random.random() &lt; chance_cpu:\n                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)\n            else:\n                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)\n        return\n\n    #change to READY STATE, the current proc&#39;s state should be expected\n    #if pid==-1, then pid=self.curr_proc\n    def move_to_ready(self, expected, pid=-1):\n        #YOUR CODE\n        if pid == -1:\n            pid = self.curr_proc\n        assert(self.proc_info[pid][PROC_STATE] == expected)\n        self.proc_info[pid][PROC_STATE] = STATE_READY\n        return\n\n    #change to RUNNING STATE, the current proc&#39;s state should be expected\n    def move_to_running(self, expected):\n        #YOUR CODE\n        pid = self.curr_proc\n        assert(self.proc_info[pid][PROC_STATE] == expected)\n        self.proc_info[pid][PROC_STATE] = STATE_RUNNING\n        return\n\n    #change to DONE STATE, the current proc&#39;s state should be expected\n    def move_to_done(self, expected):\n        #YOUR CODE\n        pid = self.curr_proc\n        assert(self.proc_info[pid][PROC_STATE] == expected)\n        self.proc_info[pid][PROC_STATE] = STATE_DONE\n        return\n\n    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc\n    def next_proc(self, pid=-1):\n        #YOUR CODE\n        if pid == -1:\n            for i in range(self.curr_proc &#43; 1, len(self.proc_info)):\n                if (self.proc_info[i][PROC_STATE] == STATE_READY):\n                    pid = i\n                    break\n        if pid == -1:\n            for i in range(0, self.curr_proc &#43; 1):\n                if (self.proc_info[i][PROC_STATE] == STATE_READY):\n                    pid = i\n                    break\n\t\tif pid == -1:\n\t\t\tpid = self.curr_proc\n        self.curr_proc = pid\n        if self.proc_info[self.curr_proc][PROC_STATE] == STATE_READY:\n            self.move_to_running(STATE_READY)\n            self.check_if_done()\n        return\n\n    def get_num_processes(self):\n        return len(self.proc_info)\n\n    def get_num_instructions(self, pid):\n        return len(self.proc_info[pid][PROC_CODE])\n\n    def get_instruction(self, pid, index):\n        return self.proc_info[pid][PROC_CODE][index]\n\n    def get_num_active(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] != STATE_DONE:\n                num_active &#43;= 1\n        return num_active\n\n    def get_num_runnable(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\\n                   self.proc_info[pid][PROC_STATE] == STATE_RUNNING:\n                num_active &#43;= 1\n        return num_active\n\n    def space(self, num_columns):\n        for i in range(num_columns):\n            print &#39;%10s&#39; % &#39; &#39;,\n\n    def check_if_done(self):\n        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n                self.move_to_done(STATE_RUNNING)\n                self.next_proc()\n        return\n\n    def run(self):\n        clock_tick = 0\n\n        if len(self.proc_info) == 0:\n            return\n\n        # make first one active\n        self.curr_proc = 0\n        self.move_to_running(STATE_READY)\n\n        # OUTPUT: heade&#96;[rs for each column\n        print &#39;%s&#39; % &#39;Time&#39;, \n        for pid in range(len(self.proc_info)):\n            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),\n\n        print &#39;&#39;\n\n        # init statistics\n        cpu_busy = 0\n\n        while self.get_num_active() &gt; 0 and clock_tick &lt; 15:\n            clock_tick &#43;= 1\n            \n            # if current proc is RUNNING and has an instruction, execute it\n            # statistics clock_tick\n            instruction_to_execute = &#39;&#39;\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n                   len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                #YOUR CODE\n                instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)\n                cpu_busy &#43;= 1\n\n            # OUTPUT: print what everyone is up to\n            print &#39;%3d &#39; % clock_tick,\n            for pid in range(len(self.proc_info)):\n                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n                    print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),\n                else:\n                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),\n\n            print &#39;&#39;\n\n            # if this is an YIELD instruction, switch to ready state\n            # and add an io completion in the future\n            if instruction_to_execute == DO_YIELD:\n                #YOUR CODE\n                self.move_to_ready(STATE_RUNNING)\n                self.next_proc()\n                \n            # ENDCASE: check if currently running thing is out of instructions\n            self.check_if_done()\n        return (clock_tick)\n        \n#\n# PARSE ARGUMENTS\n#\n\nparser = OptionParser()\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0, help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)\nparser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,\n                  help=&#39;a comma-separated list of processes to run, in the form X1:Y1,X2:Y2,... where X is the number of instructions that process should run, and Y the chances (from 0 to 100) that an instruction will use the CPU or issue an YIELD&#39;,\n                  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)\nparser.add_option(&#39;-p&#39;, &#39;--printstats&#39;, help=&#39;print statistics at end; only useful with -c flag (otherwise stats are not printed)&#39;, action=&#39;store_true&#39;, default=False, dest=&#39;print_stats&#39;)\n(options, args) = parser.parse_args()\n\nrandom.seed(options.seed)\n\ns = scheduler()\n\n# example process description (10:100,10:100)\nfor p in options.process_list.split(&#39;,&#39;):\n    s.load(p)\n\n\nprint &#39;Produce a trace of what would happen when you run these processes:&#39;\nfor pid in range(s.get_num_processes()):\n    print &#39;Process %d&#39; % pid\n    for inst in range(s.get_num_instructions(pid)):\n        print &#39;  %s&#39; % s.get_instruction(pid, inst)\n    print &#39;&#39;\nprint &#39;Important behaviors:&#39;\nprint &#39;  System will switch when the current process is FINISHED or ISSUES AN YIELD&#39;\n\n(clock_tick) = s.run()\n\nif options.print_stats:\n    print &#39;&#39;\n    print &#39;Stats: Total Time %d&#39; % clock_tick\n    print &#39;&#39;</pre>\n<p></p>", "created": "2019-04-03T15:05:50Z", "bucket_order": 55, "bucket_name": "Week 3/31 - 4/6", "type": "feedback", "tag_good": [], "uid": "jsn9fs59DCSn", "children": [], "tag_good_arr": [], "id": "ju1cfvi6i97i0", "updated": "2019-04-03T15:05:50Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "jtxsqpb82n16hl", "updated": "2019-04-01T03:31:04Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>孙志航 2016011363</p>", "created": "2019-04-03T14:25:53Z", "bucket_order": 55, "bucket_name": "Week 3/31 - 4/6", "type": "followup", "tag_good": [], "uid": "jsld0u9sp4k3", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>#change to READY STATE, the current proc&#39;s state should be expected</p>\n<div>\n<div>#if pid==-1, then pid=self.curr_proc</div>\n<div>def move_to_ready(self, expected, pid=-1):</div>\n<div>        if pid == -1:</div>\n<div>                pid = self.curr_proc</div>\n<div>        if self.proc_info[pid][PROC_STATE] == expected:</div>\n<div>                self.proc_info[pid][PROC_STATE] = STATE_READY</div>\n<div>        return</div>\n<br />\n<div>#change to RUNNING STATE, the current proc&#39;s state should be expected</div>\n<div>def move_to_running(self, expected):</div>\n<div>        if self.proc_info[pid][PROC_STATE] == expected:</div>\n<div>                self.proc_info[pid][PROC_STATE] = STATE_RUNNING</div>\n<div>        return</div>\n<br />\n<div>#change to DONE STATE, the current proc&#39;s state should be expected</div>\n<div>def move_to_done(self, expected):</div>\n<div>        if self.proc_info[pid][PROC_STATE] == expected:</div>\n<div>                self.proc_info[pid][PROC_STATE] = STATE_DONE</div>\n<div>        return</div>\n<br />\n<div>#choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc</div>\n<div>def next_proc(self, pid=-1):</div>\n<div>        if pid == -1:</div>\n<div>                pid = self.curr_proc</div>\n<br />\n<div>        for i in range(pid&#43;1, len(self.proc_info)):</div>\n<div>                if self.proc_info[i][PROC_STATE] == STATE_READY:</div>\n<div>                        self.proc_info[i][PROC_STATE] = STATE_RUNNING</div>\n<div>                        self.curr_proc = i</div>\n<div>                        return</div>\n<br />\n<div>        for i in range(0, pid&#43;1):</div>\n<div>                if self.proc_info[i][PROC_STATE] == STATE_READY:</div>\n<div>                        self.proc_info[i][PROC_STATE] = STATE_RUNNING</div>\n<div>                        self.curr_proc = i</div>\n<div>                        return</div>\n<div>        return</div>\n<br />\n<div>def run(self):</div>\n<div>        clock_tick = 0</div>\n<br />\n<div>        if len(self.proc_info) == 0:</div>\n<div>                return</div>\n<br />\n<div>        # make first one active</div>\n<div>        self.curr_proc = 0</div>\n<div>        self.move_to_running(STATE_READY)</div>\n        <br />\n<div>        # OUTPUT: heade&#96;[rs for each column</div>\n<div>        print &#39;%s&#39; % &#39;Time&#39;,</div>\n<div>        for pid in range(len(self.proc_info)):</div>\n<div>                print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),</div>\n        <br />\n<div>        print &#39;&#39;</div>\n        <br />\n<div>        # init statistics</div>\n<div>        cpu_busy = 0</div>\n<br />\n<div>        while self.get_num_active() &gt; 0:</div>\n<div>                clock_tick &#43;= 1</div>\n<div>                </div>\n<div>                # if current proc is RUNNING and has an instruction, execute it</div>\n<div>                # statistics clock_tick</div>\n<div>                instruction_to_execute = &#39;&#39;</div>\n<div>                if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\</div>\n<div>                        len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:</div>\n<div>                        instruction_to_execute = self.proc_info[self.curr_proc[PROC_CODE].pop(0)</div>\n<div>                        cpu_busy &#43;= 1</div>\n<br />\n<div>                        # OUTPUT: print what everyone is up to</div>\n<div>                        print &#39;%3d &#39; % clock_tick,</div>\n<div>                        for pid in range(len(self.proc_info)):</div>\n<div>                                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:</div>\n<div>                                        print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),</div>\n<div>                                else:</div>\n<div>                                        print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),</div>\n<br />\n<div>                        print &#39;&#39;</div>\n                        <br />\n<div>                        # if this is an YIELD instruction, switch to ready state</div>\n<div>                        # and add an io completion in the future</div>\n<div>                        if instruction_to_execute == DO_YIELD:</div>\n<div>                                self.move_to_ready(STATE_RUNNING)</div>\n<div>                                self.next_proc()</div>\n<br />\n<div>                        # ENDCASE: check if currently running thing is out of instructions</div>\n<div>                        self.check_if_done()</div>\n<div>                return</div></div>", "created": "2019-04-03T14:27:20Z", "bucket_order": 55, "bucket_name": "Week 3/31 - 4/6", "type": "feedback", "tag_good": [], "uid": "jsld0u9sp4k3", "children": [], "tag_good_arr": [], "id": "ju1b2dbkfts19b", "updated": "2019-04-03T14:27:20Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "ju1b0i0ss896y4", "updated": "2019-04-03T14:25:53Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>参考了参考答案&#xff0c; 最终理解了大概&#xff0c;run函数中cpu_busy好像没用&#xff1f;</p>\n<pre>&#96;&#96;&#96;<br />    # change to READY STATE, the current proc&#39;s state should be expected<br />    # if pid==-1, then pid=self.curr_proc<br />    def move_to_ready(self, expected, pid=-1):<br />        # YOUR CODE<br />        if pid == -1:<br />            pid = self.curr_proc<br />        assert (self.proc_info[pid][PROC_STATE] == expected)<br />        self.proc_info[pid][PROC_STATE] = STATE_READY<br />        return<br /><br />    # change to RUNNING STATE, the current proc&#39;s state should be expected<br />    def move_to_running(self, expected):<br />        # YOUR CODE<br />        assert (self.proc_info[self.curr_proc][PROC_STATE] == expected)<br />        self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING<br />        return<br /><br />    # change to DONE STATE, the current proc&#39;s state should be expected<br />    def move_to_done(self, expected):<br />        # YOUR CODE<br />        assert (self.proc_info[self.curr_proc][PROC_STATE] == expected)<br />        self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE<br />        return<br /><br />    # choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc<br />    def next_proc(self, pid=-1):<br />        # YOUR CODE<br />        if pid != -1:<br />            self.curr_proc = pid<br />            self.move_to_running(STATE_READY)<br />            self.check_if_done()<br />            return<br />        for pid in range(self.curr_proc &#43; 1, len(self.proc_info)):<br />            if self.proc_info[pid][PROC_STATE] == STATE_READY:<br />                self.curr_proc = pid<br />                self.move_to_running(STATE_READY)<br />                self.check_if_done()<br />                return<br />        for pid in range(0, self.curr_proc):<br />            if self.proc_info[pid][PROC_STATE] == STATE_READY:<br />                self.curr_proc = pid<br />                self.move_to_running(STATE_READY)<br />                self.check_if_done()<br />                return<br />        return<br /><br />    def run(self):<br />        clock_tick = 0<br /><br />        if len(self.proc_info) == 0:<br />            return<br /><br />        # make first one active<br />        self.curr_proc = 0<br />        self.move_to_running(STATE_READY)<br /><br />        # OUTPUT: heade&#96;[rs for each column<br />        print &#39;%s&#39; % &#39;Time&#39;,<br />        for pid in range(len(self.proc_info)):<br />            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),<br /><br />        print &#39;&#39;<br /><br />        # init statistics<br />        cpu_busy = 0<br /><br />        while self.get_num_active() &gt; 0:<br />            clock_tick &#43;= 1<br /><br />            # if current proc is RUNNING and has an instruction, execute it<br />            # statistics clock_tick<br />            instruction_to_execute = &#39;&#39;<br />            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\<br />                            len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:<br />            # YOUR CODE<br />                instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)<br /><br />            # OUTPUT: print what everyone is up to<br />            print &#39;%3d &#39; % clock_tick,<br />            for pid in range(len(self.proc_info)):<br />                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:<br />                    print &#39;%10s&#39; % (&#39;RUN:&#39; &#43; instruction_to_execute),<br />                else:<br />                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),<br /><br />            print &#39;&#39;<br /><br />            # if this is an YIELD instruction, switch to ready state<br />            # and add an io completion in the future<br />            if instruction_to_execute == DO_YIELD:<br />            # YOUR CODE<br />                self.move_to_ready(STATE_RUNNING)<br />                self.next_proc()<br /><br />            # ENDCASE: check if currently running thing is out of instructions<br />            self.check_if_done()<br />        return (clock_tick)<br />&#96;&#96;&#96;</pre>\n<p></p>", "created": "2019-04-10T09:45:01Z", "bucket_order": 54, "bucket_name": "Week 4/7 - 4/13", "type": "followup", "tag_good": [], "uid": "jsk4iwnsAnmZ", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "jub12a466wzyh", "updated": "2019-04-10T09:45:01Z", "config": {}}], "tag_good_arr": [], "id": "jfho7tmc5az57x", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 6, "num_favorites": 1, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169350482, "default_anonymity": "no"}, "error": null, "aid": "kyv0lt8y8zu2zk"}