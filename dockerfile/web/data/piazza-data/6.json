{"result": {"history_size": 3, "folders": ["quiz1", "quiz2", "quiz3", "quiz4", "quiz5", "quiz6", "quiz7", "quiz8", "quiz9", "quiz10", "quiz11", "quiz12", "quiz13", "lab1", "lab2", "lab3", "lab4", "lab5", "lab6", "lab7", "lab8", "exam", "logistics", "other", "ucore_plus", "big_proj"], "nr": 6, "data": {"embed_links": []}, "created": "2015-03-02T01:23:49Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"uid": "hcrrjuyequh4bt", "anon": "no", "when": "2015-03-02T01:23:49Z", "data": "i6r6nyb54fe7ik", "type": "create"}, {"to": "i6r6nyb34qx7ij", "uid": "i6ry1ln7xRU", "anon": "no", "when": "2015-03-02T18:05:43Z", "type": "followup"}, {"to": "i6r6nyb34qx7ij", "uid": "i6xpirx4SbG", "anon": "no", "when": "2015-03-08T12:13:59Z", "type": "followup"}, {"to": "i6r6nyb34qx7ij", "uid": "hcrrjuyequh4bt", "anon": "no", "when": "2015-03-08T13:25:48Z", "type": "feedback"}, {"to": "i6r6nyb34qx7ij", "uid": "i6xpirx4SbG", "anon": "no", "when": "2015-03-08T13:30:28Z", "type": "feedback"}, {"uid": "hcrrjuyequh4bt", "anon": "no", "when": "2015-03-09T02:41:03Z", "data": "i719i8im87c4bn", "type": "update"}, {"uid": "hcrrjuyequh4bt", "anon": "no", "when": "2015-03-10T01:58:49Z", "data": "i72nfrikx1hji", "type": "update"}, {"anon": "no", "uid": "i1jdydfsfpuys", "to": "i6r6nyb34qx7ij", "type": "feedback", "when": "2017-01-20T05:28:56Z"}, {"anon": "no", "uid": "hcrrjuyequh4bt", "to": "i6r6nyb34qx7ij", "type": "feedback", "when": "2018-05-22T03:17:39Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hcrrjuyequh4bt", "subject": "提问技巧", "created": "2015-03-10T01:58:49Z", "content": "<p>提问请标注所属分类&#xff0c;这样对学生的好处是巨大的。<br />老师在上实体课前&#xff0c;能够看到学生在看视频后的共性问题&#xff0c;可以有针对性的讲解一下。<br />学生和助教可以更好地发现是否已有的问题已有人提&#xff0c;并有回答了。<br /><br />原理课程内容和课后练习的问题分类&#xff1a;</p>\n<ul><li>quiz1: 第1讲 操作系统概述</li><li>quiz2:第3讲 中断与系统调用</li><li>quiz3:第5讲 物理内存管理&#xff1a;连续内存分配</li><li>quiz4:第6讲 物理内存管理&#xff1a;非连续内存分配</li><li>quiz5:第8讲 虚拟存储&#xff1a;缺页中断</li><li>quiz6:第9讲 虚拟存储&#xff1a;置换算法</li><li>quiz7:第11讲 进程状态与控制</li><li>quiz8:第14讲 处理机调度</li><li>quiz9:第16讲 同步互斥</li><li>quiz10:第17讲 信号量和管程</li><li>quiz11:第19讲 进程间通信和死锁</li><li>quiz12:第20讲 文件系统</li><li>quiz13:第22讲 I/O子系统</li></ul>\n<p></p>\n<p>实验课程内容和课后练习的问题分类&#xff1a;lab0~lab8</p>\n<ul><li>lab0: 第2讲 实验环境准备</li><li>lab1: 第4讲 OS启动和中断处理</li><li>lab2: 第7讲 物理内存管理的实现</li><li>lab3: 第10讲 虚拟内存管理的实现</li><li>lab4: 第12讲 线程管理与内核线程实现</li><li>lab5: 第13讲 用户进程设计实现</li><li>lab6: 第15讲 处理机调度设计与实现</li><li>lab7:第18讲 内核信号量和条件变量</li><li>lab8: 第21讲 Simple FS的设计实现</li></ul>\n<p></p>\n<p>大实验分类&#xff1a;big_proj<br /><br />其他问题&#xff1a; other&#xff0c; exam&#xff0c;logistics</p>"}, {"anon": "no", "uid": "hcrrjuyequh4bt", "subject": "提问技巧", "created": "2015-03-09T02:41:03Z", "content": "提问请标注所属分类&#xff0c;这样对学生的好处是巨大的。\n老师在上实体课前&#xff0c;能够看到学生在看视频后的共性问题&#xff0c;可以有针对性的讲解一下。\n学生和助教可以更好地发现是否已有的问题已有人提&#xff0c;并有回答了。\n\n原理课程内容和课后练习的问题分类&#xff1a;\n<ul><li>quiz1: 第1讲 操作系统概述</li><li>quiz2:第3讲 中断与系统调用</li><li>quiz3:第5讲 物理内存管理&#xff1a;连续内存分配</li><li>quiz4:第6讲 物理内存管理&#xff1a;非连续内存分配</li><li>quiz5:第8讲 虚拟存储&#xff1a;缺页中断</li><li>quiz6:第9讲 虚拟存储&#xff1a;置换算法</li><li>quiz7:第11讲 进程状态与控制</li><li>quiz8:第14讲 处理机调度</li><li>quiz9:第16讲 同步互斥</li><li>quiz10:第17讲 信号量和管程</li><li>quiz11:第19讲 进程间通信和死锁</li><li>quiz12:第20讲 文件系统</li><li>quiz13:第22讲 I/O子系统</li></ul>\n\n实验课程内容和课后练习的问题分类&#xff1a;lab0~lab8\n\n大实验分类&#xff1a;big_proj\n\n其他问题&#xff1a; other&#xff0c; exam&#xff0c;logistics"}, {"anon": "no", "uid": "hcrrjuyequh4bt", "subject": "提问技巧", "created": "2015-03-02T01:23:49Z", "content": "<p>提问请标注所属分类。</p>\n<p></p>\n<p>原理课程内容和课后练习的问题分类&#xff1a;</p>\n<ul><li>quiz1: 第1讲 操作系统概述</li><li>quiz2:第3讲 中断与系统调用</li><li>quiz3:第5讲 物理内存管理&#xff1a;连续内存分配</li><li>quiz4:第6讲 物理内存管理&#xff1a;非连续内存分配</li><li>quiz5:第8讲 虚拟存储&#xff1a;缺页中断</li><li>quiz6:第9讲 虚拟存储&#xff1a;置换算法</li><li>quiz7:第11讲 进程状态与控制</li><li>quiz8:第14讲 处理机调度</li><li>quiz9:第16讲 同步互斥</li><li>quiz10:第17讲 信号量和管程</li><li>quiz11:第19讲 进程间通信和死锁</li><li>quiz12:第20讲 文件系统</li><li>quiz13:第22讲 I/O子系统</li></ul>\n<p></p>\n<p>实验课程内容和课后练习的问题分类&#xff1a;lab0~lab8</p>\n<p></p>\n<p>大实验分类&#xff1a;big_proj</p>\n<p></p>\n<p>其他问题&#xff1a; other&#xff0c; exam&#xff0c;logistics</p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>"}], "type": "note", "tags": ["big_proj", "exam", "instructor-note", "lab1", "lab2", "lab3", "lab4", "lab5", "lab6", "lab7", "lab8", "logistics", "other", "quiz1", "quiz10", "quiz11", "quiz12", "quiz13", "quiz2", "quiz3", "quiz4", "quiz5", "quiz6", "quiz7", "quiz8", "quiz9", "ucore_plus"], "tag_good": [{"role": "instructor", "name": "Yu Chen", "endorser": {}, "admin": true, "photo": "1378950179_35.png", "id": "hcrrjuyequh4bt", "photo_url": "https://cdn-uploads.piazza.com/photos/hcrrjuyequh4bt/1378950179_35.png", "us": false, "class_sections": ["课程设计_i5j09fnsl7k5x0", "清华学生_i5j09fnsl7k5x0", "所有老师和助教_i5j09fnsl7k5x0", "os2018spring_i5j09fnsl7k5x0"], "facebook_id": null}], "unique_views": 729, "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p></p>", "created": "2015-03-02T18:05:43Z", "bucket_order": 327, "bucket_name": "Week 3/1 - 3/7", "type": "followup", "tag_good": [], "uid": "i6ry1ln7xRU", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "i6s6gektkv3281", "updated": "2015-03-02T18:05:43Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>老师您好&#xff0c;在第一讲中&#xff0c;1.3什么是操作系统-&gt;操作系统内核特征-&gt;异步性   有点不是很明白&#xff0c;能否给出更形象的解释&#xff1f;或者是更准确的。</p>", "created": "2015-03-08T12:13:59Z", "bucket_order": 326, "bucket_name": "Week 3/8 - 3/14", "type": "followup", "tag_good": [], "uid": "i6xpirx4SbG", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "我理解操作系统的异步性实际上是指进程&#xff08;程序执行的过程&#xff09;的异步性&#xff0c;即是指进程的实际执行“走走停停”&#xff0c;走多久&#xff0c;停多久不确定&#xff0c;体现了进程在执行时间上的一种不确定性。\n进程的实际执行“走走停停”是由于\n1 OS有多个进程在执行\n2 存在进程可能等待某个资源&#xff0c;而进程何时获得资源是无法提前预知的。", "created": "2015-03-08T13:25:48Z", "bucket_order": 326, "bucket_name": "Week 3/8 - 3/14", "type": "feedback", "tag_good": [{"role": "student", "name": "刘佳乐", "endorser": {}, "admin": false, "photo": null, "id": "k88jacp4uj45sw", "photo_url": null, "published": true, "us": false, "facebook_id": null}], "uid": "hcrrjuyequh4bt", "children": [], "tag_good_arr": ["k88jacp4uj45sw"], "id": "i70h3jf92tq1bb", "updated": "2015-03-08T13:25:48Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>也就说是&#xff0c;对于一个进程来说他的执行时间是不连续的&#xff1f;和数电中的异步性 定义不同&#xff0c;有点受束缚了&#xff01;3Q</p>", "created": "2015-03-08T13:30:28Z", "bucket_order": 326, "bucket_name": "Week 3/8 - 3/14", "type": "feedback", "tag_good": [], "uid": "i6xpirx4SbG", "children": [], "tag_good_arr": [], "id": "i70h9j2dsvk1ay", "updated": "2015-03-08T13:30:28Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>感觉老师这说的更偏向于并行性。</p>\n<p>我感觉</p>\n<p></p>\n<p><a href=\"https://www.zhihu.com/question/19732473\">https://www.zhihu.com/question/19732473</a> </p>\n<p></p>\n<p>这个解释异步阻塞更合理&#xff0c;异步阻塞首先应该是不可分离的&#xff0c;再者这个过程应该有两个主体&#xff0c;调用者与被调用者。</p>\n<p></p>\n<p>操作系统的异步性用系统调用来解释更合适.</p>\n<p></p>", "created": "2017-01-20T05:28:56Z", "bucket_order": 229, "bucket_name": "Week 1/15 - 1/21", "type": "feedback", "tag_good": [], "uid": "i1jdydfsfpuys", "children": [], "tag_good_arr": [], "id": "iy5d8y9eaf13ex", "updated": "2017-01-20T05:28:56Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>其实在操作系统或其他领域中&#xff0c;一个词在不同的上下文&#xff08;context&#xff09;中有不同的解释。</p>\n<p>异步1&#xff1a;</p>\n<p>由于操作系统中完成系统调用服务的执行时间也是不确定&#xff0c;在某种程度上体现了这种异步性。</p>\n<p></p>\n<p>异步2&#xff1a;</p>\n<p>上面  杨振振 同学的提法&#xff0c;在操作系统中也有&#xff0c;比如异步/非阻塞系统调用和同步/阻塞系统调用。</p>\n<p><a href=\"/class/i5j09fnsl7k5x0?cid=6\"></a></p>\n<p></p>\n<p>http://www.cnblogs.com/diyingyun/archive/2011/11/25/2263126.html</p>\n<p>在进行网络编程时&#xff0c;我们常常也见到同步、异步、阻塞和非阻塞四种调用方式。</p>\n<p></p>\n<p>同步 </p>\n<p>　　所谓同步&#xff0c;就是在发出一个功能调用时&#xff0c;在没有得到结果之前&#xff0c;该调用就不返回。按照这个定义&#xff0c;其实绝大多数函数都是同步调用&#xff08;例如sin, isdigit等&#xff09;。但是一般而言&#xff0c;我们在说同步、异步的时候&#xff0c;特指那些需要其他部件协作或者需要一定时间完成的任务。最常见的例子就是 SendMessage。该函数发送一个消息给某个窗口&#xff0c;在对方处理完消息之前&#xff0c;这个函数不返回。当对方处理完毕以后&#xff0c;该函数才把消息处理函数所返回的 LRESULT值返回给调用者。 </p>\n<p></p>\n<p>异步 </p>\n<p>　　异步的概念和同步相对。当一个异步过程调用发出后&#xff0c;调用者不能立刻得到结果。实际处理这个调用的部件在完成后&#xff0c;通过状态、通知和回调来通知调用者。以CAsycSocket类为例&#xff08;注意&#xff0c;CSocket从CAsyncSocket派生&#xff0c;但是起功能已经由异步转化为同步&#xff09;&#xff0c;当一个客户端通过调用 Connect函数发出一个连接请求后&#xff0c;调用者线程立刻可以朝下运行。当连接真正建立起来以后&#xff0c;socket底层会发送一个消息通知该对象。 </p>\n<p></p>", "created": "2018-05-22T03:17:39Z", "bucket_order": 159, "bucket_name": "Week 5/20 - 5/26", "type": "feedback", "tag_good": [], "uid": "hcrrjuyequh4bt", "children": [], "tag_good_arr": [], "id": "jhh3zz7n46d1nw", "updated": "2018-05-22T03:17:39Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "i70ej6h78gi7n6", "updated": "2015-03-08T12:13:59Z", "config": {}}], "tag_good_arr": ["hcrrjuyequh4bt"], "id": "i6r6nyb34qx7ij", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 6, "num_favorites": 5, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643167103034, "default_anonymity": "no"}, "error": null, "aid": "kyuz9n3ug3o7x"}