{"result": {"history_size": 1, "folders": ["2017", "课堂问答", "lecture4"], "nr": 995, "data": {"embed_links": []}, "created": "2017-03-03T06:33:17Z", "bucket_order": 3, "no_answer_followup": 18, "change_log": [{"anon": "no", "uid": "hdjonbiyfs62ie", "data": "iztg1hlxrve5p6", "type": "create", "when": "2017-03-03T06:33:17Z"}, {"anon": "no", "uid": "ie7xyabq1z61v9", "to": "iztg1hlu2x25p5", "type": "followup", "when": "2017-03-03T06:37:40Z"}, {"anon": "no", "uid": "ie7xy5sipx51qz", "to": "iztg1hlu2x25p5", "type": "followup", "when": "2017-03-03T06:40:11Z"}, {"anon": "no", "uid": "ie7xy0l5qrq1lq", "to": "iztg1hlu2x25p5", "type": "followup", "when": "2017-03-03T06:41:28Z"}, {"anon": "no", "uid": "izb0cbqbyzd6wf", "to": "iztg1hlu2x25p5", "type": "followup", "when": "2017-03-03T06:41:51Z"}, {"anon": "no", "uid": "ie7xy0nh1811ls", "to": "iztg1hlu2x25p5", "type": "followup", "when": "2017-03-03T06:41:55Z"}, {"anon": "no", "uid": "ie7xy1b3f61mi", "to": "iztg1hlu2x25p5", "type": "followup", "when": "2017-03-03T06:41:59Z"}, {"anon": "no", "uid": "i5g31e12hcr27s", "to": "iztg1hlu2x25p5", "type": "followup", "when": "2017-03-03T06:42:21Z"}, {"anon": "no", "uid": "ie7xy0669cj1lc", "to": "iztg1hlu2x25p5", "type": "followup", "when": "2017-03-03T06:42:29Z"}, {"anon": "no", "uid": "izb0ce5rlex6xc", "to": "iztg1hlu2x25p5", "type": "followup", "when": "2017-03-03T06:42:46Z"}, {"anon": "no", "uid": "ie7xxyhe7dp1jr", "to": "iztg1hlu2x25p5", "type": "followup", "when": "2017-03-03T06:42:47Z"}, {"anon": "no", "uid": "ie7xy5cvsc61qg", "to": "iztg1hlu2x25p5", "type": "followup", "when": "2017-03-03T06:43:55Z"}, {"anon": "no", "uid": "ixur2nigPyB", "to": "iztg1hlu2x25p5", "type": "followup", "when": "2017-03-03T06:44:28Z"}, {"anon": "no", "uid": "izb0cbe1zb56w5", "to": "iztg1hlu2x25p5", "type": "followup", "when": "2017-03-03T06:47:02Z"}, {"anon": "no", "uid": "ie7xy0669cj1lc", "to": "iztg1hlu2x25p5", "type": "feedback", "when": "2017-03-03T06:51:57Z"}, {"anon": "no", "uid": "ie7xxz4di3o1ke", "to": "iztg1hlu2x25p5", "type": "followup", "when": "2017-03-03T06:53:11Z"}, {"anon": "no", "uid": "ie7xy0l5qrq1lq", "to": "iztg1hlu2x25p5", "type": "feedback", "when": "2017-03-03T06:53:34Z"}, {"anon": "no", "uid": "ikjdo9jtz0e2jq", "to": "iztg1hlu2x25p5", "type": "followup", "when": "2017-03-03T06:54:45Z"}, {"anon": "no", "uid": "ie7xy6ut1rx1rv", "to": "iztg1hlu2x25p5", "type": "feedback", "when": "2017-03-03T06:54:47Z"}, {"anon": "no", "uid": "ikjdo9jtz0e2jq", "to": "iztg1hlu2x25p5", "type": "feedback", "when": "2017-03-03T06:57:05Z"}, {"anon": "no", "uid": "ie7xy1b3f61mi", "to": "iztg1hlu2x25p5", "type": "feedback", "when": "2017-03-03T06:59:16Z"}, {"anon": "no", "uid": "ie7xy9yltfs1uq", "to": "iztg1hlu2x25p5", "type": "followup", "when": "2017-03-03T08:21:48Z"}, {"anon": "no", "uid": "ie7xy8iscsw1t7", "to": "iztg1hlu2x25p5", "type": "followup", "when": "2017-03-03T10:09:25Z"}, {"anon": "no", "uid": "izb0cbkdd5s6w9", "to": "iztg1hlu2x25p5", "type": "followup", "when": "2017-03-03T13:46:18Z"}, {"anon": "no", "uid": "ie7xy6gkrq21rh", "to": "iztg1hlu2x25p5", "type": "followup", "when": "2017-03-03T14:45:17Z"}, {"anon": "no", "uid": "ie7xy6isp8v1rk", "to": "iztg1hlu2x25p5", "type": "feedback", "when": "2017-03-04T02:13:36Z"}, {"anon": "no", "uid": "ie7xy6isp8v1rk", "to": "iztg1hlu2x25p5", "type": "followup", "when": "2017-03-04T03:13:51Z"}, {"anon": "no", "uid": "ie7xy8gtpwk1t5", "to": "iztg1hlu2x25p5", "type": "followup", "when": "2017-03-04T09:19:20Z"}, {"anon": "no", "uid": "ie7xyb2no521w0", "to": "iztg1hlu2x25p5", "type": "followup", "when": "2017-03-10T12:18:16Z"}, {"anon": "no", "uid": "ie7xy5f0l9b1qi", "to": "iztg1hlu2x25p5", "type": "followup", "when": "2017-03-11T02:20:23Z"}, {"anon": "no", "uid": "ie7xy42ohjs1p9", "to": "iztg1hlu2x25p5", "type": "followup", "when": "2017-03-16T09:48:11Z"}, {"anon": "no", "uid": "kma28mmq2242ou", "to": "iztg1hlu2x25p5", "type": "followup", "when": "2021-04-14T14:25:52Z", "cid": "knhjqjw2ckm29f"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "2017春季-第四讲 课堂思考题回答", "created": "2017-03-03T06:33:17Z", "content": "<p><a href=\"https://chyyuu.gitbooks.io/os_course_exercises/content/all/02-2-lab1-spoc-discussion.html\">https://chyyuu.gitbooks.io/os_course_exercises/content/all/02-2-lab1-spoc-discussion.html</a></p>\n<p><br />每个同学找一段ucore中的一段内联汇编代码&#xff0c;进行完整的解释。在本贴后回复你的解释。如果有多个同学解释同一段代码&#xff0c;后面的同学只需要修改或完善前面同学的回答。</p>\n<p></p>\n<p>下面链接是一个内联汇编解释的样例。</p>\n<p><a href=\"http://ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html\">http://ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html</a></p>\n<p></p>"}], "type": "note", "tags": ["2017", "instructor-note", "lecture4", "课堂问答"], "tag_good": [], "unique_views": 214, "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>lab8 libs/x86.h line 64</p>\n<pre>asm volatile (&#34;inw %1, %0&#34; : &#34;=a&#34; (data) : &#34;d&#34; (port));</pre>\n<div>翻译为汇编代码后为</div>\n<pre>inw %dx, %ax</pre>\n<div>从IO端口port中读取一个字(uint16_t)放入data中</div>", "created": "2017-03-03T06:37:40Z", "bucket_order": 221, "bucket_name": "Week 2/26 - 3/4", "type": "followup", "tag_good": [], "uid": "ie7xyabq1z61v9", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "iztg74iak9hq9", "updated": "2017-03-03T06:37:40Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "在<code>/libs/atomic.h</code>文件中有函数&#xff1a;\n<pre>/* *\n * test_and_set_bit - Atomically set a bit and return its old value\n * &#64;nr:     the bit to set\n * &#64;addr:   the address to count from\n * */\nstatic inline bool\ntest_and_set_bit(int nr, volatile void *addr) {\n    int oldbit;\n    asm volatile (&#34;btsl %2, %1; sbbl %0, %0&#34; : &#34;=r&#34; (oldbit), &#34;=m&#34; (*(volatile long *)addr) : &#34;Ir&#34; (nr) : &#34;memory&#34;);\n    return oldbit != 0;\n}</pre>\n其中的内联汇编代码为&#xff1a;\n<pre>asm volatile (&#34;btsl %2, %1; sbbl %0, %0&#34; : &#34;=r&#34; (oldbit), &#34;=m&#34; (*(volatile long *)addr) : &#34;Ir&#34; (nr) : &#34;memory&#34;);</pre>\n完整包含“三个冒号格式”。\n\n1. 第一个关键字<code>asm</code>表示内联汇编代码&#xff1b;第二个关键字<code>volatile</code>表示禁止编译器优化重排&#xff1b;\n2. 括号里引号部分表示主要指令为<code>btsl</code>和<code>sbbl</code>两条&#xff1b;\n3. 第一个冒号后的部分表示会有两个输出变量。第一个输出变量是<code>oldbit</code>&#xff0c;<code>&#34;=r&#34;</code>表示可以存到任何寄存器内&#xff1b;第二个输出变量<code>&#34;=m&#34;</code>表示将输出变量直接存到内存中地址为<code>addr</code>的地方&#xff1b;\n4. 第二个冒号后的部分表示会有一个输入变量。<code>&#34;Ir&#34;</code>表示输入变量<code>nr</code>是一个常数&#xff0c;从寄存器输入&#xff1b;\n5. 第三个冒号后的部分表示“修改部分”。<code>&#34;memory&#34;</code>表示内存已经变化&#xff0c;并通知编译器。", "created": "2017-03-03T06:40:11Z", "bucket_order": 221, "bucket_name": "Week 2/26 - 3/4", "type": "followup", "tag_good": [], "uid": "ie7xy5sipx51qz", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "iztgacnbrvi36h", "updated": "2017-03-03T06:40:11Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>/lab8_result/libs/x86.h </p>\n<p>第57行&#xff1a;占坑&#xff0c;稍后更新</p>", "created": "2017-03-03T06:41:28Z", "bucket_order": 221, "bucket_name": "Week 2/26 - 3/4", "type": "followup", "tag_good": [], "uid": "ie7xy0l5qrq1lq", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p><pre>static inline uint8_t\ninb(uint16_t port) {\n    uint8_t data;\n    asm volatile (&#34;inb %1, %0&#34; : &#34;=a&#34; (data) : &#34;d&#34; (port) : &#34;memory&#34;); &#xff0f;&#xff0f; 第57行\n    return data;\n}</pre>\n<p>从 port 输入到寄存器 dx&#xff0c;使用寄存器 ax 输出到data中。</p>\n<p></p>\n<p>修改部分&#xff08;clobber list,也称 乱码列表&#xff09;:这部分以“memory”为约束条件&#xff0c;以表示操作完成后内存中的内容已有改变&#xff0c;如果原来某个寄存器的内容来自内存&#xff0c;那么现在内存中这个单元的内容已经改变。乱码列表通知编译器&#xff0c;有些寄存器或内存因内联汇编块造成乱码&#xff0c;可隐式地破坏了条件寄存器的某些位&#xff08;字段&#xff09;。</p>", "created": "2017-03-03T06:53:34Z", "bucket_order": 221, "bucket_name": "Week 2/26 - 3/4", "type": "feedback", "tag_good": [], "uid": "ie7xy0l5qrq1lq", "children": [], "tag_good_arr": [], "id": "iztgrk36iki138", "updated": "2017-03-03T06:53:34Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "iztgc09b87f2lz", "updated": "2017-03-03T06:41:28Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p><tt>lab1/kern/mm/pmm.c</tt> 第60行. 加载 <tt>gdt</tt> 占坑.</p>\n<p></p>\n<p>代码: </p>\n<p></p>\n<pre>static inline void\nlgdt(struct pseudodesc *pd) {\n    asm volatile (&#34;lgdt (%0)&#34; :: &#34;r&#34; (pd));\n    asm volatile (&#34;movw %%ax, %%gs&#34; :: &#34;a&#34; (USER_DS));\n    asm volatile (&#34;movw %%ax, %%fs&#34; :: &#34;a&#34; (USER_DS));\n    asm volatile (&#34;movw %%ax, %%es&#34; :: &#34;a&#34; (KERNEL_DS));\n    asm volatile (&#34;movw %%ax, %%ds&#34; :: &#34;a&#34; (KERNEL_DS));\n    asm volatile (&#34;movw %%ax, %%ss&#34; :: &#34;a&#34; (KERNEL_DS));\n    // reload cs\n    asm volatile (&#34;ljmp %0, $1f\\n 1:\\n&#34; :: &#34;i&#34; (KERNEL_CS));\n}\n\n</pre>\n<p>让 cpu 知道当前 gdt 表的位置. 改一些寄存器, 然后重新获取cs.</p>", "created": "2017-03-03T06:41:51Z", "bucket_order": 221, "bucket_name": "Week 2/26 - 3/4", "type": "followup", "tag_good": [], "uid": "izb0cbqbyzd6wf", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "iztgci0s88h3bn", "updated": "2017-03-03T06:41:51Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>lab8_result/kern/process/proc.c, line 962</p>\n<pre>// kernel_execve - do SYS_exec syscall to exec a user program called by user_main kernel_thread\nstatic int\nkernel_execve(const char *name, const char **argv) {\n    int argc = 0, ret;\n    while (argv[argc] != NULL) {\n        argc &#43;&#43;;\n    }\n    asm volatile (\n        &#34;int %1;&#34;\n        : &#34;=a&#34; (ret)\n        : &#34;i&#34; (T_SYSCALL), &#34;0&#34; (SYS_exec), &#34;d&#34; (name), &#34;c&#34; (argc), &#34;b&#34; (argv)\n        : &#34;memory&#34;);\n    return ret;\n}</pre>\n<p>该函数的调用链&#xff1a;</p>\n<p>kern_init() (in kern/init/init.c)</p>\n<p>proc_init() (in kern/proc/proc.c)</p>\n<p>init_main() (in kern/proc/proc.c)</p>\n<p>user_main() (in kern/proc/proc.c)</p>\n<p>KERNEL_EXECVE() (in kern/proc/proc.c)</p>\n<p>__KERNEL_EXECVE() (in kern/proc/proc.c)</p>\n<p>kern_execve() (in kern/proc/proc.c)</p>\n<p></p>\n<p>该函数在操作系统启动时&#xff0c;从内核态调用用户态的sh程序时使用。</p>\n<p>这个函数在内核态产生了一个系统调用&#xff0c;调用类型为SYS_exec&#xff0c;把程序名和参数(argc、argv)作为系统调用的参数传入&#xff0c;通过系统调用来启动一个用户态程序。</p>", "created": "2017-03-03T06:41:55Z", "bucket_order": 221, "bucket_name": "Week 2/26 - 3/4", "type": "followup", "tag_good": [], "uid": "ie7xy0nh1811ls", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "iztgclbycz53w6", "updated": "2017-03-03T06:41:55Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>lab8 kern/init/init.c line 82-87</p>\n<p></p>\n<pre>asm volatile(\n\t&#34;mov %%cs, %0;&#34;\n \t&#34;mov %%ds, %1;&#34;\n\t&#34;mov %%es, %2;&#34; \n\t&#34;mov %%ss, %3;&#34;\n\t: &#34;=m&#34;(reg1), &#34;=m&#34;(reg2), &#34;=m&#34;(reg3), &#34;=m&#34;(reg4));</pre>\n<p></p>\n<p>1. 前四条语句为mov指令&#xff0c;分别将cs,ds,,es,ss这四个寄存器的内容依次放到第1-4个寄存器中。</p>\n<p>2. 冒号后为输出语句&#xff0c;参数皆为&#34;=m&#34;&#xff0c;表示输出变量直接存到内存中地址为<span style=\"font-family:monospace\">reg1,reg2,reg3,reg4</span>的地方。</p>\n<p>3. 因此这段代码的效果为&#xff0c;将cs, ds, es, ss这四个寄存器的内容依次赋给reg1,reg2,reg3,reg4这四个变量。</p>", "created": "2017-03-03T06:41:59Z", "bucket_order": 221, "bucket_name": "Week 2/26 - 3/4", "type": "followup", "tag_good": [], "uid": "ie7xy1b3f61mi", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>", "created": "2017-03-03T06:59:16Z", "bucket_order": 221, "bucket_name": "Week 2/26 - 3/4", "type": "feedback", "tag_good": [], "uid": "ie7xy1b3f61mi", "children": [], "tag_good_arr": [], "id": "iztgyvv9lik66p", "updated": "2017-03-03T06:59:16Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "iztgcodlmhj2cg", "updated": "2017-03-03T06:41:59Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p></p>\n<pre>// kern/libs/x86.h\nstatic inline uint32_t\nread_ebp(void) {\n    uint32_t ebp;\n    asm volatile (&#34;movl %%ebp, %0&#34; : &#34;=r&#34; (ebp));\n    return ebp;\n}</pre>\n<p>asm: 表示内联汇编</p>\n<p>volatile: 避免指令被删除/移动/组合</p>\n<pre>movl %%ebp, %0</pre>\n<p>%%ebp表示%ebp寄存器, %0表示使用1个操作数/变量.</p>\n<p>=r表示%0可以使用任意通用寄存器, (ebp)表示变量uint32_t ebp存放在该寄存器中</p>", "created": "2017-03-03T06:42:21Z", "bucket_order": 221, "bucket_name": "Week 2/26 - 3/4", "type": "followup", "tag_good": [], "uid": "i5g31e12hcr27s", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "iztgd5bqkf12hn", "updated": "2017-03-03T06:42:21Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>pmm 102 占坑</p>", "created": "2017-03-03T06:42:29Z", "bucket_order": 221, "bucket_name": "Week 2/26 - 3/4", "type": "followup", "tag_good": [], "uid": "ie7xy0669cj1lc", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<pre>    asm volatile (&#34;lgdt (%0)&#34; :: &#34;r&#34; (pd));\n    asm volatile (&#34;movw %%ax, %%gs&#34; :: &#34;a&#34; (USER_DS));\n    asm volatile (&#34;movw %%ax, %%fs&#34; :: &#34;a&#34; (USER_DS));\n    asm volatile (&#34;movw %%ax, %%es&#34; :: &#34;a&#34; (KERNEL_DS));\n    asm volatile (&#34;movw %%ax, %%ds&#34; :: &#34;a&#34; (KERNEL_DS));\n    asm volatile (&#34;movw %%ax, %%ss&#34; :: &#34;a&#34; (KERNEL_DS));\n    // reload cs\n    asm volatile (&#34;ljmp %0, $1f\\n 1:\\n&#34; :: &#34;i&#34; (KERNEL_CS));</pre>\n<p><code>加载GDT&#xff0c;并且重置kernel中的段存储。&#xff08;比如在bootloader过程中&#xff0c;初始化段存储时&#xff0c;需加载GDT表&#xff0c;第一条语句是特殊汇编指令&#xff0c;表示将pd的值作为GDT的地址&#xff0c;之后将相应的kernel中段存储的相关参数置给相应的寄存器&#xff0c;最后重新得到cs寄存器的值</code></p>", "created": "2017-03-03T06:51:57Z", "bucket_order": 221, "bucket_name": "Week 2/26 - 3/4", "type": "feedback", "tag_good": [], "uid": "ie7xy0669cj1lc", "children": [], "tag_good_arr": [], "id": "iztgphqs1wj7j9", "updated": "2017-03-03T06:51:57Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "iztgdaxysdq2lt", "updated": "2017-03-03T06:42:29Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p> /libs/x86.h</p>\n<p> 82 static inline void<br /> 83 cli(void) {<br /> 84     asm volatile (&#34;cli&#34;);<br /> 85 }</p>\n<p></p>\n<p>禁止中断</p>", "created": "2017-03-03T06:42:46Z", "bucket_order": 221, "bucket_name": "Week 2/26 - 3/4", "type": "followup", "tag_good": [], "uid": "izb0ce5rlex6xc", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "iztgdo7780t2r4", "updated": "2017-03-03T06:42:46Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>/kern/debug/kdebug.h: line 295</p>\n<p></p>\n<pre>static __noinline uint32_t\nread_eip(void) {\n    uint32_t eip;\n    asm volatile(&#34;movl 4(%%ebp), %0&#34; : &#34;=r&#34; (eip));\n    return eip;\n}</pre>\n<p></p>\n<p>读出调用此函数时 eip 寄存器的值</p>\n<p></p>\n<p>用到了调用函数时会把返回地址(即 eip 寄存器)的值压在栈上的的约定&#xff0c;所以可以通过直接读取 4(%ebp) 来读取 %eip</p>\n<p></p>\n<p>&#xff08;致上学期调板子天天 trap 到 kernel debugger 的日子 </p>\n<p></p>", "created": "2017-03-03T06:42:47Z", "bucket_order": 221, "bucket_name": "Week 2/26 - 3/4", "type": "followup", "tag_good": [], "uid": "ie7xxyhe7dp1jr", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "iztgdpeborb3fo", "updated": "2017-03-03T06:42:47Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>libs/x86.h</p>\n<p>259 static inline void *                                                                                                                      <br />260 __memset(void *s, char c, size_t n) {<br />261     int d0, d1;<br />262     asm volatile (<br />263         &#34;rep; stosb;&#34;<br />264         : &#34;=&amp;c&#34; (d0), &#34;=&amp;D&#34; (d1)<br />265         : &#34;0&#34; (n), &#34;a&#34; (c), &#34;1&#34; (s)<br />266         : &#34;memory&#34;);<br />267     return s;<br />268 }<br /><br /></p>\n<p>memset 操作</p>\n<p>rep stosb就是从EDI所指的内存开始&#xff0c;将连续的ECX个字节写成AL的内容</p>\n<p></p>", "created": "2017-03-03T06:43:55Z", "bucket_order": 221, "bucket_name": "Week 2/26 - 3/4", "type": "followup", "tag_good": [], "uid": "ie7xy5cvsc61qg", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "iztgf5e6e0a4s4", "updated": "2017-03-03T06:43:55Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>lab8/user/syscall.c</p>\n<pre>static inline int<br />syscall(int num, ...) {<br />    va_list ap;<br />    va_start(ap, num);<br />    uint32_t a[MAX_ARGS];<br />    int i, ret;<br />    for (i = 0; i &lt; MAX_ARGS; i &#43;&#43;) {<br />        a[i] = va_arg(ap, uint32_t);<br />    }<br />    va_end(ap);<br /><br />    asm volatile (<br />        &#34;int %1;&#34;<br />        : &#34;=a&#34; (ret)<br />        : &#34;i&#34; (T_SYSCALL),<br />          &#34;a&#34; (num),<br />          &#34;d&#34; (a[0]),<br />          &#34;c&#34; (a[1]),<br />          &#34;b&#34; (a[2]),<br />          &#34;D&#34; (a[3]),<br />          &#34;S&#34; (a[4])<br />        : &#34;cc&#34;, &#34;memory&#34;);<br />    return ret;<br />}</pre>\n<p>num表示系统调用号&#xff0c;存于%eax</p>\n<p>%edx&#xff0c;%ecx&#xff0c;%ebx&#xff0c;%edi&#xff0c;%esi分别存放传入的5个参数</p>\n<p>memory表示上述汇编代码会对内存进行修改</p>\n<p>结果返回值存于%eax&#xff0c;随后放入ret变量&#xff0c;返回</p>", "created": "2017-03-03T06:44:28Z", "bucket_order": 221, "bucket_name": "Week 2/26 - 3/4", "type": "followup", "tag_good": [], "uid": "ixur2nigPyB", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p><p>补充&#xff0c;%1表示第2个C语言中的标志符&#xff0c;在本处表示的是T_SYSCALL</p>\n<p></p>", "created": "2017-03-03T06:54:47Z", "bucket_order": 221, "bucket_name": "Week 2/26 - 3/4", "type": "feedback", "tag_good": [], "uid": "ie7xy6ut1rx1rv", "children": [], "tag_good_arr": [], "id": "iztgt4pnk2c2j3", "updated": "2017-03-03T06:54:47Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>补充&#34;cc&#34;</p>\n<p>手册上说&#xff1a;If our instruction can alter the condition code register, we have to add &#34;cc&#34; to the list of clobbered registers.</p>\n<p>也就是在此处会改变条件码寄存器。</p>", "created": "2017-03-04T02:13:36Z", "bucket_order": 221, "bucket_name": "Week 2/26 - 3/4", "type": "feedback", "tag_good": [], "uid": "ie7xy6isp8v1rk", "children": [], "tag_good_arr": [], "id": "izum7dj5qsb12", "updated": "2017-03-04T02:13:36Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "iztgfv7wwo657q", "updated": "2017-03-03T06:44:28Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>lab8 &#96;lab8 libs/x86.h&#96; line78-81</p>\n<pre>static inline void\noutb(uint16_t port, uint8_t data) {\n    asm volatile (&#34;outb %0, %1&#34; :: &#34;a&#34; (data), &#34;d&#34; (port));\n}</pre>\n<p>实现了将源操作数(单个字节, uint8_t)拷贝至 CPU 端口(目的操作数代表的)的功能.</p>", "created": "2017-03-03T06:47:02Z", "bucket_order": 221, "bucket_name": "Week 2/26 - 3/4", "type": "followup", "tag_good": [], "uid": "izb0cbe1zb56w5", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "iztgj632tw45ql", "updated": "2017-03-03T06:47:02Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>在<strong>libs/x86.h</strong>中的153行有&#xff1a;</p>\n<pre>asm volatile (&#34;ltr %0&#34; :: &#34;r&#34; (sel) : &#34;memory&#34;);</pre>\n<p>意思即&#xff1a;</p>\n<p>读取目标寄存器的值到task register中&#xff0c;这里的目标寄存器是r。实际上&#xff0c;load进去的是变量sel的值。</p>\n<p>memory代表会对内存进行操作。</p>\n<p></p>\n<p>mooc中提到了a, b, c, d, S, D的代表含义&#xff0c;分别指%eax, %ebx, %ecx, %edx, %esi, %edi。</p>\n<p>而在这里r的意思是指gcc会使用任意一个寄存器。</p>\n<p>也正因如此&#xff0c;我们无法预知GCC会使用哪个寄存器&#xff0c;也就无法具体给出将要发生的寄存器是哪一个。因此用一个笼统的&#34;memory&#34;来泛指&#xff1a;寄存器中有一个发生了变化。</p>", "created": "2017-03-03T06:53:11Z", "bucket_order": 221, "bucket_name": "Week 2/26 - 3/4", "type": "followup", "tag_good": [], "uid": "ie7xxz4di3o1ke", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "iztgr2tvhbhxq", "updated": "2017-03-03T06:53:11Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p><img src=\"/img/995-cb80cad2446de11a.png\" alt=\"\" /></p>\n<p>使用cscope工具在lab8中找到结果六十余条&#xff0c;上截图。</p>\n<p></p>\n<p></p>\n<p></p>", "created": "2017-03-03T06:54:45Z", "bucket_order": 221, "bucket_name": "Week 2/26 - 3/4", "type": "followup", "tag_good": [], "uid": "ikjdo9jtz0e2jq", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>分析第一条&#xff1a;取出ebp&#43;4地址中的内容&#xff0c;赋予变量eip</p>", "created": "2017-03-03T06:57:05Z", "bucket_order": 221, "bucket_name": "Week 2/26 - 3/4", "type": "feedback", "tag_good": [], "uid": "ikjdo9jtz0e2jq", "children": [], "tag_good_arr": [], "id": "iztgw2tg8ws4r3", "updated": "2017-03-03T06:57:05Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "iztgt357j9h1jn", "updated": "2017-03-03T06:54:45Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>选择<em>lab4/lib/atomic.h</em>中的以下函数&#xff1a;</p>\n<pre>/* *<br /> * change_bit - Atomically toggle a bit in memory<br /> * &#64;nr:     the bit to change<br /> * &#64;addr:   the address to start counting from<br /> * */<br />static inline void<br />change_bit(int nr, volatile void *addr) {<br />    asm volatile (&#34;btcl %1, %0&#34; :&#34;=m&#34; (*(volatile long *)addr) : &#34;Ir&#34; (nr));<br />}</pre>\n<p>其中内联汇编的作用是&#xff0c;将所传参数<em>addr</em>所指地址的第<em>nr</em>位通过汇编指令“<em>btcl</em>”反转&#xff1b;</p>\n<p>第一个可选参数表示有一个输出参数&#xff0c;将最终得到的结果赋给<em>addr</em>指针指向的内存区域&#xff1b;</p>\n<p>第二个可选参数是一个输入参数&#xff0c;指明汇编指令中要改变的是第几位。</p>", "created": "2017-03-03T08:21:48Z", "bucket_order": 221, "bucket_name": "Week 2/26 - 3/4", "type": "followup", "tag_good": [], "uid": "ie7xy9yltfs1uq", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "iztjx0ysy3u79r", "updated": "2017-03-03T08:21:48Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p></p><p>labcodes_answer/lab8_result/libs/x86.h中的159行&#xff1a;</p>\n<pre>read_eflags(void) {<br />    uint32_t eflags;<br />    asm volatile (&#34;pushfl; popl %0&#34; : &#34;=r&#34; (eflags));<br />    return eflags;<br />}</pre>\n<p>asm: 表示内联汇编</p>\n<p>volatile: 避免指令被删除/移动/组合</p>\n<pre>popl %0&#34; : &#34;=r&#34; (eflags)</pre>\n<p>%0表示使用1个操作数/变量&#xff1b;=r表示%0可以使用任意通用寄存器&#xff1b; (eflags)表示变量eflags存放在该寄存器中。</p>\n<p></p>", "created": "2017-03-03T10:09:25Z", "bucket_order": 221, "bucket_name": "Week 2/26 - 3/4", "type": "followup", "tag_good": [], "uid": "ie7xy8iscsw1t7", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "iztnrf8dedb2gm", "updated": "2017-03-03T10:09:25Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p><em>labcodes_answer/lab8_result/libs/atomic.h</em> 中一下函数</p>\n<pre>/* *\n * test_bit - Determine whether a bit is set\n * &#64;nr:     the bit to test\n * &#64;addr:   the address to count from\n * */\nstatic inline bool\ntest_bit(int nr, volatile void *addr) {\n    int oldbit;\n    asm volatile (&#34;btl %2, %1; sbbl %0,%0&#34; : &#34;=r&#34; (oldbit) : &#34;m&#34; (*(volatile long *)addr), &#34;Ir&#34; (nr));\n    return oldbit != 0;\n}</pre>\n<p>btl 测试addr的第nr位复制到寄存器CF</p>\n<p>sbbl 表示将oldorbit减去oldorbit再减去CF&#xff0c;进而判断出addr第nr位的值</p>\n<p>&#34;=r&#34;表示任意寄存器</p>\n<p>&#34;m&#34; 表示内存操作数&#xff0c;</p>\n<p>&#34;Ir&#34;表示任意寄存器&#xff0c;值在0-31之间</p>", "created": "2017-03-03T13:46:18Z", "bucket_order": 221, "bucket_name": "Week 2/26 - 3/4", "type": "followup", "tag_good": [], "uid": "izb0cbkdd5s6w9", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "iztvic661h9h8", "updated": "2017-03-03T13:46:18Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "/labcodes_answer/lab8_result/libs/x86.h中第165行<div><br /></div><div>static inline void</div><div>write_eflags(uint32_t eflags) {</div><div>    asm volatile (&#34;pushl %0; popfl&#34; :: &#34;r&#34; (eflags));</div><div>}</div><div><br /></div><div><br /></div><div>volatile 表示不进行进一步优化调整顺序</div><div><br /></div><div>&#34;r&#34; (eflags) &#xff1a;表示%0中存放的是eflags的值</div>", "created": "2017-03-03T14:45:17Z", "bucket_order": 221, "bucket_name": "Week 2/26 - 3/4", "type": "followup", "tag_good": [], "uid": "ie7xy6gkrq21rh", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "iztxm6og1rt5nm", "updated": "2017-03-03T14:45:17Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>在lab1/libs/x86.h中</p>\n<pre>#define do_div(n, base) ({                                        \\\n    unsigned long __upper, __low, __high, __mod, __base;        \\\n    __base = (base);                                            \\\n    asm(&#34;&#34; : &#34;=a&#34; (__low), &#34;=d&#34; (__high) : &#34;A&#34; (n));            \\\n    __upper = __high;                                            \\\n    if (__high != 0) {                                            \\\n        __upper = __high % __base;                                \\\n        __high = __high / __base;                                \\\n    }                                                            \\\n    asm(&#34;divl %2&#34; : &#34;=a&#34; (__low), &#34;=d&#34; (__mod)                    \\\n        : &#34;rm&#34; (__base), &#34;0&#34; (__low), &#34;1&#34; (__upper));            \\\n    asm(&#34;&#34; : &#34;=A&#34; (n) : &#34;a&#34; (__low), &#34;d&#34; (__high));                \\\n    __mod;                                                        \\\n })</pre>\n<p>第一个内联汇编代码</p>\n<pre><tt>asm(&#34;&#34; : &#34;=a&#34; (__low), &#34;=d&#34; (__high) : &#34;A&#34; (n));</tt></pre>\n<p>其中&#34;A&#34;的意思是 Specifies the &#96;a’ or &#96;d’ registers. This is primarily useful for 64-bit integer values intended to be returned with the &#96;d’ register holding the most significant bits and the &#96;a’ register holding the least significant bits. 就是说把64位的整数n的高32位放在寄存器edx&#xff0c;低32位放在寄存器eax。再把eax的值放在变量__low&#xff0c;edx的值放在变量__high。<br /><br />第二个内联汇编代码</p>\n<pre>asm(&#34;divl %2&#34; : &#34;=a&#34; (__low), &#34;=d&#34; (__mod)                    \\\n        : &#34;rm&#34; (__base), &#34;0&#34; (__low), &#34;1&#34; (__upper));</pre>\n<p>根据手册&#xff0c;Common constraints include ‘r’ for register and ‘m’ for memory. When you list more than one possible location (for example, <code>&#34;=rm&#34;</code>), the compiler chooses the most efficient one based on the current context. 这里的&#34;rm&#34;表示__base可能在寄存器里可能在内存中&#xff0c;编译器会自动选择最可能的地方。%2表示__base。divl 将商存在eax&#xff0c;将余数存在edx。</p>\n<p></p>\n<p>第三个内联汇编代码</p>\n<pre>asm(&#34;&#34; : &#34;=A&#34; (n) : &#34;a&#34; (__low), &#34;d&#34; (__high)); </pre>\n<p>将32位的__high和__low分别存到寄存器edx,eax&#xff0c;n等于edx&#xff0c;eax拼接起来。</p>\n<p></p>", "created": "2017-03-04T03:13:51Z", "bucket_order": 221, "bucket_name": "Week 2/26 - 3/4", "type": "followup", "tag_good": [], "uid": "ie7xy6isp8v1rk", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "izuocux1pvs1k0", "updated": "2017-03-04T03:13:51Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p></p><pre># ucore_os_lab/labcodes_answer/lab8_result/libs/x86.h\nstatic inline uintptr_t\nrcr0(void) {\n    uintptr_t cr0;\n    asm volatile (&#34;mov %%cr0, %0&#34; : &#34;=r&#34; (cr0) :: &#34;memory&#34;);\n    return cr0;\n}</pre>\n<ul><li>作用&#xff1a;读取cr0寄存器的内容</li><li>&#34;=r&#34;表示可使用任意寄存器存储读出的内容</li><li>&#34;memory&#34;指示指令会改变内存</li></ul>", "created": "2017-03-04T09:19:20Z", "bucket_order": 221, "bucket_name": "Week 2/26 - 3/4", "type": "followup", "tag_good": [], "uid": "ie7xy8gtpwk1t5", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "izv1evcuuyz4gp", "updated": "2017-03-04T09:19:20Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>proc.c文件中有这样一段代码&#xff1a;</p>\n<pre>// kernel_execve - do SYS_exec syscall to exec a user program called by user_main kernel_thread\nstatic int\nkernel_execve(const char *name, unsigned char *binary, size_t size) {\n    int ret, len = strlen(name);\n    asm volatile (\n        &#34;int %1;&#34;\n        : &#34;=a&#34; (ret)\n        : &#34;i&#34; (T_SYSCALL), &#34;0&#34; (SYS_exec), &#34;d&#34; (name), &#34;c&#34; (len), &#34;b&#34; (binary), &#34;D&#34; (size)\n        : &#34;memory&#34;);\n    return ret;\n}</pre>\n<p>其中</p>\n<pre>asm volatile (\n        &#34;int %1;&#34;\n        : &#34;=a&#34; (ret)\n        : &#34;i&#34; (T_SYSCALL), &#34;0&#34; (SYS_exec), &#34;d&#34; (name), &#34;c&#34; (len), &#34;b&#34; (binary), &#34;D&#34; (size)\n        : &#34;memory&#34;);</pre>\n<p>为内联汇编代码&#xff0c;进行了一个系统调用&#xff0c;int指令的参数是往后从0开始数第1个标识符&#xff0c;在这里是“i”&#xff0c;即T_SYSCALL。</p>\n<p>第一段冒号后是输出操作数&#xff0c;表示将返回值存在%eax寄存器&#xff1b;</p>\n<p>第二段冒号后是输入操作数&#xff0c;分别表示T_SYSCALL是一个立即数整数值&#xff0c;SYS_exec是值已知的立即数整数值&#xff0c;变量name的值在%edx&#xff0c;变量len的值在%ecx&#xff0c;变量binary的值再%ebx&#xff0c;变量size的值再%edi&#xff1b;</p>\n<p>第三段冒号后的“memory”提醒编译器&#xff0c;指令改变了内存。</p>", "created": "2017-03-10T12:18:16Z", "bucket_order": 220, "bucket_name": "Week 3/5 - 3/11", "type": "followup", "tag_good": [], "uid": "ie7xyb2no521w0", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "j03sg35hf2m2bb", "updated": "2017-03-10T12:18:16Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>在kern/init.c中:</p>\n<pre>static void lab1_switch_to_user(void) {\n    asm volatile (\n        &#34;sub $0x8, %%esp \\n&#34;\n        &#34;int %0 \\n&#34;\n        &#34;movl %%ebp, %%esp&#34; \n        : \n        : &#34;i&#34;(T_SWITCH_TOU)\n    );\n}</pre>\n<p></p>\n<p><code>asm</code>表示内联汇编代码&#xff0c;<code>volatile</code>表示禁止编译器优化重排&#xff0c;<code>%%esp,%%ebp </code>分别指代寄存器<code>%eax,%ebp</code>&#xff0c;<code>T_SWITCH_TOU</code> 为中断号&#xff0c;是一个立即数</p>\n<p></p>\n<p>第一条汇编指令<code>sub $0x8, %%esp</code> 将<code>%esp</code>寄存器的值减8</p>\n<p>第二条汇编指令<code>int T_SWITCH_TOU</code> 中断号为<code>T_SWITCH_TOU</code>调用软中断</p>\n<p>第三条汇编指令<code>movl %%ebp, %%esp</code> 将寄存器<code>%ebp</code>的赋到寄存器<code>%esp</code>中</p>\n<p></p>\n<p>第二段冒号后是输入操作数&#xff0c;&#34;i&#34;表示<code>T_SWITCH_TOU</code>是一个整型立即数( An immediate integer operand)&#xff0c;作为在第一个冒号后出现的第一个操作数&#xff0c;<code>T_SWITCH_TOU</code>指代内联汇编中的<code>%0</code></p>\n<p></p>", "created": "2017-03-11T02:20:23Z", "bucket_order": 220, "bucket_name": "Week 3/5 - 3/11", "type": "followup", "tag_good": [], "uid": "ie7xy5f0l9b1qi", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "j04mj2hu7gl5eu", "updated": "2017-03-11T02:20:23Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>lab8/libs/x86.h 138</p>\n<pre>137 lidt(struct pseudodesc *pd) {<br />138     asm volatile (&#34;lidt (%0)&#34; :: &#34;r&#34; (pd) : &#34;memory&#34;);<br />139 }</pre>\n<p>作用&#xff1a;将*pd指向地址中伪描述符装入到中断描述符表寄存器IDTR。其中&#xff1a;lidt为装载中断描述符表寄存器指令。&#34;lidt (%0)&#34;表示将第零个操作数&#xff08;即pd&#xff09;中伪描述符装入到中断描述符表寄存器IDTR中。&#34;r&#34; (pd)表示用r 上面的寄存器的任意一个保存变量pd。&#34;memory&#34;表示内联汇编代码改变了内存。<span style=\"font-size:9pt;color:#000\"></span></p>", "created": "2017-03-16T09:48:11Z", "bucket_order": 219, "bucket_name": "Week 3/12 - 3/18", "type": "followup", "tag_good": [], "uid": "ie7xy42ohjs1p9", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "j0c7q6utkk92o0", "updated": "2017-03-16T09:48:11Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<md>补充一下这一条\nasm volatile (\"ljmp %0, $1f\\n 1:\\n\" :: \"i\" (KERNEL_CS));\n1f 是汇编器标签，f是forward向前引用的意思，引用 1: 那里的地址。这条指令就会跳转到下一条地址，实际的作用是reload cs\n  </md>", "created": "2021-04-14T14:25:52Z", "bucket_order": 3, "bucket_name": "Today", "type": "followup", "tag_good": [], "uid": "kma28mmq2242ou", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "knhjqjw2ckm29f", "updated": "2021-04-14T14:25:52Z", "config": {"editor": "md"}}], "tag_good_arr": [], "id": "iztg1hlu2x25p5", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 29, "num_favorites": 2, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643168949089, "default_anonymity": "no"}, "error": null, "aid": "kyv0d7j64ta50f"}