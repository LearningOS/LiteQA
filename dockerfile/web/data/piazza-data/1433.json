{"result": {"folders": ["lecture10"], "nr": 1433, "data": {"embed_links": []}, "created": "2020-03-25T14:58:40Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "je2ib27z6a7691", "data": "k87gds553ea6nf", "type": "create", "when": "2020-03-25T14:58:40Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "je2ib27z6a7691", "subject": "第十讲课后练习参考解答", "created": "2020-03-25T14:58:40Z", "content": "<md>## 题目描述\n\n### 练习一\n\n设计一个简化的进程管理子系统&#xff0c;可以管理并调度支持“就绪”和“等待”状态的简化进程。在理解参考代码的基础上&#xff0c;完成&#xff02;YOUR CODE&#34;部分的内容。然后通过测试用例和比较自己的实现与往届同学的结果&#xff0c;评价自己的实现是否正确。可&#xff12;个人一组。\n* [题目的参考代码](https://github.com/chyyuu/ucore_os_lab/blob/master/related_info/lab5/process-cpuio-homework.py)\n\n\n### 练习二\n\n请分析 uCore 或 rCore 的第一个用户进程的从进入运行态到开始执行用户态的主函数 main() 的启动过程中所执行的函数和顺序。可&#xff12;个人一组。\n\n## 练习一\n\n&gt; 2015011332\n&gt; https://git.tsinghua.edu.cn/csq15/os2020_exercise/tree/master/week5\n\n### move_to_xxxx 函数\n\n&#96;&#96;&#96;\n#change to READY STATE, the current proc&#39;s state should be expected\n#if pid==-1, then pid=self.curr_proc\ndef move_to_ready(self, expected, pid=-1):\n    #YOUR CODE\n    if pid == -1:\n        pid = self.curr_proc\n    assert (self.proc_info[pid][PROC_STATE] == expected)\n    self.proc_info[pid][PROC_STATE] = STATE_READY\n    return\n\n#change to RUNNING STATE, the current proc&#39;s state should be expected\ndef move_to_running(self, expected):\n    #YOUR CODE\n    assert (self.proc_info[self.curr_proc][PROC_STATE] == expected)\n    self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING\n    return\n\n#change to DONE STATE, the current proc&#39;s state should be expected\ndef move_to_done(self, expected):\n    #YOUR CODE\n    assert (self.proc_info[self.curr_proc][PROC_STATE] == expected)\n    self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE\n    return\n\ndef move_to_wait(self, expected):\n    assert (self.proc_info[self.curr_proc][PROC_STATE] == expected)\n    self.proc_info[self.curr_proc][PROC_STATE] = STATE_WAIT\n    return\n&#96;&#96;&#96;\n\n### next_proc 函数\n\n&#96;&#96;&#96;\n#choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc\ndef next_proc(self, pid=-1):\n    #YOUR CODE\n    if pid != -1:\n        self.curr_proc = pid\n        self.move_to_running(STATE_READY)\n        return\n    for pid in range(self.curr_proc &#43; 1, len(self.proc_info)):\n        if self.proc_info[pid][PROC_STATE] == STATE_READY:\n            self.curr_proc = pid\n            self.move_to_running(STATE_READY)\n            return\n    for pid in range(0, self.curr_proc &#43; 1):\n        if self.proc_info[pid][PROC_STATE] == STATE_READY:\n            self.curr_proc = pid\n            self.move_to_running(STATE_READY)\n            return\n    return\n&#96;&#96;&#96;\n\n### 进程管理主体\n\n&#96;&#96;&#96;\nwhile self.get_num_active() &gt; 0:\n    clock_tick &#43;= 1\n\n    # check for io finish\n    io_done = False\n    for pid in range(len(self.proc_info)):\n        if clock_tick in self.io_finish_times[pid]:\n            # if IO finished, the should do something for related process\n            #YOUR CODE\n            io_done = True\n            self.move_to_ready(STATE_WAIT, pid)\n\n    if io_done and self.proc_info[self.curr_proc][PROC_STATE] != STATE_RUNNING:\n        self.next_proc()\n\n    # if current proc is RUNNING and has an instruction, execute it\n    instruction_to_execute = &#39;&#39;\n    if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n            len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n        #pop a instruction from proc_info[self.curr_proc][PROC_CODE]to instruction_to_execute\n        #YOUR CODE\n        instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)\n        cpu_busy &#43;= 1\n\n    # OUTPUT: print what everyone is up to\n    if io_done:\n        print &#39;%3d*&#39; % clock_tick,\n    else:\n        print &#39;%3d &#39; % clock_tick,\n    for pid in range(len(self.proc_info)):\n        if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n            print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),\n        else:\n            print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),\n    if instruction_to_execute == &#39;&#39;:\n        print &#39;%10s&#39; % &#39; &#39;,\n    else:\n        print &#39;%10s&#39; % 1,\n    num_outstanding = self.get_ios_in_flight(clock_tick)\n    if num_outstanding &gt; 0:\n        print &#39;%10s&#39; % str(num_outstanding),\n        io_busy &#43;= 1\n    else:\n        print &#39;%10s&#39; % &#39; &#39;,\n    print &#39;&#39;\n\n    # if this is an YIELD instruction, switch to ready state\n    # and add an io completion in the future\n    if instruction_to_execute == DO_YIELD:\n        #YOUR CODE\n        self.move_to_ready(STATE_RUNNING)\n        self.next_proc()\n    # if this is an IO instruction, switch to waiting state\n    # and add an io completion in the future\n    elif instruction_to_execute == DO_IO:\n        #YOUR CODE\n        self.move_to_wait(STATE_RUNNING)\n        self.io_finish_times[self.curr_proc].append(clock_tick &#43; self.io_length &#43; 1)\n        self.next_proc()\n\n    # ENDCASE: check if currently running thing is out of instructions\n    self.check_if_done()\n&#96;&#96;&#96;\n\n## 练习二\n\n&gt; 2016010103\n&gt; https://git.tsinghua.edu.cn/os-20/labs-2016010103/blob/master/hw10.md\n\n&#96;proc.c&#96;&#xff1a;首先在&#96;init_main&#96;函数中调用&#96;user_main()&#96;进入用户态进程。在&#96;user_main&#96;中&#xff0c;调用&#96;kernel_execve&#96;函数执行内核进程&#xff0c;在其中执行&#96;SYS_exec syscall&#96;以执行由&#96;user_main kernel_thread&#96;调用的用户态程序。\n\n&#96;syscall.c&#96;&#xff1a;在&#96;sys_exec&#96;中调用&#96;proc.c&#96;中的&#96;do_execve&#96;函数。&#96;do_execve&#96;函数回收当前进程的内存空间&#xff0c;调用&#96;load_icode&#96;设置新的内存空间&#xff0c;将用户态程序加载进内存。\n\n&#96;load_icode&#96;函数首先为用户态进程创建新的内存空间&#xff0c;然后建立页表&#xff0c;分配内存&#xff0c;最后为了用户态程序创建陷阱帧&#xff0c;切换到用户态。</md>"}], "type": "note", "tags": ["lecture10", "student"], "tag_good": [], "unique_views": 77, "children": [], "tag_good_arr": [], "id": "k87gds53fgx6ne", "config": {"seen": {"352": 3, "47": 5, "1025": 2, "468": 6, "348": 4, "1430": 9, "305": 8, "1030": 1, "749": 7, "1194": 0}}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 1, "num_favorites": 0, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643170030096, "default_anonymity": "no"}, "error": null, "aid": "kyv10dn4s5g1zr"}