{"result": {"folders": ["课堂问答"], "nr": 366, "data": {"embed_links": []}, "created": "2015-04-29T06:51:37Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"uid": "hdjonbiyfs62ie", "anon": "no", "when": "2015-04-29T06:51:37Z", "data": "i92dwwl5kk04xu", "type": "create"}, {"to": "i92dwwj2ykr4xs", "uid": "i6t6y9snjx2", "anon": "no", "when": "2015-04-29T08:46:27Z", "type": "followup"}, {"to": "i92dwwj2ykr4xs", "uid": "hdjonbiyfs62ie", "anon": "no", "when": "2015-04-29T14:25:35Z", "type": "feedback"}, {"to": "i92dwwj2ykr4xs", "uid": "i6t1w87gRBD", "anon": "no", "when": "2015-05-06T05:38:04Z", "type": "followup"}, {"to": "i92dwwj2ykr4xs", "uid": "i6t6y9snjx2", "anon": "no", "when": "2015-05-06T09:00:33Z", "type": "followup"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "第17讲课堂练习", "created": "2015-04-29T06:51:37Z", "content": "<p>尝试准确描述Eisenberg同步算法&#xff0c;并通过枚举和分类方法检查其正确性。</p>\n<p></p>\n<p><a href=\"http://os.cs.tsinghua.edu.cn/oscourse/OS2015/lecture17#head-0139bb344f3d3f88e6df2ba2bc7d358d39f9f69f\">http://os.cs.tsinghua.edu.cn/oscourse/OS2015/lecture17#head-0139bb344f3d3f88e6df2ba2bc7d358d39f9f69f</a></p>\n<p></p>\n<p>请参与课堂讨论的同学&#xff0c;回复你的回答。</p>\n<p></p>"}], "type": "note", "tags": ["instructor-note", "课堂问答"], "tag_good": [], "unique_views": 112, "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>计25 矣晓沅</p>\n<p>照我的理解多个线程的伪代码如下&#xff1a;</p>\n<p>//当前线程为i<br />//线程队列为0,1,...,i-1,i,i&#43;1,...,n<br />do {<br />      <br />        flag[i] = true;<br />        nowWho = turn; //当前占用资源的线程<br />        while (nowWho != i) {<br />            if (flag[nowWho] != false) nowWho = turn; //当前占用资源资源的线程未出临界区&#xff0c;则一直等待<br />            else nowWho = (nowWho&#43;1) % n;<br />        } //直到turn交给i       <br />        //临界区<br />        CRITICAL SECTION<br />        //退出区<br />        nextWho = (turn&#43;1) % n;<br /><br />        while (flags[nextWho] != true) {<br />                nextWho = (nextWho&#43;1) % n;<br />        } //找到下一个需要资源的线程<br />        turn = nextWho;<br />        flag[i] = false;<br />        EMAINDER SECTION<br />   } while (true);    </p>\n<p></p>\n<p>查了一些资料&#xff0c;貌似更复杂一点的Eisenberg算法将flag的取值分为了三种——</p>\n<p>IDLE&#xff1a;进程不想进入临界区&#xff1b;</p>\n<p>WAITING&#xff1a;进程想进入临界区&#xff1b;</p>\n<p>ACTIVE&#xff1a;进程想进或已进临界区</p>\n<p>下面是网上找到的一篇Eisenberg算法伪代码的博文&#xff0c;大家可以参考&#xff1a;</p>\n<p>http://blog.csdn.net/asce1885/article/details/5735565</p>", "created": "2015-04-29T08:46:27Z", "bucket_order": 263, "bucket_name": "Week 4/26 - 5/2", "type": "followup", "tag_good": [], "uid": "i6t6y9snjx2", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>你的算法是有问题的。可以分析一下你的算法与参考实现的区别&#xff0c;然后尝试构造一种执行顺序&#xff0c;出现两个以上的线程都进入临界区。</p>\n<p></p>\n<p>也欢迎其他同学参与这个分析。这个过程也还是有点儿脑筋急转弯儿的。</p>", "created": "2015-04-29T14:25:35Z", "bucket_order": 263, "bucket_name": "Week 4/26 - 5/2", "type": "feedback", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [], "tag_good_arr": [], "id": "i92u4pd5uh46jr", "updated": "2015-04-29T14:25:35Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "i92i0l295326sz", "updated": "2015-04-29T08:46:27Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p></p>\n<pre>flag[0]:= false; flag[1]:= false; turn:= 0;//or1 \n\t\ndo {\n       flag[i] = want;\n       while (flag[turn] != false) { \n            if turn ≠ i { \n               flag[i] := wait \n               while turn ≠ i { } \n               flag[i] := true \n            }  \n        } \n\tturn = i\n        CRITICAL SECTION\n\tturn := (i&#43;1)%n\n\twhile(flag[turn] == false &amp;&amp; turn != i)\n\t{\n\t\tturn := (i&#43;1)%n\n\t}\n       flag[i] = false;\n        EMAINDER SECTION\n   } while (true);\t</pre>\n<p>这个是我的想法&#xff0c;课上想好的但回去就忘记写上来了orz</p>\n<p>王昊 2012011341</p>", "created": "2015-05-06T05:38:03Z", "bucket_order": 262, "bucket_name": "Week 5/3 - 5/9", "type": "followup", "tag_good": [], "uid": "i6t1w87gRBD", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "i9cbd9w8udm9a", "updated": "2015-05-06T05:38:03Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>感谢老师和王昊兄的指正&#xff5e;我上面写的算法是有问题 的。</p>\n<p>如下&#xff1a;</p>\n<p>现在假设线程队列中有两个线程k1&#xff0c;k2&#xff0c;位置如下, k2 == k1&#43;1</p>\n<p>0,1&#xff0c;...,k1,k2,...,n</p>\n<p>又假设此时turn = k1</p>\n<p>那么&#xff0c;若此时k2先执行&#xff0c;则flag[k2] 设为true&#xff0c;且nowWhok2 = k1&#xff0c;进入循环</p>\n<p>由于当前k1尚未执行&#xff0c;所以flag[k1]是false&#xff0c;那么在k2线程的while循环内部&#xff0c;会将nowWhok2加1&#xff0c;使得nowWhok2等于k2&#xff0c;退出循环&#xff0c;进入临界区。假设这时k2的时间片用完&#xff0c;切到了k1。注意此时turn的值仍然是k1&#xff0c;所以nowWhok1 设为k1&#xff0c;不进入while循环直接进入临界区。所以此时k1和k2都进入了临界区&#xff0c;产生错误。</p>\n<p></p>\n<p>我的算法的问题在于&#xff0c;用nowWho这样一个变量暂存了turn的值&#xff0c;k2进入临界区后&#xff0c;turn的值没有被改变&#xff0c;所以k1仍然会认为turn属于自己。我是参考了上面给出的blog中的伪代码&#xff0c;blog中的代码是可以解决上述问题的。</p>\n<p></p>\n<p>blog中的伪代码里&#xff0c;当index(即我的nowWho)等于i时&#xff0c;没有立刻进入临界区&#xff0c;而是先有下面这段代码&#xff1a;</p>\n<p>index = 0;</p>\n<p>while ((index &lt; n) &amp;&amp; ((index == i) || (flags[index] != ACTIVE))) {     &#xff08;1&#xff09;</p>\n<p>    index = index&#43;1;</p>\n<p>}</p>\n<p></p>\n<p>上面这段代码包括整个index的while等待都包在一个repeat循环里&#xff0c;repeat循环的退出条件为&#xff1a;</p>\n<p>until ((index &gt;= n) &amp;&amp; ((turn == i) || (flags[turn] == IDLE)));     &#xff08;2&#xff09;</p>\n<p></p>\n<p>还是上面那个例子&#xff0c;当k1和k2都退出while循环后&#xff0c;blog中的方法并没有直接进入临界取&#xff0c;而是先执行&#xff08;1&#xff09;&#xff0c;再由&#xff08;2&#xff09;判断&#xff0c;只有退出&#xff08;2&#xff09;的repeat循环后&#xff0c;才能进入临界区。</p>\n<p>&#xff08;1&#xff09;处代码的作用为&#xff0c;找到队列中第一个处于ACTIVE状态的线程&#xff0c;如果这个线程是我自己&#xff0c;那么index将会加到n&#xff0c;然后如果此时turn还在我手中&#xff0c;则会退出repeat&#xff0c;进入临界区&#xff1b;如果第一个处于ACTIVE状态的线程不是我自己&#xff0c;那么index会等于这个线程的位置&#xff0c;无法退出repeat&#xff0c;继续整个循环等待。</p>\n<p>下面看刚刚说的k1和k2.两个线程都退出了第一个while循环&#xff0c;进入ACTIVE状态。</p>\n<p>那么对k2来说&#xff0c;执行代码段(1)&#xff0c;如果此时k1尚未进入ACTIVE状态&#xff0c;则会将index加到n&#xff0c;如果此时k1已经进入ACTIVE状态&#xff0c;则会将index加到k1&#xff0c;但不论那种情况&#xff0c;因为turn&#xff01;= k2&#xff0c;k2都无法退出repeat进入临界区。</p>\n<p>那么对k1&#xff0c;执行代码段&#xff08;2&#xff09;&#xff0c;当index加到k2时&#xff0c;虽然index&#xff01;=k1&#xff0c;但是此时flag[k2]!=ACTIVE.因为之前说到&#xff0c;k2又重新进行了repeat循环&#xff0c;将flag[k2]置为了WAITING&#xff0c;此时flag[k1] == ACTIVE, 所以k2在第一个while循环中一直以WAITING状态等待。所以k1中&#xff0c;index能加到n&#xff0c;然后退出repeat进入临界区。</p>\n<p></p>\n<p>所以blog中的算法将状态设置为3个而不是两个是有道理的&#xff0c;相当于加了两重等待。</p>", "created": "2015-05-06T09:00:33Z", "bucket_order": 262, "bucket_name": "Week 5/3 - 5/9", "type": "followup", "tag_good": [], "uid": "i6t6y9snjx2", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "i9cilop5tjp7ny", "updated": "2015-05-06T09:00:33Z", "config": {}}], "tag_good_arr": [], "id": "i92dwwj2ykr4xs", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 4, "num_favorites": 1, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643167685046, "default_anonymity": "no"}, "error": null, "aid": "kyuzm46u46o6ns"}