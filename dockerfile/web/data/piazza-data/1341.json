{"result": {"folders": ["lab1"], "nr": 1341, "data": {"embed_links": []}, "created": "2019-06-20T08:21:35Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "stud", "data": "jx4ecgtf8xo9b", "type": "create", "when": "2019-06-20T08:21:35Z", "uid_a": "a_0"}, {"anon": "stud", "data": "jx4ehhlr1p4574", "type": "update", "when": "2019-06-20T08:25:30Z", "uid_a": "a_0"}], "bucket_name": "Today", "history": [{"anon": "stud", "uid_a": "a_0", "subject": "如何理解comments---&gt; ebp = ss:[ebp]吗", "created": "2019-06-20T08:25:30Z", "content": "<p>关于一下函数&#xff1a;</p>\n<pre>static inline uint32_t\nread_ebp(void) {\n    uint32_t ebp;\n    asm volatile (&#34;movl %%ebp, %0&#34; : &#34;=r&#34; (ebp));\n    return ebp;\n}</pre>\n<p></p>\n<p>在函数print_stackframe(void)里有如下注释&#xff1a;</p>\n<pre>/* LAB1 YOUR CODE : STEP 1 */\n     /* (1) call read_ebp() to get the value of ebp. the type is (uint32_t);\n      * (2) call read_eip() to get the value of eip. the type is (uint32_t);\n      * (3) from 0 .. STACKFRAME_DEPTH\n      *    (3.1) printf value of ebp, eip\n      *    (3.2) (uint32_t)calling arguments [0..4] = the contents in address (unit32_t)ebp &#43;2 [0..4]\n      *    (3.3) cprintf(&#34;\\n&#34;);\n      *    (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc.\n      *    (3.5) popup a calling stackframe\n      *           &lt;strong&gt;NOTICE: the calling funciton&#39;s return addr eip  = ss:[ebp&#43;4]\n      *                   the calling funciton&#39;s ebp = ss:[ebp]&lt;/strong&gt;\n      */</pre>\n<p>但是答案代码上也并没有体现出来这一点&#xff1a;</p>\n<pre>eip = ((uint32_t *)ebp)[1];\nebp = ((uint32_t *)ebp)[0];</pre>\n<p>如果可以解释一下的话&#xff0c;其实内核段在逻辑地址到线性地址之间是对等映射所以不用考虑段。或者我们说DS和SS是同一个段描述符所以我们不用考虑。如果不是基于以上原因我们就得考虑&#xff1f;</p>"}, {"anon": "stud", "uid_a": "a_0", "subject": "read_ebp()函数返回的地址是ebp = ss:[ebp]吗", "created": "2019-06-20T08:21:35Z", "content": "<p>关于一下函数&#xff1a;</p>\n<pre>static inline uint32_t<br />read_ebp(void) {<br />    uint32_t ebp;<br />    asm volatile (&#34;movl %%ebp, %0&#34; : &#34;=r&#34; (ebp));<br />    return ebp;<br />}</pre>\n<p></p>\n<p>在函数print_stackframe(void)里有如下注释&#xff1a;</p>\n<pre>/* LAB1 YOUR CODE : STEP 1 */\n     /* (1) call read_ebp() to get the value of ebp. the type is (uint32_t);\n      * (2) call read_eip() to get the value of eip. the type is (uint32_t);\n      * (3) from 0 .. STACKFRAME_DEPTH\n      *    (3.1) printf value of ebp, eip\n      *    (3.2) (uint32_t)calling arguments [0..4] = the contents in address (unit32_t)ebp &#43;2 [0..4]\n      *    (3.3) cprintf(&#34;\\n&#34;);\n      *    (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc.\n      *    (3.5) popup a calling stackframe\n      *           <strong>NOTICE: the calling funciton&#39;s return addr eip  = ss:[ebp&#43;4]\n      *                   the calling funciton&#39;s ebp = ss:[ebp]</strong>\n      */</pre>\n<p>但是答案代码上也并没有体现出来这一点&#xff1a;</p>\n<pre>eip = ((uint32_t *)ebp)[1];<br />ebp = ((uint32_t *)ebp)[0];</pre>\n<p>如果可以解释一下的话&#xff0c;其实内核段在逻辑地址到线性地址之间是对等映射所以不用考虑段。或者我们说DS和SS是同一个段描述符所以我们不用考虑。如果不是基于以上原因我们就得考虑&#xff1f;</p>"}], "type": "question", "tags": ["lab1", "student", "unanswered"], "tag_good": [], "unique_views": 132, "children": [], "tag_good_arr": [], "no_answer": 1, "id": "jx4ecgtd31k9a", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 1, "num_favorites": 0, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169795532, "default_anonymity": "no"}, "error": null, "aid": "kyv0vcngd8042u"}