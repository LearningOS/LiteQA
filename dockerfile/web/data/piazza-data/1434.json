{"result": {"folders": ["lecture11"], "nr": 1434, "data": {"embed_links": []}, "created": "2020-03-26T02:12:42Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "full", "data": "k884gkxeouk4kg", "type": "create", "when": "2020-03-26T02:12:42Z", "uid_a": "a_0"}, {"anon": "full", "data": "k884h9bk33q596", "type": "update", "when": "2020-03-26T02:13:13Z", "uid_a": "a_0"}, {"anon": "full", "uid_a": "a_0", "data": "k884hqg89fi5op", "type": "update", "when": "2020-03-26T02:13:35Z"}], "bucket_name": "Today", "history": [{"anon": "full", "uid_a": "a_0", "subject": "第十一讲课后练习展示", "created": "2020-03-26T02:13:35Z", "content": "<p>题目&#xff1a;</p>\n<p>参考往届同学的处理机调度算法实现练习&#xff0c;从下列7个算法&#xff08;FIFO、SJF、RR、MLFQ、stride、EDF、RM&#xff09;中选择一个你感兴趣的调度算法&#xff0c;对其实现进行完善&#xff0c;并分析算法特征。</p>\n<p>模板代码&#xff1a;<a href=\"https://github.com/chyyuu/ucore_os_lab/blob/master/related_info/lab6/scheduler-homework.py\">https://github.com/chyyuu/ucore_os_lab/blob/master/related_info/lab6/scheduler-homework.py</a></p>\n<p>同学们主要实现了FIFO、SJF和RR调度算法。</p>\n<p></p>\n<p>FIFO&#xff1a;</p>\n<pre>if options.policy == &#39;FIFO&#39;:\n    thetime = 0\n    print &#39;Execution trace:&#39;\n    for tmp in joblist:\n        print &#39;  [ time %3d ] Run job %d for %3.2f secs ( DONE at %3.2f )&#39; % (thetime, tmp[0], tmp[1], thetime &#43; tmp[1])\n        thetime &#43;= tmp[1]</pre>\n<p>只需要按照顺序执行即可&#xff0c;简单的雅痞。</p>\n<p>周转效率也比较低&#xff0c;平均等待时间波动大&#xff0c;相应时间没有保证&#xff0c;依赖于入队顺序。</p>\n<p></p>\n<p>SJF&#xff1a;</p>\n<pre>if options.policy == &#39;SJF&#39;:\n    joblist.sort(key=lambda x: x[1])\n    \n    thetime = 0\n    print &#39;Execution trace:&#39;\n    for tmp in joblist:\n        print &#39;  [ time %3d ] Run job %d for %3.2f secs ( DONE at %3.2f )&#39; % (thetime, tmp[0], tmp[1], thetime &#43; tmp[1])\n        thetime &#43;= tmp[1]</pre>\n<p>只需要在开头进行一次排序&#xff0c;然后按次序执行即可。</p>\n<p>周转时间最优&#xff0c;但是响应时间不稳定。</p>\n<p></p>\n<p>RR</p>\n<pre>if options.policy == &#39;RR&#39;:\n    print &#39;Execution trace:&#39;\n    turnaround = {}\n    response = {}\n    lastran = {}\n    wait = {}\n    quantum  = float(options.quantum)\n    jobcount = len(joblist)\n    for i in range(0,jobcount):\n        lastran[i] = 0.0\n        wait[i] = 0.0\n        turnaround[i] = 0.0\n        response[i] = -1\n\n    runlist = []\n    for e in joblist:\n        runlist.append(e)\n\n    thetime  = 0.0\n    while jobcount &gt; 0:\n        # print &#39;%d jobs remaining&#39; % jobcount\n        job = runlist.pop(0)\n        jobnum  = job[0]\n        runtime = float(job[1])\n        if response[jobnum] == -1:\n            response[jobnum] = thetime\n        currwait = thetime - lastran[jobnum]\n        wait[jobnum] &#43;= currwait\n        ranfor = 0\n        if runtime &gt; quantum:\n            ranfor = quantum\n            runtime -= quantum\n            print &#39;  [ time %3d ] Run job %3d for %.2f secs&#39; % (thetime, jobnum, ranfor)\n            runlist.append([jobnum, runtime])\n        else:\n            ranfor = runtime\n            print &#39;  [ time %3d ] Run job %3d for %.2f secs ( DONE at %.2f )&#39; % (thetime, jobnum, ranfor, thetime &#43; ranfor)\n            turnaround[jobnum] = thetime &#43; ranfor\n            jobcount -= 1\n        thetime &#43;= ranfor\n        lastran[jobnum] = thetime</pre>\n<p>实现难度也较小&#xff0c;执行完一个时间片进行判断删除还是加入队尾即可。</p>\n<p>分析&#xff1a;&#xff08;计65 <a href=\"mailto:laijinlin&#64;laijinlindeMacBook-Pro.local\">赖金霖</a> https://git.tsinghua.edu.cn/laijl16/os-homeworks/tree/master/lec11&#xff09;</p>\n<p><img src=\"/img/1434-f76a16459410cb63.png\" alt=\"\" /></p>\n<p>可以看出&#xff0c;随着时间片的增大&#xff0c;平均反应时间增加。而平均等待时间和平均完成时间的曲线模式相同&#xff08;两者相差平均运行时间&#xff09;。可以看出&#xff0c;当时间片增大时&#xff0c;平均等待时间有下降趋势&#xff0c;而当执行顺序相同时&#xff0c;随着时间片增大&#xff0c;平均等待时间增大&#xff08;如上图的局部上升直线所示&#xff09;。</p>\n<p><img src=\"/img/1434-73af4249b30fd209.png\" alt=\"\" /></p>\n<p>当时间片较大时&#xff0c;趋势不变&#xff0c;但是当时间片很小时&#xff0c;平均等待时间和平均完成时间迅速上升。</p>\n<p></p>\n<p>MLFQ&#xff1a;</p>\n<pre>if options.policy == &#39;MLFQ&#39;:\n        thetime = 0\n        multilist = [] #creates multi list\n        tempjoblist = joblist.copy()\n        multilist.append(tempjoblist) #places joblist in multilist[0]\n        quantumlist = []\n        quantumlist.append(float(options.quantum))\n        print(&#39;Execution trace:&#39;)\n\t\t#YOUR CODE\n        turnaround = {}\n        response = {}\n        lastran = {}\n        wait = {}\n        jobcount = len(joblist)\n        for i in range(0,jobcount):\n            lastran[i] = 0.0\n            wait[i] = 0.0\n            turnaround[i] = 0.0\n            response[i] = -1\n        \n        while len(multilist) &gt; 0:\n            \n            runlist = multilist.pop(0)\n            quantum = quantumlist.pop(0)\n            print(&#39;running on new list, quantum &#39;, quantum)\n            while len(runlist) &gt; 0:\n                job = runlist.pop(0)\n                jobnum  = job[0]\n                runtime = float(job[1])\n                if response[jobnum] == -1:\n                    response[jobnum] = thetime\n                currwait = thetime - lastran[jobnum]\n                wait[jobnum] &#43;= currwait\n                ranfor = 0\n                if runtime &gt; quantum:\n                    ranfor = quantum\n                    runtime = runtime - quantum\n                    print(&#39;  [ time %3d ] Run job %3d for %.2f secs&#39; % (thetime, jobnum, ranfor))\n                    if len(multilist) == 0:\n                        addlist = []\n                        addlist.append([jobnum, runtime])\n                        multilist.append(addlist)\n                        quantumlist.append(quantum &#43; 1)\n                        #print(&#39;creating new list&#39;)\n                    else:\n                        multilist[0].append([jobnum, runtime]) #next level of multilist\n                else:\n                    \n                    ranfor = runtime\n                    print(&#39;  [ time %3d ] Run job %3d for %.2f secs ( DONE at %.2f )&#39; % (thetime, jobnum, ranfor, thetime &#43; ranfor))\n                    turnaround[jobnum] = thetime &#43; ranfor\n                    jobcount -= 1\n                thetime &#43;= ranfor\n                lastran[jobnum] = thetime</pre>\n<p dir=\"auto\">参考实现&#xff1a;</p>\n<p dir=\"auto\">维护一个<code>multilist</code>多级队列&#xff0c;将初始的<code>joblist</code>放入<code>multilist[0]</code>。在<code>multilist</code>不为空的情况下&#xff0c;先跑完优先级最高的队列&#xff0c;再按照优先级一个队列一个队列开始跑&#xff0c;优先级越低&#xff0c;时间片越长。为了简单起见&#xff0c;假设队列n比队列n&#43;1优先级高一级&#xff0c;那么队列n&#43;1的时间片我设为比队列n的时间片长一秒。如果当前进程在该队列中没有跑完&#xff0c;则加入下一优先级队列中。</p>\n<p dir=\"auto\">分析&#xff1a;</p>\n<p dir=\"auto\">这种算法的特征就是进程的在CPU执行时间越短&#xff0c;优先级越高。</p>"}, {"anon": "full", "uid_a": "a_0", "subject": "第十一讲课后练习展示", "created": "2020-03-26T02:13:13Z", "content": "<p>题目&#xff1a;</p>\n<p>参考往届同学的处理机调度算法实现练习&#xff0c;从下列7个算法&#xff08;FIFO、SJF、RR、MLFQ、stride、EDF、RM&#xff09;中选择一个你感兴趣的调度算法&#xff0c;对其实现进行完善&#xff0c;并分析算法特征。</p>\n<p>模板代码&#xff1a;<a href=\"https://github.com/chyyuu/ucore_os_lab/blob/master/related_info/lab6/scheduler-homework.py\">https://github.com/chyyuu/ucore_os_lab/blob/master/related_info/lab6/scheduler-homework.py</a></p>\n<p>同学们主要实现了FIFO、SJF和RR调度算法。</p>\n<p></p>\n<p>FIFO&#xff1a;</p>\n<pre>if options.policy == &#39;FIFO&#39;:\n    thetime = 0\n    print &#39;Execution trace:&#39;\n    for tmp in joblist:\n        print &#39;  [ time %3d ] Run job %d for %3.2f secs ( DONE at %3.2f )&#39; % (thetime, tmp[0], tmp[1], thetime &#43; tmp[1])\n        thetime &#43;= tmp[1]</pre>\n<p>只需要按照顺序执行即可&#xff0c;简单的雅痞。</p>\n<p>周转效率也比较低&#xff0c;平均等待时间波动大&#xff0c;相应时间没有保证&#xff0c;依赖于入队顺序。</p>\n<p></p>\n<p>SJF&#xff1a;</p>\n<pre>if options.policy == &#39;SJF&#39;:\n    joblist.sort(key=lambda x: x[1])\n    \n    thetime = 0\n    print &#39;Execution trace:&#39;\n    for tmp in joblist:\n        print &#39;  [ time %3d ] Run job %d for %3.2f secs ( DONE at %3.2f )&#39; % (thetime, tmp[0], tmp[1], thetime &#43; tmp[1])\n        thetime &#43;= tmp[1]</pre>\n<p>只需要在开头进行一次排序&#xff0c;然后按次序执行即可。</p>\n<p>周转时间最优&#xff0c;但是响应时间不稳定</p>\n<p></p>\n<p>RR</p>\n<pre>if options.policy == &#39;RR&#39;:\n    print &#39;Execution trace:&#39;\n    turnaround = {}\n    response = {}\n    lastran = {}\n    wait = {}\n    quantum  = float(options.quantum)\n    jobcount = len(joblist)\n    for i in range(0,jobcount):\n        lastran[i] = 0.0\n        wait[i] = 0.0\n        turnaround[i] = 0.0\n        response[i] = -1\n\n    runlist = []\n    for e in joblist:\n        runlist.append(e)\n\n    thetime  = 0.0\n    while jobcount &gt; 0:\n        # print &#39;%d jobs remaining&#39; % jobcount\n        job = runlist.pop(0)\n        jobnum  = job[0]\n        runtime = float(job[1])\n        if response[jobnum] == -1:\n            response[jobnum] = thetime\n        currwait = thetime - lastran[jobnum]\n        wait[jobnum] &#43;= currwait\n        ranfor = 0\n        if runtime &gt; quantum:\n            ranfor = quantum\n            runtime -= quantum\n            print &#39;  [ time %3d ] Run job %3d for %.2f secs&#39; % (thetime, jobnum, ranfor)\n            runlist.append([jobnum, runtime])\n        else:\n            ranfor = runtime\n            print &#39;  [ time %3d ] Run job %3d for %.2f secs ( DONE at %.2f )&#39; % (thetime, jobnum, ranfor, thetime &#43; ranfor)\n            turnaround[jobnum] = thetime &#43; ranfor\n            jobcount -= 1\n        thetime &#43;= ranfor\n        lastran[jobnum] = thetime</pre>\n<p>实现难度也较小&#xff0c;执行完一个时间片进行判断删除还是加入队尾即可。</p>\n<p>分析&#xff1a;&#xff08;计65 <a href=\"mailto:laijinlin&#64;laijinlindeMacBook-Pro.local\">赖金霖</a> https://git.tsinghua.edu.cn/laijl16/os-homeworks/tree/master/lec11&#xff09;</p>\n<p><img src=\"/img/1434-f76a16459410cb63.png\" alt=\"\" /></p>\n<p>可以看出&#xff0c;随着时间片的增大&#xff0c;平均反应时间增加。而平均等待时间和平均完成时间的曲线模式相同&#xff08;两者相差平均运行时间&#xff09;。可以看出&#xff0c;当时间片增大时&#xff0c;平均等待时间有下降趋势&#xff0c;而当执行顺序相同时&#xff0c;随着时间片增大&#xff0c;平均等待时间增大&#xff08;如上图的局部上升直线所示&#xff09;。</p>\n<p><img src=\"/img/1434-73af4249b30fd209.png\" alt=\"\" /></p>\n<p>当时间片较大时&#xff0c;趋势不变&#xff0c;但是当时间片很小时&#xff0c;平均等待时间和平均完成时间迅速上升。</p>\n<p></p>\n<p>MLFQ&#xff1a;</p>\n<pre>if options.policy == &#39;MLFQ&#39;:\n        thetime = 0\n        multilist = [] #creates multi list\n        tempjoblist = joblist.copy()\n        multilist.append(tempjoblist) #places joblist in multilist[0]\n        quantumlist = []\n        quantumlist.append(float(options.quantum))\n        print(&#39;Execution trace:&#39;)\n\t\t#YOUR CODE\n        turnaround = {}\n        response = {}\n        lastran = {}\n        wait = {}\n        jobcount = len(joblist)\n        for i in range(0,jobcount):\n            lastran[i] = 0.0\n            wait[i] = 0.0\n            turnaround[i] = 0.0\n            response[i] = -1\n        \n        while len(multilist) &gt; 0:\n            \n            runlist = multilist.pop(0)\n            quantum = quantumlist.pop(0)\n            print(&#39;running on new list, quantum &#39;, quantum)\n            while len(runlist) &gt; 0:\n                job = runlist.pop(0)\n                jobnum  = job[0]\n                runtime = float(job[1])\n                if response[jobnum] == -1:\n                    response[jobnum] = thetime\n                currwait = thetime - lastran[jobnum]\n                wait[jobnum] &#43;= currwait\n                ranfor = 0\n                if runtime &gt; quantum:\n                    ranfor = quantum\n                    runtime = runtime - quantum\n                    print(&#39;  [ time %3d ] Run job %3d for %.2f secs&#39; % (thetime, jobnum, ranfor))\n                    if len(multilist) == 0:\n                        addlist = []\n                        addlist.append([jobnum, runtime])\n                        multilist.append(addlist)\n                        quantumlist.append(quantum &#43; 1)\n                        #print(&#39;creating new list&#39;)\n                    else:\n                        multilist[0].append([jobnum, runtime]) #next level of multilist\n                else:\n                    \n                    ranfor = runtime\n                    print(&#39;  [ time %3d ] Run job %3d for %.2f secs ( DONE at %.2f )&#39; % (thetime, jobnum, ranfor, thetime &#43; ranfor))\n                    turnaround[jobnum] = thetime &#43; ranfor\n                    jobcount -= 1\n                thetime &#43;= ranfor\n                lastran[jobnum] = thetime</pre>\n<p dir=\"auto\">参考实现&#xff1a;</p>\n<p dir=\"auto\">维护一个<code>multilist</code>多级队列&#xff0c;将初始的<code>joblist</code>放入<code>multilist[0]</code>。在<code>multilist</code>不为空的情况下&#xff0c;先跑完优先级最高的队列&#xff0c;再按照优先级一个队列一个队列开始跑&#xff0c;优先级越低&#xff0c;时间片越长。为了简单起见&#xff0c;假设队列n比队列n&#43;1优先级高一级&#xff0c;那么队列n&#43;1的时间片我设为比队列n的时间片长一秒。如果当前进程在该队列中没有跑完&#xff0c;则加入下一优先级队列中。</p>\n<p dir=\"auto\">分析&#xff1a;</p>\n<p dir=\"auto\">这种算法的特征就是进程的在CPU执行时间越短&#xff0c;优先级越高。</p>"}, {"anon": "full", "uid_a": "a_0", "subject": "第十一讲课后练习展示", "created": "2020-03-26T02:12:42Z", "content": "<p>题目&#xff1a;</p>\n<p>参考往届同学的处理机调度算法实现练习&#xff0c;从下列7个算法&#xff08;FIFO、SJF、RR、MLFQ、stride、EDF、RM&#xff09;中选择一个你感兴趣的调度算法&#xff0c;对其实现进行完善&#xff0c;并分析算法特征。</p>\n<p>模板代码&#xff1a;<a href=\"https://github.com/chyyuu/ucore_os_lab/blob/master/related_info/lab6/scheduler-homework.py\">https://github.com/chyyuu/ucore_os_lab/blob/master/related_info/lab6/scheduler-homework.py</a></p>\n<p>同学们主要实现了FIFO、SJF和RR调度算法。</p>\n<p></p>\n<p>FIFO&#xff1a;</p>\n<pre>if options.policy == &#39;FIFO&#39;:<br />    thetime = 0<br />    print &#39;Execution trace:&#39;<br />    for tmp in joblist:<br />        print &#39;  [ time %3d ] Run job %d for %3.2f secs ( DONE at %3.2f )&#39; % (thetime, tmp[0], tmp[1], thetime &#43; tmp[1])<br />        thetime &#43;= tmp[1]</pre>\n<p>只需要按照顺序执行即可&#xff0c;简单的雅痞。</p>\n<p>周转效率也比较低&#xff0c;平均等待时间波动大&#xff0c;相应时间没有保证&#xff0c;依赖于入队顺序。</p>\n<p></p>\n<p>SJF&#xff1a;</p>\n<pre>if options.policy == &#39;SJF&#39;:\n    joblist.sort(key=lambda x: x[1])\n    \n    thetime = 0\n    print &#39;Execution trace:&#39;\n    for tmp in joblist:\n        print &#39;  [ time %3d ] Run job %d for %3.2f secs ( DONE at %3.2f )&#39; % (thetime, tmp[0], tmp[1], thetime &#43; tmp[1])\n        thetime &#43;= tmp[1]</pre>\n<p>只需要在开头进行一次排序&#xff0c;然后按次序执行即可。</p>\n<p>周转时间最优&#xff0c;但是相应时间不稳定</p>\n<p></p>\n<p>RR</p>\n<pre>if options.policy == &#39;RR&#39;:\n    print &#39;Execution trace:&#39;\n    turnaround = {}\n    response = {}\n    lastran = {}\n    wait = {}\n    quantum  = float(options.quantum)\n    jobcount = len(joblist)\n    for i in range(0,jobcount):\n        lastran[i] = 0.0\n        wait[i] = 0.0\n        turnaround[i] = 0.0\n        response[i] = -1\n\n    runlist = []\n    for e in joblist:\n        runlist.append(e)\n\n    thetime  = 0.0\n    while jobcount &gt; 0:\n        # print &#39;%d jobs remaining&#39; % jobcount\n        job = runlist.pop(0)\n        jobnum  = job[0]\n        runtime = float(job[1])\n        if response[jobnum] == -1:\n            response[jobnum] = thetime\n        currwait = thetime - lastran[jobnum]\n        wait[jobnum] &#43;= currwait\n        ranfor = 0\n        if runtime &gt; quantum:\n            ranfor = quantum\n            runtime -= quantum\n            print &#39;  [ time %3d ] Run job %3d for %.2f secs&#39; % (thetime, jobnum, ranfor)\n            runlist.append([jobnum, runtime])\n        else:\n            ranfor = runtime\n            print &#39;  [ time %3d ] Run job %3d for %.2f secs ( DONE at %.2f )&#39; % (thetime, jobnum, ranfor, thetime &#43; ranfor)\n            turnaround[jobnum] = thetime &#43; ranfor\n            jobcount -= 1\n        thetime &#43;= ranfor\n        lastran[jobnum] = thetime</pre>\n<p>实现难度也较小&#xff0c;执行完一个时间片进行判断删除还是加入队尾即可。</p>\n<p>分析&#xff1a;&#xff08;计65 <a href=\"mailto:laijinlin&#64;laijinlindeMacBook-Pro.local\">赖金霖</a> https://git.tsinghua.edu.cn/laijl16/os-homeworks/tree/master/lec11&#xff09;</p>\n<p><img src=\"/img/1434-f76a16459410cb63.png\" alt=\"\" /></p>\n<p>可以看出&#xff0c;随着时间片的增大&#xff0c;平均反应时间增加。而平均等待时间和平均完成时间的曲线模式相同&#xff08;两者相差平均运行时间&#xff09;。可以看出&#xff0c;当时间片增大时&#xff0c;平均等待时间有下降趋势&#xff0c;而当执行顺序相同时&#xff0c;随着时间片增大&#xff0c;平均等待时间增大&#xff08;如上图的局部上升直线所示&#xff09;。</p>\n<p><img src=\"/img/1434-73af4249b30fd209.png\" alt=\"\" /></p>\n<p>当时间片较大时&#xff0c;趋势不变&#xff0c;但是当时间片很小时&#xff0c;平均等待时间和平均完成时间迅速上升。</p>\n<p></p>\n<p>MLFQ&#xff1a;</p>\n<pre>if options.policy == &#39;MLFQ&#39;:\n        thetime = 0\n        multilist = [] #creates multi list\n        tempjoblist = joblist.copy()\n        multilist.append(tempjoblist) #places joblist in multilist[0]\n        quantumlist = []\n        quantumlist.append(float(options.quantum))\n        print(&#39;Execution trace:&#39;)\n\t\t#YOUR CODE\n        turnaround = {}\n        response = {}\n        lastran = {}\n        wait = {}\n        jobcount = len(joblist)\n        for i in range(0,jobcount):\n            lastran[i] = 0.0\n            wait[i] = 0.0\n            turnaround[i] = 0.0\n            response[i] = -1\n        \n        while len(multilist) &gt; 0:\n            \n            runlist = multilist.pop(0)\n            quantum = quantumlist.pop(0)\n            print(&#39;running on new list, quantum &#39;, quantum)\n            while len(runlist) &gt; 0:\n                job = runlist.pop(0)\n                jobnum  = job[0]\n                runtime = float(job[1])\n                if response[jobnum] == -1:\n                    response[jobnum] = thetime\n                currwait = thetime - lastran[jobnum]\n                wait[jobnum] &#43;= currwait\n                ranfor = 0\n                if runtime &gt; quantum:\n                    ranfor = quantum\n                    runtime = runtime - quantum\n                    print(&#39;  [ time %3d ] Run job %3d for %.2f secs&#39; % (thetime, jobnum, ranfor))\n                    if len(multilist) == 0:\n                        addlist = []\n                        addlist.append([jobnum, runtime])\n                        multilist.append(addlist)\n                        quantumlist.append(quantum &#43; 1)\n                        #print(&#39;creating new list&#39;)\n                    else:\n                        multilist[0].append([jobnum, runtime]) #next level of multilist\n                else:\n                    \n                    ranfor = runtime\n                    print(&#39;  [ time %3d ] Run job %3d for %.2f secs ( DONE at %.2f )&#39; % (thetime, jobnum, ranfor, thetime &#43; ranfor))\n                    turnaround[jobnum] = thetime &#43; ranfor\n                    jobcount -= 1\n                thetime &#43;= ranfor\n                lastran[jobnum] = thetime</pre>\n<p dir=\"auto\">参考实现&#xff1a;</p>\n<p dir=\"auto\">维护一个<code>multilist</code>多级队列&#xff0c;将初始的<code>joblist</code>放入<code>multilist[0]</code>。在<code>multilist</code>不为空的情况下&#xff0c;先跑完优先级最高的队列&#xff0c;再按照优先级一个队列一个队列开始跑&#xff0c;优先级越低&#xff0c;时间片越长。为了简单起见&#xff0c;假设队列n比队列n&#43;1优先级高一级&#xff0c;那么队列n&#43;1的时间片我设为比队列n的时间片长一秒。如果当前进程在该队列中没有跑完&#xff0c;则加入下一优先级队列中。</p>\n<p dir=\"auto\">分析&#xff1a;</p>\n<p dir=\"auto\">这种算法的特征就是进程的在CPU执行时间越短&#xff0c;优先级越高。</p>"}], "type": "note", "tags": ["lecture11", "student"], "tag_good": [], "unique_views": 106, "children": [], "tag_good_arr": [], "id": "k884gkxc2544kf", "config": {"seen": {"366": 8, "1027": 6, "1433": 2, "852": 4, "1432": 0, "413": 9, "1022": 7, "1030": 3, "1072": 5, "1428": 1}}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 1, "num_favorites": 0, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643170031658, "default_anonymity": "no"}, "error": null, "aid": "kyv10euiy6523v"}