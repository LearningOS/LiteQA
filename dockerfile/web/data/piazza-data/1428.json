{"result": {"folders": ["lecture7"], "nr": 1428, "data": {"embed_links": []}, "created": "2020-03-15T14:50:29Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "full", "data": "k7t5oqsre1c13e", "type": "create", "when": "2020-03-15T14:50:29Z", "uid_a": "a_0"}, {"anon": "full", "data": "k7t5qgzdjv421e", "type": "update", "when": "2020-03-15T14:51:50Z", "uid_a": "a_0"}, {"anon": "full", "data": "k7t65d43wuu544", "type": "update", "when": "2020-03-15T15:03:25Z", "uid_a": "a_0"}, {"anon": "full", "uid_a": "a_0", "data": "k7tszkevn5x57", "type": "update", "when": "2020-03-16T01:42:46Z"}], "bucket_name": "Today", "history": [{"anon": "full", "uid_a": "a_0", "subject": "第七讲课后习题展示", "created": "2020-03-16T01:42:46Z", "content": "<p><strong>题目一&#xff1a;</strong>考虑在 X86-32 CPU上采用4KB页面大小、两级页表、页表自映射的虚拟存储系统。如果在虚拟地址空间中&#xff0c;4MB 的页表区域从虚拟地址 0xD0000000 开始&#xff0c;请回答自映射页表项的虚拟地址。<br />正确答案&#xff1a;0xD0340D00</p>\n<p>解法简述&#xff1a;典型的自映射情景&#xff0c;此时整个页表(4M)在整个虚存的index&#xff0c;二级页表(4K)在整个页表的index&#xff0c;页表自映射项(4B)在二级页表的index&#xff0c;三者相同&#xff0c;都是 0xD0000000 &gt;&gt; 22 = 0x340&#xff0c;所以答案为 0x340 || 0x340 || 0x340 || 00 = 0xD0340D00</p>\n<p>主要错误&#xff1a;</p>\n<p>1. 0xD0340000  错误为对题干自映射页表项理解有误&#xff0c;自映射页表项是一个4B的页表项。</p>\n<p>2. 0x681A0340‬  竟然有不止一位同学 0x340 || 0x340 || 0x340 || 00 运算出错。。。计算认真一点哦</p>\n<p></p>\n<p></p>\n<p><strong>题目二&#xff1a;</strong>确定选择一种页面置换算法&#xff08;0&#xff1a;LRU置换算法&#xff0c;1:改进的clock 页置换算法&#xff09;中的一种来设计一个应用程序&#xff08;可基于rust, python, ruby, C, C&#43;&#43;&#xff0c;LISP等&#xff09;模拟实现&#xff0c;并给出测试用例和测试结果。请参考如下python代码或独自实现。</p>\n<p></p>\n<p>选择该题目同学较少&#xff0c;但是有些同学完成度极高。由于是简单抽查&#xff0c;可能有些完成很认真的同学作业并没有看到&#xff0c;欢迎毛遂自荐&#xff0c;有切实好处。可在本贴回复姓名学号仓库信息。</p>\n<p>另外提醒大家&#xff0c;如果完成了代码类作业&#xff0c;最好在报告中简单描述自己的做法或者增添注释&#xff0c;这样会极大的方便他人阅读你的代码&#xff08;秋梨膏&#xff09;。</p>\n<p></p>\n<p>示例&#xff1a;</p>\n<p><strong>java-LRU-双向链表&#43;哈希</strong></p>\n<p><strong>计73 陈旭 https://git.tsinghua.edu.cn/chengjw17/os_exercise/</strong></p>\n<pre>import java.util.HashMap;\n\nclass LRU&lt;E&gt; {\n    private class Node&lt;E&gt; {\n        E item;\n        Node&lt;E&gt; prev;\n        Node&lt;E&gt; next;\n\n        Node(Node&lt;E&gt; prev, E item, Node&lt;E&gt; next) {\n            this.prev = prev;\n            this.item = item;\n            this.next = next;\n        }\n    }\n\n    private Node&lt;E&gt; first;\n    private Node&lt;E&gt; last;\n    private HashMap&lt;E, Node&lt;E&gt;&gt; num2unit;\n    private int size;\n    private int capacity;\n\n    LRU(int capacity) {\n        num2unit = new HashMap&lt;&gt;();\n        this.capacity = capacity;\n    }\n\n    private void linkLast(E item) {\n        final Node&lt;E&gt; l = last;\n        final Node&lt;E&gt; newNode = new Node&lt;E&gt;(l, item, null);\n        last = newNode;\n        if (l == null)\n            first = newNode;\n        else\n            l.next = newNode;\n        size&#43;&#43;;\n    }\n\n    private E unlink(Node&lt;E&gt; x) {\n        // assert x != null;\n        final E element = x.item;\n        final Node&lt;E&gt; next = x.next;\n        final Node&lt;E&gt; prev = x.prev;\n\n        if (prev == null) {\n            first = next;\n        } else {\n            prev.next = next;\n            x.prev = null;\n        }\n\n        if (next == null) {\n            last = prev;\n        } else {\n            next.prev = prev;\n            x.next = null;\n        }\n\n        size--;\n        return element;\n    }\n\n    // return whether page fault occurs\n    boolean visit(E item) {\n        Node&lt;E&gt; node = num2unit.get(item);\n        if (node != null) {\n            unlink(node);\n            linkLast(item);\n            num2unit.replace(item, last);\n            return false;\n        } else {\n            if (size == capacity) {\n                num2unit.remove(unlink(first));\n            }\n            linkLast(item);\n            num2unit.put(item, last);\n            return true;\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        LRU&lt;Character&gt; lru = new LRU&lt;&gt;(4);\n        lru.visit(&#39;a&#39;);\n        lru.visit(&#39;b&#39;);\n        lru.visit(&#39;c&#39;);\n        lru.visit(&#39;d&#39;);\n        char[] data = { &#39;c&#39;, &#39;a&#39;, &#39;d&#39;, &#39;b&#39;, &#39;e&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39; };\n        for (var item : data) {\n            System.out.println(String.format(&#34;data %c %s&#34;, item, lru.visit(item) ? &#34;with page fault&#34; : &#34;normal&#34;));\n        }\n    }\n}\n</pre>\n<p></p>\n<p><strong>cpp-LRU-双向链表&#43;哈希(?) </strong></p>\n<p><strong>钟子谦 计预70 https://git.tsinghua.edu.cn/zzq20/os-homework-7<br /> </strong></p>\n<pre>#include &lt;bits/stdc&#43;&#43;.h&gt;\nusing namespace std;\n//assume the system has S virtual pages and W real pages\n#define S 4096\nint W,num_access=0,num_miss=0,num_swap=0;\nint current_size=0;\nbool in_mem[S];\nint L[S&#43;1],R[S&#43;1];\nvoid access_page(int p,bool verbose=false)\n{\n\tassert(p&gt;=0&amp;&amp;p&lt;S);\n\t&#43;&#43;num_access;\n\t#define vprintf if(verbose) printf\n\tvprintf(&#34;Trying to access page %d: &#34;,p);\n\tif(in_mem[p])\n\t{\n\t\tint l=L[p],r=R[p];\n\t\tR[l]=r; L[r]=l;\n\t\tr=R[S];\n\t\tR[S]=p; L[r]=p;\n\t\tL[p]=S; R[p]=r;\n\t\tvprintf(&#34;in memory.\\n&#34;);\n\t\treturn;\n\t}\n\t&#43;&#43;num_miss;\n\tin_mem[p]=1;\n\tif(current_size&#43;1&lt;=W)\n\t{\n\t\t&#43;&#43;current_size;\n\t\tvprintf(&#34;have room, stored.\\n&#34;);\n\t\tint r=R[S];\n\t\tR[S]=p; L[r]=p;\n\t\tL[p]=S; R[p]=r;\n\t\treturn;\n\t}\n\telse\n\t{\n\t\t&#43;&#43;num_swap;\n\t\tint u=L[S];\n\t\tassert(u!=S);\n\t\tvprintf(&#34;full, swapping out %d\\n&#34;,u);\n\t\tint l=L[u],r=R[u];\n\t\tR[l]=r; L[r]=l;\n\t\tin_mem[u]=0;\n\t\tr=R[S];\n\t\tR[S]=p; L[r]=p;\n\t\tL[p]=S; R[p]=r;\n\t}\n\t#undef vprintf\n}\nvoid test_custom()\n{\n\tprintf(&#34;Custom test: enter page to access, -1 to quit\\n&#34;);\n\twhile(1)\n\t{\n\t\tint t=0;\n\t\tprintf(&#34;access page: &#34;);\n\t\tscanf(&#34;%d&#34;,&amp;t);\n\t\tif(t==-1) break;\n\t\tif(t&lt;0||t&gt;=S)\n\t\t{\n\t\t\tprintf(&#34;invalid page!\\n&#34;);\n\t\t\tcontinue;\n\t\t}\n\t\taccess_page(t,true);\n\t}\n}\nvoid test_rng()\n{\n\tsrand(12345);\n\tfor(int i=1;i&lt;=1000000;&#43;&#43;i)\n\t\taccess_page(rand()%S);\n}\nvoid test_cyc()\n{\n\tfor(int i=1;i&lt;=1000000;&#43;&#43;i)\n\t\taccess_page(i%S);\n}\nvoid test_srange()\n{\n\tfor(int i=1;i&lt;=4000;&#43;&#43;i)\n\t{\n\t\tint w=rand()%S;\n\t\tfor(int j=0;j&lt;250;&#43;&#43;j)\n\t\t\taccess_page((w&#43;j)%S);\n\t}\n}\nvoid test_lrange()\n{\n\tfor(int i=1;i&lt;=400;&#43;&#43;i)\n\t{\n\t\tint w=rand()%S;\n\t\tfor(int j=0;j&lt;2500;&#43;&#43;j)\n\t\t\taccess_page((w&#43;j)%S);\n\t}\n}\nvoid test_mat()\n{\n\tint u=36;\n\tassert(u*u*3&lt;=S);\n\tfor(int o=1;o&lt;=7;&#43;&#43;o)\n\t\tfor(int i=0;i&lt;u;&#43;&#43;i)\n\t\t\tfor(int j=0;j&lt;u;&#43;&#43;j)\n\t\t\t\tfor(int k=0;k&lt;u;&#43;&#43;k)\n\t\t\t\t\taccess_page(i*u&#43;j),\n\t\t\t\t\taccess_page(i*u&#43;k&#43;u*u),\n\t\t\t\t\taccess_page(k*u&#43;j&#43;u*u*2);\n}\ntypedef void (*func_ptr)();\nmap&lt;string,func_ptr&gt; f;\nvoid stats()\n{\n\tprintf(&#34;no. of access:\\t%d\\n&#34;,num_access);\n\tprintf(&#34;no. of miss:\\t%d\\n&#34;,num_miss);\n\tprintf(&#34;%% of miss:\\t%.2lf%%\\n&#34;,num_miss*100.0/num_access);\n\tprintf(&#34;no. of swap:\\t%d\\n&#34;,num_swap);\n\tprintf(&#34;%% of swap:\\t%.2lf%%\\n&#34;,num_swap*100.0/num_access);\n}\nvoid init()\n{\n\tL[S]=R[S]=S;\n}\nint main()\n{\n\tf[&#34;custom&#34;]=test_custom;\n\tf[&#34;rng&#34;]=test_rng;\n\tf[&#34;cyc&#34;]=test_cyc;\n\tf[&#34;lrange&#34;]=test_lrange;\n\tf[&#34;srange&#34;]=test_srange;\n\tf[&#34;mat&#34;]=test_mat;\n\tcout&lt;&lt;&#34;========LRU Demo========\\n&#34;;\n\tcout&lt;&lt;&#34;Avail. Tests:&#34;;\n\tfor(auto t:f) cout&lt;&lt;&#34; &#34;&lt;&lt;t.first;cout&lt;&lt;&#34;\\n&#34;;\n\tinit();\n\tcout&lt;&lt;&#34;Size of Memory: &#34;; cin&gt;&gt;W;\n\twhile(1)\n\t{\n\t\tcout&lt;&lt;&#34;Select Test: &#34;;\n\t\tstring t; cin&gt;&gt;t;\n\t\tif(!f.count(t)) continue;\n\t\tcout&lt;&lt;&#34;========================\\n&#34;;\n\t\tf[t](); break;\n\t}\n\tstats();\n}\n</pre>\n<p>求大佬写点注释&#xff0c;并没有见过这种写法的童鞋看懂这个用了好久.....&#xff0c;增加了效率测试&#xff0c;很值得鼓励。</p>\n<p></p>\n<p><strong>python-ALL : 计71 王亦凡 https://git.tsinghua.edu.cn/yfwang17/os-2020</strong></p>\n<pre>#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\nimport math\n\ndef hfunc(index):\n    if index == -1:\n        return &#39;MISS&#39;\n    else:\n        return &#39;HIT &#39;\n\ndef vfunc(victim):\n    if victim == -1:\n        return &#39;-&#39;\n    else:\n        return str(victim)\n\n#\n# main program\n#\nparser = OptionParser()\nparser.add_option(&#39;-a&#39;, &#39;--addresses&#39;, default=&#39;-1&#39;,   help=&#39;a set of comma-separated pages to access; -1 means randomly generate&#39;,  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;addresses&#39;)\nparser.add_option(&#39;-p&#39;, &#39;--policy&#39;, default=&#39;FIFO&#39;,    help=&#39;replacement policy: FIFO, LRU, OPT, CLOCK, WorkingSet&#39;,                action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;policy&#39;)\nparser.add_option(&#39;-b&#39;, &#39;--clockbits&#39;, default=1,      help=&#39;for CLOCK policy, how many clock bits to use&#39;,                          action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;clockbits&#39;)\nparser.add_option(&#39;-t&#39;, &#39;--setsize&#39;, default=3,      help=&#39;for WorkingSet policy, how many visits to use&#39;,                          action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;setsize&#39;)\nparser.add_option(&#39;-f&#39;, &#39;--pageframesize&#39;, default=&#39;3&#39;,    help=&#39;size of the physical page frame, in pages&#39;,                                  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;pageframesize&#39;)\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=&#39;0&#39;,         help=&#39;random number seed&#39;,                                                    action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;seed&#39;)\nparser.add_option(&#39;-N&#39;, &#39;--notrace&#39;, default=False,    help=&#39;do not print out a detailed trace&#39;,                                     action=&#39;store_true&#39;, dest=&#39;notrace&#39;)\nparser.add_option(&#39;-c&#39;, &#39;--compute&#39;, default=False,    help=&#39;compute answers for me&#39;,                                                action=&#39;store_true&#39;, dest=&#39;solve&#39;)\n\n(options, args) = parser.parse_args()\n\nprint &#39;ARG addresses&#39;, options.addresses\nprint &#39;ARG policy&#39;, options.policy\nprint &#39;ARG clockbits&#39;, options.clockbits\nprint &#39;ARG setsize&#39;, options.setsize\nprint &#39;ARG pageframesize&#39;, options.pageframesize\nprint &#39;ARG seed&#39;, options.seed\nprint &#39;ARG notrace&#39;, options.notrace\nprint &#39;&#39;\n\naddresses   = str(options.addresses)\npageframesize   = int(options.pageframesize)\nseed        = int(options.seed)\npolicy      = str(options.policy)\nnotrace     = options.notrace\nclockbits   = int(options.clockbits)\nsetsize   = int(options.setsize)\n\nrandom.seed(seed)\n\naddrList = []\naddrList = addresses.split(&#39;,&#39;)\n\nif options.solve == False:\n    print &#39;Assuming a replacement policy of %s, and a physical page frame of size %d pages,&#39; % (policy, pageframesize)\n    print &#39;figure out whether each of the following page references hit or miss&#39;\n\n    for n in addrList:\n        print &#39;Access: %d  Hit/Miss?  State of Memory?&#39; % int(n)\n    print &#39;&#39;\n\nelse:\n    if notrace == False:\n        print &#39;Solving...\\n&#39;\n\n    # init memory structure\n    count = 0\n    memory = []\n    hits = 0\n    miss = 0\n\n    if policy == &#39;FIFO&#39;:\n        leftStr = &#39;FirstIn&#39;\n        riteStr = &#39;Lastin &#39;\n    elif policy == &#39;LRU&#39;:\n        leftStr = &#39;LRU&#39;\n        riteStr = &#39;MRU&#39;\n    elif policy == &#39;OPT&#39; or  policy == &#39;CLOCK&#39;:\n        leftStr = &#39;Left &#39;\n        riteStr = &#39;Right&#39;\n    elif policy == &#39;WorkingSet&#39;:\n        leftStr = &#39;Left &#39;\n        riteStr = &#39;Right&#39;\n    else:\n        print &#39;Policy %s is not yet implemented&#39; % policy\n        exit(1)\n\n    # track reference bits for clock\n    ref   = {}\n\n    cdebug = False\n\n    # need to generate addresses\n    addrIndex = 0\n\n    visitList = []\n\n    for nStr in addrList:\n        # first, lookup\n        n = int(nStr)\n        try:\n            idx = memory.index(n)\n            hits = hits &#43; 1\n            if policy == &#39;LRU&#39; :\n                update = memory.remove(n)\n                memory.append(n) # puts it on MRU side\n            if policy == &#39;WorkingSet&#39;:\n                if hits &#43; miss &gt;= setsize &#43; 1:\n                    saddr = visitList.pop(0)\n                    visitList.append(n)\n                    if visitList.count(saddr) == 0:\n                        memory.remove(saddr)\n                else:\n                    visitList.append(n)\n        except:\n            idx = -1\n            miss = miss &#43; 1\n\n        victim = -1        \n        if idx == -1:\n            # miss, replace?\n            # print &#39;BUG count, pageframesize:&#39;, count, pageframesize\n            if policy == &#39;WorkingSet&#39;:\n                if hits &#43; miss &gt;= setsize &#43; 1:\n                    saddr = visitList.pop(0)\n                    visitList.append(n)\n                    memory.append(n)\n                    if visitList.count(saddr) == 0:\n                        memory.remove(saddr)                    \n                else:\n                    visitList.append(n)\n                    memory.append(n)\n            \n            if count == pageframesize:\n                # must replace\n                if policy == &#39;FIFO&#39; or policy == &#39;LRU&#39;:\n                    victim = memory.pop(0)\n                elif policy == &#39;CLOCK&#39;:\n                    if cdebug:\n                        print &#39;REFERENCE TO PAGE&#39;, n\n                        print &#39;MEMORY &#39;, memory\n                        print &#39;REF (b)&#39;, ref\n                    # hack: for now, do random\n                    # victim = memory.pop(int(random.random() * count))\n                    victim = -1\n                    while victim == -1:\n                        page = memory[int(random.random() * count)]\n                        if cdebug:\n                            print &#39;  scan page:&#39;, page, ref[page]\n                        if ref[page] &gt;= 1:\n                            ref[page] -= 1\n                        else:\n                            # this is our victim\n                            victim = page\n                            memory.remove(page)\n                            break\n\n                    # remove old page&#39;s ref count\n                    if page in memory:\n                        assert(&#39;BROKEN&#39;)\n                    del ref[victim]\n                    if cdebug:\n                        print &#39;VICTIM&#39;, page\n                        print &#39;LEN&#39;, len(memory)\n                        print &#39;MEM&#39;, memory\n                        print &#39;REF (a)&#39;, ref\n\n                elif policy == &#39;OPT&#39;:\n                    maxReplace  = -1\n                    replaceIdx  = -1\n                    replacePage = -1\n                    # print &#39;OPT: access %d, memory %s&#39; % (n, memory) \n                    # print &#39;OPT: replace from FUTURE (%s)&#39; % addrList[addrIndex&#43;1:]\n                    for pageIndex in range(0,count):\n                        page = memory[pageIndex]\n                        # now, have page &#39;page&#39; at index &#39;pageIndex&#39; in memory\n                        whenReferenced = len(addrList)\n                        # whenReferenced tells us when, in the future, this was referenced\n                        for futureIdx in range(addrIndex&#43;1,len(addrList)):\n                            futurePage = int(addrList[futureIdx])\n                            if page == futurePage:\n                                whenReferenced = futureIdx\n                                break\n                        # print &#39;OPT: page %d is referenced at %d&#39; % (page, whenReferenced)\n                        if whenReferenced &gt;= maxReplace:\n                            # print &#39;OPT: ??? updating maxReplace (%d %d %d)&#39; % (replaceIdx, replacePage, maxReplace)\n                            replaceIdx  = pageIndex\n                            replacePage = page\n                            maxReplace  = whenReferenced\n                            # print &#39;OPT: --&gt; updating maxReplace (%d %d %d)&#39; % (replaceIdx, replacePage, maxReplace)\n                    victim = memory.pop(replaceIdx)\n                    # print &#39;OPT: replacing page %d (idx:%d) because I saw it in future at %d&#39; % (victim, replaceIdx, whenReferenced)\n            else:\n                # miss, but no replacement needed (page frame not full)\n                victim = -1\n                count = count &#43; 1\n\n            # now add to memory\n            if policy != &#39;WorkingSet&#39;:\n                memory.append(n)\n            if cdebug:\n                print &#39;LEN (a)&#39;, len(memory)\n            if victim != -1:\n                assert(victim not in memory)\n\n        # after miss processing, update reference bit\n        if n not in ref:\n            ref[n] = 1\n        else:\n            ref[n] &#43;= 1\n            if ref[n] &gt; clockbits:\n                ref[n] = clockbits\n        \n        if cdebug:\n            print &#39;REF (a)&#39;, ref\n\n        if notrace == False:\n            print &#39;Access: %d  %s %s -&gt; %12s &lt;- %s Replaced:%s [Hits:%d Misses:%d]&#39; % (n, hfunc(idx), leftStr, memory, riteStr, vfunc(victim), hits, miss)\n        addrIndex = addrIndex &#43; 1\n        \n    print &#39;&#39;\n    print &#39;FINALSTATS hits %d   misses %d   hitrate %.2f&#39; % (hits, miss, (100.0*float(hits))/(float(hits)&#43;float(miss)))\n    print &#39;&#39;\n</pre>\n<p>相当强大。</p>"}, {"anon": "full", "uid_a": "a_0", "subject": "第七讲课后习题展示", "created": "2020-03-15T15:03:25Z", "content": "<p><strong>题目一&#xff1a;</strong>考虑在 X86-32 CPU上采用4KB页面大小、两级页表、页表自映射的虚拟存储系统。如果在虚拟地址空间中&#xff0c;4MB 的页表区域从虚拟地址 0xD0000000 开始&#xff0c;请回答自映射页表项的虚拟地址。<br />正确答案&#xff1a;0xD0340D00</p>\n<p>解法简述&#xff1a;典型的自映射情景&#xff0c;此时整个页表(4M)在整个虚存的index&#xff0c;二级页表(4K)在整个页表的index&#xff0c;页表自映射项(4B)在二级页表的index&#xff0c;三者相同&#xff0c;都是 0xD0000000 &gt;&gt; 22 = 0x340&#xff0c;所以答案为 0x340 || 0x340 || 0x340 || 00 = 0xD0340D00</p>\n<p>主要错误&#xff1a;</p>\n<p>1. 0xD0340000  错误为对题干自映射页表项理解有误&#xff0c;自映射页表项是一个4B的页表项。</p>\n<p>2. 0x681A0340‬  竟然有不止一位同学 0x340 || 0x340 || 0x340 || 00 运算出错。。。计算认真一点哦</p>\n<p></p>\n<p></p>\n<p><strong>题目二&#xff1a;</strong>确定选择一种页面置换算法&#xff08;0&#xff1a;LRU置换算法&#xff0c;1:改进的clock 页置换算法&#xff09;中的一种来设计一个应用程序&#xff08;可基于rust, python, ruby, C, C&#43;&#43;&#xff0c;LISP等&#xff09;模拟实现&#xff0c;并给出测试用例和测试结果。请参考如下python代码或独自实现。</p>\n<p></p>\n<p>选择该题目同学较少&#xff0c;但是有些同学完成度极高。由于是简单抽查&#xff0c;可能有些完成很认真的同学作业并没有看到&#xff0c;欢迎毛遂自荐&#xff0c;有切实好处。可在本贴回复姓名学号仓库信息或者微信私信助教ZYR(DeathWish42)。</p>\n<p>另外提醒大家&#xff0c;如果完成了代码类作业&#xff0c;最好在报告中简单描述自己的做法或者增添注释&#xff0c;这样会极大的方便他人阅读你的代码&#xff08;秋梨膏&#xff09;。</p>\n<p></p>\n<p>示例&#xff1a;</p>\n<p><strong>java-LRU-双向链表&#43;哈希</strong></p>\n<p><strong>计73 陈旭 https://git.tsinghua.edu.cn/chengjw17/os_exercise/</strong></p>\n<pre>import java.util.HashMap;\n\nclass LRU&lt;E&gt; {\n    private class Node&lt;E&gt; {\n        E item;\n        Node&lt;E&gt; prev;\n        Node&lt;E&gt; next;\n\n        Node(Node&lt;E&gt; prev, E item, Node&lt;E&gt; next) {\n            this.prev = prev;\n            this.item = item;\n            this.next = next;\n        }\n    }\n\n    private Node&lt;E&gt; first;\n    private Node&lt;E&gt; last;\n    private HashMap&lt;E, Node&lt;E&gt;&gt; num2unit;\n    private int size;\n    private int capacity;\n\n    LRU(int capacity) {\n        num2unit = new HashMap&lt;&gt;();\n        this.capacity = capacity;\n    }\n\n    private void linkLast(E item) {\n        final Node&lt;E&gt; l = last;\n        final Node&lt;E&gt; newNode = new Node&lt;E&gt;(l, item, null);\n        last = newNode;\n        if (l == null)\n            first = newNode;\n        else\n            l.next = newNode;\n        size&#43;&#43;;\n    }\n\n    private E unlink(Node&lt;E&gt; x) {\n        // assert x != null;\n        final E element = x.item;\n        final Node&lt;E&gt; next = x.next;\n        final Node&lt;E&gt; prev = x.prev;\n\n        if (prev == null) {\n            first = next;\n        } else {\n            prev.next = next;\n            x.prev = null;\n        }\n\n        if (next == null) {\n            last = prev;\n        } else {\n            next.prev = prev;\n            x.next = null;\n        }\n\n        size--;\n        return element;\n    }\n\n    // return whether page fault occurs\n    boolean visit(E item) {\n        Node&lt;E&gt; node = num2unit.get(item);\n        if (node != null) {\n            unlink(node);\n            linkLast(item);\n            num2unit.replace(item, last);\n            return false;\n        } else {\n            if (size == capacity) {\n                num2unit.remove(unlink(first));\n            }\n            linkLast(item);\n            num2unit.put(item, last);\n            return true;\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        LRU&lt;Character&gt; lru = new LRU&lt;&gt;(4);\n        lru.visit(&#39;a&#39;);\n        lru.visit(&#39;b&#39;);\n        lru.visit(&#39;c&#39;);\n        lru.visit(&#39;d&#39;);\n        char[] data = { &#39;c&#39;, &#39;a&#39;, &#39;d&#39;, &#39;b&#39;, &#39;e&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39; };\n        for (var item : data) {\n            System.out.println(String.format(&#34;data %c %s&#34;, item, lru.visit(item) ? &#34;with page fault&#34; : &#34;normal&#34;));\n        }\n    }\n}\n</pre>\n<p></p>\n<p><strong>cpp-LRU-双向链表&#43;哈希(?) </strong></p>\n<p><strong>钟子谦 计预70 https://git.tsinghua.edu.cn/zzq20/os-homework-7<br /> </strong></p>\n<pre>#include &lt;bits/stdc&#43;&#43;.h&gt;\nusing namespace std;\n//assume the system has S virtual pages and W real pages\n#define S 4096\nint W,num_access=0,num_miss=0,num_swap=0;\nint current_size=0;\nbool in_mem[S];\nint L[S&#43;1],R[S&#43;1];\nvoid access_page(int p,bool verbose=false)\n{\n\tassert(p&gt;=0&amp;&amp;p&lt;S);\n\t&#43;&#43;num_access;\n\t#define vprintf if(verbose) printf\n\tvprintf(&#34;Trying to access page %d: &#34;,p);\n\tif(in_mem[p])\n\t{\n\t\tint l=L[p],r=R[p];\n\t\tR[l]=r; L[r]=l;\n\t\tr=R[S];\n\t\tR[S]=p; L[r]=p;\n\t\tL[p]=S; R[p]=r;\n\t\tvprintf(&#34;in memory.\\n&#34;);\n\t\treturn;\n\t}\n\t&#43;&#43;num_miss;\n\tin_mem[p]=1;\n\tif(current_size&#43;1&lt;=W)\n\t{\n\t\t&#43;&#43;current_size;\n\t\tvprintf(&#34;have room, stored.\\n&#34;);\n\t\tint r=R[S];\n\t\tR[S]=p; L[r]=p;\n\t\tL[p]=S; R[p]=r;\n\t\treturn;\n\t}\n\telse\n\t{\n\t\t&#43;&#43;num_swap;\n\t\tint u=L[S];\n\t\tassert(u!=S);\n\t\tvprintf(&#34;full, swapping out %d\\n&#34;,u);\n\t\tint l=L[u],r=R[u];\n\t\tR[l]=r; L[r]=l;\n\t\tin_mem[u]=0;\n\t\tr=R[S];\n\t\tR[S]=p; L[r]=p;\n\t\tL[p]=S; R[p]=r;\n\t}\n\t#undef vprintf\n}\nvoid test_custom()\n{\n\tprintf(&#34;Custom test: enter page to access, -1 to quit\\n&#34;);\n\twhile(1)\n\t{\n\t\tint t=0;\n\t\tprintf(&#34;access page: &#34;);\n\t\tscanf(&#34;%d&#34;,&amp;t);\n\t\tif(t==-1) break;\n\t\tif(t&lt;0||t&gt;=S)\n\t\t{\n\t\t\tprintf(&#34;invalid page!\\n&#34;);\n\t\t\tcontinue;\n\t\t}\n\t\taccess_page(t,true);\n\t}\n}\nvoid test_rng()\n{\n\tsrand(12345);\n\tfor(int i=1;i&lt;=1000000;&#43;&#43;i)\n\t\taccess_page(rand()%S);\n}\nvoid test_cyc()\n{\n\tfor(int i=1;i&lt;=1000000;&#43;&#43;i)\n\t\taccess_page(i%S);\n}\nvoid test_srange()\n{\n\tfor(int i=1;i&lt;=4000;&#43;&#43;i)\n\t{\n\t\tint w=rand()%S;\n\t\tfor(int j=0;j&lt;250;&#43;&#43;j)\n\t\t\taccess_page((w&#43;j)%S);\n\t}\n}\nvoid test_lrange()\n{\n\tfor(int i=1;i&lt;=400;&#43;&#43;i)\n\t{\n\t\tint w=rand()%S;\n\t\tfor(int j=0;j&lt;2500;&#43;&#43;j)\n\t\t\taccess_page((w&#43;j)%S);\n\t}\n}\nvoid test_mat()\n{\n\tint u=36;\n\tassert(u*u*3&lt;=S);\n\tfor(int o=1;o&lt;=7;&#43;&#43;o)\n\t\tfor(int i=0;i&lt;u;&#43;&#43;i)\n\t\t\tfor(int j=0;j&lt;u;&#43;&#43;j)\n\t\t\t\tfor(int k=0;k&lt;u;&#43;&#43;k)\n\t\t\t\t\taccess_page(i*u&#43;j),\n\t\t\t\t\taccess_page(i*u&#43;k&#43;u*u),\n\t\t\t\t\taccess_page(k*u&#43;j&#43;u*u*2);\n}\ntypedef void (*func_ptr)();\nmap&lt;string,func_ptr&gt; f;\nvoid stats()\n{\n\tprintf(&#34;no. of access:\\t%d\\n&#34;,num_access);\n\tprintf(&#34;no. of miss:\\t%d\\n&#34;,num_miss);\n\tprintf(&#34;%% of miss:\\t%.2lf%%\\n&#34;,num_miss*100.0/num_access);\n\tprintf(&#34;no. of swap:\\t%d\\n&#34;,num_swap);\n\tprintf(&#34;%% of swap:\\t%.2lf%%\\n&#34;,num_swap*100.0/num_access);\n}\nvoid init()\n{\n\tL[S]=R[S]=S;\n}\nint main()\n{\n\tf[&#34;custom&#34;]=test_custom;\n\tf[&#34;rng&#34;]=test_rng;\n\tf[&#34;cyc&#34;]=test_cyc;\n\tf[&#34;lrange&#34;]=test_lrange;\n\tf[&#34;srange&#34;]=test_srange;\n\tf[&#34;mat&#34;]=test_mat;\n\tcout&lt;&lt;&#34;========LRU Demo========\\n&#34;;\n\tcout&lt;&lt;&#34;Avail. Tests:&#34;;\n\tfor(auto t:f) cout&lt;&lt;&#34; &#34;&lt;&lt;t.first;cout&lt;&lt;&#34;\\n&#34;;\n\tinit();\n\tcout&lt;&lt;&#34;Size of Memory: &#34;; cin&gt;&gt;W;\n\twhile(1)\n\t{\n\t\tcout&lt;&lt;&#34;Select Test: &#34;;\n\t\tstring t; cin&gt;&gt;t;\n\t\tif(!f.count(t)) continue;\n\t\tcout&lt;&lt;&#34;========================\\n&#34;;\n\t\tf[t](); break;\n\t}\n\tstats();\n}\n</pre>\n<p>求大佬写点注释&#xff0c;并没有见过这种写法的童鞋看懂这个用了好久.....&#xff0c;增加了效率测试&#xff0c;很值得鼓励。</p>\n<p></p>\n<p><strong>python-ALL : 计71 王亦凡 https://git.tsinghua.edu.cn/yfwang17/os-2020</strong></p>\n<pre>#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\nimport math\n\ndef hfunc(index):\n    if index == -1:\n        return &#39;MISS&#39;\n    else:\n        return &#39;HIT &#39;\n\ndef vfunc(victim):\n    if victim == -1:\n        return &#39;-&#39;\n    else:\n        return str(victim)\n\n#\n# main program\n#\nparser = OptionParser()\nparser.add_option(&#39;-a&#39;, &#39;--addresses&#39;, default=&#39;-1&#39;,   help=&#39;a set of comma-separated pages to access; -1 means randomly generate&#39;,  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;addresses&#39;)\nparser.add_option(&#39;-p&#39;, &#39;--policy&#39;, default=&#39;FIFO&#39;,    help=&#39;replacement policy: FIFO, LRU, OPT, CLOCK, WorkingSet&#39;,                action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;policy&#39;)\nparser.add_option(&#39;-b&#39;, &#39;--clockbits&#39;, default=1,      help=&#39;for CLOCK policy, how many clock bits to use&#39;,                          action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;clockbits&#39;)\nparser.add_option(&#39;-t&#39;, &#39;--setsize&#39;, default=3,      help=&#39;for WorkingSet policy, how many visits to use&#39;,                          action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;setsize&#39;)\nparser.add_option(&#39;-f&#39;, &#39;--pageframesize&#39;, default=&#39;3&#39;,    help=&#39;size of the physical page frame, in pages&#39;,                                  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;pageframesize&#39;)\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=&#39;0&#39;,         help=&#39;random number seed&#39;,                                                    action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;seed&#39;)\nparser.add_option(&#39;-N&#39;, &#39;--notrace&#39;, default=False,    help=&#39;do not print out a detailed trace&#39;,                                     action=&#39;store_true&#39;, dest=&#39;notrace&#39;)\nparser.add_option(&#39;-c&#39;, &#39;--compute&#39;, default=False,    help=&#39;compute answers for me&#39;,                                                action=&#39;store_true&#39;, dest=&#39;solve&#39;)\n\n(options, args) = parser.parse_args()\n\nprint &#39;ARG addresses&#39;, options.addresses\nprint &#39;ARG policy&#39;, options.policy\nprint &#39;ARG clockbits&#39;, options.clockbits\nprint &#39;ARG setsize&#39;, options.setsize\nprint &#39;ARG pageframesize&#39;, options.pageframesize\nprint &#39;ARG seed&#39;, options.seed\nprint &#39;ARG notrace&#39;, options.notrace\nprint &#39;&#39;\n\naddresses   = str(options.addresses)\npageframesize   = int(options.pageframesize)\nseed        = int(options.seed)\npolicy      = str(options.policy)\nnotrace     = options.notrace\nclockbits   = int(options.clockbits)\nsetsize   = int(options.setsize)\n\nrandom.seed(seed)\n\naddrList = []\naddrList = addresses.split(&#39;,&#39;)\n\nif options.solve == False:\n    print &#39;Assuming a replacement policy of %s, and a physical page frame of size %d pages,&#39; % (policy, pageframesize)\n    print &#39;figure out whether each of the following page references hit or miss&#39;\n\n    for n in addrList:\n        print &#39;Access: %d  Hit/Miss?  State of Memory?&#39; % int(n)\n    print &#39;&#39;\n\nelse:\n    if notrace == False:\n        print &#39;Solving...\\n&#39;\n\n    # init memory structure\n    count = 0\n    memory = []\n    hits = 0\n    miss = 0\n\n    if policy == &#39;FIFO&#39;:\n        leftStr = &#39;FirstIn&#39;\n        riteStr = &#39;Lastin &#39;\n    elif policy == &#39;LRU&#39;:\n        leftStr = &#39;LRU&#39;\n        riteStr = &#39;MRU&#39;\n    elif policy == &#39;OPT&#39; or  policy == &#39;CLOCK&#39;:\n        leftStr = &#39;Left &#39;\n        riteStr = &#39;Right&#39;\n    elif policy == &#39;WorkingSet&#39;:\n        leftStr = &#39;Left &#39;\n        riteStr = &#39;Right&#39;\n    else:\n        print &#39;Policy %s is not yet implemented&#39; % policy\n        exit(1)\n\n    # track reference bits for clock\n    ref   = {}\n\n    cdebug = False\n\n    # need to generate addresses\n    addrIndex = 0\n\n    visitList = []\n\n    for nStr in addrList:\n        # first, lookup\n        n = int(nStr)\n        try:\n            idx = memory.index(n)\n            hits = hits &#43; 1\n            if policy == &#39;LRU&#39; :\n                update = memory.remove(n)\n                memory.append(n) # puts it on MRU side\n            if policy == &#39;WorkingSet&#39;:\n                if hits &#43; miss &gt;= setsize &#43; 1:\n                    saddr = visitList.pop(0)\n                    visitList.append(n)\n                    if visitList.count(saddr) == 0:\n                        memory.remove(saddr)\n                else:\n                    visitList.append(n)\n        except:\n            idx = -1\n            miss = miss &#43; 1\n\n        victim = -1        \n        if idx == -1:\n            # miss, replace?\n            # print &#39;BUG count, pageframesize:&#39;, count, pageframesize\n            if policy == &#39;WorkingSet&#39;:\n                if hits &#43; miss &gt;= setsize &#43; 1:\n                    saddr = visitList.pop(0)\n                    visitList.append(n)\n                    memory.append(n)\n                    if visitList.count(saddr) == 0:\n                        memory.remove(saddr)                    \n                else:\n                    visitList.append(n)\n                    memory.append(n)\n            \n            if count == pageframesize:\n                # must replace\n                if policy == &#39;FIFO&#39; or policy == &#39;LRU&#39;:\n                    victim = memory.pop(0)\n                elif policy == &#39;CLOCK&#39;:\n                    if cdebug:\n                        print &#39;REFERENCE TO PAGE&#39;, n\n                        print &#39;MEMORY &#39;, memory\n                        print &#39;REF (b)&#39;, ref\n                    # hack: for now, do random\n                    # victim = memory.pop(int(random.random() * count))\n                    victim = -1\n                    while victim == -1:\n                        page = memory[int(random.random() * count)]\n                        if cdebug:\n                            print &#39;  scan page:&#39;, page, ref[page]\n                        if ref[page] &gt;= 1:\n                            ref[page] -= 1\n                        else:\n                            # this is our victim\n                            victim = page\n                            memory.remove(page)\n                            break\n\n                    # remove old page&#39;s ref count\n                    if page in memory:\n                        assert(&#39;BROKEN&#39;)\n                    del ref[victim]\n                    if cdebug:\n                        print &#39;VICTIM&#39;, page\n                        print &#39;LEN&#39;, len(memory)\n                        print &#39;MEM&#39;, memory\n                        print &#39;REF (a)&#39;, ref\n\n                elif policy == &#39;OPT&#39;:\n                    maxReplace  = -1\n                    replaceIdx  = -1\n                    replacePage = -1\n                    # print &#39;OPT: access %d, memory %s&#39; % (n, memory) \n                    # print &#39;OPT: replace from FUTURE (%s)&#39; % addrList[addrIndex&#43;1:]\n                    for pageIndex in range(0,count):\n                        page = memory[pageIndex]\n                        # now, have page &#39;page&#39; at index &#39;pageIndex&#39; in memory\n                        whenReferenced = len(addrList)\n                        # whenReferenced tells us when, in the future, this was referenced\n                        for futureIdx in range(addrIndex&#43;1,len(addrList)):\n                            futurePage = int(addrList[futureIdx])\n                            if page == futurePage:\n                                whenReferenced = futureIdx\n                                break\n                        # print &#39;OPT: page %d is referenced at %d&#39; % (page, whenReferenced)\n                        if whenReferenced &gt;= maxReplace:\n                            # print &#39;OPT: ??? updating maxReplace (%d %d %d)&#39; % (replaceIdx, replacePage, maxReplace)\n                            replaceIdx  = pageIndex\n                            replacePage = page\n                            maxReplace  = whenReferenced\n                            # print &#39;OPT: --&gt; updating maxReplace (%d %d %d)&#39; % (replaceIdx, replacePage, maxReplace)\n                    victim = memory.pop(replaceIdx)\n                    # print &#39;OPT: replacing page %d (idx:%d) because I saw it in future at %d&#39; % (victim, replaceIdx, whenReferenced)\n            else:\n                # miss, but no replacement needed (page frame not full)\n                victim = -1\n                count = count &#43; 1\n\n            # now add to memory\n            if policy != &#39;WorkingSet&#39;:\n                memory.append(n)\n            if cdebug:\n                print &#39;LEN (a)&#39;, len(memory)\n            if victim != -1:\n                assert(victim not in memory)\n\n        # after miss processing, update reference bit\n        if n not in ref:\n            ref[n] = 1\n        else:\n            ref[n] &#43;= 1\n            if ref[n] &gt; clockbits:\n                ref[n] = clockbits\n        \n        if cdebug:\n            print &#39;REF (a)&#39;, ref\n\n        if notrace == False:\n            print &#39;Access: %d  %s %s -&gt; %12s &lt;- %s Replaced:%s [Hits:%d Misses:%d]&#39; % (n, hfunc(idx), leftStr, memory, riteStr, vfunc(victim), hits, miss)\n        addrIndex = addrIndex &#43; 1\n        \n    print &#39;&#39;\n    print &#39;FINALSTATS hits %d   misses %d   hitrate %.2f&#39; % (hits, miss, (100.0*float(hits))/(float(hits)&#43;float(miss)))\n    print &#39;&#39;\n</pre>\n<p>相当强大。</p>"}, {"anon": "full", "uid_a": "a_0", "subject": "第七讲课后习题展示", "created": "2020-03-15T14:51:50Z", "content": "<p><strong>题目一&#xff1a;</strong>考虑在 X86-32 CPU上采用4KB页面大小、两级页表、页表自映射的虚拟存储系统。如果在虚拟地址空间中&#xff0c;4MB 的页表区域从虚拟地址 0xD0000000 开始&#xff0c;请回答自映射页表项的虚拟地址。<br />正确答案&#xff1a;0xD0340D00</p>\n<p>解法简述&#xff1a;典型的自映射情景&#xff0c;此时整个页表(4M)在整个虚存的index&#xff0c;二级页表(4K)在整个页表的index&#xff0c;页表自映射项(4B)在二级页表的index&#xff0c;三者相同&#xff0c;都是 0xD0000000 &gt;&gt; 22 = 0x340&#xff0c;所以答案为 0x340 || 0x340 || 0x340 || 00 = 0xD0340D00</p>\n<p>主要错误&#xff1a;</p>\n<p>1. 0xD0340000  错误为对题干自映射页表项理解有误&#xff0c;自映射页表项是一个4B的页表项。</p>\n<p>2. 0x681A0340‬  竟然有不止一位同学 0x340 || 0x340 || 0x340 || 00 运算出错。。。计算认真一点哦</p>\n<p></p>\n<p></p>\n<p><strong>题目二&#xff1a;</strong>确定选择一种页面置换算法&#xff08;0&#xff1a;LRU置换算法&#xff0c;1:改进的clock 页置换算法&#xff09;中的一种来设计一个应用程序&#xff08;可基于rust, python, ruby, C, C&#43;&#43;&#xff0c;LISP等&#xff09;模拟实现&#xff0c;并给出测试用例和测试结果。请参考如下python代码或独自实现。</p>\n<p></p>\n<p>选择该题目同学较少&#xff0c;但是有些同学完成度极高。由于是简单抽查&#xff0c;可能有些完成很认真的同学作业并没有看到&#xff0c;欢迎毛遂自荐&#xff0c;有切实好处。可在本贴回复姓名学号仓库信息或者微信私信助教ZYR(DeathWish42)。</p>\n<p>另外提醒大家&#xff0c;如果完成了代码类作业&#xff0c;最好在报告中简单描述自己的做法或者增添注释&#xff0c;这样会极大的方便他人阅读你的代码&#xff08;秋梨膏&#xff09;。</p>\n<p></p>\n<p>示例&#xff1a;</p>\n<p><strong>java-LRU-双向链表&#43;哈希</strong></p>\n<p><strong>计73 陈旭 https://git.tsinghua.edu.cn/chengjw17/os_exercise/</strong></p>\n<pre>import java.util.HashMap;\n\nclass LRU&lt;E&gt; {\n    private class Node&lt;E&gt; {\n        E item;\n        Node&lt;E&gt; prev;\n        Node&lt;E&gt; next;\n\n        Node(Node&lt;E&gt; prev, E item, Node&lt;E&gt; next) {\n            this.prev = prev;\n            this.item = item;\n            this.next = next;\n        }\n    }\n\n    private Node&lt;E&gt; first;\n    private Node&lt;E&gt; last;\n    private HashMap&lt;E, Node&lt;E&gt;&gt; num2unit;\n    private int size;\n    private int capacity;\n\n    LRU(int capacity) {\n        num2unit = new HashMap&lt;&gt;();\n        this.capacity = capacity;\n    }\n\n    private void linkLast(E item) {\n        final Node&lt;E&gt; l = last;\n        final Node&lt;E&gt; newNode = new Node&lt;E&gt;(l, item, null);\n        last = newNode;\n        if (l == null)\n            first = newNode;\n        else\n            l.next = newNode;\n        size&#43;&#43;;\n    }\n\n    private E unlink(Node&lt;E&gt; x) {\n        // assert x != null;\n        final E element = x.item;\n        final Node&lt;E&gt; next = x.next;\n        final Node&lt;E&gt; prev = x.prev;\n\n        if (prev == null) {\n            first = next;\n        } else {\n            prev.next = next;\n            x.prev = null;\n        }\n\n        if (next == null) {\n            last = prev;\n        } else {\n            next.prev = prev;\n            x.next = null;\n        }\n\n        size--;\n        return element;\n    }\n\n    // return whether page fault occurs\n    boolean visit(E item) {\n        Node&lt;E&gt; node = num2unit.get(item);\n        if (node != null) {\n            unlink(node);\n            linkLast(item);\n            num2unit.replace(item, last);\n            return false;\n        } else {\n            if (size == capacity) {\n                num2unit.remove(unlink(first));\n            }\n            linkLast(item);\n            num2unit.put(item, last);\n            return true;\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        LRU&lt;Character&gt; lru = new LRU&lt;&gt;(4);\n        lru.visit(&#39;a&#39;);\n        lru.visit(&#39;b&#39;);\n        lru.visit(&#39;c&#39;);\n        lru.visit(&#39;d&#39;);\n        char[] data = { &#39;c&#39;, &#39;a&#39;, &#39;d&#39;, &#39;b&#39;, &#39;e&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39; };\n        for (var item : data) {\n            System.out.println(String.format(&#34;data %c %s&#34;, item, lru.visit(item) ? &#34;with page fault&#34; : &#34;normal&#34;));\n        }\n    }\n}\n</pre>\n<p></p>\n<p><strong>cpp-LRU-双向链表&#43;哈希(?) </strong></p>\n<p><strong>钟子谦 计预70 https://git.tsinghua.edu.cn/zzq20/os-homework-7<br /> </strong></p>\n<pre>#include &lt;bits/stdc&#43;&#43;.h&gt;\nusing namespace std;\n//assume the system has S virtual pages and W real pages\n#define S 4096\nint W,num_access=0,num_miss=0,num_swap=0;\nint current_size=0;\nbool in_mem[S];\nint L[S&#43;1],R[S&#43;1];\nvoid access_page(int p,bool verbose=false)\n{\n\tassert(p&gt;=0&amp;&amp;p&lt;S);\n\t&#43;&#43;num_access;\n\t#define vprintf if(verbose) printf\n\tvprintf(&#34;Trying to access page %d: &#34;,p);\n\tif(in_mem[p])\n\t{\n\t\tint l=L[p],r=R[p];\n\t\tR[l]=r; L[r]=l;\n\t\tr=R[S];\n\t\tR[S]=p; L[r]=p;\n\t\tL[p]=S; R[p]=r;\n\t\tvprintf(&#34;in memory.\\n&#34;);\n\t\treturn;\n\t}\n\t&#43;&#43;num_miss;\n\tin_mem[p]=1;\n\tif(current_size&#43;1&lt;=W)\n\t{\n\t\t&#43;&#43;current_size;\n\t\tvprintf(&#34;have room, stored.\\n&#34;);\n\t\tint r=R[S];\n\t\tR[S]=p; L[r]=p;\n\t\tL[p]=S; R[p]=r;\n\t\treturn;\n\t}\n\telse\n\t{\n\t\t&#43;&#43;num_swap;\n\t\tint u=L[S];\n\t\tassert(u!=S);\n\t\tvprintf(&#34;full, swapping out %d\\n&#34;,u);\n\t\tint l=L[u],r=R[u];\n\t\tR[l]=r; L[r]=l;\n\t\tin_mem[u]=0;\n\t\tr=R[S];\n\t\tR[S]=p; L[r]=p;\n\t\tL[p]=S; R[p]=r;\n\t}\n\t#undef vprintf\n}\nvoid test_custom()\n{\n\tprintf(&#34;Custom test: enter page to access, -1 to quit\\n&#34;);\n\twhile(1)\n\t{\n\t\tint t=0;\n\t\tprintf(&#34;access page: &#34;);\n\t\tscanf(&#34;%d&#34;,&amp;t);\n\t\tif(t==-1) break;\n\t\tif(t&lt;0||t&gt;=S)\n\t\t{\n\t\t\tprintf(&#34;invalid page!\\n&#34;);\n\t\t\tcontinue;\n\t\t}\n\t\taccess_page(t,true);\n\t}\n}\nvoid test_rng()\n{\n\tsrand(12345);\n\tfor(int i=1;i&lt;=1000000;&#43;&#43;i)\n\t\taccess_page(rand()%S);\n}\nvoid test_cyc()\n{\n\tfor(int i=1;i&lt;=1000000;&#43;&#43;i)\n\t\taccess_page(i%S);\n}\nvoid test_srange()\n{\n\tfor(int i=1;i&lt;=4000;&#43;&#43;i)\n\t{\n\t\tint w=rand()%S;\n\t\tfor(int j=0;j&lt;250;&#43;&#43;j)\n\t\t\taccess_page((w&#43;j)%S);\n\t}\n}\nvoid test_lrange()\n{\n\tfor(int i=1;i&lt;=400;&#43;&#43;i)\n\t{\n\t\tint w=rand()%S;\n\t\tfor(int j=0;j&lt;2500;&#43;&#43;j)\n\t\t\taccess_page((w&#43;j)%S);\n\t}\n}\nvoid test_mat()\n{\n\tint u=36;\n\tassert(u*u*3&lt;=S);\n\tfor(int o=1;o&lt;=7;&#43;&#43;o)\n\t\tfor(int i=0;i&lt;u;&#43;&#43;i)\n\t\t\tfor(int j=0;j&lt;u;&#43;&#43;j)\n\t\t\t\tfor(int k=0;k&lt;u;&#43;&#43;k)\n\t\t\t\t\taccess_page(i*u&#43;j),\n\t\t\t\t\taccess_page(i*u&#43;k&#43;u*u),\n\t\t\t\t\taccess_page(k*u&#43;j&#43;u*u*2);\n}\ntypedef void (*func_ptr)();\nmap&lt;string,func_ptr&gt; f;\nvoid stats()\n{\n\tprintf(&#34;no. of access:\\t%d\\n&#34;,num_access);\n\tprintf(&#34;no. of miss:\\t%d\\n&#34;,num_miss);\n\tprintf(&#34;%% of miss:\\t%.2lf%%\\n&#34;,num_miss*100.0/num_access);\n\tprintf(&#34;no. of swap:\\t%d\\n&#34;,num_swap);\n\tprintf(&#34;%% of swap:\\t%.2lf%%\\n&#34;,num_swap*100.0/num_access);\n}\nvoid init()\n{\n\tL[S]=R[S]=S;\n}\nint main()\n{\n\tf[&#34;custom&#34;]=test_custom;\n\tf[&#34;rng&#34;]=test_rng;\n\tf[&#34;cyc&#34;]=test_cyc;\n\tf[&#34;lrange&#34;]=test_lrange;\n\tf[&#34;srange&#34;]=test_srange;\n\tf[&#34;mat&#34;]=test_mat;\n\tcout&lt;&lt;&#34;========LRU Demo========\\n&#34;;\n\tcout&lt;&lt;&#34;Avail. Tests:&#34;;\n\tfor(auto t:f) cout&lt;&lt;&#34; &#34;&lt;&lt;t.first;cout&lt;&lt;&#34;\\n&#34;;\n\tinit();\n\tcout&lt;&lt;&#34;Size of Memory: &#34;; cin&gt;&gt;W;\n\twhile(1)\n\t{\n\t\tcout&lt;&lt;&#34;Select Test: &#34;;\n\t\tstring t; cin&gt;&gt;t;\n\t\tif(!f.count(t)) continue;\n\t\tcout&lt;&lt;&#34;========================\\n&#34;;\n\t\tf[t](); break;\n\t}\n\tstats();\n}\n</pre>\n<p>求大佬写点注释&#xff0c;看懂这个用了好久.....&#xff0c;增加了效率测试&#xff0c;很值得鼓励。</p>\n<p></p>\n<p><strong>python-ALL : 计71 王亦凡 https://git.tsinghua.edu.cn/yfwang17/os-2020</strong></p>\n<pre>#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\nimport math\n\ndef hfunc(index):\n    if index == -1:\n        return &#39;MISS&#39;\n    else:\n        return &#39;HIT &#39;\n\ndef vfunc(victim):\n    if victim == -1:\n        return &#39;-&#39;\n    else:\n        return str(victim)\n\n#\n# main program\n#\nparser = OptionParser()\nparser.add_option(&#39;-a&#39;, &#39;--addresses&#39;, default=&#39;-1&#39;,   help=&#39;a set of comma-separated pages to access; -1 means randomly generate&#39;,  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;addresses&#39;)\nparser.add_option(&#39;-p&#39;, &#39;--policy&#39;, default=&#39;FIFO&#39;,    help=&#39;replacement policy: FIFO, LRU, OPT, CLOCK, WorkingSet&#39;,                action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;policy&#39;)\nparser.add_option(&#39;-b&#39;, &#39;--clockbits&#39;, default=1,      help=&#39;for CLOCK policy, how many clock bits to use&#39;,                          action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;clockbits&#39;)\nparser.add_option(&#39;-t&#39;, &#39;--setsize&#39;, default=3,      help=&#39;for WorkingSet policy, how many visits to use&#39;,                          action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;setsize&#39;)\nparser.add_option(&#39;-f&#39;, &#39;--pageframesize&#39;, default=&#39;3&#39;,    help=&#39;size of the physical page frame, in pages&#39;,                                  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;pageframesize&#39;)\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=&#39;0&#39;,         help=&#39;random number seed&#39;,                                                    action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;seed&#39;)\nparser.add_option(&#39;-N&#39;, &#39;--notrace&#39;, default=False,    help=&#39;do not print out a detailed trace&#39;,                                     action=&#39;store_true&#39;, dest=&#39;notrace&#39;)\nparser.add_option(&#39;-c&#39;, &#39;--compute&#39;, default=False,    help=&#39;compute answers for me&#39;,                                                action=&#39;store_true&#39;, dest=&#39;solve&#39;)\n\n(options, args) = parser.parse_args()\n\nprint &#39;ARG addresses&#39;, options.addresses\nprint &#39;ARG policy&#39;, options.policy\nprint &#39;ARG clockbits&#39;, options.clockbits\nprint &#39;ARG setsize&#39;, options.setsize\nprint &#39;ARG pageframesize&#39;, options.pageframesize\nprint &#39;ARG seed&#39;, options.seed\nprint &#39;ARG notrace&#39;, options.notrace\nprint &#39;&#39;\n\naddresses   = str(options.addresses)\npageframesize   = int(options.pageframesize)\nseed        = int(options.seed)\npolicy      = str(options.policy)\nnotrace     = options.notrace\nclockbits   = int(options.clockbits)\nsetsize   = int(options.setsize)\n\nrandom.seed(seed)\n\naddrList = []\naddrList = addresses.split(&#39;,&#39;)\n\nif options.solve == False:\n    print &#39;Assuming a replacement policy of %s, and a physical page frame of size %d pages,&#39; % (policy, pageframesize)\n    print &#39;figure out whether each of the following page references hit or miss&#39;\n\n    for n in addrList:\n        print &#39;Access: %d  Hit/Miss?  State of Memory?&#39; % int(n)\n    print &#39;&#39;\n\nelse:\n    if notrace == False:\n        print &#39;Solving...\\n&#39;\n\n    # init memory structure\n    count = 0\n    memory = []\n    hits = 0\n    miss = 0\n\n    if policy == &#39;FIFO&#39;:\n        leftStr = &#39;FirstIn&#39;\n        riteStr = &#39;Lastin &#39;\n    elif policy == &#39;LRU&#39;:\n        leftStr = &#39;LRU&#39;\n        riteStr = &#39;MRU&#39;\n    elif policy == &#39;OPT&#39; or  policy == &#39;CLOCK&#39;:\n        leftStr = &#39;Left &#39;\n        riteStr = &#39;Right&#39;\n    elif policy == &#39;WorkingSet&#39;:\n        leftStr = &#39;Left &#39;\n        riteStr = &#39;Right&#39;\n    else:\n        print &#39;Policy %s is not yet implemented&#39; % policy\n        exit(1)\n\n    # track reference bits for clock\n    ref   = {}\n\n    cdebug = False\n\n    # need to generate addresses\n    addrIndex = 0\n\n    visitList = []\n\n    for nStr in addrList:\n        # first, lookup\n        n = int(nStr)\n        try:\n            idx = memory.index(n)\n            hits = hits &#43; 1\n            if policy == &#39;LRU&#39; :\n                update = memory.remove(n)\n                memory.append(n) # puts it on MRU side\n            if policy == &#39;WorkingSet&#39;:\n                if hits &#43; miss &gt;= setsize &#43; 1:\n                    saddr = visitList.pop(0)\n                    visitList.append(n)\n                    if visitList.count(saddr) == 0:\n                        memory.remove(saddr)\n                else:\n                    visitList.append(n)\n        except:\n            idx = -1\n            miss = miss &#43; 1\n\n        victim = -1        \n        if idx == -1:\n            # miss, replace?\n            # print &#39;BUG count, pageframesize:&#39;, count, pageframesize\n            if policy == &#39;WorkingSet&#39;:\n                if hits &#43; miss &gt;= setsize &#43; 1:\n                    saddr = visitList.pop(0)\n                    visitList.append(n)\n                    memory.append(n)\n                    if visitList.count(saddr) == 0:\n                        memory.remove(saddr)                    \n                else:\n                    visitList.append(n)\n                    memory.append(n)\n            \n            if count == pageframesize:\n                # must replace\n                if policy == &#39;FIFO&#39; or policy == &#39;LRU&#39;:\n                    victim = memory.pop(0)\n                elif policy == &#39;CLOCK&#39;:\n                    if cdebug:\n                        print &#39;REFERENCE TO PAGE&#39;, n\n                        print &#39;MEMORY &#39;, memory\n                        print &#39;REF (b)&#39;, ref\n                    # hack: for now, do random\n                    # victim = memory.pop(int(random.random() * count))\n                    victim = -1\n                    while victim == -1:\n                        page = memory[int(random.random() * count)]\n                        if cdebug:\n                            print &#39;  scan page:&#39;, page, ref[page]\n                        if ref[page] &gt;= 1:\n                            ref[page] -= 1\n                        else:\n                            # this is our victim\n                            victim = page\n                            memory.remove(page)\n                            break\n\n                    # remove old page&#39;s ref count\n                    if page in memory:\n                        assert(&#39;BROKEN&#39;)\n                    del ref[victim]\n                    if cdebug:\n                        print &#39;VICTIM&#39;, page\n                        print &#39;LEN&#39;, len(memory)\n                        print &#39;MEM&#39;, memory\n                        print &#39;REF (a)&#39;, ref\n\n                elif policy == &#39;OPT&#39;:\n                    maxReplace  = -1\n                    replaceIdx  = -1\n                    replacePage = -1\n                    # print &#39;OPT: access %d, memory %s&#39; % (n, memory) \n                    # print &#39;OPT: replace from FUTURE (%s)&#39; % addrList[addrIndex&#43;1:]\n                    for pageIndex in range(0,count):\n                        page = memory[pageIndex]\n                        # now, have page &#39;page&#39; at index &#39;pageIndex&#39; in memory\n                        whenReferenced = len(addrList)\n                        # whenReferenced tells us when, in the future, this was referenced\n                        for futureIdx in range(addrIndex&#43;1,len(addrList)):\n                            futurePage = int(addrList[futureIdx])\n                            if page == futurePage:\n                                whenReferenced = futureIdx\n                                break\n                        # print &#39;OPT: page %d is referenced at %d&#39; % (page, whenReferenced)\n                        if whenReferenced &gt;= maxReplace:\n                            # print &#39;OPT: ??? updating maxReplace (%d %d %d)&#39; % (replaceIdx, replacePage, maxReplace)\n                            replaceIdx  = pageIndex\n                            replacePage = page\n                            maxReplace  = whenReferenced\n                            # print &#39;OPT: --&gt; updating maxReplace (%d %d %d)&#39; % (replaceIdx, replacePage, maxReplace)\n                    victim = memory.pop(replaceIdx)\n                    # print &#39;OPT: replacing page %d (idx:%d) because I saw it in future at %d&#39; % (victim, replaceIdx, whenReferenced)\n            else:\n                # miss, but no replacement needed (page frame not full)\n                victim = -1\n                count = count &#43; 1\n\n            # now add to memory\n            if policy != &#39;WorkingSet&#39;:\n                memory.append(n)\n            if cdebug:\n                print &#39;LEN (a)&#39;, len(memory)\n            if victim != -1:\n                assert(victim not in memory)\n\n        # after miss processing, update reference bit\n        if n not in ref:\n            ref[n] = 1\n        else:\n            ref[n] &#43;= 1\n            if ref[n] &gt; clockbits:\n                ref[n] = clockbits\n        \n        if cdebug:\n            print &#39;REF (a)&#39;, ref\n\n        if notrace == False:\n            print &#39;Access: %d  %s %s -&gt; %12s &lt;- %s Replaced:%s [Hits:%d Misses:%d]&#39; % (n, hfunc(idx), leftStr, memory, riteStr, vfunc(victim), hits, miss)\n        addrIndex = addrIndex &#43; 1\n        \n    print &#39;&#39;\n    print &#39;FINALSTATS hits %d   misses %d   hitrate %.2f&#39; % (hits, miss, (100.0*float(hits))/(float(hits)&#43;float(miss)))\n    print &#39;&#39;\n</pre>\n<p>相当强大。</p>"}, {"anon": "full", "uid_a": "a_0", "subject": "第七讲课后习题展示", "created": "2020-03-15T14:50:29Z", "content": "<p>题目一&#xff1a;考虑在 X86-32 CPU上采用4KB页面大小、两级页表、页表自映射的虚拟存储系统。如果在虚拟地址空间中&#xff0c;4MB 的页表区域从虚拟地址 0xD0000000 开始&#xff0c;请回答自映射页表项的虚拟地址。<br />正确答案&#xff1a;0xD0340D00</p>\n<p>解法简述&#xff1a;典型的自映射情景&#xff0c;此时整个页表(4M)在整个虚存的index&#xff0c;二级页表(4K)在整个页表的index&#xff0c;页表自映射项(4B)在二级页表的index&#xff0c;三者相同&#xff0c;都是 0xD0000000 &gt;&gt; 22 = 0x340&#xff0c;所以答案为 0x340 || 0x340 || 0x340 || 00 = 0xD0340D00</p>\n<p>主要错误&#xff1a;</p>\n<p>1. 0xD0340000  错误为对题干自映射页表项理解有误&#xff0c;自映射页表项是一个4B的页表项。</p>\n<p>2. 0x681A0340‬  竟然有不止一位同学 0x340 || 0x340 || 0x340 || 00 运算出错。。。计算认真一点哦</p>\n<p></p>\n<p>题目二&#xff1a;确定选择一种页面置换算法&#xff08;0&#xff1a;LRU置换算法&#xff0c;1:改进的clock 页置换算法&#xff09;中的一种来设计一个应用程序&#xff08;可基于rust, python, ruby, C, C&#43;&#43;&#xff0c;LISP等&#xff09;模拟实现&#xff0c;并给出测试用例和测试结果。请参考如下python代码或独自实现。</p>\n<p></p>\n<p>选择该题目同学较少&#xff0c;但是有些同学完成度极高。由于是简单抽查&#xff0c;可能有些完成很认真的同学作业并没有看到&#xff0c;欢迎毛遂自荐&#xff0c;有切实好处。可在本贴回复姓名学号仓库信息或者微信私信助教ZYR(DeathWish42)。</p>\n<p>另外提醒大家&#xff0c;如果完成了代码类作业&#xff0c;最好在报告中简单描述自己的做法或者增添注释&#xff0c;这样会极大的方便他人阅读你的代码&#xff08;秋梨膏&#xff09;。</p>\n<p></p>\n<p>示例&#xff1a;</p>\n<p><strong>java-LRU-双向链表&#43;哈希</strong></p>\n<p><strong>计73 陈旭 https://git.tsinghua.edu.cn/chengjw17/os_exercise/</strong></p>\n<pre>import java.util.HashMap;\n\nclass LRU&lt;E&gt; {\n    private class Node&lt;E&gt; {\n        E item;\n        Node&lt;E&gt; prev;\n        Node&lt;E&gt; next;\n\n        Node(Node&lt;E&gt; prev, E item, Node&lt;E&gt; next) {\n            this.prev = prev;\n            this.item = item;\n            this.next = next;\n        }\n    }\n\n    private Node&lt;E&gt; first;\n    private Node&lt;E&gt; last;\n    private HashMap&lt;E, Node&lt;E&gt;&gt; num2unit;\n    private int size;\n    private int capacity;\n\n    LRU(int capacity) {\n        num2unit = new HashMap&lt;&gt;();\n        this.capacity = capacity;\n    }\n\n    private void linkLast(E item) {\n        final Node&lt;E&gt; l = last;\n        final Node&lt;E&gt; newNode = new Node&lt;E&gt;(l, item, null);\n        last = newNode;\n        if (l == null)\n            first = newNode;\n        else\n            l.next = newNode;\n        size&#43;&#43;;\n    }\n\n    private E unlink(Node&lt;E&gt; x) {\n        // assert x != null;\n        final E element = x.item;\n        final Node&lt;E&gt; next = x.next;\n        final Node&lt;E&gt; prev = x.prev;\n\n        if (prev == null) {\n            first = next;\n        } else {\n            prev.next = next;\n            x.prev = null;\n        }\n\n        if (next == null) {\n            last = prev;\n        } else {\n            next.prev = prev;\n            x.next = null;\n        }\n\n        size--;\n        return element;\n    }\n\n    // return whether page fault occurs\n    boolean visit(E item) {\n        Node&lt;E&gt; node = num2unit.get(item);\n        if (node != null) {\n            unlink(node);\n            linkLast(item);\n            num2unit.replace(item, last);\n            return false;\n        } else {\n            if (size == capacity) {\n                num2unit.remove(unlink(first));\n            }\n            linkLast(item);\n            num2unit.put(item, last);\n            return true;\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        LRU&lt;Character&gt; lru = new LRU&lt;&gt;(4);\n        lru.visit(&#39;a&#39;);\n        lru.visit(&#39;b&#39;);\n        lru.visit(&#39;c&#39;);\n        lru.visit(&#39;d&#39;);\n        char[] data = { &#39;c&#39;, &#39;a&#39;, &#39;d&#39;, &#39;b&#39;, &#39;e&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39; };\n        for (var item : data) {\n            System.out.println(String.format(&#34;data %c %s&#34;, item, lru.visit(item) ? &#34;with page fault&#34; : &#34;normal&#34;));\n        }\n    }\n}\n</pre>\n<p><strong></strong></p>\n<p><strong>cpp-LRU-双向链表&#43;哈希(?) </strong></p>\n<p><strong>钟子谦 计预70 https://git.tsinghua.edu.cn/zzq20/os-homework-7<br /> </strong></p>\n<pre>#include &lt;bits/stdc&#43;&#43;.h&gt;\nusing namespace std;\n//assume the system has S virtual pages and W real pages\n#define S 4096\nint W,num_access=0,num_miss=0,num_swap=0;\nint current_size=0;\nbool in_mem[S];\nint L[S&#43;1],R[S&#43;1];\nvoid access_page(int p,bool verbose=false)\n{\n\tassert(p&gt;=0&amp;&amp;p&lt;S);\n\t&#43;&#43;num_access;\n\t#define vprintf if(verbose) printf\n\tvprintf(&#34;Trying to access page %d: &#34;,p);\n\tif(in_mem[p])\n\t{\n\t\tint l=L[p],r=R[p];\n\t\tR[l]=r; L[r]=l;\n\t\tr=R[S];\n\t\tR[S]=p; L[r]=p;\n\t\tL[p]=S; R[p]=r;\n\t\tvprintf(&#34;in memory.\\n&#34;);\n\t\treturn;\n\t}\n\t&#43;&#43;num_miss;\n\tin_mem[p]=1;\n\tif(current_size&#43;1&lt;=W)\n\t{\n\t\t&#43;&#43;current_size;\n\t\tvprintf(&#34;have room, stored.\\n&#34;);\n\t\tint r=R[S];\n\t\tR[S]=p; L[r]=p;\n\t\tL[p]=S; R[p]=r;\n\t\treturn;\n\t}\n\telse\n\t{\n\t\t&#43;&#43;num_swap;\n\t\tint u=L[S];\n\t\tassert(u!=S);\n\t\tvprintf(&#34;full, swapping out %d\\n&#34;,u);\n\t\tint l=L[u],r=R[u];\n\t\tR[l]=r; L[r]=l;\n\t\tin_mem[u]=0;\n\t\tr=R[S];\n\t\tR[S]=p; L[r]=p;\n\t\tL[p]=S; R[p]=r;\n\t}\n\t#undef vprintf\n}\nvoid test_custom()\n{\n\tprintf(&#34;Custom test: enter page to access, -1 to quit\\n&#34;);\n\twhile(1)\n\t{\n\t\tint t=0;\n\t\tprintf(&#34;access page: &#34;);\n\t\tscanf(&#34;%d&#34;,&amp;t);\n\t\tif(t==-1) break;\n\t\tif(t&lt;0||t&gt;=S)\n\t\t{\n\t\t\tprintf(&#34;invalid page!\\n&#34;);\n\t\t\tcontinue;\n\t\t}\n\t\taccess_page(t,true);\n\t}\n}\nvoid test_rng()\n{\n\tsrand(12345);\n\tfor(int i=1;i&lt;=1000000;&#43;&#43;i)\n\t\taccess_page(rand()%S);\n}\nvoid test_cyc()\n{\n\tfor(int i=1;i&lt;=1000000;&#43;&#43;i)\n\t\taccess_page(i%S);\n}\nvoid test_srange()\n{\n\tfor(int i=1;i&lt;=4000;&#43;&#43;i)\n\t{\n\t\tint w=rand()%S;\n\t\tfor(int j=0;j&lt;250;&#43;&#43;j)\n\t\t\taccess_page((w&#43;j)%S);\n\t}\n}\nvoid test_lrange()\n{\n\tfor(int i=1;i&lt;=400;&#43;&#43;i)\n\t{\n\t\tint w=rand()%S;\n\t\tfor(int j=0;j&lt;2500;&#43;&#43;j)\n\t\t\taccess_page((w&#43;j)%S);\n\t}\n}\nvoid test_mat()\n{\n\tint u=36;\n\tassert(u*u*3&lt;=S);\n\tfor(int o=1;o&lt;=7;&#43;&#43;o)\n\t\tfor(int i=0;i&lt;u;&#43;&#43;i)\n\t\t\tfor(int j=0;j&lt;u;&#43;&#43;j)\n\t\t\t\tfor(int k=0;k&lt;u;&#43;&#43;k)\n\t\t\t\t\taccess_page(i*u&#43;j),\n\t\t\t\t\taccess_page(i*u&#43;k&#43;u*u),\n\t\t\t\t\taccess_page(k*u&#43;j&#43;u*u*2);\n}\ntypedef void (*func_ptr)();\nmap&lt;string,func_ptr&gt; f;\nvoid stats()\n{\n\tprintf(&#34;no. of access:\\t%d\\n&#34;,num_access);\n\tprintf(&#34;no. of miss:\\t%d\\n&#34;,num_miss);\n\tprintf(&#34;%% of miss:\\t%.2lf%%\\n&#34;,num_miss*100.0/num_access);\n\tprintf(&#34;no. of swap:\\t%d\\n&#34;,num_swap);\n\tprintf(&#34;%% of swap:\\t%.2lf%%\\n&#34;,num_swap*100.0/num_access);\n}\nvoid init()\n{\n\tL[S]=R[S]=S;\n}\nint main()\n{\n\tf[&#34;custom&#34;]=test_custom;\n\tf[&#34;rng&#34;]=test_rng;\n\tf[&#34;cyc&#34;]=test_cyc;\n\tf[&#34;lrange&#34;]=test_lrange;\n\tf[&#34;srange&#34;]=test_srange;\n\tf[&#34;mat&#34;]=test_mat;\n\tcout&lt;&lt;&#34;========LRU Demo========\\n&#34;;\n\tcout&lt;&lt;&#34;Avail. Tests:&#34;;\n\tfor(auto t:f) cout&lt;&lt;&#34; &#34;&lt;&lt;t.first;cout&lt;&lt;&#34;\\n&#34;;\n\tinit();\n\tcout&lt;&lt;&#34;Size of Memory: &#34;; cin&gt;&gt;W;\n\twhile(1)\n\t{\n\t\tcout&lt;&lt;&#34;Select Test: &#34;;\n\t\tstring t; cin&gt;&gt;t;\n\t\tif(!f.count(t)) continue;\n\t\tcout&lt;&lt;&#34;========================\\n&#34;;\n\t\tf[t](); break;\n\t}\n\tstats();\n}\n</pre>\n<p>求大佬写点注释&#xff0c;看懂这个用了好久.....&#xff0c;增加了效率测试&#xff0c;很值得鼓励。</p>\n<p><strong></strong></p>\n<p><strong>python-ALL : 计71 王亦凡 https://git.tsinghua.edu.cn/yfwang17/os-2020</strong></p>\n<pre>#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\nimport math\n\ndef hfunc(index):\n    if index == -1:\n        return &#39;MISS&#39;\n    else:\n        return &#39;HIT &#39;\n\ndef vfunc(victim):\n    if victim == -1:\n        return &#39;-&#39;\n    else:\n        return str(victim)\n\n#\n# main program\n#\nparser = OptionParser()\nparser.add_option(&#39;-a&#39;, &#39;--addresses&#39;, default=&#39;-1&#39;,   help=&#39;a set of comma-separated pages to access; -1 means randomly generate&#39;,  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;addresses&#39;)\nparser.add_option(&#39;-p&#39;, &#39;--policy&#39;, default=&#39;FIFO&#39;,    help=&#39;replacement policy: FIFO, LRU, OPT, CLOCK, WorkingSet&#39;,                action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;policy&#39;)\nparser.add_option(&#39;-b&#39;, &#39;--clockbits&#39;, default=1,      help=&#39;for CLOCK policy, how many clock bits to use&#39;,                          action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;clockbits&#39;)\nparser.add_option(&#39;-t&#39;, &#39;--setsize&#39;, default=3,      help=&#39;for WorkingSet policy, how many visits to use&#39;,                          action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;setsize&#39;)\nparser.add_option(&#39;-f&#39;, &#39;--pageframesize&#39;, default=&#39;3&#39;,    help=&#39;size of the physical page frame, in pages&#39;,                                  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;pageframesize&#39;)\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=&#39;0&#39;,         help=&#39;random number seed&#39;,                                                    action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;seed&#39;)\nparser.add_option(&#39;-N&#39;, &#39;--notrace&#39;, default=False,    help=&#39;do not print out a detailed trace&#39;,                                     action=&#39;store_true&#39;, dest=&#39;notrace&#39;)\nparser.add_option(&#39;-c&#39;, &#39;--compute&#39;, default=False,    help=&#39;compute answers for me&#39;,                                                action=&#39;store_true&#39;, dest=&#39;solve&#39;)\n\n(options, args) = parser.parse_args()\n\nprint &#39;ARG addresses&#39;, options.addresses\nprint &#39;ARG policy&#39;, options.policy\nprint &#39;ARG clockbits&#39;, options.clockbits\nprint &#39;ARG setsize&#39;, options.setsize\nprint &#39;ARG pageframesize&#39;, options.pageframesize\nprint &#39;ARG seed&#39;, options.seed\nprint &#39;ARG notrace&#39;, options.notrace\nprint &#39;&#39;\n\naddresses   = str(options.addresses)\npageframesize   = int(options.pageframesize)\nseed        = int(options.seed)\npolicy      = str(options.policy)\nnotrace     = options.notrace\nclockbits   = int(options.clockbits)\nsetsize   = int(options.setsize)\n\nrandom.seed(seed)\n\naddrList = []\naddrList = addresses.split(&#39;,&#39;)\n\nif options.solve == False:\n    print &#39;Assuming a replacement policy of %s, and a physical page frame of size %d pages,&#39; % (policy, pageframesize)\n    print &#39;figure out whether each of the following page references hit or miss&#39;\n\n    for n in addrList:\n        print &#39;Access: %d  Hit/Miss?  State of Memory?&#39; % int(n)\n    print &#39;&#39;\n\nelse:\n    if notrace == False:\n        print &#39;Solving...\\n&#39;\n\n    # init memory structure\n    count = 0\n    memory = []\n    hits = 0\n    miss = 0\n\n    if policy == &#39;FIFO&#39;:\n        leftStr = &#39;FirstIn&#39;\n        riteStr = &#39;Lastin &#39;\n    elif policy == &#39;LRU&#39;:\n        leftStr = &#39;LRU&#39;\n        riteStr = &#39;MRU&#39;\n    elif policy == &#39;OPT&#39; or  policy == &#39;CLOCK&#39;:\n        leftStr = &#39;Left &#39;\n        riteStr = &#39;Right&#39;\n    elif policy == &#39;WorkingSet&#39;:\n        leftStr = &#39;Left &#39;\n        riteStr = &#39;Right&#39;\n    else:\n        print &#39;Policy %s is not yet implemented&#39; % policy\n        exit(1)\n\n    # track reference bits for clock\n    ref   = {}\n\n    cdebug = False\n\n    # need to generate addresses\n    addrIndex = 0\n\n    visitList = []\n\n    for nStr in addrList:\n        # first, lookup\n        n = int(nStr)\n        try:\n            idx = memory.index(n)\n            hits = hits &#43; 1\n            if policy == &#39;LRU&#39; :\n                update = memory.remove(n)\n                memory.append(n) # puts it on MRU side\n            if policy == &#39;WorkingSet&#39;:\n                if hits &#43; miss &gt;= setsize &#43; 1:\n                    saddr = visitList.pop(0)\n                    visitList.append(n)\n                    if visitList.count(saddr) == 0:\n                        memory.remove(saddr)\n                else:\n                    visitList.append(n)\n        except:\n            idx = -1\n            miss = miss &#43; 1\n\n        victim = -1        \n        if idx == -1:\n            # miss, replace?\n            # print &#39;BUG count, pageframesize:&#39;, count, pageframesize\n            if policy == &#39;WorkingSet&#39;:\n                if hits &#43; miss &gt;= setsize &#43; 1:\n                    saddr = visitList.pop(0)\n                    visitList.append(n)\n                    memory.append(n)\n                    if visitList.count(saddr) == 0:\n                        memory.remove(saddr)                    \n                else:\n                    visitList.append(n)\n                    memory.append(n)\n            \n            if count == pageframesize:\n                # must replace\n                if policy == &#39;FIFO&#39; or policy == &#39;LRU&#39;:\n                    victim = memory.pop(0)\n                elif policy == &#39;CLOCK&#39;:\n                    if cdebug:\n                        print &#39;REFERENCE TO PAGE&#39;, n\n                        print &#39;MEMORY &#39;, memory\n                        print &#39;REF (b)&#39;, ref\n                    # hack: for now, do random\n                    # victim = memory.pop(int(random.random() * count))\n                    victim = -1\n                    while victim == -1:\n                        page = memory[int(random.random() * count)]\n                        if cdebug:\n                            print &#39;  scan page:&#39;, page, ref[page]\n                        if ref[page] &gt;= 1:\n                            ref[page] -= 1\n                        else:\n                            # this is our victim\n                            victim = page\n                            memory.remove(page)\n                            break\n\n                    # remove old page&#39;s ref count\n                    if page in memory:\n                        assert(&#39;BROKEN&#39;)\n                    del ref[victim]\n                    if cdebug:\n                        print &#39;VICTIM&#39;, page\n                        print &#39;LEN&#39;, len(memory)\n                        print &#39;MEM&#39;, memory\n                        print &#39;REF (a)&#39;, ref\n\n                elif policy == &#39;OPT&#39;:\n                    maxReplace  = -1\n                    replaceIdx  = -1\n                    replacePage = -1\n                    # print &#39;OPT: access %d, memory %s&#39; % (n, memory) \n                    # print &#39;OPT: replace from FUTURE (%s)&#39; % addrList[addrIndex&#43;1:]\n                    for pageIndex in range(0,count):\n                        page = memory[pageIndex]\n                        # now, have page &#39;page&#39; at index &#39;pageIndex&#39; in memory\n                        whenReferenced = len(addrList)\n                        # whenReferenced tells us when, in the future, this was referenced\n                        for futureIdx in range(addrIndex&#43;1,len(addrList)):\n                            futurePage = int(addrList[futureIdx])\n                            if page == futurePage:\n                                whenReferenced = futureIdx\n                                break\n                        # print &#39;OPT: page %d is referenced at %d&#39; % (page, whenReferenced)\n                        if whenReferenced &gt;= maxReplace:\n                            # print &#39;OPT: ??? updating maxReplace (%d %d %d)&#39; % (replaceIdx, replacePage, maxReplace)\n                            replaceIdx  = pageIndex\n                            replacePage = page\n                            maxReplace  = whenReferenced\n                            # print &#39;OPT: --&gt; updating maxReplace (%d %d %d)&#39; % (replaceIdx, replacePage, maxReplace)\n                    victim = memory.pop(replaceIdx)\n                    # print &#39;OPT: replacing page %d (idx:%d) because I saw it in future at %d&#39; % (victim, replaceIdx, whenReferenced)\n            else:\n                # miss, but no replacement needed (page frame not full)\n                victim = -1\n                count = count &#43; 1\n\n            # now add to memory\n            if policy != &#39;WorkingSet&#39;:\n                memory.append(n)\n            if cdebug:\n                print &#39;LEN (a)&#39;, len(memory)\n            if victim != -1:\n                assert(victim not in memory)\n\n        # after miss processing, update reference bit\n        if n not in ref:\n            ref[n] = 1\n        else:\n            ref[n] &#43;= 1\n            if ref[n] &gt; clockbits:\n                ref[n] = clockbits\n        \n        if cdebug:\n            print &#39;REF (a)&#39;, ref\n\n        if notrace == False:\n            print &#39;Access: %d  %s %s -&gt; %12s &lt;- %s Replaced:%s [Hits:%d Misses:%d]&#39; % (n, hfunc(idx), leftStr, memory, riteStr, vfunc(victim), hits, miss)\n        addrIndex = addrIndex &#43; 1\n        \n    print &#39;&#39;\n    print &#39;FINALSTATS hits %d   misses %d   hitrate %.2f&#39; % (hits, miss, (100.0*float(hits))/(float(hits)&#43;float(miss)))\n    print &#39;&#39;\n</pre>\n<p>相当强大。</p>"}], "type": "note", "tags": ["lecture7", "student"], "tag_good": [], "unique_views": 137, "children": [], "tag_good_arr": [], "id": "k7t5oqsogeg13d", "config": {"seen": {"1426": 0, "177": 2, "1303": 4, "1421": 1, "227": 7, "1144": 8, "181": 6, "1171": 5, "1307": 3}}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 2, "num_favorites": 1, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643170022100, "default_anonymity": "no"}, "error": null, "aid": "kyv107h0pzq181"}