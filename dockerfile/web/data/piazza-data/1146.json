{"result": {"folders": ["2018", "课堂问答", "lab1", "lecture4"], "nr": 1146, "data": {"embed_links": []}, "created": "2018-03-09T02:04:37Z", "bucket_order": 3, "no_answer_followup": 7, "change_log": [{"anon": "no", "uid": "hdjonbiyfs62ie", "data": "jejat09kmj359m", "type": "create", "when": "2018-03-09T02:04:37Z"}, {"anon": "no", "uid": "itd595aeazu35p", "to": "jejat09izer59l", "type": "followup", "when": "2018-03-09T07:05:01Z"}, {"anon": "no", "uid": "itd595aeazu35p", "to": "jejat09izer59l", "type": "followup", "when": "2018-03-09T07:06:41Z"}, {"anon": "no", "uid": "isyonz8fhdh5ga", "to": "jejat09izer59l", "type": "followup", "when": "2018-03-12T15:54:54Z"}, {"anon": "no", "uid": "isvxeq6bspf1vn", "to": "jejat09izer59l", "type": "followup", "when": "2018-03-13T01:15:03Z"}, {"anon": "no", "uid": "jsmy9rsoDR0n", "to": "jejat09izer59l", "type": "followup", "when": "2019-03-07T01:20:15Z"}, {"anon": "no", "uid": "jsl9bhefCIIS", "to": "jejat09izer59l", "type": "followup", "when": "2019-03-07T01:24:25Z"}, {"anon": "no", "uid": "jshne06k1n84ml", "to": "jejat09izer59l", "type": "feedback", "when": "2019-03-07T01:36:02Z"}, {"anon": "no", "uid": "jshne06k1n84ml", "to": "jejat09izer59l", "type": "followup", "when": "2019-03-07T01:36:54Z"}, {"anon": "no", "uid": "jsjp7j7mu8BB", "to": "jejat09izer59l", "type": "followup", "when": "2019-03-07T01:37:38Z"}, {"anon": "no", "uid": "jshne06k1n84ml", "to": "jejat09izer59l", "type": "feedback", "when": "2019-03-08T03:05:26Z"}, {"anon": "no", "uid": "jsk1to9nLhla", "to": "jejat09izer59l", "type": "followup", "when": "2019-03-10T14:25:25Z"}, {"anon": "no", "uid": "jsk1to9nLhla", "to": "jejat09izer59l", "type": "feedback", "when": "2019-03-10T14:41:36Z"}, {"anon": "no", "uid": "jsjp7j7mu8BB", "to": "jejat09izer59l", "type": "feedback", "when": "2019-03-10T14:59:11Z"}, {"anon": "no", "uid": "jsl9bhefCIIS", "to": "jejat09izer59l", "type": "feedback", "when": "2019-03-10T16:25:13Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "2018春季-第四讲课堂实践练习一", "created": "2018-03-09T02:04:37Z", "content": "<p>在Linux系统的应用程序中写一个函数print_stackframe()&#xff0c;用于获取当前位置的函数调用栈信息。实现如下一种或多种功能&#xff1a;函数入口地址、函数名信息、参数调用参数信息、返回值信息。</p>\n<p></p>\n<p><a href=\"https://github.com/chyyuu/os_course_exercises/blob/2018spring/all/02-2-lab1-spoc-discussion.md#%E7%BB%83%E4%B9%A0%E4%B8%80\">https://github.com/chyyuu/os_course_exercises/blob/2018spring/all/02-2-lab1-spoc-discussion.md#%E7%BB%83%E4%B9%A0%E4%B8%80</a></p>\n<p></p>"}], "type": "note", "tags": ["2018", "instructor-note", "lab1", "lecture4", "课堂问答"], "tag_good": [], "unique_views": 174, "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>//这个可以得到一个只有函数名的函数调用栈</p>\n<p>#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;<br />#include &lt;execinfo.h&gt;</p>\n<p>void print_stackframe()<br />{<br /> void* buffer[100] = {NULL};<br /> char** trace = NULL;</p>\n<p>int size = backtrace(buffer, 100);<br /> trace = backtrace_symbols(buffer, size);<br /> if (trace == NULL)<br /> return;<br /> for(int i = 0; i &lt; size; &#43;&#43;i) {<br /> printf(&#34;%s\\n&#34;, trace[i]);<br /> }<br /> return;<br />}</p>\n<p>int main() {<br /> print_stackframe();<br />}</p>", "created": "2018-03-09T07:05:01Z", "bucket_order": 108, "bucket_name": "Week 3/4 - 3/10", "type": "followup", "tag_good": [], "uid": "itd595aeazu35p", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "jejljbmygzn5r8", "updated": "2018-03-09T07:05:01Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p></p><p>xzwkl Desktop gcc -o tmp tmp.c</p>\n<p>xzwkl Desktop ./tmp</p>\n<p>0   tmp                                 0x0000000103f5be90 print_stackframe &#43; 96</p>\n<p>1   tmp                                 0x0000000103f5bf49 main &#43; 9</p>\n<p>2   libdyld.dylib                       0x00007fff54af5115 start &#43; 1</p>\n<p>3   ???                                 0x0000000000000001 0x0 &#43; 1</p>", "created": "2018-03-09T07:06:41Z", "bucket_order": 108, "bucket_name": "Week 3/4 - 3/10", "type": "followup", "tag_good": [], "uid": "itd595aeazu35p", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "jejllgkeav66p4", "updated": "2018-03-09T07:06:41Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p></p><pre>#include &lt;stdio.h&gt;<br />#include &lt;execinfo.h&gt;<br />#include &lt;signal.h&gt;<br />#include &lt;stdlib.h&gt;<br />#include &lt;unistd.h&gt;<br />void handler(int sig) {<br />\tvoid *array[5];<br />\tsize_t size; // get void*&#39;s for all entries on the stack<br />\tsize = backtrace(array, 5); // print out all the frames to stderr<br />\tfprintf(stderr, &#34;Error: signal %d:\\n&#34;, sig);<br />\tchar** msgs = backtrace_symbols(array, size);<br />\tfor(int i=1;i&lt;size &amp;&amp; msgs[i];&#43;&#43;i)<br />\t\tprintf(&#34;[%d] %s\\n&#34;, i, msgs[i]); <br />\texit(1);<br />}<br />void baz() {<br />\tint *foo = (int*)-1; // make a bad pointer<br />\tprintf(&#34;%d\\n&#34;, *foo);  // causes segfault<br />}<br />void bar() { baz(); }<br />void foo() { bar(); }<br />int main(int argc, char **argv) {<br />\tsignal(SIGSEGV, handler); // install our handler<br />\tfoo(); // this will call foo, bar, and baz. baz segfaults.<br />}</pre>\n<blockquote>\n<p>Error: signal 11:</p>\n<p>[1] 1   libsystem_platform.dylib            0x00007fff63e8af5a _sigtramp &#43; 26</p>\n<p>[2] 2   ???                                 0x0000000117ed42d4 0x0 &#43; 4696392404</p>\n<p>[3] 3   print_stackframe                    0x000000010e685ed9 bar &#43; 9</p>\n<p>[4] 4   print_stackframe                    0x000000010e685ee9 foo &#43; 9</p>\n</blockquote>", "created": "2018-03-12T15:54:54Z", "bucket_order": 107, "bucket_name": "Week 3/11 - 3/17", "type": "followup", "tag_good": [], "uid": "isyonz8fhdh5ga", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "jeoesba7vfk1w6", "updated": "2018-03-12T15:54:54Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p></p>\n<pre>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;execinfo.h&gt;\nvoid get_ebp(unsigned long * ebp)\n{\n\t__asm__ __volatile__ (&#34;mov %%ebp, %0 \\r\\n&#34;\n\t:&#34;=m&#34;(*ebp)\n\t::&#34;memory&#34;);\n}\nvoid get_esp(unsigned long * esp)\n{\n\t__asm__ __volatile__ (&#34;mov %%esp, %0 \\r\\n&#34;\n\t:&#34;=m&#34;(*esp)\n\t::&#34;memory&#34;);\n}\n\n\nvoid print_stackframe()\n{\n\tprintf(&#34;---------- stack state ----------\\n&#34;);\n\tvoid * buffer[100] = {NULL};\n\tchar** trace = NULL;\n\t\n\tint layer = backtrace(buffer,100);\n\ttrace = backtrace_symbols(buffer, layer);\n\tfor(int i = 0; i &lt; layer; i&#43;&#43;){\n\t\tprintf(&#34;%s\\n&#34;,trace[i]);\t\n\t}\n\t\n\tprintf(&#34;-------- stack state over ---------\\n&#34;);\n}\n\nint factor(int i){\n\tunsigned long ebp = 0;\n\tunsigned long esp = 0;\n\tget_ebp(&amp;ebp);\n\tget_esp(&amp;esp);\n\tprint_stackframe();\n\tif (i == 1) return 1;\n\treturn i * factor(i-1);\n}\t\n\nint main(){\n\tprint_stackframe();\n\tfactor(6);\n}\n\nCompiling Command:\ngcc -o print_stackframe print_stackframe.c -std=c99 -rdynamic\n./print_stackframe\n\nRuntime Answer:\n---------- stack state ----------\n./print_stackframe(print_stackframe&#43;0x4e) [0x400aa4]\n./print_stackframe(main&#43;0xe) [0x400b9f]\n/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main&#43;0xf5) [0x7fa3f2e21ec5]\n./print_stackframe() [0x4008a9]\n-------- stack state over ---------\n\n---------- stack state ----------\n./print_stackframe(print_stackframe&#43;0x4e) [0x400aa4]\n./print_stackframe(factor&#43;0x57) [0x400b71]\n./print_stackframe(main&#43;0x18) [0x400ba9]\n/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main&#43;0xf5) [0x7fa3f2e21ec5]\n./print_stackframe() [0x4008a9]\n-------- stack state over ---------\n\n---------- stack state ----------\n./print_stackframe(print_stackframe&#43;0x4e) [0x400aa4]\n./print_stackframe(factor&#43;0x57) [0x400b71]\n./print_stackframe(factor&#43;0x71) [0x400b8b]\n./print_stackframe(main&#43;0x18) [0x400ba9]\n/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main&#43;0xf5) [0x7fa3f2e21ec5]\n./print_stackframe() [0x4008a9]\n-------- stack state over ---------\n\n---------- stack state ----------\n./print_stackframe(print_stackframe&#43;0x4e) [0x400aa4]\n./print_stackframe(factor&#43;0x57) [0x400b71]\n./print_stackframe(factor&#43;0x71) [0x400b8b]\n./print_stackframe(factor&#43;0x71) [0x400b8b]\n./print_stackframe(main&#43;0x18) [0x400ba9]\n/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main&#43;0xf5) [0x7fa3f2e21ec5]\n./print_stackframe() [0x4008a9]\n-------- stack state over ---------\n\n---------- stack state ----------\n./print_stackframe(print_stackframe&#43;0x4e) [0x400aa4]\n./print_stackframe(factor&#43;0x57) [0x400b71]\n./print_stackframe(factor&#43;0x71) [0x400b8b]\n./print_stackframe(factor&#43;0x71) [0x400b8b]\n./print_stackframe(factor&#43;0x71) [0x400b8b]\n./print_stackframe(main&#43;0x18) [0x400ba9]\n/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main&#43;0xf5) [0x7fa3f2e21ec5]\n./print_stackframe() [0x4008a9]\n-------- stack state over ---------\n\n---------- stack state ----------\n./print_stackframe(print_stackframe&#43;0x4e) [0x400aa4]\n./print_stackframe(factor&#43;0x57) [0x400b71]\n./print_stackframe(factor&#43;0x71) [0x400b8b]\n./print_stackframe(factor&#43;0x71) [0x400b8b]\n./print_stackframe(factor&#43;0x71) [0x400b8b]\n./print_stackframe(factor&#43;0x71) [0x400b8b]\n./print_stackframe(main&#43;0x18) [0x400ba9]\n/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main&#43;0xf5) [0x7fa3f2e21ec5]\n./print_stackframe() [0x4008a9]\n-------- stack state over ---------\n\n---------- stack state ----------\n./print_stackframe(print_stackframe&#43;0x4e) [0x400aa4]\n./print_stackframe(factor&#43;0x57) [0x400b71]\n./print_stackframe(factor&#43;0x71) [0x400b8b]\n./print_stackframe(factor&#43;0x71) [0x400b8b]\n./print_stackframe(factor&#43;0x71) [0x400b8b]\n./print_stackframe(factor&#43;0x71) [0x400b8b]\n./print_stackframe(factor&#43;0x71) [0x400b8b]\n./print_stackframe(main&#43;0x18) [0x400ba9]\n/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main&#43;0xf5) [0x7fa3f2e21ec5]\n./print_stackframe() [0x4008a9]\n-------- stack state over ---------\n</pre>", "created": "2018-03-13T01:15:03Z", "bucket_order": 107, "bucket_name": "Week 3/11 - 3/17", "type": "followup", "tag_good": [], "uid": "isvxeq6bspf1vn", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>", "created": "2019-03-07T01:36:02Z", "bucket_order": 56, "bucket_name": "Week 3/3 - 3/9", "type": "feedback", "tag_good": [], "uid": "jshne06k1n84ml", "children": [], "tag_good_arr": [], "id": "jsxymh7zmgt1en", "updated": "2019-03-07T01:36:02Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "jeoysny3zq63w", "updated": "2018-03-13T01:15:03Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>大多数同学都使用了 <strong>&#96;int backtrace (void **buffer, int size)&#96;</strong> 和 <strong>&#96;char ** backtrace_symbols (void *const *buffer, int size)&#96;</strong> 两个函数. <br /><br />在调用 libc 函数库函数实现这些功能不外乎要用到这两个函数, 所以我解释一下这两个函数的用法及意义.</p>\n<p></p>\n<p><br />对于<strong> &#96;int backtrace (void **buffer, int size)&#96;</strong> 函数, 该函数获得的是<strong>当前线程</strong>的函数调用栈信息.</p>\n<p></p>\n<p>每个栈帧信息通过函数返回地址间接携带 (关联另一个函数作用), 所有地址以指针形式存放在 &#96;buffer&#96; 指向的指针数组中. &#96;size&#96; 用于预设返回栈帧总数的最大值, 返回值为 &#96;buffer&#96; 中实际存储的指针总数.<br /><br />设实际函数调用栈中的的栈帧总数为 &#96;real_size&#96;, 则返回值为 &#96;min(size, real_size)&#96;, 超出部分舍去. 值得注意的是, 编译器优化可能会干扰该函数的正常实现.<br /><br /></p>\n<p></p>\n<p>对于<strong> &#96;char ** backtrace_symbols (void *const *buffer, int size)&#96;</strong> 函数, 相当于 &#96;backtrace&#96; 函数的解释器, 将间接携带的栈帧信息转化为可打印的字符串信息, 包括函数名(如果能确定), 函数偏移地址 和 实际返回地址.<br /><br />&#96;buffer&#96; 即为 &#96;backtrace&#96; 中的 &#96;buffer&#96;, &#96;size&#96; 为 &#96;buffer&#96; 中实际存储的数量 (应为 &#96;backtrace&#96; 返回值), 返回值即为对应信息的字符串数组, 每行一条.<br /><br />这里注意的是, 返回值 (字符串数组) 需要在本函数之后释放, 它是在本函数中被 &#96;malloc&#96; 分配出的.<br /><br /></p>\n<p></p>\n<p>例程, 编译指令和代码输出如下<br /><br />prog.c</p>\n<pre>#include &lt;execinfo.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n\n#define BT_BUF_SIZE 100\n\nvoid\nmyfunc3(void)\n{\n   int j, nptrs;\n   void *buffer[BT_BUF_SIZE];\n   char **strings;\n\n   nptrs = backtrace(buffer, BT_BUF_SIZE);\n   printf(&#34;backtrace() returned %d addresses\\n&#34;, nptrs);\n\n   /* The call backtrace_symbols_fd(buffer, nptrs, STDOUT_FILENO)\n      would produce similar output to the following: */\n\n   strings = backtrace_symbols(buffer, nptrs);\n   if (strings == NULL) {\n       perror(&#34;backtrace_symbols&#34;);\n       exit(EXIT_FAILURE);\n   }\n\n   for (j = 0; j &lt; nptrs; j&#43;&#43;)\n       printf(&#34;%s\\n&#34;, strings[j]);\n\n   free(strings);\n}\n\nstatic void   /* &#34;static&#34; means don&#39;t export the symbol... */\nmyfunc2(void)\n{\n   myfunc3();\n}\n\nvoid\nmyfunc(int ncalls)\n{\n   if (ncalls &gt; 1)\n       myfunc(ncalls - 1);\n   else\n       myfunc2();\n}\n\nint\nmain(int argc, char *argv[])\n{\n   if (argc != 2) {\n       fprintf(stderr, &#34;%s num-calls\\n&#34;, argv[0]);\n       exit(EXIT_FAILURE);\n   }\n\n   myfunc(atoi(argv[1]));\n   exit(EXIT_SUCCESS);\n}</pre>\n<p><br />编译指令</p>\n<pre>cc -rdynamic prog.c -o prog</pre>\n<p></p>\n<p>输出结果</p>\n<pre>backtrace() returned 8 addresses\n./prog0(myfunc3&#43;0x2e) [0x55d1f2f0db78]\n./prog0(&#43;0xc4a) [0x55d1f2f0dc4a]\n./prog0(myfunc&#43;0x25) [0x55d1f2f0dc72]\n./prog0(myfunc&#43;0x1e) [0x55d1f2f0dc6b]\n./prog0(myfunc&#43;0x1e) [0x55d1f2f0dc6b]\n./prog0(main&#43;0x5b) [0x55d1f2f0dcd0]\n/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main&#43;0xe7) [0x7f0ab104bb97]\n./prog0(_start&#43;0x2a) [0x55d1f2f0da6a]</pre>\n<p></p>\n<p>参考资料:</p>\n<p></p>\n<p>[1] <a href=\"https://www.gnu.org/software/libc/manual/html_node/Backtraces.html\" target=\"_blank\">GNU Backtraces</a></p>\n<p></p>\n<p>[2] <a href=\"http://man7.org/linux/man-pages/man3/backtrace.3.html\" target=\"_blank\">MAN backtrace (3)</a></p>\n<p></p>", "created": "2019-03-07T01:20:15Z", "bucket_order": 56, "bucket_name": "Week 3/3 - 3/9", "type": "followup", "tag_good": [], "uid": "jsmy9rsoDR0n", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "jsxy265fe1q6ee", "updated": "2019-03-07T01:20:15Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p></p>", "created": "2019-03-07T01:24:25Z", "bucket_order": 56, "bucket_name": "Week 3/3 - 3/9", "type": "followup", "tag_good": [], "uid": "jsl9bhefCIIS", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>先调用backtrace()函数回溯函数调用栈&#xff0c;再调用backtrace_symbols(buffer, nptrs)函数得到栈内信息</p>\n<p>代码如下</p>\n<p>#include &lt;execinfo.h&gt;<br />#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;<br />#include &lt;unistd.h&gt;</p>\n<p>void print_stackframe()<br />{<br />    int nptrs;<br />    void *buffer[100];<br />    char **strings;</p>\n<p>    nptrs = backtrace(buffer, 100);<br />    printf(&#34;backtrace() returned %d addresses\\n&#34;, nptrs);<br />    strings = backtrace_symbols(buffer, nptrs);<br />    if (strings == NULL) {<br />        perror(&#34;backtrace_symbols&#34;);<br />        exit(EXIT_FAILURE);<br />    }</p>\n<p>    for (int i = 0; i &lt; nptrs; i&#43;&#43;)<br />        printf(&#34;%s\\n&#34;, strings[i]);</p>\n<p>    free(strings);<br />}</p>\n<p>int main()<br />{<br />    print_stackframe();<br />    return 0;<br />}</p>\n<p>一开始编译命令为</p>\n<p>gcc -g -o backtrace backtrace.c</p>\n<p>输出结果为</p>\n<p>backtrace() returned 4 addresses<br />./backtrace() [0x400784]<br />./backtrace() [0x400857]<br />/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main&#43;0xf0) [0x7f1d6b2b1830]<br />./backtrace() [0x400689]</p>\n<p>发现没有返回函数名&#xff0c;后来参考了其他同学的回帖后添加了参数-rdynamic&#xff0c;输出如下</p>\n<p>backtrace() returned 4 addresses<br />./backtrace(print_stackframe&#43;0x2e) [0x400a14]<br />./backtrace(main&#43;0xe) [0x400ae7]<br />/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main&#43;0xf0) [0x7f9e7a0e8830]<br />./backtrace(_start&#43;0x29) [0x400919]</p>\n<p>得到了正确函数名</p>\n<p></p>\n<p>为了验证返回地址的正确性&#xff0c;我分别查看了三次backtrace()函数的返回地址</p>\n<p>命令&#xff1a;addr2line 400a14 -e ./backtrace</p>\n<p>输出&#xff1a;/home/jerryxu/backtrace.c:12</p>\n<p>命令&#xff1a;addr2line 400ae7 -e ./backtrace</p>\n<p>输出&#xff1a;/home/jerryxu/backtrace.c:29</p>\n<p>命令&#xff1a;addr2line 400919 -e ./backtrace</p>\n<p>输出&#xff1a;??:?</p>\n<p>分别对应了源文件正确的行数</p>\n<p>为了查看可执行文件对应的汇编代码&#xff0c;输入命令如下</p>\n<p>objdump -S ./backtrace|less</p>\n<p>发现返回地址均为调用函数地址的下一行&#xff0c;符合函数调用的返回规则</p>\n<p></p>\n<p></p>", "created": "2019-03-10T16:25:13Z", "bucket_order": 55, "bucket_name": "Week 3/10 - 3/16", "type": "feedback", "tag_good": [], "uid": "jsl9bhefCIIS", "children": [], "tag_good_arr": [], "id": "jt34pil3deu56n", "updated": "2019-03-10T16:25:13Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "jsxy7j8hblc4aj", "updated": "2019-03-07T01:24:25Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>魏宇轩</p>", "created": "2019-03-07T01:36:54Z", "bucket_order": 56, "bucket_name": "Week 3/3 - 3/9", "type": "followup", "tag_good": [], "uid": "jshne06k1n84ml", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p><md><br />在Linux中打印函数调用栈<br /> <br /><br />要求<br /> <br /><br />在Linux系统的应用程序中写一个函数print_stackframe()&#xff0c;用于获取当前位置的函数调用栈信息<br /> <br /><br />方法<br /> <br /><br />execinfo.h库下的函数backtrace可以得到当前线程的函数调用栈指针和调用栈深度&#xff0c;backtrace_symbols可以将调用栈指针转化为字符串信息。详见<br /><a href=\"https://www.gnu.org/software/libc/manual/html_node/Backtraces.html\"></a><br /><a href=\"https://www.gnu.org/software/libc/manual/html_node/Backtraces.html\">Backtraces</a><br /><br />或在Linux命令行运行命令man backtrace.<br /> <br /><br />代码<br /> <br /><br /> <br />1 <br />// Created Time:   2019-03-08 09:48:30                                               <br /><br /><br /> <br />2 <br />// Modified Time:   2019-03-08 10:45:25<br /><br /><br /> <br />3  <br /><br /><br /> <br />4 <br />#include <br />&lt;<br />stdio.<br />h<br />&gt;<br /><br /><br /> <br />5 #include &lt;<br />execinfo.h&gt;<br /><br /><br /> <br />6  <br /><br /><br /> <br />7 <br />#define <br />MAX_DEPTH (<br />20)<br /><br /><br /> <br />8  <br /><br /><br /> <br />9 <br />void <br />func0(void);<br /><br /><br /><br />10 void <br />func1(void);<br /><br /><br /><br />11 void <br />func2(void);<br /><br /><br /><br />12 void <br />print_stackframe(void);<br /><br /><br /><br />13  <br /><br /><br /><br />14 void print_stackframe(void)<br /><br /><br /><br />15 {<br /><br /><br /><br />16     void <br />* <br />buffer[<br />MAX_DEPTH];<br /><br /><br /><br />17     <br />int <br />depth <br />= <br />backtrace(buffer, MAX_DEPTH);<br /><br /><br /><br />18     <br />char <br />** <br />func_names = <br />backtrace_symbols(buffer, depth);<br /><br /><br /><br />19     <br />for (int <br />i=<br />0; i&lt;depth; i<br />&#43;&#43;)<br /><br /><br />20     {<br /><br /><br />21         <br />printf(<br />&#34;Depth: %d, func name: %s\\n&#34;, i, func_names[i]);<br /><br /><br /><br />22     }<br /><br /><br /><br />23 }<br /><br /><br /><br />24  <br /><br /><br /><br />25 void func0(void)<br /><br /><br /><br />26 {<br /><br /><br /><br />27     <br />func1();<br /><br /><br /><br />28 }<br /><br /><br /><br />29  <br /><br /><br /><br />30 void func1(void)<br /><br /><br /><br />31 {<br /><br /><br /><br />32     <br />func2();<br /><br /><br /><br />33 }<br /><br /><br /><br />34  <br /><br /><br /><br />35 void func2(void)<br /><br /><br /><br />36 {<br /><br /><br /><br />37     <br />print_stackframe();<br /><br /><br /><br />38 }<br /><br /><br /><br />39  <br /><br /><br /><br />40 int <br />main(int <br />argc, char *<br />argv[]) {<br /><br /><br /><br />41     <br />// print_stackframe();<br /><br /><br /><br />42     <br />func0();<br /><br /><br /><br />43     <br />return 0;<br /><br /><br /><br />44 }<br /><br /> <br /><br />编译运行<br /> <br /><br />gcc编译时加上-rdynamic参数&#xff0c;通知链接器支持函数名功能&#xff08;不加-rdynamic参数则无函数名打印&#xff09;&#xff1a;<br /> <br /><br /><br />gcc print_stackframe.c <br />-o print_stackframe <br />-rdynamic<br /><br /> <br /><br />运行可执行文件&#xff1a;<br /> <br /><br />./print_stackframe<br /> <br /><br />结果<br /> <br /><br />Depth: 0, func name: ./print_stackframe(print_stackframe<br />&#43;0x2e) [0x400964]<br /><br /><br />Depth: 1, func name: ./print_stackframe(func2&#43;0x9) [0x400a15]<br /><br />Depth: 2, func name: ./print_stackframe(func1&#43;0x9) [0x400a09]<br /><br />Depth: 3, func name: ./print_stackframe(func0&#43;0x9) [0x4009fd]<br /><br />Depth: 4, func name: ./print_stackframe(main&#43;0x14) [0x400a2c]<br /><br />Depth: 5, func name: /lib/x86_64-linux-gnu/libc.so.6(__libc_start_main&#43;0xf0) [0x7f7abe418830]<br /><br />Depth: 6, func name: ./print_stackframe(_start&#43;0x29) [0x400869]<br /></md></p>", "created": "2019-03-08T03:05:26Z", "bucket_order": 56, "bucket_name": "Week 3/3 - 3/9", "type": "feedback", "tag_good": [], "uid": "jshne06k1n84ml", "children": [], "tag_good_arr": [], "id": "jszh9aobc4pup", "updated": "2019-03-08T03:05:26Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "jsxynl43odv2cw", "updated": "2019-03-07T01:36:54Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>参考之前同学的回答&#xff0c;使用 execinfo.h 库中的 backtrace 和 backtrace_symbols 函数来完成</p>\n<pre>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;execinfo.h&gt;\n#define MAX_AMOUNT 30\t//限定获取记录的最大条数\n\nvoid print_stackframe() {\n\tprintf(&#34;current stack:\\n&#34;);\n\tvoid* buffer[MAX_AMOUNT] = {NULL};\n\tint actual_amount = backtrace(buffer, MAX_AMOUNT);\t//backtrace返回实际获取的记录条数&#xff0c;buffer返回一串地址\n\tchar** stackframe_info = backtrace_symbols(buffer, actual_amount);\t//获得actual_amount条记录\n\tfor(int i = 0; i &lt; actual_amount; i&#43;&#43;) {\t//若题意为打印调用print_stackframe之前的函数栈&#xff0c;则i初始值需要修改\n\t\tprintf(&#34;%s\\n&#34;, stackframe_info[i]);\n\t}\n\tprintf(&#34;\\n&#34;);\n}\n\nint main() {\n\tprint_stackframe();\n\treturn 0;\n}</pre>\n<p>经同学提醒&#xff0c;编译时需加参数-rdynamic&#xff0c;否则没有输出函数名</p>", "created": "2019-03-07T01:37:38Z", "bucket_order": 56, "bucket_name": "Week 3/3 - 3/9", "type": "followup", "tag_good": [], "uid": "jsjp7j7mu8BB", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>", "created": "2019-03-10T14:59:11Z", "bucket_order": 55, "bucket_name": "Week 3/10 - 3/16", "type": "feedback", "tag_good": [], "uid": "jsjp7j7mu8BB", "children": [], "tag_good_arr": [], "id": "jt31mvxhtpg31o", "updated": "2019-03-10T14:59:11Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "jsxyois63yt327", "updated": "2019-03-07T01:37:38Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p><md><br />可以打印出函数名和地址<br /></md>\n</p><pre>#include &lt;stdio.h&gt;<br />#include &lt;signal.h&gt;<br />#include &lt;execinfo.h&gt;\nvoid show_stackframe() {<br /> void *trace[16];<br /> char **messages = (char **)NULL;<br /> int i, trace_size = 0;<br />trace_size = backtrace(trace, 16);\n messages = backtrace_symbols(trace, trace_size);<br /> printf(&#34;[bt] Execution path:\\n&#34;);<br /> for (i=0; i&lt;trace_size; &#43;&#43;i)<br /> printf(&#34;[bt] %s\\n&#34;, messages[i]);<br />}<br />int func() {<br /> show_stackframe();<br />}<br />int test(int p1) {<br /> func();<br /> return p1;<br />}<br />int main() {<br /> printf(&#34;call: %d\\n\\n&#34;, test(100));<br />}</pre>\n<md><br />编译命令<br /></md>\n<pre>gcc -rdynamic main.c -o main</pre>\n<md><br />输出<br /></md>\n<pre>[bt] Execution path:\n[bt] ./main(show_stackframe&#43;0x31) [0x40091e]\n[bt] ./main(func&#43;0xe) [0x4009a9]\n[bt] ./main(test&#43;0x15) [0x4009c0]\n[bt] ./main(main&#43;0xe) [0x4009d3]\n[bt] /lib/x86_64-linux-gnu/libc.so.6(__libc_start_main&#43;0xf5) [0x7fabf49c9ec5]\n[bt] ./main() [0x400829]\ncall: 100</pre>\n<p></p><p></p>", "created": "2019-03-10T14:25:25Z", "bucket_order": 55, "bucket_name": "Week 3/10 - 3/16", "type": "followup", "tag_good": [], "uid": "jsk1to9nLhla", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>", "created": "2019-03-10T14:41:36Z", "bucket_order": 55, "bucket_name": "Week 3/10 - 3/16", "type": "feedback", "tag_good": [], "uid": "jsk1to9nLhla", "children": [], "tag_good_arr": [], "id": "jt310a1wkki1pq", "updated": "2019-03-10T14:41:36Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "jt30fgvk2tqp", "updated": "2019-03-10T14:25:25Z", "config": {}}], "tag_good_arr": [], "id": "jejat09izer59l", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 11, "num_favorites": 1, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169234083, "default_anonymity": "no"}, "error": null, "aid": "kyv0jbfndkn15t"}