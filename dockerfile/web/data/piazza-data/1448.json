{"result": {"folders": ["lecture13"], "nr": 1448, "data": {"embed_links": []}, "created": "2020-04-11T08:57:26Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "jsjptolvvI0o", "data": "k8vdypgsxjs6ui", "v": "all", "type": "create", "when": "2020-04-11T08:57:26Z"}, {"anon": "no", "uid": "jsjptolvvI0o", "data": "k8vdzmutnmj7a2", "type": "update", "when": "2020-04-11T08:58:09Z"}, {"anon": "no", "uid": "jsjptolvvI0o", "data": "k8ve0l6dldt7ng", "type": "update", "when": "2020-04-11T08:58:54Z"}, {"anon": "no", "uid": "jsjptolvvI0o", "data": "k8ve14cl1wd5e", "type": "update", "when": "2020-04-11T08:59:18Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "jsjptolvvI0o", "subject": "2020春-第13讲课后习题展示", "created": "2020-04-11T08:59:18Z", "content": "<md>## 问题\n下面有9种基于软件的两线程同步方法实现&#xff0c;请选择并分析两种实现的正确性&#xff0c;并与已有的回答进行比较。对于正确的实现&#xff0c;描述你的枚举分类&#xff1b;对于错误的实现&#xff0c;给出一个反例。\n\n## 方法一\n&#96;&#96;&#96;\nCONCEPT: A shared variable named turn is used to keep track of whose turn it is to enter the critical section.\nINITIALIZATION:\n\n\tshared int turn;\n\t...\n\tturn = i ;\nENTRY PROTOCOL (for Process i ):\n\t/* wait until it&#39;s our turn */\n\twhile (turn != i ) {\n\t}\nEXIT PROTOCOL (for Process i ):\n\t/* pass the turn on */\n\tturn = j ;\n&#96;&#96;&#96;\n\n是课堂上讲的第一种尝试。满足忙则等待&#xff0c;但不满足空闲则入。两个进程必须交替执行&#xff0c;效率很低。\n\n## 方法二\n&#96;&#96;&#96;\nCONCEPT: A shared Boolean array named flags contains a flag for each process. The flag values are BUSY when the process is in its critical section (using the resource), or FREE when it is not.\nINITIALIZATION:\n\n\ttypedef char boolean;\n\t...\n\tshared boolean flags[n - 1];\n\t...\n\tflags[i ] = FREE;\n\t...\n\tflags[j ] = FREE;\n\t...\nENTRY PROTOCOL (for Process i ):\n\t/* wait while the other process is in its CS */\n\twhile (flags[j ] == BUSY) {\n\t}\n--&gt;\n\t/* claim the resource */\n\tflags[i ] = BUSY;\nEXIT PROTOCOL (for Process i ):\n\t/* release the resource */\n\tflags[i ] = FREE;\n&#96;&#96;&#96;\n同样是课堂上讨论过的&#xff0c;满足空闲则入&#xff0c;不满足忙则等待&#xff0c;反例如下所示\n (赖金霖 2016011377 https://git.tsinghua.edu.cn/laijl16/os-homeworks/blob/master/lec13/answer.md)\n&#96;&#96;&#96;\nENTRY PROTOCOL (for Process i ):\n\t/* wait while the other process is in its CS */\n\twhile (flags[j ] == BUSY) {\n\t}\n--&gt;\n                                    ENTRY PROTOCOL (for Process j ):\n                                        /* wait while the other process is in its CS */\n                                        while (flags[i ] == BUSY) {\n                                        }\n                                    --&gt;\n                                    \t/* claim the resource */\n\t/* claim the resource */\n\tflags[i ] = BUSY;\nEXIT PROTOCOL (for Process i ):\n\t/* release the resource */\n\tflags[i ] = FREE;\n                                        flags[i ] = BUSY;\n                                    EXIT PROTOCOL (for Process i ):\n                                        /* release the resource */\n                                        flags[i ] = FREE;\n\n&#96;&#96;&#96;\n## 方法三\n&#96;&#96;&#96;\nCONCEPT: Again we use a shared Boolean array as in Algorithm 2. Each process sets its flag before  testing the other flag, thus avoiding the problem of violating mutual exclusion.\nINITIALIZATION:\n\n\ttypedef char boolean;\n\t...\n\tshared boolean flags[n -1];\n\t...\n\tflags[i ] = FREE;\n\t...\n\tflags[j ] = FREE;\n\t...\nENTRY PROTOCOL (for Process i ):\n\t/* claim the resource */\n\tflags[i ] = BUSY;\n--&gt;\n\t/* wait if the other process is using the resource */\n\twhile (flags[j ] == BUSY) {\n\t}\nEXIT PROTOCOL (for Process i ):\n\t/* release the resource */\n\tflags[i ] = FREE;\n&#96;&#96;&#96;\n(陈昱霏 2017080067 https://git.tsinghua.edu.cn/chen-yf17/os-lecture13hw)\n在进程i把flag设为busy之后&#xff0c;这时有可能跳转进程到进程j&#xff0c;然后进程j把自己设为busy&#xff0c;然后发现进程i是busy&#xff0c;进入while循环&#xff0c;但是回到进程i&#xff0c;会发现flag[j]也是busy&#xff0c;那两个都在busy状态&#xff0c;就都进入不了临界区。这个方法可以满足忙则等待&#xff0c;但是不能满足空闲则入。\n\n## 方法四\n&#96;&#96;&#96;\nCONCEPT: To avoid the deadlock problem of Algorithm 3, we periodically clear and reset our own flag while waiting for the other one.\nINITIALIZATION:\n\n\ttypedef char boolean;\n\t...\n\tshared boolean flags[n -1];\n\t...\n\tflags[i ] = FREE;\n\t...\n\tflags[j ] = FREE;\n\t...\nENTRY PROTOCOL (for Process i ):\n\t/* claim the resource */\n\tflags[i ] = BUSY;\n--&gt;\n\t/* wait if the other process is using the resource */\n\twhile (flags[j ] == BUSY) {\n\t\tflags[i ] = FREE;\n\t\tdelay a while ;\n\t\tflags[i ] = BUSY;\n\t}\nEXIT PROTOCOL (for Process i ):\n\t/* release the resource */\n\tflags[i ] = FREE;\n&#96;&#96;&#96;\n满足忙则等待&#xff0c;但是在极端情况下不满足空闲则入。\n(https://piazza.com/class/i5j09fnsl7k5x0?cid=1060)\n比如这样一种情况&#xff0c;i和j都从代码第一行开始&#xff0c;i运行一行后切换到j运行&#xff0c;然后j也只运行一行就切换到i&#xff0c;以此方式执行下去&#xff0c;最终会导致两者都在while循环中永远出不去&#xff0c;具体执行为&#xff1a;flags[i] = FREE -&gt; flags[j] = FREE -&gt; i ENTRY -&gt; j ENTRY -&gt;flags[i] = BUSY -&gt; flags[j] = BUSY -&gt;i 进入while -&gt; j 进入 while -&gt;flags[i] = FREE -&gt; flags[j] = FREE -&gt; i delay a while -&gt; j delay a while -&gt;flags[i] = BUSY -&gt; flags[j] = BUSY -&gt;i 又进入while -&gt; j 又进入while......\n但是实际使用中几乎不会出现这种这种极端情况&#xff0c;所以可以认为该方法是可以使用的&#xff0c;但严格来说是错误的。\n## 方法五\n&#96;&#96;&#96;\n# CONCEPT: Both the turn variable and the status flags are combined in a way which we (the requesting process) set our flag and then check our neighbor&#39;s flag. \n\nINITIALIZATION:\n\n\ttypedef char boolean;\n\t...\n\tshared boolean flags[n -1];\n\tshared int turn;\n\t...\n\tturn = i ;\n\t...\n\tflags[i ] = FREE;\n\t...\n\tflags[j ] = FREE;\n\t...\nENTRY PROTOCOL (for Process i ):\n\t/* claim the resource */\n\tflags[i ] = BUSY;\n\n\t/* wait if the other process is using the resource */\n\twhile (flags[j ] == BUSY) {\n\n\t\t/* if waiting for the resource, also wait our turn */\n\t\tif (turn != i ) {\n\t\t\n\t\t\t/* but release the resource while waiting */\n\t\t\tflags[i ] = FREE;\n\t\t\twhile (turn != i ) {\n\t\t\t}\n\t\t\tflags[i ] = BUSY;\n\t\t}\n\n\t}\nEXIT PROTOCOL (for Process i ):\n\t/* pass the turn on, and release the resource */\n\tturn = j ;\n\tflags[i ] = FREE;\n&#96;&#96;&#96;\n正确。和第四种方法的不同在于&#xff0c;由于turn只能指向一个进程&#xff0c;这样两个进程不可能完全同步。\n如果两个进程发生竞争&#xff08;同时设置BUSY&#xff09;&#xff0c;不被turn指向的进程总会退出&#xff0c;而turn指向的进程则持续尝试进入&#xff0c;必然可以进入到临界区。\n\n## 方法六\n\n&#96;&#96;&#96;\nCONCEPT: Both the turn variable and the status flags are used.\n\nINITIALIZATION:\n\n\ttypedef char boolean;\n\t...\n\tshared boolean flags[n -1];\n\tshared int turn;\n\t...\n\tturn = i ;\n\t...\n\tflags[i ] = FREE;\n\t...\n\tflags[j ] = FREE;\n\t...\nENTRY PROTOCOL (for Process i ):\n\t/* claim the resource */\n\tflags[i ] = BUSY;\n\n\t/* give away the turn */\n\tturn = j ;\n\t/* wait while the other process is using the resource *and* has the turn */\n\twhile ((flags[j ] == BUSY) &amp;&amp; (turn != i )) {\n\t}\nEXIT PROTOCOL (for Process i ):\n\t/* release the resource */\n\tflags[i ] = FREE;\n&#96;&#96;&#96;\n&#xff08;郭诚 2016010563 https://git.tsinghua.edu.cn/c-guo16/os_practice&#xff09;\n正确。该同步机制既是peterson算法&#xff0c;能够满足同步互斥算法的要求。终点在于&#xff0c;进入区代码 turn = j 为对变量写入的操作&#xff0c;因此必定有先后顺序&#xff0c;在两进程发生冲突时&#xff0c;后写入的进程必定不满足之后while循环的要求&#xff0c;因此会忙等待。临界区空闲时&#xff0c;若有一进程到达临界区前&#xff0c;则必定不满足flags[j]==BUSY&#xff0c;可以进入临界区。\n\n## 方法七\n&#96;&#96;&#96;\n# CONCEPT: The turn variable and status flags are used as in Dekker&#39;s algorithm for the 2-process case. The flags now have three possible values: WAITING for a process in the entry protocol, waiting for the resource&#39; ACTIVE for a process in the critical section, using the resource; and IDLE for other cases.\n\nProcess priority is maintained in circular order beginning with the one holding the turn. Each process begins the entry protocol by scanning all processes from the one with the turn up to itself. These are the only processes that might have to go first if there is competition.\n\nIf the scan finds all processes idle, the process advances tentatively to the ACTIVE state. However, it is still possible that another process which started scanning later but belongs before us will also reach this state. We check one more time to be sure there are no active processes.\n\nINITIALIZATION:\n\n\tshared enum states {IDLE, WAITING, ACTIVE} flags[n -1];\n\tshared int turn;\n\tint index;\t/* not shared! */\n\t...\n\tturn = 0;\n\t...\n\tfor (index=0; index&lt;n; index&#43;&#43;) {\n\t\tflags[index] = IDLE;\n\t}\nENTRY PROTOCOL (for Process i ):\n\n\trepeat {\n\n\t\t/* announce that we need the resource */\n\t\tflags[i] = WAITING;\n\n\t\t/* scan processes from the one with the turn up to ourselves. */\n\t\t/* repeat if necessary until the scan finds all processes idle */\n\t\tindex = turn;\n\t\twhile (index != i) {\n\t\t\tif (flag[index] != IDLE) index = turn;\n\t\t\telse index = index&#43;1 mod n;\n\t\t}\n\n\t\t/* now tentatively claim the resource */\n\t\tflags[i] = ACTIVE;\n\n\t\t/* find the first active process besides ourselves, if any */\n\t\tindex = 0;\n\t\twhile ((index &lt; n) &amp;&amp; ((index == i) || (flags[index] != ACTIVE))) {\n\t\t\tindex = index&#43;1;\n\t\t}\n\n\t/* if there were no other active processes, AND if we have the turn\n\t   or else whoever has it is idle, then proceed.  Otherwise, repeat\n\t   the whole sequence. */\n\t} until ((index &gt;= n) &amp;&amp; ((turn == i) || (flags[turn] == IDLE)));\n\n\t/* claim the turn and proceed */\n\tturn = i;\nEXIT PROTOCOL (for Process i ):\n\n\t/* find a process which is not IDLE */\n\t/* (if there are no others, we will find ourselves) */\n\tindex = turn&#43;1 mod n;\n\twhile (flags[index] == IDLE) {\n\t\tindex = index&#43;1 mod n;\n\t}\n\n\t/* give the turn to someone that needs it, or keep it */\n\tturn = index;\n\n\t/* we&#39;re finished now */\n\tflag[i] = IDLE;\n&#96;&#96;&#96;\n这个方法是Eisenberg同步算法。正确。\n1.证明互斥进入\n  实际上循环2就已经实现了互斥进入&#xff0c;即只能有一个进程进入临界区&#xff0c;即只有第一个设置ACTIVE的才有可能进入临界区。\n  这里的第一个是指在写之前flags全不是ACTIVE&#xff0c;写后一个变为ACTIVE&#xff0c;如果有进程写了然后循环回去又改成了WAITING&#xff0c;则下一个第一个改ACTIVE的才有可能进入临界区。\n  因为先设置ACTIVE并还没有循环回去的进程会让其他进程数ACTIVE数目时都发现不只自己&#xff0c;这样就进不到临界区。\n  因此循环2保证了在临界区没有进程时最多一个进程可能进入临界区\n  然后&#xff0c;如果有一个进程进入了临界区&#xff0c;那么&#xff0c;该进程的flags必定为ACTIVE&#xff0c;继而阻止了其他所有进程在循环2中将index加到n&#xff0c;所以这时没有进程能再进去&#xff0c;除非临界区的进程退出临界区&#xff0c;改了自己的flags。\n综上&#xff0c;互斥进入得证。\n而空闲则入&#xff0c;仍采用上面的反证法&#xff0c;基本思路是&#xff0c;如果无限循环&#xff0c;那么能通过循环1的越来越少&#xff0c;由于进程数目有限&#xff0c;总会有减到1的时候&#xff0c;这时这个进程必定能进入临界区&#xff0c;与假设矛盾。\n\n## 方法八\n&#96;&#96;&#96;\n# CONCEPT: Both status values and turn values are used. The status array is expanded to an integer value for each process, which is used to track that process&#39; progress in scanning the status of other processes. The turn value is also expanded to an integer array. Its values represent the relative ordering for each pair of processes.\n\n\nINITIALIZATION:\n\nshared int flags[NUMPROCS];\nshared int turn[NUMPROCS - 1];\nint index;\n\nfor (index = 0; index &lt; (NUMPROCS); index&#43;&#43;) {\n\n\tflags[index] = -1\n}\n\n\nfor (index = 0; index &lt; (NUMPROCS-1); index&#43;&#43;) {\n\tturn[index] = 0;\n}\n\nENTRY PROTOCOL (for Process i):\n/* repeat for all partners */\nfor (count = 0; count &lt; (NUMPROCS-1); count&#43;&#43;) {\n\n\tflags[i] = count;\n\tturn[count] = i;\n\n\t&#34;wait until (for all k != i, flag[k]&lt;count) or (turn[count] != i)&#34;\n\n}\n\nEXIT PROTOCOL (for Process i):\n/* tell everyone we are finished */\nflags[i] = -1;\n&#96;&#96;&#96;\n这个算法应该是正确的&#xff0c;戴臻旸助教指出&#xff0c;这个算法就是 peterson 原本给的 n-process.\nhttps://piazza.com/class/i5j09fnsl7k5x0?cid=1060 中给出的反例是不可构造的&#xff0c;turn中允许进程数量-1个进程等待&#xff0c;同时有一个进程在运行临界区代码&#xff0c;不会出现同时两个进程进入临界区。\n\n## 方法九\n&#96;&#96;&#96;\nCONCEPT: A process waiting to enter its critical section chooses a number. This number must be greater than all other numbers currently in use. There is a global shared array of current numbers for each process. The entering process checks all other processes sequentially, and waits for each one which has a lower number. Ties are possible; these are resolved using process IDs.\n\nINITIALIZATION:\n\n\ttypedef char boolean;\n\t...\n\tshared boolean choosing[n]\n\tshared int num[n];\n\t...\n\tfor (j=0; j &lt; n; j&#43;&#43;) {\n\t\tnum[j] = 0;\n\t}\n\t...\nENTRY PROTOCOL (for Process i):\n\t/* choose a number */\n\tchoosing[i] = TRUE;\n\tnum[i] = max(num[0], ..., num[n-1]) &#43; 1;\n\tchoosing[i] = FALSE;\n\t\n\t/* for all other processes */\n\tfor (j=0; j &lt; n; j&#43;&#43;) {\n\t\n\t\t/* wait if the process is currently choosing */\n\t\twhile (choosing[j]) {}\n\t\t\n\t\t/* wait if the process has a number and comes ahead of us */\n\t\tif ((num[j] &gt; 0) &amp;&amp;\n\t\t  ((num[j] &lt; num[i]) ||\n\t\t  (num[j] == num[i]) &amp;&amp; (j &lt; i))) {\n\t\t\twhile (num[j] &gt; 0) {}\n\t\t}\n\t}\n\t\t\nEXIT PROTOCOL (for Process i):\n\t/* clear our number */\n\tnum[i] = 0;\n&#96;&#96;&#96;\n正确。https://piazza.com/class/i5j09fnsl7k5x0?cid=1060 中有不错的描述。</md>"}, {"anon": "no", "uid": "jsjptolvvI0o", "subject": "2020春-第13讲课后习题展示", "created": "2020-04-11T08:58:54Z", "content": "<md>## 问题\n下面有9种基于软件的两线程同步方法实现&#xff0c;请选择并分析两种实现的正确性&#xff0c;并与已有的回答进行比较。对于正确的实现&#xff0c;描述你的枚举分类&#xff1b;对于错误的实现&#xff0c;给出一个反例。\n\n## 方法一\n&#96;&#96;&#96;\nCONCEPT: A shared variable named turn is used to keep track of whose turn it is to enter the critical section.\nINITIALIZATION:\n\n\tshared int turn;\n\t...\n\tturn = i ;\nENTRY PROTOCOL (for Process i ):\n\t/* wait until it&#39;s our turn */\n\twhile (turn != i ) {\n\t}\nEXIT PROTOCOL (for Process i ):\n\t/* pass the turn on */\n\tturn = j ;\n&#96;&#96;&#96;\n\n是课堂上讲的第一种尝试。满足忙则等待&#xff0c;但不满足空闲则入。两个进程必须交替执行&#xff0c;效率很低。\n\n## 方法二\n&#96;&#96;&#96;\nCONCEPT: A shared Boolean array named flags contains a flag for each process. The flag values are BUSY when the process is in its critical section (using the resource), or FREE when it is not.\nINITIALIZATION:\n\n\ttypedef char boolean;\n\t...\n\tshared boolean flags[n - 1];\n\t...\n\tflags[i ] = FREE;\n\t...\n\tflags[j ] = FREE;\n\t...\nENTRY PROTOCOL (for Process i ):\n\t/* wait while the other process is in its CS */\n\twhile (flags[j ] == BUSY) {\n\t}\n--&gt;\n\t/* claim the resource */\n\tflags[i ] = BUSY;\nEXIT PROTOCOL (for Process i ):\n\t/* release the resource */\n\tflags[i ] = FREE;\n&#96;&#96;&#96;\n同样是课堂上讨论过的&#xff0c;满足空闲则入&#xff0c;不满足忙则等待&#xff0c;反例如下所示\n (赖金霖 2016011377 https://git.tsinghua.edu.cn/laijl16/os-homeworks/blob/master/lec13/answer.md)\n&#96;&#96;&#96;\nENTRY PROTOCOL (for Process i ):\n\t/* wait while the other process is in its CS */\n\twhile (flags[j ] == BUSY) {\n\t}\n--&gt;\n                                    ENTRY PROTOCOL (for Process j ):\n                                        /* wait while the other process is in its CS */\n                                        while (flags[i ] == BUSY) {\n                                        }\n                                    --&gt;\n                                    \t/* claim the resource */\n\t/* claim the resource */\n\tflags[i ] = BUSY;\nEXIT PROTOCOL (for Process i ):\n\t/* release the resource */\n\tflags[i ] = FREE;\n                                        flags[i ] = BUSY;\n                                    EXIT PROTOCOL (for Process i ):\n                                        /* release the resource */\n                                        flags[i ] = FREE;\n\n&#96;&#96;&#96;\n## 方法三\n&#96;&#96;&#96;\nCONCEPT: Again we use a shared Boolean array as in Algorithm 2. Each process sets its flag before  testing the other flag, thus avoiding the problem of violating mutual exclusion.\nINITIALIZATION:\n\n\ttypedef char boolean;\n\t...\n\tshared boolean flags[n -1];\n\t...\n\tflags[i ] = FREE;\n\t...\n\tflags[j ] = FREE;\n\t...\nENTRY PROTOCOL (for Process i ):\n\t/* claim the resource */\n\tflags[i ] = BUSY;\n--&gt;\n\t/* wait if the other process is using the resource */\n\twhile (flags[j ] == BUSY) {\n\t}\nEXIT PROTOCOL (for Process i ):\n\t/* release the resource */\n\tflags[i ] = FREE;\n&#96;&#96;&#96;\n(陈昱霏 2017080067 https://git.tsinghua.edu.cn/chen-yf17/os-lecture13hw)\n在进程i把flag设为busy之后&#xff0c;这时有可能跳转进程到进程j&#xff0c;然后进程j把自己设为busy&#xff0c;然后发现进程i是busy&#xff0c;进入while循环&#xff0c;但是回到进程i&#xff0c;会发现flag[j]也是busy&#xff0c;那两个都在busy状态&#xff0c;就都进入不了临界区。这个方法可以满足忙则等待&#xff0c;但是不能满足空闲则入。\n\n## 方法四\n&#96;&#96;&#96;\nCONCEPT: To avoid the deadlock problem of Algorithm 3, we periodically clear and reset our own flag while waiting for the other one.\nINITIALIZATION:\n\n\ttypedef char boolean;\n\t...\n\tshared boolean flags[n -1];\n\t...\n\tflags[i ] = FREE;\n\t...\n\tflags[j ] = FREE;\n\t...\nENTRY PROTOCOL (for Process i ):\n\t/* claim the resource */\n\tflags[i ] = BUSY;\n--&gt;\n\t/* wait if the other process is using the resource */\n\twhile (flags[j ] == BUSY) {\n\t\tflags[i ] = FREE;\n\t\tdelay a while ;\n\t\tflags[i ] = BUSY;\n\t}\nEXIT PROTOCOL (for Process i ):\n\t/* release the resource */\n\tflags[i ] = FREE;\n&#96;&#96;&#96;\n满足忙则等待&#xff0c;但是在极端情况下不满足空闲则入。\n(https://piazza.com/class/i5j09fnsl7k5x0?cid=1060)\n比如这样一种情况&#xff0c;i和j都从代码第一行开始&#xff0c;i运行一行后切换到j运行&#xff0c;然后j也只运行一行就切换到i&#xff0c;以此方式执行下去&#xff0c;最终会导致两者都在while循环中永远出不去&#xff0c;具体执行为&#xff1a;flags[i] = FREE -&gt; flags[j] = FREE -&gt; i ENTRY -&gt; j ENTRY -&gt;flags[i] = BUSY -&gt; flags[j] = BUSY -&gt;i 进入while -&gt; j 进入 while -&gt;flags[i] = FREE -&gt; flags[j] = FREE -&gt; i delay a while -&gt; j delay a while -&gt;flags[i] = BUSY -&gt; flags[j] = BUSY -&gt;i 又进入while -&gt; j 又进入while......\n但是实际使用中几乎不会出现这种这种极端情况&#xff0c;所以可以认为该方法是可以使用的&#xff0c;但严格来说是错误的。\n## 方法五\n&#96;&#96;&#96;\n# CONCEPT: Both the turn variable and the status flags are combined in a way which we (the requesting process) set our flag and then check our neighbor&#39;s flag. \n\nINITIALIZATION:\n\n\ttypedef char boolean;\n\t...\n\tshared boolean flags[n -1];\n\tshared int turn;\n\t...\n\tturn = i ;\n\t...\n\tflags[i ] = FREE;\n\t...\n\tflags[j ] = FREE;\n\t...\nENTRY PROTOCOL (for Process i ):\n\t/* claim the resource */\n\tflags[i ] = BUSY;\n\n\t/* wait if the other process is using the resource */\n\twhile (flags[j ] == BUSY) {\n\n\t\t/* if waiting for the resource, also wait our turn */\n\t\tif (turn != i ) {\n\t\t\n\t\t\t/* but release the resource while waiting */\n\t\t\tflags[i ] = FREE;\n\t\t\twhile (turn != i ) {\n\t\t\t}\n\t\t\tflags[i ] = BUSY;\n\t\t}\n\n\t}\nEXIT PROTOCOL (for Process i ):\n\t/* pass the turn on, and release the resource */\n\tturn = j ;\n\tflags[i ] = FREE;\n&#96;&#96;&#96;\n正确。和第四种方法的不同在于&#xff0c;由于turn只能指向一个进程&#xff0c;这样两个进程不可能完全同步。\n如果两个进程发生竞争&#xff08;同时设置BUSY&#xff09;&#xff0c;不被turn指向的进程总会退出&#xff0c;而turn指向的进程则持续尝试进入&#xff0c;必然可以进入到临界区。\n\n## 方法六\n\n&#96;&#96;&#96;\nCONCEPT: Both the turn variable and the status flags are used.\n\nINITIALIZATION:\n\n\ttypedef char boolean;\n\t...\n\tshared boolean flags[n -1];\n\tshared int turn;\n\t...\n\tturn = i ;\n\t...\n\tflags[i ] = FREE;\n\t...\n\tflags[j ] = FREE;\n\t...\nENTRY PROTOCOL (for Process i ):\n\t/* claim the resource */\n\tflags[i ] = BUSY;\n\n\t/* give away the turn */\n\tturn = j ;\n\t/* wait while the other process is using the resource *and* has the turn */\n\twhile ((flags[j ] == BUSY) &amp;&amp; (turn != i )) {\n\t}\nEXIT PROTOCOL (for Process i ):\n\t/* release the resource */\n\tflags[i ] = FREE;\n&#96;&#96;&#96;\n&#xff08;郭诚 2016010563 https://git.tsinghua.edu.cn/c-guo16/os_practice&#xff09;\n正确。该同步机制既是peterson算法&#xff0c;能够满足同步互斥算法的要求。终点在于&#xff0c;进入区代码 turn = j 为对变量写入的操作&#xff0c;因此必定有先后顺序&#xff0c;在两进程发生冲突时&#xff0c;后写入的进程必定不满足之后while循环的要求&#xff0c;因此会忙等待。临界区空闲时&#xff0c;若有一进程到达临界区前&#xff0c;则必定不满足flags[j]==BUSY&#xff0c;可以进入临界区。\n\n## 方法七\n&#96;&#96;&#96;\n# CONCEPT: The turn variable and status flags are used as in Dekker&#39;s algorithm for the 2-process case. The flags now have three possible values: WAITING for a process in the entry protocol, waiting for the resource&#39; ACTIVE for a process in the critical section, using the resource; and IDLE for other cases.\n\nProcess priority is maintained in circular order beginning with the one holding the turn. Each process begins the entry protocol by scanning all processes from the one with the turn up to itself. These are the only processes that might have to go first if there is competition.\n\nIf the scan finds all processes idle, the process advances tentatively to the ACTIVE state. However, it is still possible that another process which started scanning later but belongs before us will also reach this state. We check one more time to be sure there are no active processes.\n\nINITIALIZATION:\n\n\tshared enum states {IDLE, WAITING, ACTIVE} flags[n -1];\n\tshared int turn;\n\tint index;\t/* not shared! */\n\t...\n\tturn = 0;\n\t...\n\tfor (index=0; index&lt;n; index&#43;&#43;) {\n\t\tflags[index] = IDLE;\n\t}\nENTRY PROTOCOL (for Process i ):\n\n\trepeat {\n\n\t\t/* announce that we need the resource */\n\t\tflags[i] = WAITING;\n\n\t\t/* scan processes from the one with the turn up to ourselves. */\n\t\t/* repeat if necessary until the scan finds all processes idle */\n\t\tindex = turn;\n\t\twhile (index != i) {\n\t\t\tif (flag[index] != IDLE) index = turn;\n\t\t\telse index = index&#43;1 mod n;\n\t\t}\n\n\t\t/* now tentatively claim the resource */\n\t\tflags[i] = ACTIVE;\n\n\t\t/* find the first active process besides ourselves, if any */\n\t\tindex = 0;\n\t\twhile ((index &lt; n) &amp;&amp; ((index == i) || (flags[index] != ACTIVE))) {\n\t\t\tindex = index&#43;1;\n\t\t}\n\n\t/* if there were no other active processes, AND if we have the turn\n\t   or else whoever has it is idle, then proceed.  Otherwise, repeat\n\t   the whole sequence. */\n\t} until ((index &gt;= n) &amp;&amp; ((turn == i) || (flags[turn] == IDLE)));\n\n\t/* claim the turn and proceed */\n\tturn = i;\nEXIT PROTOCOL (for Process i ):\n\n\t/* find a process which is not IDLE */\n\t/* (if there are no others, we will find ourselves) */\n\tindex = turn&#43;1 mod n;\n\twhile (flags[index] == IDLE) {\n\t\tindex = index&#43;1 mod n;\n\t}\n\n\t/* give the turn to someone that needs it, or keep it */\n\tturn = index;\n\n\t/* we&#39;re finished now */\n\tflag[i] = IDLE;\n&#96;&#96;&#96;\n这个方法是Eisenberg同步算法。正确。\n1.证明互斥进入\n  实际上循环2就已经实现了互斥进入&#xff0c;即只能有一个进程进入临界区&#xff0c;即只有第一个设置ACTIVE的才有可能进入临界区。\n  这里的第一个是指在写之前flags全不是ACTIVE&#xff0c;写后一个变为ACTIVE&#xff0c;如果有进程写了然后循环回去又改成了WAITING&#xff0c;则下一个第一个改ACTIVE的才有可能进入临界区。\n  因为先设置ACTIVE并还没有循环回去的进程会让其他进程数ACTIVE数目时都发现不只自己&#xff0c;这样就进不到临界区。\n  因此循环2保证了在临界区没有进程时最多一个进程可能进入临界区\n  然后&#xff0c;如果有一个进程进入了临界区&#xff0c;那么&#xff0c;该进程的flags必定为ACTIVE&#xff0c;继而阻止了其他所有进程在循环2中将index加到n&#xff0c;所以这时没有进程能再进去&#xff0c;除非临界区的进程退出临界区&#xff0c;改了自己的flags。\n综上&#xff0c;互斥进入得证。\n而空闲则入&#xff0c;仍采用上面的反证法&#xff0c;基本思路是&#xff0c;如果无限循环&#xff0c;那么能通过循环1的越来越少&#xff0c;由于进程数目有限&#xff0c;总会有减到1的时候&#xff0c;这时这个进程必定能进入临界区&#xff0c;与假设矛盾。\n\n## 方法八\n&#96;&#96;&#96;\nCONCEPT: Both status values and turn values are used. The status array is expanded to an integer value for each process, which is used to track that process&#39; progress in scanning the status of other processes. The turn value is also expanded to an integer array. Its values represent the relative ordering for each pair of processes.\n\n\nINITIALIZATION:\n\nshared int flags[NUMPROCS];\nshared int turn[NUMPROCS - 1];\nint index;\n\nfor (index = 0; index &lt; (NUMPROCS); index&#43;&#43;) {\n\n\tflags[index] = -1\n}\n\n\nfor (index = 0; index &lt; (NUMPROCS-1); index&#43;&#43;) {\n\tturn[index] = 0;\n}\n\nENTRY PROTOCOL (for Process i):\n/* repeat for all partners */\nfor (count = 0; count &lt; (NUMPROCS-1); count&#43;&#43;) {\n\n\tflags[i] = count;\n\tturn[count] = i;\n\n\t&#34;wait until (for all k != i, flag[k]&lt;count) or (turn[count] != i)&#34;\n\n}\n\nEXIT PROTOCOL (for Process i):\n/* tell everyone we are finished */\nflags[i] = -1;\n&#96;&#96;&#96;\n这个算法应该是正确的&#xff0c;戴臻旸助教指出&#xff0c;这个算法就是 peterson 原本给的 n-process.\nhttps://piazza.com/class/i5j09fnsl7k5x0?cid=1060 中给出的反例是不可构造的&#xff0c;turn中允许进程数量-1个进程等待&#xff0c;同时有一个进程在运行临界区代码&#xff0c;不会出现同时两个进程进入临界区。\n\n## 方法九\n&#96;&#96;&#96;\nCONCEPT: A process waiting to enter its critical section chooses a number. This number must be greater than all other numbers currently in use. There is a global shared array of current numbers for each process. The entering process checks all other processes sequentially, and waits for each one which has a lower number. Ties are possible; these are resolved using process IDs.\n\nINITIALIZATION:\n\n\ttypedef char boolean;\n\t...\n\tshared boolean choosing[n]\n\tshared int num[n];\n\t...\n\tfor (j=0; j &lt; n; j&#43;&#43;) {\n\t\tnum[j] = 0;\n\t}\n\t...\nENTRY PROTOCOL (for Process i):\n\t/* choose a number */\n\tchoosing[i] = TRUE;\n\tnum[i] = max(num[0], ..., num[n-1]) &#43; 1;\n\tchoosing[i] = FALSE;\n\t\n\t/* for all other processes */\n\tfor (j=0; j &lt; n; j&#43;&#43;) {\n\t\n\t\t/* wait if the process is currently choosing */\n\t\twhile (choosing[j]) {}\n\t\t\n\t\t/* wait if the process has a number and comes ahead of us */\n\t\tif ((num[j] &gt; 0) &amp;&amp;\n\t\t  ((num[j] &lt; num[i]) ||\n\t\t  (num[j] == num[i]) &amp;&amp; (j &lt; i))) {\n\t\t\twhile (num[j] &gt; 0) {}\n\t\t}\n\t}\n\t\t\nEXIT PROTOCOL (for Process i):\n\t/* clear our number */\n\tnum[i] = 0;\n&#96;&#96;&#96;\n正确。https://piazza.com/class/i5j09fnsl7k5x0?cid=1060 中有不错的描述。</md>"}, {"anon": "no", "uid": "jsjptolvvI0o", "subject": "2020春-第13讲课后习题展示", "created": "2020-04-11T08:58:09Z", "content": "<md>## 问题\n下面有9种基于软件的两线程同步方法实现&#xff0c;请选择并分析两种实现的正确性&#xff0c;并与已有的回答进行比较。对于正确的实现&#xff0c;描述你的枚举分类&#xff1b;对于错误的实现&#xff0c;给出一个反例。\n\n## 方法一\n&#96;&#96;&#96;\nCONCEPT: A shared variable named turn is used to keep track of whose turn it is to enter the critical section.\nINITIALIZATION:\n\n\tshared int turn;\n\t...\n\tturn = i ;\nENTRY PROTOCOL (for Process i ):\n\t/* wait until it&#39;s our turn */\n\twhile (turn != i ) {\n\t}\nEXIT PROTOCOL (for Process i ):\n\t/* pass the turn on */\n\tturn = j ;\n&#96;&#96;&#96;\n\n是课堂上讲的第一种尝试。满足忙则等待&#xff0c;但不满足空闲则入。两个进程必须交替执行&#xff0c;效率很低。\n\n## 方法二\n&#96;&#96;&#96;\nCONCEPT: A shared Boolean array named flags contains a flag for each process. The flag values are BUSY when the process is in its critical section (using the resource), or FREE when it is not.\nINITIALIZATION:\n\n\ttypedef char boolean;\n\t...\n\tshared boolean flags[n - 1];\n\t...\n\tflags[i ] = FREE;\n\t...\n\tflags[j ] = FREE;\n\t...\nENTRY PROTOCOL (for Process i ):\n\t/* wait while the other process is in its CS */\n\twhile (flags[j ] == BUSY) {\n\t}\n--&gt;\n\t/* claim the resource */\n\tflags[i ] = BUSY;\nEXIT PROTOCOL (for Process i ):\n\t/* release the resource */\n\tflags[i ] = FREE;\n&#96;&#96;&#96;\n同样是课堂上讨论过的&#xff0c;满足空闲则入&#xff0c;不满足忙则等待&#xff0c;反例如下所示\n (赖金霖 2016011377 https://git.tsinghua.edu.cn/laijl16/os-homeworks/blob/master/lec13/answer.md)\n&#96;&#96;&#96;\nENTRY PROTOCOL (for Process i ):\n\t/* wait while the other process is in its CS */\n\twhile (flags[j ] == BUSY) {\n\t}\n--&gt;\n                                    ENTRY PROTOCOL (for Process j ):\n                                        /* wait while the other process is in its CS */\n                                        while (flags[i ] == BUSY) {\n                                        }\n                                    --&gt;\n                                    \t/* claim the resource */\n\t/* claim the resource */\n\tflags[i ] = BUSY;\nEXIT PROTOCOL (for Process i ):\n\t/* release the resource */\n\tflags[i ] = FREE;\n                                        flags[i ] = BUSY;\n                                    EXIT PROTOCOL (for Process i ):\n                                        /* release the resource */\n                                        flags[i ] = FREE;\n\n&#96;&#96;&#96;\n## 方法三\n&#96;&#96;&#96;\nCONCEPT: Again we use a shared Boolean array as in Algorithm 2. Each process sets its flag before  testing the other flag, thus avoiding the problem of violating mutual exclusion.\nINITIALIZATION:\n\n\ttypedef char boolean;\n\t...\n\tshared boolean flags[n -1];\n\t...\n\tflags[i ] = FREE;\n\t...\n\tflags[j ] = FREE;\n\t...\nENTRY PROTOCOL (for Process i ):\n\t/* claim the resource */\n\tflags[i ] = BUSY;\n--&gt;\n\t/* wait if the other process is using the resource */\n\twhile (flags[j ] == BUSY) {\n\t}\nEXIT PROTOCOL (for Process i ):\n\t/* release the resource */\n\tflags[i ] = FREE;\n&#96;&#96;&#96;\n(陈昱霏 2017080067 https://git.tsinghua.edu.cn/chen-yf17/os-lecture13hw)\n在进程i把flag设为busy之后&#xff0c;这时有可能跳转进程到进程j&#xff0c;然后进程j把自己设为busy&#xff0c;然后发现进程i是busy&#xff0c;进入while循环&#xff0c;但是回到进程i&#xff0c;会发现flag[j]也是busy&#xff0c;那两个都在busy状态&#xff0c;就都进入不了临界区。这个方法可以满足忙则等待&#xff0c;但是不能满足空闲则入。\n\n## 方法四\n&#96;&#96;&#96;\nCONCEPT: To avoid the deadlock problem of Algorithm 3, we periodically clear and reset our own flag while waiting for the other one.\nINITIALIZATION:\n\n\ttypedef char boolean;\n\t...\n\tshared boolean flags[n -1];\n\t...\n\tflags[i ] = FREE;\n\t...\n\tflags[j ] = FREE;\n\t...\nENTRY PROTOCOL (for Process i ):\n\t/* claim the resource */\n\tflags[i ] = BUSY;\n--&gt;\n\t/* wait if the other process is using the resource */\n\twhile (flags[j ] == BUSY) {\n\t\tflags[i ] = FREE;\n\t\tdelay a while ;\n\t\tflags[i ] = BUSY;\n\t}\nEXIT PROTOCOL (for Process i ):\n\t/* release the resource */\n\tflags[i ] = FREE;\n&#96;&#96;&#96;\n满足忙则等待&#xff0c;但是在极端情况下不满足空闲则入。\n(https://piazza.com/class/i5j09fnsl7k5x0?cid=1060)\n比如这样一种情况&#xff0c;i和j都从代码第一行开始&#xff0c;i运行一行后切换到j运行&#xff0c;然后j也只运行一行就切换到i&#xff0c;以此方式执行下去&#xff0c;最终会导致两者都在while循环中永远出不去&#xff0c;具体执行为&#xff1a;flags[i] = FREE -&gt; flags[j] = FREE -&gt; i ENTRY -&gt; j ENTRY -&gt;flags[i] = BUSY -&gt; flags[j] = BUSY -&gt;i 进入while -&gt; j 进入 while -&gt;flags[i] = FREE -&gt; flags[j] = FREE -&gt; i delay a while -&gt; j delay a while -&gt;flags[i] = BUSY -&gt; flags[j] = BUSY -&gt;i 又进入while -&gt; j 又进入while......\n但是实际使用中几乎不会出现这种这种极端情况&#xff0c;所以可以认为该方法是可以使用的&#xff0c;但严格来说是错误的。\n## 方法五\n&#96;&#96;&#96;\nCONCEPT: Both the turn variable and the status flags are combined in a way which we (the requesting process) set our flag and then check our neighbor&#39;s flag. \n\nINITIALIZATION:\n\n\ttypedef char boolean;\n\t...\n\tshared boolean flags[n -1];\n\tshared int turn;\n\t...\n\tturn = i ;\n\t...\n\tflags[i ] = FREE;\n\t...\n\tflags[j ] = FREE;\n\t...\nENTRY PROTOCOL (for Process i ):\n\t/* claim the resource */\n\tflags[i ] = BUSY;\n\n\t/* wait if the other process is using the resource */\n\twhile (flags[j ] == BUSY) {\n\n\t\t/* if waiting for the resource, also wait our turn */\n\t\tif (turn != i ) {\n\t\t\n\t\t\t/* but release the resource while waiting */\n\t\t\tflags[i ] = FREE;\n\t\t\twhile (turn != i ) {\n\t\t\t}\n\t\t\tflags[i ] = BUSY;\n\t\t}\n\n\t}\nEXIT PROTOCOL (for Process i ):\n\t/* pass the turn on, and release the resource */\n\tturn = j ;\n\tflags[i ] = FREE;\n&#96;&#96;&#96;\n正确。和第四种方法的不同在于&#xff0c;由于turn只能指向一个进程&#xff0c;这样两个进程不可能完全同步。\n如果两个进程发生竞争&#xff08;同时设置BUSY&#xff09;&#xff0c;不被turn指向的进程总会退出&#xff0c;而turn指向的进程则持续尝试进入&#xff0c;必然可以进入到临界区。\n\n## 方法六\n\n&#96;&#96;&#96;\nCONCEPT: Both the turn variable and the status flags are used.\n\nINITIALIZATION:\n\n\ttypedef char boolean;\n\t...\n\tshared boolean flags[n -1];\n\tshared int turn;\n\t...\n\tturn = i ;\n\t...\n\tflags[i ] = FREE;\n\t...\n\tflags[j ] = FREE;\n\t...\nENTRY PROTOCOL (for Process i ):\n\t/* claim the resource */\n\tflags[i ] = BUSY;\n\n\t/* give away the turn */\n\tturn = j ;\n\t/* wait while the other process is using the resource *and* has the turn */\n\twhile ((flags[j ] == BUSY) &amp;&amp; (turn != i )) {\n\t}\nEXIT PROTOCOL (for Process i ):\n\t/* release the resource */\n\tflags[i ] = FREE;\n&#96;&#96;&#96;\n&#xff08;郭诚 2016010563 https://git.tsinghua.edu.cn/c-guo16/os_practice&#xff09;\n正确。该同步机制既是peterson算法&#xff0c;能够满足同步互斥算法的要求。终点在于&#xff0c;进入区代码 turn = j 为对变量写入的操作&#xff0c;因此必定有先后顺序&#xff0c;在两进程发生冲突时&#xff0c;后写入的进程必定不满足之后while循环的要求&#xff0c;因此会忙等待。临界区空闲时&#xff0c;若有一进程到达临界区前&#xff0c;则必定不满足flags[j]==BUSY&#xff0c;可以进入临界区。\n\n## 方法七\n&#96;&#96;&#96;\nCONCEPT: The turn variable and status flags are used as in Dekker&#39;s algorithm for the 2-process case. The flags now have three possible values: WAITING for a process in the entry protocol, waiting for the resource&#39; ACTIVE for a process in the critical section, using the resource; and IDLE for other cases.\n\nProcess priority is maintained in circular order beginning with the one holding the turn. Each process begins the entry protocol by scanning all processes from the one with the turn up to itself. These are the only processes that might have to go first if there is competition.\n\nIf the scan finds all processes idle, the process advances tentatively to the ACTIVE state. However, it is still possible that another process which started scanning later but belongs before us will also reach this state. We check one more time to be sure there are no active processes.\n\nINITIALIZATION:\n\n\tshared enum states {IDLE, WAITING, ACTIVE} flags[n -1];\n\tshared int turn;\n\tint index;\t/* not shared! */\n\t...\n\tturn = 0;\n\t...\n\tfor (index=0; index&lt;n; index&#43;&#43;) {\n\t\tflags[index] = IDLE;\n\t}\nENTRY PROTOCOL (for Process i ):\n\n\trepeat {\n\n\t\t/* announce that we need the resource */\n\t\tflags[i] = WAITING;\n\n\t\t/* scan processes from the one with the turn up to ourselves. */\n\t\t/* repeat if necessary until the scan finds all processes idle */\n\t\tindex = turn;\n\t\twhile (index != i) {\n\t\t\tif (flag[index] != IDLE) index = turn;\n\t\t\telse index = index&#43;1 mod n;\n\t\t}\n\n\t\t/* now tentatively claim the resource */\n\t\tflags[i] = ACTIVE;\n\n\t\t/* find the first active process besides ourselves, if any */\n\t\tindex = 0;\n\t\twhile ((index &lt; n) &amp;&amp; ((index == i) || (flags[index] != ACTIVE))) {\n\t\t\tindex = index&#43;1;\n\t\t}\n\n\t/* if there were no other active processes, AND if we have the turn\n\t   or else whoever has it is idle, then proceed.  Otherwise, repeat\n\t   the whole sequence. */\n\t} until ((index &gt;= n) &amp;&amp; ((turn == i) || (flags[turn] == IDLE)));\n\n\t/* claim the turn and proceed */\n\tturn = i;\nEXIT PROTOCOL (for Process i ):\n\n\t/* find a process which is not IDLE */\n\t/* (if there are no others, we will find ourselves) */\n\tindex = turn&#43;1 mod n;\n\twhile (flags[index] == IDLE) {\n\t\tindex = index&#43;1 mod n;\n\t}\n\n\t/* give the turn to someone that needs it, or keep it */\n\tturn = index;\n\n\t/* we&#39;re finished now */\n\tflag[i] = IDLE;\n&#96;&#96;&#96;\n这个方法是Eisenberg同步算法。正确。\n1.证明互斥进入\n  实际上循环2就已经实现了互斥进入&#xff0c;即只能有一个进程进入临界区&#xff0c;即只有第一个设置ACTIVE的才有可能进入临界区。\n  这里的第一个是指在写之前flags全不是ACTIVE&#xff0c;写后一个变为ACTIVE&#xff0c;如果有进程写了然后循环回去又改成了WAITING&#xff0c;则下一个第一个改ACTIVE的才有可能进入临界区。\n  因为先设置ACTIVE并还没有循环回去的进程会让其他进程数ACTIVE数目时都发现不只自己&#xff0c;这样就进不到临界区。\n  因此循环2保证了在临界区没有进程时最多一个进程可能进入临界区\n  然后&#xff0c;如果有一个进程进入了临界区&#xff0c;那么&#xff0c;该进程的flags必定为ACTIVE&#xff0c;继而阻止了其他所有进程在循环2中将index加到n&#xff0c;所以这时没有进程能再进去&#xff0c;除非临界区的进程退出临界区&#xff0c;改了自己的flags。\n综上&#xff0c;互斥进入得证。\n而空闲则入&#xff0c;仍采用上面的反证法&#xff0c;基本思路是&#xff0c;如果无限循环&#xff0c;那么能通过循环1的越来越少&#xff0c;由于进程数目有限&#xff0c;总会有减到1的时候&#xff0c;这时这个进程必定能进入临界区&#xff0c;与假设矛盾。\n\n## 方法八\n&#96;&#96;&#96;\nCONCEPT: Both status values and turn values are used. The status array is expanded to an integer value for each process, which is used to track that process&#39; progress in scanning the status of other processes. The turn value is also expanded to an integer array. Its values represent the relative ordering for each pair of processes.\n\n\nINITIALIZATION:\n\nshared int flags[NUMPROCS];\nshared int turn[NUMPROCS - 1];\nint index;\n\nfor (index = 0; index &lt; (NUMPROCS); index&#43;&#43;) {\n\n\tflags[index] = -1\n}\n\n\nfor (index = 0; index &lt; (NUMPROCS-1); index&#43;&#43;) {\n\tturn[index] = 0;\n}\n\nENTRY PROTOCOL (for Process i):\n/* repeat for all partners */\nfor (count = 0; count &lt; (NUMPROCS-1); count&#43;&#43;) {\n\n\tflags[i] = count;\n\tturn[count] = i;\n\n\t&#34;wait until (for all k != i, flag[k]&lt;count) or (turn[count] != i)&#34;\n\n}\n\nEXIT PROTOCOL (for Process i):\n/* tell everyone we are finished */\nflags[i] = -1;\n&#96;&#96;&#96;\n这个算法应该是正确的&#xff0c;戴臻旸助教指出&#xff0c;这个算法就是 peterson 原本给的 n-process.\nhttps://piazza.com/class/i5j09fnsl7k5x0?cid=1060 中给出的反例是不可构造的&#xff0c;turn中允许进程数量-1个进程等待&#xff0c;同时有一个进程在运行临界区代码&#xff0c;不会出现同时两个进程进入临界区。\n\n## 方法九\n&#96;&#96;&#96;\nCONCEPT: A process waiting to enter its critical section chooses a number. This number must be greater than all other numbers currently in use. There is a global shared array of current numbers for each process. The entering process checks all other processes sequentially, and waits for each one which has a lower number. Ties are possible; these are resolved using process IDs.\n\nINITIALIZATION:\n\n\ttypedef char boolean;\n\t...\n\tshared boolean choosing[n]\n\tshared int num[n];\n\t...\n\tfor (j=0; j &lt; n; j&#43;&#43;) {\n\t\tnum[j] = 0;\n\t}\n\t...\nENTRY PROTOCOL (for Process i):\n\t/* choose a number */\n\tchoosing[i] = TRUE;\n\tnum[i] = max(num[0], ..., num[n-1]) &#43; 1;\n\tchoosing[i] = FALSE;\n\t\n\t/* for all other processes */\n\tfor (j=0; j &lt; n; j&#43;&#43;) {\n\t\n\t\t/* wait if the process is currently choosing */\n\t\twhile (choosing[j]) {}\n\t\t\n\t\t/* wait if the process has a number and comes ahead of us */\n\t\tif ((num[j] &gt; 0) &amp;&amp;\n\t\t  ((num[j] &lt; num[i]) ||\n\t\t  (num[j] == num[i]) &amp;&amp; (j &lt; i))) {\n\t\t\twhile (num[j] &gt; 0) {}\n\t\t}\n\t}\n\t\t\nEXIT PROTOCOL (for Process i):\n\t/* clear our number */\n\tnum[i] = 0;\n&#96;&#96;&#96;\n正确。https://piazza.com/class/i5j09fnsl7k5x0?cid=1060 中有不错的描述。</md>"}, {"anon": "no", "uid": "jsjptolvvI0o", "subject": "2020春-第13讲课后习题展示", "created": "2020-04-11T08:57:26Z", "content": "<md>## 问题\n下面有9种基于软件的两线程同步方法实现&#xff0c;请选择并分析两种实现的正确性&#xff0c;并与已有的回答进行比较。对于正确的实现&#xff0c;描述你的枚举分类&#xff1b;对于错误的实现&#xff0c;给出一个反例。\n\n## 方法一\n&#96;&#96;&#96;\nCONCEPT: A shared variable named turn is used to keep track of whose turn it is to enter the critical section.\nINITIALIZATION:\n\n\tshared int turn;\n\t...\n\tturn = i ;\nENTRY PROTOCOL (for Process i ):\n\t/* wait until it&#39;s our turn */\n\twhile (turn != i ) {\n\t}\nEXIT PROTOCOL (for Process i ):\n\t/* pass the turn on */\n\tturn = j ;\n&#96;&#96;&#96;\n\n是课堂上讲的第一种尝试。满足忙则等待&#xff0c;但不满足空闲则入。两个进程必须交替执行&#xff0c;效率很低。\n\n## 方法二\n&#96;&#96;&#96;\nCONCEPT: A shared Boolean array named flags contains a flag for each process. The flag values are BUSY when the process is in its critical section (using the resource), or FREE when it is not.\nINITIALIZATION:\n\n\ttypedef char boolean;\n\t...\n\tshared boolean flags[n - 1];\n\t...\n\tflags[i ] = FREE;\n\t...\n\tflags[j ] = FREE;\n\t...\nENTRY PROTOCOL (for Process i ):\n\t/* wait while the other process is in its CS */\n\twhile (flags[j ] == BUSY) {\n\t}\n--&gt;\n\t/* claim the resource */\n\tflags[i ] = BUSY;\nEXIT PROTOCOL (for Process i ):\n\t/* release the resource */\n\tflags[i ] = FREE;\n&#96;&#96;&#96;\n同样是课堂上讨论过的&#xff0c;满足空闲则入&#xff0c;不满足忙则等待&#xff0c;反例如下所示\n (赖金霖 2016011377 https://git.tsinghua.edu.cn/laijl16/os-homeworks/blob/master/lec13/answer.md)\n&#96;&#96;&#96;\nENTRY PROTOCOL (for Process i ):\n\t/* wait while the other process is in its CS */\n\twhile (flags[j ] == BUSY) {\n\t}\n--&gt;\n                                    ENTRY PROTOCOL (for Process j ):\n                                        /* wait while the other process is in its CS */\n                                        while (flags[i ] == BUSY) {\n                                        }\n                                    --&gt;\n                                    \t/* claim the resource */\n\t/* claim the resource */\n\tflags[i ] = BUSY;\nEXIT PROTOCOL (for Process i ):\n\t/* release the resource */\n\tflags[i ] = FREE;\n                                        flags[i ] = BUSY;\n                                    EXIT PROTOCOL (for Process i ):\n                                        /* release the resource */\n                                        flags[i ] = FREE;\n\n&#96;&#96;&#96;\n## 方法三\n&#96;&#96;&#96;\nCONCEPT: Again we use a shared Boolean array as in Algorithm 2. Each process sets its flag before  testing the other flag, thus avoiding the problem of violating mutual exclusion.\nINITIALIZATION:\n\n\ttypedef char boolean;\n\t...\n\tshared boolean flags[n -1];\n\t...\n\tflags[i ] = FREE;\n\t...\n\tflags[j ] = FREE;\n\t...\nENTRY PROTOCOL (for Process i ):\n\t/* claim the resource */\n\tflags[i ] = BUSY;\n--&gt;\n\t/* wait if the other process is using the resource */\n\twhile (flags[j ] == BUSY) {\n\t}\nEXIT PROTOCOL (for Process i ):\n\t/* release the resource */\n\tflags[i ] = FREE;\n&#96;&#96;&#96;\n(陈昱霏 2017080067 https://git.tsinghua.edu.cn/chen-yf17/os-lecture13hw)\n在进程i把flag设为busy之后&#xff0c;这时有可能跳转进程到进程j&#xff0c;然后进程j把自己设为busy&#xff0c;然后发现进程i是busy&#xff0c;进入while循环&#xff0c;但是回到进程i&#xff0c;会发现flag[j]也是busy&#xff0c;那两个都在busy状态&#xff0c;就都进入不了临界区。这个方法可以满足忙则等待&#xff0c;但是不能满足空闲则入。\n\n## 方法四\n&#96;&#96;&#96;\nCONCEPT: To avoid the deadlock problem of Algorithm 3, we periodically clear and reset our own flag while waiting for the other one.\nINITIALIZATION:\n\n\ttypedef char boolean;\n\t...\n\tshared boolean flags[n -1];\n\t...\n\tflags[i ] = FREE;\n\t...\n\tflags[j ] = FREE;\n\t...\nENTRY PROTOCOL (for Process i ):\n\t/* claim the resource */\n\tflags[i ] = BUSY;\n--&gt;\n\t/* wait if the other process is using the resource */\n\twhile (flags[j ] == BUSY) {\n\t\tflags[i ] = FREE;\n\t\tdelay a while ;\n\t\tflags[i ] = BUSY;\n\t}\nEXIT PROTOCOL (for Process i ):\n\t/* release the resource */\n\tflags[i ] = FREE;\n&#96;&#96;&#96;\n满足忙则等待&#xff0c;但是在极端情况下不满足空闲则入。\n(https://piazza.com/class/i5j09fnsl7k5x0?cid=1060)\n比如这样一种情况&#xff0c;i和j都从代码第一行开始&#xff0c;i运行一行后切换到j运行&#xff0c;然后j也只运行一行就切换到i&#xff0c;以此方式执行下去&#xff0c;最终会导致两者都在while循环中永远出不去&#xff0c;具体执行为&#xff1a;flags[i] = FREE -&gt; flags[j] = FREE -&gt; i ENTRY -&gt; j ENTRY -&gt;flags[i] = BUSY -&gt; flags[j] = BUSY -&gt;i 进入while -&gt; j 进入 while -&gt;flags[i] = FREE -&gt; flags[j] = FREE -&gt; i delay a while -&gt; j delay a while -&gt;flags[i] = BUSY -&gt; flags[j] = BUSY -&gt;i 又进入while -&gt; j 又进入while......\n但是实际使用中几乎不会出现这种这种极端情况&#xff0c;所以可以认为该方法是可以使用的&#xff0c;但严格来说是错误的。\n## 方法五\n&#96;&#96;&#96;\nCONCEPT: Both the turn variable and the status flags are combined in a way which we (the requesting process) set our flag and then check our neighbor&#39;s flag. \n\nINITIALIZATION:\n\n\ttypedef char boolean;\n\t...\n\tshared boolean flags[n -1];\n\tshared int turn;\n\t...\n\tturn = i ;\n\t...\n\tflags[i ] = FREE;\n\t...\n\tflags[j ] = FREE;\n\t...\nENTRY PROTOCOL (for Process i ):\n\t/* claim the resource */\n\tflags[i ] = BUSY;\n\n\t/* wait if the other process is using the resource */\n\twhile (flags[j ] == BUSY) {\n\n\t\t/* if waiting for the resource, also wait our turn */\n\t\tif (turn != i ) {\n\t\t\n\t\t\t/* but release the resource while waiting */\n\t\t\tflags[i ] = FREE;\n\t\t\twhile (turn != i ) {\n\t\t\t}\n\t\t\tflags[i ] = BUSY;\n\t\t}\n\n\t}\nEXIT PROTOCOL (for Process i ):\n\t/* pass the turn on, and release the resource */\n\tturn = j ;\n\tflags[i ] = FREE;\n&#96;&#96;&#96;\n正确。和第四种方法的不同在于&#xff0c;由于turn只能指向一个进程&#xff0c;这样两个进程不可能完全同步。\n如果两个进程发生竞争&#xff08;同时设置BUSY&#xff09;&#xff0c;不被turn指向的进程总会退出&#xff0c;而turn指向的进程则持续尝试进入&#xff0c;必然可以进入到临界区。\n\n## 方法六\n\n&#96;&#96;&#96;\nCONCEPT: Both the turn variable and the status flags are used.\n\nINITIALIZATION:\n\n\ttypedef char boolean;\n\t...\n\tshared boolean flags[n -1];\n\tshared int turn;\n\t...\n\tturn = i ;\n\t...\n\tflags[i ] = FREE;\n\t...\n\tflags[j ] = FREE;\n\t...\nENTRY PROTOCOL (for Process i ):\n\t/* claim the resource */\n\tflags[i ] = BUSY;\n\n\t/* give away the turn */\n\tturn = j ;\n\t/* wait while the other process is using the resource *and* has the turn */\n\twhile ((flags[j ] == BUSY) &amp;&amp; (turn != i )) {\n\t}\nEXIT PROTOCOL (for Process i ):\n\t/* release the resource */\n\tflags[i ] = FREE;\n&#96;&#96;&#96;\n&#xff08;郭诚 2016010563 https://git.tsinghua.edu.cn/c-guo16/os_practice&#xff09;\n正确。该同步机制既是peterson算法&#xff0c;能够满足同步互斥算法的要求。终点在于&#xff0c;进入区代码 turn = j 为对变量写入的操作&#xff0c;因此必定有先后顺序&#xff0c;在两进程发生冲突时&#xff0c;后写入的进程必定不满足之后while循环的要求&#xff0c;因此会忙等待。临界区空闲时&#xff0c;若有一进程到达临界区前&#xff0c;则必定不满足flags[j]==BUSY&#xff0c;可以进入临界区。\n\n## 方法七\n&#96;&#96;&#96;\nCONCEPT: The turn variable and status flags are used as in Dekker&#39;s algorithm for the 2-process case. The flags now have three possible values: WAITING for a process in the entry protocol, waiting for the resource&#39; ACTIVE for a process in the critical section, using the resource; and IDLE for other cases.\n\nProcess priority is maintained in circular order beginning with the one holding the turn. Each process begins the entry protocol by scanning all processes from the one with the turn up to itself. These are the only processes that might have to go first if there is competition.\n\nIf the scan finds all processes idle, the process advances tentatively to the ACTIVE state. However, it is still possible that another process which started scanning later but belongs before us will also reach this state. We check one more time to be sure there are no active processes.\n\nINITIALIZATION:\n\n\tshared enum states {IDLE, WAITING, ACTIVE} flags[n -1];\n\tshared int turn;\n\tint index;\t/* not shared! */\n\t...\n\tturn = 0;\n\t...\n\tfor (index=0; index&lt;n; index&#43;&#43;) {\n\t\tflags[index] = IDLE;\n\t}\nENTRY PROTOCOL (for Process i ):\n\n\trepeat {\n\n\t\t/* announce that we need the resource */\n\t\tflags[i] = WAITING;\n\n\t\t/* scan processes from the one with the turn up to ourselves. */\n\t\t/* repeat if necessary until the scan finds all processes idle */\n\t\tindex = turn;\n\t\twhile (index != i) {\n\t\t\tif (flag[index] != IDLE) index = turn;\n\t\t\telse index = index&#43;1 mod n;\n\t\t}\n\n\t\t/* now tentatively claim the resource */\n\t\tflags[i] = ACTIVE;\n\n\t\t/* find the first active process besides ourselves, if any */\n\t\tindex = 0;\n\t\twhile ((index &lt; n) &amp;&amp; ((index == i) || (flags[index] != ACTIVE))) {\n\t\t\tindex = index&#43;1;\n\t\t}\n\n\t/* if there were no other active processes, AND if we have the turn\n\t   or else whoever has it is idle, then proceed.  Otherwise, repeat\n\t   the whole sequence. */\n\t} until ((index &gt;= n) &amp;&amp; ((turn == i) || (flags[turn] == IDLE)));\n\n\t/* claim the turn and proceed */\n\tturn = i;\nEXIT PROTOCOL (for Process i ):\n\n\t/* find a process which is not IDLE */\n\t/* (if there are no others, we will find ourselves) */\n\tindex = turn&#43;1 mod n;\n\twhile (flags[index] == IDLE) {\n\t\tindex = index&#43;1 mod n;\n\t}\n\n\t/* give the turn to someone that needs it, or keep it */\n\tturn = index;\n\n\t/* we&#39;re finished now */\n\tflag[i] = IDLE;\n&#96;&#96;&#96;\n这个方法是Eisenberg同步算法。正确。\n1.证明互斥进入\n  实际上循环2就已经实现了互斥进入&#xff0c;即只能有一个进程进入临界区&#xff0c;即只有第一个设置ACTIVE的才有可能进入临界区。\n  这里的第一个是指在写之前flags全不是ACTIVE&#xff0c;写后一个变为ACTIVE&#xff0c;如果有进程写了然后循环回去又改成了WAITING&#xff0c;则下一个第一个改ACTIVE的才有可能进入临界区。\n  因为先设置ACTIVE并还没有循环回去的进程会让其他进程数ACTIVE数目时都发现不只自己&#xff0c;这样就进不到临界区。\n  因此循环2保证了在临界区没有进程时最多一个进程可能进入临界区\n  然后&#xff0c;如果有一个进程进入了临界区&#xff0c;那么&#xff0c;该进程的flags必定为ACTIVE&#xff0c;继而阻止了其他所有进程在循环2中将index加到n&#xff0c;所以这时没有进程能再进去&#xff0c;除非临界区的进程退出临界区&#xff0c;改了自己的flags。\n综上&#xff0c;互斥进入得证。\n而空闲则入&#xff0c;仍采用上面的反证法&#xff0c;基本思路是&#xff0c;如果无限循环&#xff0c;那么能通过循环1的越来越少&#xff0c;由于进程数目有限&#xff0c;总会有减到1的时候&#xff0c;这时这个进程必定能进入临界区&#xff0c;与假设矛盾。\n\n## 方法八\n&#96;&#96;&#96;\nCONCEPT: Both status values and turn values are used. The status array is expanded to an integer value for each process, which is used to track that process&#39; progress in scanning the status of other processes. The turn value is also expanded to an integer array. Its values represent the relative ordering for each pair of processes.\n\n\nINITIALIZATION:\n\nshared int flags[NUMPROCS];\nshared int turn[NUMPROCS - 1];\nint index;\n\nfor (index = 0; index &lt; (NUMPROCS); index&#43;&#43;) {\n\n\tflags[index] = -1\n}\n\n\nfor (index = 0; index &lt; (NUMPROCS-1); index&#43;&#43;) {\n\tturn[index] = 0;\n}\n\nENTRY PROTOCOL (for Process i):\n/* repeat for all partners */\nfor (count = 0; count &lt; (NUMPROCS-1); count&#43;&#43;) {\n\n\tflags[i] = count;\n\tturn[count] = i;\n\n\t&#34;wait until (for all k != i, flag[k]&lt;count) or (turn[count] != i)&#34;\n\n}\n\nEXIT PROTOCOL (for Process i):\n/* tell everyone we are finished */\nflags[i] = -1;\n&#96;&#96;&#96;\n这个算法应该是正确的&#xff0c;戴臻旸助教指出&#xff0c;这个算法就是 peterson 原本给的 n-process.\nhttps://piazza.com/class/i5j09fnsl7k5x0?cid=1060 中给出的反例是不可构造的&#xff0c;turn中允许进程数量-1个进程等待&#xff0c;同时有一个进程在运行临界区代码&#xff0c;不会出现同时两个进程进入临界区。\n\n## 方法九\n&#96;&#96;&#96;\nCONCEPT: A process waiting to enter its critical section chooses a number. This number must be greater than all other numbers currently in use. There is a global shared array of current numbers for each process. The entering process checks all other processes sequentially, and waits for each one which has a lower number. Ties are possible; these are resolved using process IDs.\n\nINITIALIZATION:\n\n\ttypedef char boolean;\n\t...\n\tshared boolean choosing[n]\n\tshared int num[n];\n\t...\n\tfor (j=0; j &lt; n; j&#43;&#43;) {\n\t\tnum[j] = 0;\n\t}\n\t...\nENTRY PROTOCOL (for Process i):\n\t/* choose a number */\n\tchoosing[i] = TRUE;\n\tnum[i] = max(num[0], ..., num[n-1]) &#43; 1;\n\tchoosing[i] = FALSE;\n\t\n\t/* for all other processes */\n\tfor (j=0; j &lt; n; j&#43;&#43;) {\n\t\n\t\t/* wait if the process is currently choosing */\n\t\twhile (choosing[j]) {}\n\t\t\n\t\t/* wait if the process has a number and comes ahead of us */\n\t\tif ((num[j] &gt; 0) &amp;&amp;\n\t\t  ((num[j] &lt; num[i]) ||\n\t\t  (num[j] == num[i]) &amp;&amp; (j &lt; i))) {\n\t\t\twhile (num[j] &gt; 0) {}\n\t\t}\n\t}\n\t\t\nEXIT PROTOCOL (for Process i):\n\t/* clear our number */\n\tnum[i] = 0;\n&#96;&#96;&#96;\n正确。https://piazza.com/class/i5j09fnsl7k5x0?cid=1060 中有不错的描述。</md>"}], "type": "note", "tags": ["lecture13", "student"], "tag_good": [], "unique_views": 97, "children": [], "tag_good_arr": [], "id": "k8vdypeyc446uh", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 1, "num_favorites": 0, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643170072120, "default_anonymity": "no"}, "error": null, "aid": "kyv11a2goet6h4"}