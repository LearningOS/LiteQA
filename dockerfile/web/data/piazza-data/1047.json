{"result": {"folders": ["2017", "lecture14", "课堂问答"], "nr": 1047, "data": {"embed_links": []}, "created": "2017-04-14T05:50:17Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "hdjonbiyfs62ie", "data": "j1hezyfltch3qp", "type": "create", "when": "2017-04-14T05:50:17Z"}, {"anon": "no", "uid": "ie7xy5sipx51qz", "to": "j1hezyfjhqa3qo", "type": "followup", "when": "2017-04-14T06:49:38Z"}, {"anon": "no", "uid": "isvxeq6bspf1vn", "to": "j1hezyfjhqa3qo", "type": "followup", "when": "2018-04-20T07:08:25Z"}, {"anon": "no", "uid": "isvxeq6bspf1vn", "to": "j1hezyfjhqa3qo", "type": "feedback", "when": "2018-04-23T13:24:22Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "2017春季-第十四讲课堂实践练习(3)", "created": "2017-04-14T05:50:17Z", "content": "<p>请两人一组完成“第十四讲 实验五 用户进程管理”中指定小题的回答在此贴中回复&#xff0c;每组同学选做一个题目。<br /> <br />题目&#xff1a;<br /><a href=\"https://chyyuu.gitbooks.io/os_course_exercises/content/all/05-4-lab5-spoc-discussion.html\">https://chyyuu.gitbooks.io/os_course_exercises/content/all/05-4-lab5-spoc-discussion.html</a></p>\n<p></p>\n<p>视频相关思考题 -&gt; 14.4 执行ELF格式的二进制代码-load_icode的实现 -&gt; 第2小题</p>\n<p></p>\n<p>分析第一个用户进程的创建流程&#xff0c;说明进程切换后执行的第一条是什么。</p>"}], "type": "note", "tags": ["2017", "instructor-note", "lecture14", "课堂问答"], "tag_good": [], "unique_views": 154, "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>陈雅正&#xff0c;2014011423</p>\n<p>高童&#xff0c;2014011357</p>\n<p></p>\n<p>首先&#xff0c;通过系统调用进入<code>do_execve()</code>执行。<br />在进入<code>do_execve()<br /></code>中&#xff0c;在经过初始内容后&#xff0c;程序首先会把新进程的mm抹去。随后通过<br /><code>load_icode(binary, size)</code>函数&#xff0c;开始将ELF格式程序拷贝进内存。<br /><br /><code>load_icode(binary, size)</code>实现比较复杂。但在最后<code>trapframe</code>的设置中&#xff0c;将各个段寄存器设置成正确的值&#xff0c;包括用户代码段、用户栈以及<code>eip</code>&#xff0c;其中<code>eip</code>指向<code>elf-&gt;entry</code>。随后一路return&#xff0c;即可在最后通过<code>trapframe</code>设置返回<code>elf-&gt;entry</code>执行。</p>", "created": "2017-04-14T06:49:38Z", "bucket_order": 154, "bucket_name": "Week 4/9 - 4/15", "type": "followup", "tag_good": [], "uid": "ie7xy5sipx51qz", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "j1hh4a4v3id3j6", "updated": "2017-04-14T06:49:38Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>魏钧宇 2015011263</p>", "created": "2018-04-20T07:08:25Z", "bucket_order": 101, "bucket_name": "Week 4/15 - 4/21", "type": "followup", "tag_good": [], "uid": "isvxeq6bspf1vn", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>操作系统加载第一个用户进程的过程&#xff1a;</p>\n<p></p>\n<p>1. 创建Idle内核线程&#xff08;同Lab 4的过程 可参见我的回答 https://piazza.com/class/i5j09fnsl7k5x0?cid=1039&#xff09;</p>\n<p></p>\n<p>2. 由Idle内核线程创建Init线程并实现切换&#xff08;同Lab 4的过程&#xff0c;可参见我的回答 <a href=\"https://www.piazza.com/class/i5j09fnsl7k5x0?cid=1040\">https://piazza.com/class/i5j09fnsl7k5x0?cid=1040</a>&#xff09;</p>\n<p></p>\n<p>3. init线程创建第三个内核线程user_proc</p>\n<p></p>\n<p>Init会从init_main的地方开始执行&#xff0c;在Lab 5中init_main对应的部分相关代码如下</p>\n<p></p>\n<pre>static int init_main(void *arg) {<br />    int pid = kernel_thread(user_main, NULL, 0); //在这里创建了第三个内核线程user_proc<br />    if (pid &lt;= 0) {<br />        panic(&#34;create user_main failed.\\n&#34;);<br />    }<br /><br />    while (do_wait(0, NULL) == 0) {<br />        schedule(); //从这里调度执行user_proc<br />    }<br />}</pre>\n<p>可见init_proc会创建第三个内核线程user_proc&#xff0c;这个线程会从user_main的位置开始执行&#xff0c;user_main的代码如下&#xff1a;</p>\n<pre>static int user_main(void *arg) {\n#ifdef TEST\n    KERNEL_EXECVE2(TEST, TESTSTART, TESTSIZE);\n#else\n    KERNEL_EXECVE(exit);\n#endif\n    panic(&#34;user_main execve failed.\\n&#34;);\n}</pre>\n<p>在正常情况下&#xff08;非测试情况&#xff09;会使用宏KERNEL_EXECVE加载第一个用户进程&#xff08;这里的exit是用户进程的名字&#xff09;</p>\n<p></p>\n<p>4. user_proc 使用KERNEL_EXECVE装载用户进程并执行&#xff1a;</p>\n<p>我们首先来看宏KERNEL_EXECVE的结构&#xff1a;</p>\n<pre>#define KERNEL_EXECVE(x) ({                                             \\\n            extern unsigned char _binary_obj___user_##x##_out_start[],  \\\n                _binary_obj___user_##x##_out_size[];                    \\\n            __KERNEL_EXECVE(#x, _binary_obj___user_##x##_out_start,     \\\n                            _binary_obj___user_##x##_out_size);         \\\n        })</pre>\n<p>这里的 _binary_obj___user_##x##_out_start 和 _binary_obj___user_##x##_out_size 是bootloader在加载内核镜像的过程中同时加载进来的第一个用户进程的二进制代码的启始地址&#xff08;内核虚地址&#xff09;和大小。宏定义__KRNEL_EXECVE如下&#xff1a;</p>\n<pre>#define __KERNEL_EXECVE(name, binary, size) ({                          \\\n            cprintf(&#34;kernel_execve: pid = %d, name = \\&#34;%s\\&#34;.\\n&#34;,        \\\n                    current-&gt;pid, name);                                \\\n            kernel_execve(name, binary, (size_t)(size));                \\\n        })</pre>\n<p>可以看到这里将从kernel_execve处开始执行&#xff0c;主要有三个参数&#xff1a;</p>\n<ol><li>name&#xff1a;即将执行的用户进程</li><li>binary&#xff1a;用户程序的二进制代码起始地址&#xff08;内核虚地址&#xff09;</li><li>size&#xff1a;用户程序的二进制代码的大小</li></ol>\n<p></p>\n<p></p>\n<p>5. kernel_execve通过系统调用的方式创建用户进程&#xff1a;</p>\n<p>函数kernel_execve如下&#xff1a;</p>\n<pre>static int kernel_execve(const char *name, unsigned char *binary, size_t size) {\n    int ret, len = strlen(name);\n    asm volatile (\n        &#34;int %1;&#34;\n        : &#34;=a&#34; (ret)\n        : &#34;i&#34; (T_SYSCALL), &#34;0&#34; (SYS_exec), &#34;d&#34; (name), &#34;c&#34; (len), &#34;b&#34; (binary), &#34;D&#34; (size)\n        : &#34;memory&#34;);\n    return ret;\n}</pre>\n<p>我们看到kernel_execve通过内联汇编 int SYS_exec的形式进行了系统调用&#xff0c;同时传入了四个参数&#xff1a;</p>\n<ol><li>name&#xff1a;即将执行的用户进程名</li><li>len&#xff1a;用户进程名的长度</li><li>binary&#xff1a;用户程序的二进制代码起始地址</li><li>size&#xff1a;用户程序的二进制代码的大小</li></ol>\n<p></p>\n<p></p>\n<p>6. 系统调用将由do_execve函数响应&#xff1a;</p>\n<p>系统调用将会引发中断&#xff0c;该中断将从vectors.S处开始处理&#xff0c;然后跳转到all_traps然后跳转到trap再跳到trap_dispatch&#xff08;这个过程和中断一样&#xff0c;我们在这里不再详细讨论&#xff09;</p>\n<p>在trap_dispatch中会将系统调用分发到如下的分支上执行&#xff1a;</p>\n<pre>    case T_SYSCALL:\n        syscall();\n        break;</pre>\n<p>可见所有的系统调用将跳转到syscall()的位置执行</p>\n<p>而syscall()在syscall/syscall.c中&#xff0c;代码如下&#xff1a;</p>\n<pre>void syscall(void) {\n    struct trapframe *tf = current-&gt;tf;\n    uint32_t arg[5];\n    int num = tf-&gt;tf_regs.reg_eax; //获取具体的系统调用号\n    if (num &gt;= 0 &amp;&amp; num &lt; NUM_SYSCALLS) {\n        if (syscalls[num] != NULL) {\n            arg[0] = tf-&gt;tf_regs.reg_edx; //传递一系列参数\n            arg[1] = tf-&gt;tf_regs.reg_ecx;\n            arg[2] = tf-&gt;tf_regs.reg_ebx;\n            arg[3] = tf-&gt;tf_regs.reg_edi;\n            arg[4] = tf-&gt;tf_regs.reg_esi;\n            tf-&gt;tf_regs.reg_eax = syscalls[num](arg); //到syscalls数组对应的系统调用例程处开始执行\n            return ;\n        }\n    }\n    print_trapframe(tf);\n    panic(&#34;undefined syscall %d, pid = %d, name = %s.\\n&#34;,\n            num, current-&gt;pid, current-&gt;name);\n}</pre>\n<p>在当前的例子中&#xff0c;将到syscalls[SYS_exec]处执行&#xff0c;这个位置对应的函数入口是sys_exec&#xff0c;下面是sys_exec的代码</p>\n<pre>static int\nsys_exec(uint32_t arg[]) {\n    const char *name = (const char *)arg[0]; //参数传递\n    size_t len = (size_t)arg[1];\n    unsigned char *binary = (unsigned char *)arg[2];\n    size_t size = (size_t)arg[3];\n    return do_execve(name, len, binary, size); //调用do_execve\n}</pre>\n<p>sys_exec将调用do_execve</p>\n<p></p>\n<p>7. do_execve清除了旧的mm结构&#xff0c;调用load_icode拷贝新的mm结构</p>\n<p>do_execve对应的代码如下&#xff1a;</p>\n<pre>int do_execve(const char *name, size_t len, unsigned char *binary, size_t size) {\n    <br />    struct mm_struct *mm = current-&gt;mm; //使得mm指向将当前线程的mm结构体&#xff08;这里是user_proc的mm为NULL)\n    <br />    char local_name[PROC_NAME_LEN &#43; 1]; memcpy(local_name, name, len); //拷贝进程名\n\n    if (mm != NULL) { //对于第一个用户进程来说不存在删除原来进程的mm空间的情况&#xff0c;但是在一般情况下需要将原来的mm结构破坏\n        lcr3(boot_cr3);\n        if (mm_count_dec(mm) == 0) {//将对应mm的引用数目减1&#xff0c;如果结果为0&#xff0c;说明该mm已经无用&#xff0c;则可直接将其destroy<br />\texit_mmap(mm); //解除原来的映射关系<br />\tput_pgdir(mm); //释放页表空间<br />\tmm_destroy(mm); //将mm结构destroy<br />\t}<br />\tcurrent-&gt;mm = NULL;\n    }<br />\n    int ret;\n    if ((ret = load_icode(binary, size)) != 0) { //调用load_icode将新进程的内存装载到mm中\n        goto execve_exit;\n    }\n    set_proc_name(current, local_name); //设置新的进程名\n    return 0;\n\n}</pre>\n<p></p>\n<p>8. load_icode将新的内容装载到mm中&#xff1a;</p>\n<p>load_icode是一个规模非常庞大的函数&#xff0c;我们将在这里将其剖分开&#xff0c;细细分析其中的每一条语句的作用和含义&#xff1a;</p>\n<p>load_icode的主要功能有下面几个&#xff1a;</p>\n<p>&#xff08;1&#xff09;拷贝内核页表</p>\n<p>&#xff08;2&#xff09;读ELF格式的文件</p>\n<p>&#xff08;3&#xff09;建立用户态的虚拟空间</p>\n<p>&#xff08;4&#xff09;设置用户进程的初始运行环境</p>\n<p>下面我们分别讨论上述的四个方面</p>\n<p></p>\n<p>step 1 拷贝内核页表</p>\n<pre>    struct mm_struct *mm;\n    if ((mm = mm_create()) == NULL) { //新建mm结构\n        goto bad_mm;\n    }\n    if (setup_pgdir(mm) != 0) { //使用setup_pgdir拷贝内核页表\n        goto bad_pgdir_cleanup_mm;\n    }</pre>\n<p>setup_pgdir的实现如下&#xff1a;</p>\n<pre>static int setup_pgdir(struct mm_struct *mm) {\n    struct Page *page; \n    if ((page = alloc_page()) == NULL) { //分配一个新页面用于拷贝页目录表\n        return -E_NO_MEM;\n    }\n    pde_t *pgdir = page2kva(page); //得到新分配页面的内核虚地址\n    memcpy(pgdir, boot_pgdir, PGSIZE); //将内核页表的内容拷贝到新分配的页表上\n    pgdir[PDX(VPT)] = PADDR(pgdir) | PTE_P | PTE_W; //设置自映射关系\n    mm-&gt;pgdir = pgdir; //将当前的页目录设置为mm结构中的页目录\n    return 0;\n}</pre>\n<p>在完成这一步以后&#xff0c;这个用户进程就能够像内核线程一样去访问内核空间&#xff0c;同时这也就解释了为什么不同的用户进程在进行特权切换时&#xff08;如中断&#xff09;&#xff0c;能够找到同样的内核代码了&#xff0c;因为在内核虚空间的部分所有的用户进程的页表都是一样的&#xff08;都拷贝自内核页表boot_pgdir&#xff09;</p>\n<p></p>\n<p>step2 读ELF格式的文件</p>\n<pre>struct elfhdr *elf = (struct elfhdr *)binary; //elf中保存了二进制elf格式文件的起始地址<br />struct proghdr *ph = (struct proghdr *)(binary &#43; elf-&gt;e_phoff); //ph中保存了elf格式文件中程序头数组的地址\nif (elf-&gt;e_magic != ELF_MAGIC) { //验证elf格式文件的合法性\n\tret = -E_INVAL_ELF;\n        goto bad_elf_cleanup_pgdir;<br />}\n    <br />uint32_t vm_flags, perm;<br />struct proghdr *ph_end = ph &#43; elf-&gt;e_phnum; //从ph到ph_end逐个遍历elf格式文件的程序块<br />\nfor (; ph &lt; ph_end; ph &#43;&#43;) {\n        <br />\t//根据每一个程序块头部记录的权限和读写信息设置对应的vma的权限和可读写信息<br />\tvm_flags = 0, perm = PTE_U; \n        if (ph-&gt;p_flags &amp; ELF_PF_X) vm_flags |= VM_EXEC;\n        if (ph-&gt;p_flags &amp; ELF_PF_W) vm_flags |= VM_WRITE;\n        if (ph-&gt;p_flags &amp; ELF_PF_R) vm_flags |= VM_READ;\n        if (vm_flags &amp; VM_WRITE) perm |= PTE_W;\n\t<br />\t//mm_map 能够建立从p_va(程序块的内存虚拟首地址开始的p_memsz&#xff08;程序块大小&#xff09;的vma结构\t\n        if ((ret = mm_map(mm, ph-&gt;p_va, ph-&gt;p_memsz, vm_flags, NULL)) != 0) { \n            goto bad_cleanup_mmap;\n        }\n        <br />\t//这一段就是将原来在文件中的代码段信息拷贝到内存中&#xff0c;分配相应的物理页面&#xff0c;并进行映射&#xff08;中间涉及到很多如何实现页面对齐的细节问题&#xff0c;在这里就不再赘述了&#xff09;<br />\tunsigned char *from = binary &#43; ph-&gt;p_offset;\n        size_t off, size;\n        uintptr_t start = ph-&gt;p_va, end, la = ROUNDDOWN(start, PGSIZE);\n        ret = -E_NO_MEM;\n        end = ph-&gt;p_va &#43; ph-&gt;p_filesz;\n        while (start &lt; end) {\n            if ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == NULL) {\n                goto bad_cleanup_mmap;\n            }\n            off = start - la, size = PGSIZE - off, la &#43;= PGSIZE;\n            if (end &lt; la) {\n                size -= la - end;\n            }\n            memcpy(page2kva(page) &#43; off, from, size);\n            start &#43;= size, from &#43;= size;\n        }\n\t<br />\t//这一段就是为elf的程序块分配并映射需要的bss段/数据段\n        end = ph-&gt;p_va &#43; ph-&gt;p_memsz;\n        if (start &lt; la) {\n            /* ph-&gt;p_memsz == ph-&gt;p_filesz */\n            if (start == end) {\n                continue ;\n            }\n            off = start &#43; PGSIZE - la, size = PGSIZE - off;\n            if (end &lt; la) {\n                size -= la - end;\n            }\n            memset(page2kva(page) &#43; off, 0, size);\n            start &#43;= size;\n            assert((end &lt; la &amp;&amp; start == end) || (end &gt;= la &amp;&amp; start == la));\n        }\n        while (start &lt; end) {\n            if ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == NULL) {\n                goto bad_cleanup_mmap;\n            }\n            off = start - la, size = PGSIZE - off, la &#43;= PGSIZE;\n            if (end &lt; la) {\n                size -= la - end;\n            }\n            memset(page2kva(page) &#43; off, 0, size);\n            start &#43;= size;\n        }\n    }</pre>\n<p></p>\n<p>step 3设置用户内存信息&#xff1a;</p>\n<p></p>\n<p>在完成了elf格式的可执行文件拷贝之后&#xff0c;开始分配用户的堆栈信息</p>\n<pre>    vm_flags = VM_READ | VM_WRITE | VM_STACK;\n    if ((ret = mm_map(mm, USTACKTOP - USTACKSIZE, USTACKSIZE, vm_flags, NULL)) != 0) { //首先分配用户堆栈结构对应的vma\n        goto bad_cleanup_mmap;\n    }<br />    <br />    //为用户堆栈预先分配四个物理页并设置映射\n    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-PGSIZE , PTE_USER) != NULL);\n    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-2*PGSIZE , PTE_USER) != NULL);\n    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-3*PGSIZE , PTE_USER) != NULL);\n    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-4*PGSIZE , PTE_USER) != NULL);</pre>\n<p>分配好用户堆栈以后&#xff0c;接下来需要设置用户页表和存储信息&#xff1a;</p>\n<pre>    mm_count_inc(mm);\n    current-&gt;mm = mm; //正式让当前进程的mm指针指向刚</pre>", "created": "2018-04-23T13:24:22Z", "bucket_order": 100, "bucket_name": "Week 4/22 - 4/28", "type": "feedback", "tag_good": [], "uid": "isvxeq6bspf1vn", "children": [], "tag_good_arr": [], "id": "jgc9wije9f1480", "updated": "2018-04-23T13:24:22Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "jg7m5gyahprnh", "updated": "2018-04-20T07:08:25Z", "config": {}}], "tag_good_arr": [], "id": "j1hezyfjhqa3qo", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 3, "num_favorites": 0, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169030467, "default_anonymity": "no"}, "error": null, "aid": "kyv0eybnlwi4yt"}