{"result": {"folders": ["lab1"], "nr": 1003, "data": {"embed_links": []}, "created": "2017-03-10T08:12:02Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "ie7xy5f0l9b1qi", "data": "j03jnfib82h10", "type": "create", "when": "2017-03-10T08:12:02Z"}, {"anon": "no", "uid": "ie7xy5f0l9b1qi", "data": "j03joe1rf7m7j8", "type": "update", "when": "2017-03-10T08:12:47Z"}, {"anon": "no", "uid": "ie7xy5f0l9b1qi", "data": "j03jtggksw35f9", "type": "update", "when": "2017-03-10T08:16:43Z"}, {"anon": "no", "uid": "ie7xy5f0l9b1qi", "data": "j04ltuf28k2co", "type": "update", "when": "2017-03-11T02:00:46Z"}, {"anon": "no", "uid": "ie7xy53vpn41q7", "data": "j04vkwd9fda7hl", "to": "j03jnfi9ertz", "type": "s_answer", "when": "2017-03-11T06:33:45Z"}, {"anon": "no", "uid": "k1z7c5yedn72kq", "to": "j03jnfi9ertz", "type": "followup", "when": "2019-12-20T06:26:07Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "ie7xy5f0l9b1qi", "subject": "关于Lab1 Challenge的几个小问题", "created": "2017-03-11T02:00:46Z", "content": "<p>老师&#xff0c;助教&#xff0c;同学们好&#xff0c;我对Lab1的Challenge有一些不懂的地方:</p>\n<p>在Lab1的Challenge2中要求:</p>\n<p>用键盘实现用户模式内核模式切换。具体目标是&#xff1a;“键盘输入3时切换到用户模式&#xff0c;键盘输入0时切换到内核模式”。</p>\n<p>答案(github branch lab1-X)的实现为:</p>\n<pre>     case IRQ_OFFSET &#43; IRQ_KBD:<br />         c = cons_getc();<br />         cprintf(&#34;kbd [%03d] %c\\n&#34;, c, c);<br /> <br />         /*********************/<br />         //Hardware Interrupt is different with software trap, so no need use temp stack<br />         if ( c ==&#39;3&#39;){<br />             tf-&gt;tf_eflags |= 0x3000;<br />             if (tf-&gt;tf_cs != USER_CS) {<br /> <br />                 tf-&gt;tf_cs = USER_CS;<br />                 tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS;<br />                 tf-&gt;tf_eflags |= FL_IOPL_MASK;<br />         }<br />         print_trapframe(tf);<br />       }</pre>\n<p></p>\n<p>按照我的理解,在内核态时触发键盘中断&#xff0c;此时是从内核态转换为内核态&#xff0c;故栈中不会先压入ss和esp。此时通过修改栈帧再iret的方法进行状态切换&#xff0c;</p>\n<p>直接修改tf-&gt;tf_ss为USER_DS&#xff0c;会不会有越过当前栈帧的问题&#xff1f;因为此时栈帧中并没有ss这一项。答案中强调了硬中断和软中断的不同所以处理方式不同&#xff0c;这个不同是什么呢&#xff1f;</p>\n<p></p>\n<p>另外&#xff0c;我猜想在Challenge1的答案中可能会有点小问题:<br />(1)在内核态转换到用户态时: </p>\n<pre>case T_SWITCH_TOU:<br />         tf-&gt;tf_eflags |= 0x3000;<br />         if (tf-&gt;tf_cs != USER_CS) {<br />             switchk2u = *tf;<br />             switchk2u.tf_cs = USER_CS;<br />             switchk2u.tf_ds = switchk2u.tf_es = switchk2u.tf_ss = USER_DS;<br />             switchk2u.tf_esp = (uint32_t)tf &#43; sizeof(struct trapframe) - 8;<br /> <br />             // set eflags, make sure ucore can use io under user mode.<br />             // if CPL &gt; IOPL, then cpu will generate a general protection.<br />             switchk2u.tf_eflags |= FL_IOPL_MASK;<br /> <br />             // set temporary stack<br />             // then iret will jump to the right stack<br />             *((uint32_t *)tf - 1) = (uint32_t)&amp;switchk2u;<br /><br /></pre>\n<p><br />switchk2u.tf_esp = (uint32_t)tf &#43; sizeof(struct trapframe) - 8;我觉得这里不应该加上-8&#xff0c;在init.c中</p>\n<p></p>\n<pre><br />static void lab1_switch_to_user(void) {<br /> //LAB1 CHALLENGE 1 : TODO<br />     asm volatile (<br />         &#34;sub $0x8, %%esp \\n&#34;<br />         &#34;int %0 \\n&#34;<br />         &#34;movl %%ebp, %%esp&#34; //can cancel<br />        : \n         : &#34;i&#34;(T_SWITCH_TOU)\n     );\n}</pre>\n<p><br />已经提前把esp减了8再调用软中断&#xff0c;此时再到上面的case中处理时&#xff0c;新建栈帧的esp若要指向上一个栈帧的结尾&#xff0c;值应为(uint32_t)tf &#43; sizeof(struct trapframe)。<br />经测试&#xff0c;若去掉这个-8&#xff0c;可在lab1_switch_to_user中去掉&#34;movl %%ebp, %%esp&#34;&#xff0c;此时仍正常运行&#xff0c;因为iret时esp已修正为正确值。</p>\n<p></p>\n<p>(2)在用户态转化到内核态时:</p>\n<p></p>\n<pre>     case T_SWITCH_TOK:<br />         if (tf-&gt;tf_cs != KERNEL_CS) {<br />             tf-&gt;tf_cs = KERNEL_CS;<br />             tf-&gt;tf_ds = tf-&gt;tf_es = KERNEL_DS;<br />             tf-&gt;tf_eflags &amp;= ~FL_IOPL_MASK;<br />             switchu2k = (struct trapframe *)(tf-&gt;tf_esp - (sizeof(struct trapframe) - 8));<br />             memmove(switchu2k, tf, sizeof(struct trapframe) - 8);<br />             *((uint32_t *)tf - 1) = (uint32_t)switchu2k;<br />         }<br />     break;<br /><br /></pre>\n<p>if{}中的后三句似乎没有存在的必要诶&#xff0c;直接改当前tf好像就可以了?</p>\n<p>我的理解可能有些浅薄&#xff0c;希望老师同学一起讨论一下&#xff0c;谢谢&#xff01;</p>\n<p></p>\n<p></p>\n<p></p>"}, {"anon": "no", "uid": "ie7xy5f0l9b1qi", "subject": "关于Lab1 Challenge的几个小问题", "created": "2017-03-10T08:16:43Z", "content": "<p>老师&#xff0c;助教&#xff0c;同学们好&#xff0c;我对Lab1的Challenge有一些不懂的地方:</p>\n<p>在Lab1的Challenge2中要求:</p>\n<p>用键盘实现用户模式内核模式切换。具体目标是&#xff1a;“键盘输入3时切换到用户模式&#xff0c;键盘输入0时切换到内核模式”。</p>\n<p>答案(github branch lab1-X)的实现为:<br />&#96;&#96;&#96;<br />     case IRQ_OFFSET &#43; IRQ_KBD:<br />         c = cons_getc();<br />         cprintf(&#34;kbd [%03d] %c\\n&#34;, c, c);<br /> <br />         /*********************/<br />         //Hardware Interrupt is different with software trap, so no need use temp stack<br />         if ( c ==&#39;3&#39;){<br />             tf-&gt;tf_eflags |= 0x3000;<br />             if (tf-&gt;tf_cs != USER_CS) {<br /> <br />                 tf-&gt;tf_cs = USER_CS;<br />                 tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS;<br />                 tf-&gt;tf_eflags |= FL_IOPL_MASK;<br />         }<br />         print_trapframe(tf);</p>\n<p>    }<br /> ......<br />&#96;&#96;&#96;</p>\n<p>按照我的理解,在内核态时触发键盘中断&#xff0c;此时是从内核态转换为内核态&#xff0c;故栈中不会先压入ss和esp。此时通过修改栈帧再iret的方法进行状态切换&#xff0c;<br />直接修改tf-&gt;tf_ss为USER_DS&#xff0c;会不会有越过当前栈帧的问题&#xff1f;因为此时栈帧中并没有ss这一项。答案中强调了硬中断和软中断的不同所以处理方式不同&#xff0c;这个不同是什么呢&#xff1f;</p>\n<p></p>\n<p>另外&#xff0c;我猜想在Challenge1的答案中可能会有点小问题:<br />(1)在内核态转换到用户态时:<br />&#96;&#96;&#96;<br />     case T_SWITCH_TOU:<br />         tf-&gt;tf_eflags |= 0x3000;<br />         if (tf-&gt;tf_cs != USER_CS) {<br />             switchk2u = *tf;<br />             switchk2u.tf_cs = USER_CS;<br />             switchk2u.tf_ds = switchk2u.tf_es = switchk2u.tf_ss = USER_DS;<br />             switchk2u.tf_esp = (uint32_t)tf &#43; sizeof(struct trapframe) - 8;<br /> <br />             // set eflags, make sure ucore can use io under user mode.<br />             // if CPL &gt; IOPL, then cpu will generate a general protection.<br />             switchk2u.tf_eflags |= FL_IOPL_MASK;<br /> <br />             // set temporary stack<br />             // then iret will jump to the right stack<br />             *((uint32_t *)tf - 1) = (uint32_t)&amp;switchk2u;<br />&#96;&#96;&#96;</p>\n<p><br />switchk2u.tf_esp = (uint32_t)tf &#43; sizeof(struct trapframe) - 8;我觉得这里不应该加上-8&#xff0c;在init.c中</p>\n<p></p>\n<p>&#96;&#96;&#96;<br />static void lab1_switch_to_user(void) {<br /> //LAB1 CHALLENGE 1 : TODO<br />     asm volatile (<br />         &#34;sub $0x8, %%esp \\n&#34;<br />         &#34;int %0 \\n&#34;<br />         &#34;movl %%ebp, %%esp&#34; //can cancel</p>\n<p>        : <br />         : &#34;i&#34;(T_SWITCH_TOU)<br />     );<br />}<br />&#96;&#96;&#96;</p>\n<p><br />已经提前把esp减了8再调用软中断&#xff0c;此时再到上面的case中处理时&#xff0c;新建栈帧的esp若要指向上一个栈帧的结尾&#xff0c;值应为(uint32_t)tf &#43; sizeof(struct trapframe)。<br />经测试&#xff0c;若去掉这个-8&#xff0c;可在lab1_switch_to_user中去掉&#34;movl %%ebp, %%esp&#34;&#xff0c;此时仍正常运行&#xff0c;因为iret时esp已修正为正确值。</p>\n<p></p>\n<p>(2)在用户态转化到内核态时:<br />&#96;&#96;&#96;<br />     case T_SWITCH_TOK:<br />         if (tf-&gt;tf_cs != KERNEL_CS) {<br />             tf-&gt;tf_cs = KERNEL_CS;<br />             tf-&gt;tf_ds = tf-&gt;tf_es = KERNEL_DS;<br />             tf-&gt;tf_eflags &amp;= ~FL_IOPL_MASK;<br />             switchu2k = (struct trapframe *)(tf-&gt;tf_esp - (sizeof(struct trapframe) - 8));<br />             memmove(switchu2k, tf, sizeof(struct trapframe) - 8);<br />             *((uint32_t *)tf - 1) = (uint32_t)switchu2k;<br />         }<br />     break;<br />&#96;&#96;&#96;</p>\n<p>if{}中的后三句似乎没有存在的必要诶&#xff0c;直接改当前tf好像就可以了?</p>\n<p>我的理解可能有些浅薄&#xff0c;希望老师同学一起讨论一下&#xff0c;谢谢&#xff01;</p>\n<p></p>"}, {"anon": "no", "uid": "ie7xy5f0l9b1qi", "subject": "关于Lab1 Challenge的几个小问题", "created": "2017-03-10T08:12:47Z", "content": "<p>老师&#xff0c;助教&#xff0c;同学们好&#xff0c;我对Lab1的Challenge有一些不懂的地方:</p>\n<p>在Lab1的Challenge2中要求:</p>\n<p>用键盘实现用户模式内核模式切换。具体目标是&#xff1a;“键盘输入3时切换到用户模式&#xff0c;键盘输入0时切换到内核模式”。</p>\n<p>答案(github branch lab1-X)的实现为:<br />&#96;&#96;&#96;<br /> case IRQ_OFFSET &#43; IRQ_KBD:<br /> c = cons_getc();<br /> cprintf(&#34;kbd [%03d] %c\\n&#34;, c, c);<br /> <br /> /*********************/<br /> //Hardware Interrupt is different with software trap, so no need use temp stack<br /> if ( c ==&#39;3&#39;){<br /> tf-&gt;tf_eflags |= 0x3000;<br /> if (tf-&gt;tf_cs != USER_CS) {<br /> <br /> tf-&gt;tf_cs = USER_CS;<br /> tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS;<br /> tf-&gt;tf_eflags |= FL_IOPL_MASK;<br /> }<br /> print_trapframe(tf);</p>\n<p>}<br /> ......<br />&#96;&#96;&#96;</p>\n<p>按照我的理解,在内核态时触发键盘中断&#xff0c;此时是从内核态转换为内核态&#xff0c;故栈中不会先压入ss和esp。此时通过修改栈帧再iret的方法进行状态切换&#xff0c;<br />直接修改tf-&gt;tf_ss为USER_DS&#xff0c;会不会有越过当前栈帧的问题&#xff1f;因为此时栈帧中并没有ss这一项。答案中强调了硬中断和软中断的不同所以处理方式不同&#xff0c;<br />这个不同是什么呢&#xff1f;</p>\n<p>另外&#xff0c;我猜想在Challenge1的答案中可能会有点小问题:<br />(1)在内核态转换到用户态时:<br />&#96;&#96;&#96;<br /> case T_SWITCH_TOU:<br /> tf-&gt;tf_eflags |= 0x3000;<br /> if (tf-&gt;tf_cs != USER_CS) {<br /> switchk2u = *tf;<br /> switchk2u.tf_cs = USER_CS;<br /> switchk2u.tf_ds = switchk2u.tf_es = switchk2u.tf_ss = USER_DS;<br /> switchk2u.tf_esp = (uint32_t)tf &#43; sizeof(struct trapframe) - 8;<br /> <br /> // set eflags, make sure ucore can use io under user mode.<br /> // if CPL &gt; IOPL, then cpu will generate a general protection.<br /> switchk2u.tf_eflags |= FL_IOPL_MASK;<br /> <br /> // set temporary stack<br /> // then iret will jump to the right stack<br /> *((uint32_t *)tf - 1) = (uint32_t)&amp;switchk2u;<br />&#96;&#96;&#96;<br />switchk2u.tf_esp = (uint32_t)tf &#43; sizeof(struct trapframe) - 8;我觉得这里不应该加上-8&#xff0c;在init.c中<br />&#96;&#96;&#96;<br />static void<br />lab1_switch_to_user(void) {<br /> //LAB1 CHALLENGE 1 : TODO<br /> asm volatile (<br /> &#34;sub $0x8, %%esp \\n&#34;<br /> &#34;int %0 \\n&#34;<br /> &#34;movl %%ebp, %%esp&#34; //can cancel<br /> : <br /> : &#34;i&#34;(T_SWITCH_TOU)<br /> );<br />}<br />&#96;&#96;&#96;<br />已经提前把esp减了8再调用软中断&#xff0c;此时再到上面的case中处理时&#xff0c;新建栈帧的esp若要指向上一个栈帧的结尾&#xff0c;值应为(uint32_t)tf &#43; sizeof(struct trapframe)。<br />经测试&#xff0c;若去掉这个-8&#xff0c;可在lab1_switch_to_user中去掉&#34;movl %%ebp, %%esp&#34;&#xff0c;此时仍正常运行&#xff0c;因为iret时esp已修正为正确值。</p>\n<p>(2)在用户态转化到内核态时:<br />&#96;&#96;&#96;<br /> case T_SWITCH_TOK:<br /> if (tf-&gt;tf_cs != KERNEL_CS) {<br /> tf-&gt;tf_cs = KERNEL_CS;<br /> tf-&gt;tf_ds = tf-&gt;tf_es = KERNEL_DS;<br /> tf-&gt;tf_eflags &amp;= ~FL_IOPL_MASK;<br /> switchu2k = (struct trapframe *)(tf-&gt;tf_esp - (sizeof(struct trapframe) - 8));<br /> memmove(switchu2k, tf, sizeof(struct trapframe) - 8);<br /> *((uint32_t *)tf - 1) = (uint32_t)switchu2k;<br /> }<br /> break;<br />&#96;&#96;&#96;</p>\n<p>if{}中的后三句似乎没有存在的必要诶&#xff0c;直接改当前tf好像就可以了?</p>\n<p>我的理解可能有些浅薄&#xff0c;希望老师同学一起讨论一下&#xff0c;谢谢&#xff01;</p>\n<p></p>"}, {"anon": "no", "uid": "ie7xy5f0l9b1qi", "subject": "关于Lab1 Challenge的几个小问题", "created": "2017-03-10T08:12:02Z", "content": "<p>老师&#xff0c;助教你们好&#xff0c;我对Lab1的Challenge有一些不懂的地方:</p>\n<p>在Lab1的Challenge2中要求:</p>\n<p>用键盘实现用户模式内核模式切换。具体目标是&#xff1a;“键盘输入3时切换到用户模式&#xff0c;键盘输入0时切换到内核模式”。</p>\n<p>答案(github branch lab1-X)的实现为:<br />&#96;&#96;&#96;<br /> case IRQ_OFFSET &#43; IRQ_KBD:<br /> c = cons_getc();<br /> cprintf(&#34;kbd [%03d] %c\\n&#34;, c, c);<br /> <br /> /*********************/<br /> //Hardware Interrupt is different with software trap, so no need use temp stack<br /> if ( c ==&#39;3&#39;){<br /> tf-&gt;tf_eflags |= 0x3000;<br /> if (tf-&gt;tf_cs != USER_CS) {<br /> <br /> tf-&gt;tf_cs = USER_CS;<br /> tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS;<br /> tf-&gt;tf_eflags |= FL_IOPL_MASK;<br /> }<br /> print_trapframe(tf);</p>\n<p>}<br /> ......<br />&#96;&#96;&#96;</p>\n<p>按照我的理解,在内核态时触发键盘中断&#xff0c;此时是从内核态转换为内核态&#xff0c;故栈中不会先压入ss和esp。此时通过修改栈帧再iret的方法进行状态切换&#xff0c;<br />直接修改tf-&gt;tf_ss为USER_DS&#xff0c;会不会有越过当前栈帧的问题&#xff1f;因为此时栈帧中并没有ss这一项。答案中强调了硬中断和软中断的不同所以处理方式不同&#xff0c;<br />这个不同是什么呢&#xff1f;</p>\n<p>另外&#xff0c;我猜想在Challenge1的答案中可能会有点小问题:<br />(1)在内核态转换到用户态时:<br />&#96;&#96;&#96;<br /> case T_SWITCH_TOU:<br /> tf-&gt;tf_eflags |= 0x3000;<br /> if (tf-&gt;tf_cs != USER_CS) {<br /> switchk2u = *tf;<br /> switchk2u.tf_cs = USER_CS;<br /> switchk2u.tf_ds = switchk2u.tf_es = switchk2u.tf_ss = USER_DS;<br /> switchk2u.tf_esp = (uint32_t)tf &#43; sizeof(struct trapframe) - 8;<br /> <br /> // set eflags, make sure ucore can use io under user mode.<br /> // if CPL &gt; IOPL, then cpu will generate a general protection.<br /> switchk2u.tf_eflags |= FL_IOPL_MASK;<br /> <br /> // set temporary stack<br /> // then iret will jump to the right stack<br /> *((uint32_t *)tf - 1) = (uint32_t)&amp;switchk2u;<br />&#96;&#96;&#96;<br />switchk2u.tf_esp = (uint32_t)tf &#43; sizeof(struct trapframe) - 8;我觉得这里不应该加上-8&#xff0c;在init.c中<br />&#96;&#96;&#96;<br />static void<br />lab1_switch_to_user(void) {<br /> //LAB1 CHALLENGE 1 : TODO<br /> asm volatile (<br /> &#34;sub $0x8, %%esp \\n&#34;<br /> &#34;int %0 \\n&#34;<br /> &#34;movl %%ebp, %%esp&#34; //can cancel<br /> : <br /> : &#34;i&#34;(T_SWITCH_TOU)<br /> );<br />}<br />&#96;&#96;&#96;<br />已经提前把esp减了8再调用软中断&#xff0c;此时再到上面的case中处理时&#xff0c;新建栈帧的esp若要指向上一个栈帧的结尾&#xff0c;值应为(uint32_t)tf &#43; sizeof(struct trapframe)。<br />经测试&#xff0c;若去掉这个-8&#xff0c;可在lab1_switch_to_user中去掉&#34;movl %%ebp, %%esp&#34;&#xff0c;此时仍正常运行&#xff0c;因为iret时esp已修正为正确值。</p>\n<p>(2)在用户态转化到内核态时:<br />&#96;&#96;&#96;<br /> case T_SWITCH_TOK:<br /> if (tf-&gt;tf_cs != KERNEL_CS) {<br /> tf-&gt;tf_cs = KERNEL_CS;<br /> tf-&gt;tf_ds = tf-&gt;tf_es = KERNEL_DS;<br /> tf-&gt;tf_eflags &amp;= ~FL_IOPL_MASK;<br /> switchu2k = (struct trapframe *)(tf-&gt;tf_esp - (sizeof(struct trapframe) - 8));<br /> memmove(switchu2k, tf, sizeof(struct trapframe) - 8);<br /> *((uint32_t *)tf - 1) = (uint32_t)switchu2k;<br /> }<br /> break;<br />&#96;&#96;&#96;</p>\n<p>if{}中的后三句似乎没有存在的必要诶&#xff0c;直接改当前tf好像就可以了?</p>\n<p>我的理解可能有些浅薄&#xff0c;希望老师同学一起讨论一下&#xff0c;谢谢&#xff01;</p>\n<p></p>"}], "type": "question", "tags": ["lab1", "student"], "tag_good": [], "unique_views": 234, "children": [{"folders": [], "data": {"embed_links": []}, "children": [], "created": "2017-03-11T06:33:45Z", "bucket_order": 3, "tag_endorse": [], "bucket_name": "Today", "id": "j04vkwd4bl87hk", "history": [{"anon": "no", "uid": "ie7xy53vpn41q7", "subject": "", "created": "2017-03-11T06:33:45Z", "content": "<p>看懂了(2)&#xff0c;我也感觉没什么必要……</p>\n<p>其实 (1)我试了下&#xff0c;直接改tf也能正常工作。 </p>"}], "type": "s_answer", "tag_endorse_arr": [], "config": {}, "is_tag_endorse": false}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p><md><br />我来提供一些关于问题 (1) 的看法。<br /><br />## 先说结论<br /><br />确实会越界&#xff0c;但是已经没有影响了。<br /><br />## 解释<br /><br />&gt; Hardware Interrupt is different with software trap, so no need use temp stack<br /><br />我对这句话的理解体现在&#xff1a;软中断在 &#96;__alltraps&#96; 前是有栈帧的&#xff0c;而硬中断直接从 &#96;__alltraps&#96; 开始。<br /><br />&#96;&#96;&#96;<br /># 软中断的栈帧<br />#0 trap_dispatch (tf=0x7b4c) at kern/trap/trap.c:168<br />#1 0x00101f7d in trap (tf=0x7b4c) at kern/trap/trap.c:253<br />#2 0x00102a08 in __alltraps () at kern/trap/trapentry.S:24<br />#3 0x00007b4c in ?? ()<br />#4 0x001001f6 in lab1_switch_test () at kern/init/init.c:110<br />#5 0x0010006f in kern_init () at kern/init/init.c:40<br /><br /># 硬中断的栈帧<br />#0 trap_dispatch (tf=0x7b7c) at kern/trap/trap.c:168<br />#1 0x00101f7d in trap (tf=0x7b7c) at kern/trap/trap.c:253<br />#2 0x00102a08 in __alltraps () at kern/trap/trapentry.S:24<br />#3 0x00007b7c in ?? ()<br />#4 0x00007d70 in ?? ()<br />#5 0x00007c4f in ?? ()<br />&#96;&#96;&#96;<br /><br />因此&#xff0c;软中断需要保护栈帧&#xff0c;而硬中断不大需要保护 &#96;__alltraps&#96; 之前的数据。比如 &#96;tf-&gt;tf_ss&#96; 的地址为 &#96;0x7bc4&#96;&#xff0c;除了硬中断以外&#xff0c;唯一的一次修改是在一个 &#96;cprintf&#96; 语句中修改了值。而进入 &#96;while(1)&#96; 后&#xff0c;&#96;esp&#96; 的值为 &#96;0x7bc0&#96;&#xff0c;实际上高于这个地址&#xff0c;也就是在此之后正常情况下不会有代码访问使用到该区域&#xff0c;故曰“没有影响”。<br /></md>\n</p><p></p><p></p>", "created": "2019-12-20T06:26:07Z", "bucket_order": 40, "bucket_name": "Week 12/15 - 12/21", "type": "followup", "tag_good": [], "uid": "k1z7c5yedn72kq", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "k4drsv3wlmm1m1", "updated": "2019-12-20T06:26:07Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "j03jnfi9ertz", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 7, "num_favorites": 2, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643168962761, "default_anonymity": "no"}, "error": null, "aid": "kyv0di2xkuu61b"}