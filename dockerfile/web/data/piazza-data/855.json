{"result": {"folders": ["lab7", "other"], "nr": 855, "data": {"embed_links": []}, "created": "2016-05-09T13:46:49Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"uid": "i0et95bli7r7ky", "anon": "no", "when": "2016-05-09T13:46:49Z", "data": "io02b5i8ot42xe", "type": "create"}, {"uid": "i0et95bli7r7ky", "anon": "no", "when": "2016-05-09T13:47:34Z", "data": "io02c42kbb55p0", "type": "update"}, {"to": "io02b5i65dr2xd", "uid": "i0b2fq3ezjw50r", "anon": "no", "when": "2016-05-09T15:03:40Z", "data": "io051zcy3gj12s", "type": "s_answer"}, {"uid": "i0b2fq3ezjw50r", "anon": "no", "when": "2016-05-09T15:04:07Z", "data": "io052k2y39l4t5", "type": "s_answer_update"}, {"to": "io02b5i65dr2xd", "uid": "i0c90j8pjf56sn", "anon": "no", "when": "2016-05-09T15:26:39Z", "type": "followup"}, {"to": "io02b5i65dr2xd", "uid": "i0c90j8pjf56sn", "anon": "no", "when": "2016-05-09T15:26:55Z", "type": "feedback"}, {"to": "io02b5i65dr2xd", "uid": "i0b2fq3ezjw50r", "anon": "no", "when": "2016-05-10T01:09:28Z", "type": "feedback"}, {"to": "io02b5i65dr2xd", "uid": "hcrrjuyequh4bt", "anon": "no", "when": "2016-05-10T02:21:35Z", "data": "io0t9s6sb6t78", "type": "i_answer"}, {"to": "io02b5i65dr2xd", "uid": "hcrrjuyequh4bt", "anon": "no", "when": "2016-05-10T02:41:14Z", "type": "followup"}, {"to": "io02b5i65dr2xd", "uid": "hcrrjuyequh4bt", "anon": "no", "when": "2016-05-10T03:17:21Z", "type": "followup"}, {"to": "io02b5i65dr2xd", "uid": "i0c90j8pjf56sn", "anon": "no", "when": "2016-05-10T03:18:30Z", "type": "feedback"}, {"to": "io02b5i65dr2xd", "uid": "i0b2fq3ezjw50r", "anon": "no", "when": "2016-05-10T13:46:54Z", "type": "feedback"}, {"to": "io02b5i65dr2xd", "uid": "i0b2fq3ezjw50r", "anon": "no", "when": "2016-05-10T13:47:24Z", "type": "feedback"}, {"to": "io02b5i65dr2xd", "uid": "i0c90j8pjf56sn", "anon": "no", "when": "2016-05-10T16:20:06Z", "type": "feedback"}, {"to": "io02b5i65dr2xd", "uid": "i14g50r7ui12pn", "anon": "no", "when": "2016-05-11T06:02:23Z", "type": "followup"}, {"to": "io02b5i65dr2xd", "uid": "i0b2fq3ezjw50r", "anon": "no", "when": "2016-05-11T07:36:50Z", "type": "feedback"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "i0et95bli7r7ky", "subject": "ucore中cond_wait的实现", "created": "2016-05-09T13:47:34Z", "content": "<p>在陈渝老师课上&#xff0c;我们讨论了cv.next是否可能&lt;0的问题</p>\n<p>cond_wait代码如下</p>\n<p></p>\n<pre>cv.count&#43;&#43;;\nif(monitor.next_count &gt; 0)\n   sem_signal(monitor.next);\nelse\n   sem_signal(monitor.mutex);\nsem_wait(cv.sem);\ncv.count -- ;</pre>\n<p></p>\n<h3>问题1</h3>\n<p>sem_wait(cv.sem)之后是否要加上 sem_wait(monitor.mutex)呢&#xff1f;</p>\n<p>因为观察到在ucore中&#xff0c;默认管程要管理的代码前后需要程序员要加上</p>\n<pre>function &#xff08;…&#xff09;\n{\nsem.wait(monitor.mutex);\nhe real body of function;\nif(monitor.next_count &gt; 0)\n     sem_signal(monitor.next);\n  else\n     sem_signal(monitor.mutex);\n}</pre>\n<p>也就是说&#xff0c;默认进入cond_wait的时候是持有mutex的&#xff0c;那么是否有必要保证出cond_wait的时候&#xff0c;也有mutex&#xff0c;否则有两个问题&#xff1a;</p>\n<p>1. cv.count--不是原子操作&#xff08;如今天课上王楠指出的&#xff09;</p>\n<p>2. 在func出口处的 else sem_signal(monitor.mutex&#xff09;就不匹配了</p>\n<p></p>\n<h3>问题2</h3>\n<p>sem_signal 后会继续执行当前进程&#xff1f;</p>\n<p>cond_signal后会切换立即到wait(cv)的进程&#xff1f;</p>\n<p>这样是一半Hansen 一半Hoare策略&#xff1f;</p>"}, {"anon": "no", "uid": "i0et95bli7r7ky", "subject": "ucore中cond_wait的实现", "created": "2016-05-09T13:46:49Z", "content": "<p>在陈渝老师课上&#xff0c;我们讨论了cv.next是否可能&lt;0的问题</p>\n<p>cond_wait代码如下</p>\n<p></p>\n<pre>cv.count&#43;&#43;;\nif(monitor.next_count &gt; 0)\n   sem_signal(monitor.next);\nelse\n   sem_signal(monitor.mutex);\nsem_wait(cv.sem);\ncv.count -- ;</pre>\n<p></p>\n<h3>问题1</h3>\n<p>sem_wait(cv.sem)之后是否要加上 sem_wait(monitor.mutex)呢&#xff1f;</p>\n<p>因为观察到在ucore中&#xff0c;默认管程要管理的代码前后需要程序员要加上</p>\n<pre>function &#xff08;…&#xff09;\n{\n<strong>sem.wait(monitor.mutex);\n</strong>  the real body of function;\n<strong>  if(monitor.next_count &gt; 0)\n     sem_signal(monitor.next);\n  else\n     sem_signal(monitor.mutex);\n</strong>}</pre>\n<p>也就是说&#xff0c;默认进入cond_wait的时候是持有mutex的&#xff0c;那么是否有必要保证出cond_wait的时候&#xff0c;也有mutex&#xff0c;否则有两个问题&#xff1a;</p>\n<p>1. cv.count--不是原子操作&#xff08;如今天课上王楠指出的&#xff09;</p>\n<p>2. 在func出口处的 else sem_signal(monitor.mutex&#xff09;就不匹配了</p>\n<p></p>\n<h3>问题2</h3>\n<p>sem_signal 后会继续执行当前进程&#xff1f;</p>\n<p>cond_signal后会切换立即到wait(cv)的进程&#xff1f;</p>\n<p>这样是一半Hansen 一半Hoare策略&#xff1f;</p>"}], "type": "question", "tags": ["lab7", "other", "student"], "tag_good": [{"role": "instructor", "name": "Yu Chen", "endorser": {}, "admin": true, "photo": "1378950179_35.png", "id": "hcrrjuyequh4bt", "photo_url": "https://d1b10bmlvqabco.cloudfront.net/photos/hcrrjuyequh4bt/1378950179_35.png", "us": false, "class_sections": ["课程设计_i5j09fnsl7k5x0", "清华学生_i5j09fnsl7k5x0", "所有老师和助教_i5j09fnsl7k5x0", "os2018spring_i5j09fnsl7k5x0"], "facebook_id": null}], "unique_views": 163, "children": [{"folders": [], "data": {"embed_links": []}, "children": [], "created": "2016-05-09T15:03:40Z", "bucket_order": 3, "tag_endorse": [{"role": "instructor", "name": "Yu Chen", "endorser": {}, "admin": true, "photo": "1378950179_35.png", "id": "hcrrjuyequh4bt", "photo_url": "https://d1b10bmlvqabco.cloudfront.net/photos/hcrrjuyequh4bt/1378950179_35.png", "us": false, "class_sections": ["课程设计_i5j09fnsl7k5x0", "清华学生_i5j09fnsl7k5x0", "所有老师和助教_i5j09fnsl7k5x0", "os2018spring_i5j09fnsl7k5x0"], "facebook_id": null}], "bucket_name": "Today", "id": "io051zcvrm712r", "history": [{"anon": "no", "uid": "i0b2fq3ezjw50r", "subject": "", "created": "2016-05-09T15:04:07Z", "content": "<p>Hi, 我在课堂作业写了下对这个部分的思考&#xff0c;不知道对你是否有帮助&#xff1a;&#xff09;</p>\n<p><a href=\"https://github.com/DrustZ/OS_SPOC_hw/blob/master/hw18/hw.md\" target=\"_blank\">理解</a></p>"}, {"anon": "no", "uid": "i0b2fq3ezjw50r", "subject": "", "created": "2016-05-09T15:03:40Z", "content": "<p>Hi, 我在课堂作业写了下对这个部分的思考&#xff0c;不知道对你是否有帮助&#xff1a;&#xff09;</p>\n<p>https://github.com/DrustZ/OS_SPOC_hw/blob/master/hw18/hw.md</p>"}], "type": "s_answer", "tag_endorse_arr": ["hcrrjuyequh4bt"], "config": {}, "is_tag_endorse": false}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p></p><blockquote>\n<pre><code>不会。首先我们看到&#xff0c;代码中加与减操作是配对进行的&#xff0c;也就是说&#xff0c;即使减法被打断&#xff0c;出现竞争现象&#xff0c;也只可能少减1&#xff0c;而非减到小于0。</code></pre>\n</blockquote>\n<p></p>\n<p>加减配对是不足以保证不会小于0的。&#xff08;对于实现中var--&#xff0c;var&#43;&#43;的情况而言。&#xff09;</p>\n<p>通过加减配对保证不小于0的前提是不会同时有多个自加(or自减被执行。)</p>\n<p>比如</p>\n<p>var初值为0。</p>\n<p>两个进程同时执行</p>\n<p>var&#43;&#43;</p>\n<p>结果可能是1或2。</p>\n<p></p>\n<p>要保证正确性应该:</p>\n<p>       保证自加&#xff08;自减&#xff09;不会被打断&#xff0c;亦即原子性。&#xff08;同时只有一个进程执行或换成前自加自减。&#xff09;</p>\n<p></p>\n<p></p>", "created": "2016-05-09T15:26:39Z", "bucket_order": 207, "bucket_name": "Week 5/8 - 5/14", "type": "followup", "tag_good": [], "uid": "i0c90j8pjf56sn", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>&#64;张明瑞</p>", "created": "2016-05-09T15:26:55Z", "bucket_order": 207, "bucket_name": "Week 5/8 - 5/14", "type": "feedback", "tag_good": [], "uid": "i0c90j8pjf56sn", "children": [], "tag_good_arr": [], "id": "io05vvk7sni424", "updated": "2016-05-09T15:26:55Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>加法是不会被打断的&#xff0c;请看mutex的释放情况。</p>", "created": "2016-05-10T01:09:28Z", "bucket_order": 207, "bucket_name": "Week 5/8 - 5/14", "type": "feedback", "tag_good": [], "uid": "i0b2fq3ezjw50r", "children": [], "tag_good_arr": [], "id": "io0qp1lpe1dx", "updated": "2016-05-10T01:09:28Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>count不保证不打断&#xff0c;只是因为没有超过1个线程申请而已。</p>\n<p>我举例的意思是作为佐证&#xff0c;自加自减同时执行也可能wa。mutex不保证不能同时加减。</p>\n<p>我的理解是实现保护的方法是因为要执行自减的进程之前被sem卡住了&#xff0c;解锁sem的是某个执行signal进程。</p>", "created": "2016-05-10T03:18:30Z", "bucket_order": 207, "bucket_name": "Week 5/8 - 5/14", "type": "feedback", "tag_good": [], "uid": "i0c90j8pjf56sn", "children": [], "tag_good_arr": [], "id": "io0vazu7xvy72j", "updated": "2016-05-10T03:18:30Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>减法确实会锁住啊。。。你的解锁是在之后进行的&#xff0c;之前只能有一个进程掌握锁&#xff0c;就算被打断也不会race condition啊。。。</p>", "created": "2016-05-10T13:46:54Z", "bucket_order": 207, "bucket_name": "Week 5/8 - 5/14", "type": "feedback", "tag_good": [], "uid": "i0b2fq3ezjw50r", "children": [], "tag_good_arr": [], "id": "io1hr3ytdqq7g0", "updated": "2016-05-10T13:46:54Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>我是说你当时给的证明不对&#xff0c;仅仅成对是不能保证不会有错...所以给你举了个反例。</p>\n<p>这个东西是对的&#xff0c;是因为(有锁)&amp;&amp;(加减成对)...</p>", "created": "2016-05-10T16:20:06Z", "bucket_order": 207, "bucket_name": "Week 5/8 - 5/14", "type": "feedback", "tag_good": [], "uid": "i0c90j8pjf56sn", "children": [], "tag_good_arr": [], "id": "io1n84fs9qz7br", "updated": "2016-05-10T16:20:06Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>哦</p>", "created": "2016-05-11T07:36:50Z", "bucket_order": 207, "bucket_name": "Week 5/8 - 5/14", "type": "feedback", "tag_good": [], "uid": "i0b2fq3ezjw50r", "children": [], "tag_good_arr": [], "id": "io2jz1rd8cp5me", "updated": "2016-05-11T07:36:50Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "io05vjcmbv2sb", "updated": "2016-05-09T15:26:39Z", "config": {}}, {"folders": [], "data": {"embed_links": []}, "children": [], "created": "2016-05-10T02:21:35Z", "bucket_order": 3, "tag_endorse": [], "bucket_name": "Today", "id": "io0t9s6pgcq77", "history": [{"anon": "no", "uid": "hcrrjuyequh4bt", "subject": "", "created": "2016-05-10T02:21:35Z", "content": "<p>叶雨菲能够主动进一步提出问题</p>\n<p>张明瑞有自己的理解</p>\n<p>都很不错&#xff01;</p>"}], "type": "i_answer", "tag_endorse_arr": [], "config": {}, "is_tag_endorse": false}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>伪码&#xff1a;</p>\n<pre> 0 IMPLEMENTATION:\n 1   monitor mt {\n 2     -----variable in monitor-----------\n 3     semaphore mutex;                             // the mutex lock for going into the routines in monitor, should be initialized to 1\n 4     semaphore next;                              // the next  is used to down the signaling proc, some proc should wake up the sleeped cv.signaling proc. should be initialized to 0 \n 5     int next_count;                              // the number of of sleeped signaling proc, should be initialized to 0\n 6     condvar {int count, sempahore sem}  cv[N];   // the condvars in monitor, count initial value 0, sem initial value 0\n 7     other shared variables in mt;                // shared variables should protected by mutex lock\n 8     --------condvar wait---------------\n 9     cond_wait (cv) {\n 10         cv.count &#43;&#43;;\n 11        if(mt.next_count&gt;0)\n 12           signal(mt.next)                       // first perform the EXIT PROTOCOL \n 13        else\n 14           signal(mt.mutex);\n 15        wait(cv.sem);                            // now wait on the condition waiting queue (cv.sem)\n 16        cv.count --;\n 17     }\n 18    --------condvar signal--------------\n 19     cond_signal(cv) {\n 20         if(cv.count&gt;0) {                       　// do nothing unless a process is waiting on condition waiting queue (cv.sem)\n 21            mt.next_count &#43;&#43;;\n 22            signal(cv.sem);                     　//　release the  waiting process which on  condition waiting queue (cv.sem)\n 23            wait(mt.next);                       // wait on the &#34;next&#34; waiting queue for cv.signaling proc\n 24            mt.next_count--;\n 25         }\n 26      }\n 27    --------routines in monitor-------------\n 28    routineA_in_mt () {\n 29       wait(mt.mutex);                           // ENTRY PROTOCOL (at the beginning of each monitor routines), wait for exclusive access to the monitor \n 30       ...\n 31       real body of routineA　　　　　　　　　　　　 // in here, may access shared variables, call cond_wait OR cond_signal\n 32       ...\n 33       if(next_count&gt;0)                          // EXIT PROTOCOL (at the end of each monitor function)\n 34           signal(mt.next);                      // if there are processes(sleeped cv.signaling proc) in the &#34;next&#34; queue, release one \n 35       else\n 36           signal(mt.mutex);                     // otherwise, release the monitor\n 37    }</pre>\n<p></p>", "created": "2016-05-10T02:41:14Z", "bucket_order": 207, "bucket_name": "Week 5/8 - 5/14", "type": "followup", "tag_good": [], "uid": "hcrrjuyequh4bt", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "io0tz2j0k24263", "updated": "2016-05-10T02:41:14Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>基于上述伪码的解释&#xff1a;</p>\n<p>Q: sem_wait(cv.sem)之后是否要加上 sem_wait(monitor.mutex)呢&#xff1f;</p>\n<p>A:</p>\n<p>0. cv.count是一个共享变量&#xff0c;需要互斥访问保护&#xff0e;</p>\n<p></p>\n<p>1. monitor.mutex不是专门直接用来保护cv.count的&#xff0c;主要是用来保护在monitor的routine中对共享变量的互斥访问保护&#xff0e;</p>\n<p></p>\n<p>单从cond_wait这个函数来看&#xff0c;貌似&#xff02;cv.count --&#xff02;这个操作没有互斥访问保护&#xff0e;所以会有是否应该给&#xff02;cv.count --&#xff02;代码的前后加上 sem_wait(monitor.mutex)和sem_signal(monitor.mutex)来保护一下的想法&#xff0e;</p>\n<p></p>\n<p>但从整体的代码逻辑中&#xff0c;可以看出&#xff0c;&#xff02;cv.count--&#xff02;的这个操作其实一直在monitor.mutex的互斥保护之下&#xff0e;Why?　</p>\n<p></p>\n<p></p>\n<p>这是hoare mode monitor的特征决定的&#xff0e;</p>\n<p>为简化分析&#xff0c;考虑存在3个进程A,B,C&#xff0c;A,C会执行有cond_wait的monitor函数&#xff0c;B会执行有cond_signal的monitor函数&#xff0c;A进程先执行&#xff0e;</p>\n<p></p>\n<p>我们需要了解在要执行&#xff02;cv.count--&#xff02;的这个操作时&#xff0c;当前的状态是什么&#xff0e;</p>\n<p> </p>\n<p>这个当前的状态就是&#xff0c;执行wait(cv.sem)而睡眠的进程A被某个执行cond_signal(cv) 的进程B给唤醒&#xff0e;</p>\n<p></p>\n<p>而进程B在执行cond_signal(cv) 的时候&#xff0c;一定是一个已经得到了mt.mutex的进程&#xff0c;且在它睡&#xff08;执行wait(mt.next); &#xff09;之前&#xff0c;会唤醒&#xff08;signal(cv.sem)&#xff09;一个类似进程A的进程&#xff08;注意&#xff0c;不一的是进程&#xff21;&#xff0c;也可能是其他执行了cond_wait(cv)的进程C&#xff0c;但不影响后续分析&#xff09;&#xff0e;</p>\n<p></p>\n<p>假定唤醒的这个是进程A&#xff0c;由于mt.mutex并没有被进程B释放&#xff0c;所以在进程B执行睡&#xff08;执行wait(mt.next); &#xff09;操作后&#xff0c;一定只会有进程A在monitor中执行&#xff0c;不会有第二个其他进程会进入monitor执行&#xff0e;</p>\n<p>能理解上面一句话的关键是能够理解&#xff1a;进程B通过唤醒进程A&#xff0c;并休眠自己&#xff0c;悄悄地隐含地把mt.mutex的获取权交给了进程A&#xff08;即使进程A在睡之前已经释放了mt.mutex&#xff09;&#xff0c;导致即使有其他进程想进入monitor的某routine执行&#xff0c;也由于得不到mt.mutex&#xff0c;而不得不等待在mt.mutex上的等待队列中&#xff0e;</p>\n<p></p>\n<p>所以&#xff0c;当进程A唤醒后&#xff0c;在执行&#xff02;cv.count --&#xff02;操作时&#xff0c;其实是得到了mt.mutex的获取权和保护的&#xff0e;这样在他退出时&#xff0c;由于next_count&gt;0&#xff0c;所以会执行signal(mt.next)&#xff0c;使得进程B被唤醒&#xff0c;且这样mt.mutex的获取权又悄悄还给了进程B&#xff0c;进程B随后会执行mt.next_count--&#xff0c;　这样在进程B退出monitor的routine时&#xff0c;会执行signal(mt.mutex)来释放mt.mutex&#xff0c;使得其他进程能够进入monitor; </p>\n<p></p>\n<p>在整个过程中&#xff0c;进程C会被挡在wait(mt.mutex)　或　wait(cv.sem); &#xff0c;没有机会破坏互斥性&#xff0e;</p>\n<p></p>\n<p>不知是否说明白了&#xff1f;</p>", "created": "2016-05-10T03:17:21Z", "bucket_order": 207, "bucket_name": "Week 5/8 - 5/14", "type": "followup", "tag_good": [], "uid": "hcrrjuyequh4bt", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>赞&#xff01;</p>\n<p>mark 先&#xff0c;回来再看。</p>", "created": "2016-05-10T13:47:24Z", "bucket_order": 207, "bucket_name": "Week 5/8 - 5/14", "type": "feedback", "tag_good": [], "uid": "i0b2fq3ezjw50r", "children": [], "tag_good_arr": [], "id": "io1hrriyr1w7mb", "updated": "2016-05-10T13:47:24Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "io0v9igttdt2br", "updated": "2016-05-10T03:17:21Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p><em>下面的讨论基于<tt>ucore_os_lab/labcodes_answer/lab7_result</tt>中的代码</em></p>\n<p></p>\n<p><strong>第一个问题&#xff0c;我认为不需要加<tt>sem_wait(monitor.mutex)。</tt></strong></p>\n<p></p>\n<p>大家认为需要加<tt>sem_wait(monitor.mutex)</tt>的理由是&#xff0c;<tt>cond_signal</tt>中的一次<tt>up(&amp;(cvp-&gt;sem))</tt>操作有可能会唤醒多个线程&#xff1b;这些线程被唤醒之后——也就是<tt>down(&amp;(cvp-&gt;sem))</tt>等待结束后——由于没有判断<tt>mutex</tt>的互斥&#xff0c;会导致多个线程同时进入routine。</p>\n<p><strong>然而这是不可能的。</strong>观察到<tt>cond_signal()中的这段代码&#xff1a;</tt></p>\n<pre>if(cvp-&gt;count&gt;0) {\n\tcvp-&gt;owner-&gt;next_count &#43;&#43;;\n        up(&amp;(cvp-&gt;sem));\n        down(&amp;(cvp-&gt;owner-&gt;next)); // **this line is important!!!\n        cvp-&gt;owner-&gt;next_count --;\n}</pre>\n<p>可以得知&#xff0c;对于一段有多个线程在争夺执行权的routine&#xff0c;指示哪个线程在执行的变量<strong>不是mutex&#xff0c;而是cvp-&gt;owner-&gt;next。&#xff08;</strong>因为&#xff0c;如果一个条件变量如果signal了多个线程&#xff0c;那么只有第一个执行<tt>down(&amp;(cvp-&gt;owner-&gt;next));</tt>线程能顺利获得执行权&#xff0c;而别的线程都会在这行里进入等待状态。&#xff09;</p>\n<p>进一步的思考可以得出&#xff1a;只有最后一个进入争夺队列里的线程拥有mutex&#xff08;但是不意味着他拥有执行权&#xff01;&#xff09;&#xff1b;<strong>拥有cvp-&gt;owner-&gt;next的才拥有执行权。</strong></p>\n<p></p>", "created": "2016-05-11T06:02:23Z", "bucket_order": 207, "bucket_name": "Week 5/8 - 5/14", "type": "followup", "tag_good": [], "uid": "i14g50r7ui12pn", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "io2gllqk6ic4nx", "updated": "2016-05-11T06:02:23Z", "config": {}}], "tag_good_arr": ["hcrrjuyequh4bt"], "no_answer": 0, "id": "io02b5i65dr2xd", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 8, "num_favorites": 1, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643168632649, "default_anonymity": "no"}, "error": null, "aid": "kyv06fd5gl86sh"}