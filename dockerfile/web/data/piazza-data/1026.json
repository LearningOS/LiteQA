{"result": {"folders": ["lecture11", "2017"], "nr": 1026, "data": {"embed_links": []}, "created": "2017-03-30T08:57:10Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "ie7xy53vpn41q7", "data": "j0w62if2yxn53z", "type": "create", "when": "2017-03-30T08:57:10Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "data": "j0w6gel08qn6hu", "type": "update", "when": "2017-03-30T09:07:58Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "data": "j0w6rogllql1m8", "to": "j0w62iezjlb53y", "type": "i_answer", "when": "2017-03-30T09:16:44Z"}, {"anon": "no", "uid": "ie7xxyhe7dp1jr", "to": "j0w62iezjlb53y", "type": "followup", "when": "2017-04-01T02:06:52Z"}, {"anon": "no", "uid": "ie7xxyhe7dp1jr", "to": "j0w62iezjlb53y", "type": "feedback", "when": "2017-04-01T02:13:49Z"}, {"anon": "no", "uid": "hcrrjuyequh4bt", "data": "j0zaep5qe0f3qg", "type": "i_answer_update", "when": "2017-04-01T13:21:55Z"}, {"anon": "no", "uid": "in11o0jsfdy4z2", "to": "j0w62iezjlb53y", "type": "feedback", "when": "2017-04-04T03:03:37Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "data": "j13omxrker43jv", "type": "i_answer_update", "when": "2017-04-04T15:11:19Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "关于上课所讲“三状态进程模型”的疑问", "created": "2017-03-30T09:07:58Z", "content": "<p>MOOC中11.4节所讲的“三状态进程模型”&#xff0c;进程在退出前<strong>必须</strong>要到<strong>运行</strong>状态。</p>\n<p></p>\n<p>但是我们又知道&#xff0c;操作系统会提供进程管理器从外部kill一个进程。</p>\n<p></p>\n<p>那么&#xff0c;通过这种方式kill掉的程序如果当时并没有处于运行态&#xff0c;而是在<strong>就绪或等待</strong>状态&#xff0c;那么操作系统会强行使程序进入运行态吗&#xff1f;</p>"}, {"anon": "no", "uid": "ie7xy53vpn41q7", "subject": "关于上课所讲“三状态进程模型”的疑问", "created": "2017-03-30T08:57:10Z", "content": "<p>MOOC中11.4节所讲的“三状态进程模型”&#xff0c;进程在退出前<strong>必须</strong>要到<strong>运行</strong>状态。</p>\n<p></p>\n<p>但是我们又知道&#xff0c;操作系统会提供进程管理器从外部kill一个进程。</p>\n<p></p>\n<p>那么&#xff0c;通过这种方式kill掉的程序如果当时并没有处于运行态&#xff0c;而是在<strong>就绪或等待</strong>状态&#xff0c;那么操作系统会强行使程序进入运行态吗&#xff1f;</p>"}], "type": "question", "tags": ["2017", "lecture11", "student"], "tag_good": [{"role": "instructor", "name": "Yong XIANG", "endorser": {}, "admin": true, "photo": null, "id": "hdjonbiyfs62ie", "photo_url": null, "us": false, "class_sections": ["课程设计_i5j09fnsl7k5x0", "清华学生_i5j09fnsl7k5x0", "所有老师和助教_i5j09fnsl7k5x0", "os2018spring_i5j09fnsl7k5x0"], "facebook_id": null}], "unique_views": 127, "children": [{"folders": [], "data": {"embed_links": []}, "children": [], "created": "2017-03-30T09:16:44Z", "bucket_order": 3, "tag_endorse": [], "bucket_name": "Today", "id": "j0w6roghbhh1m7", "history": [{"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "", "created": "2017-04-04T15:11:19Z", "content": "<p>这个问题涉及kill命令的处理流程。kill命令会导致操作系统给指定进程发一个信号signal&#xff0c;这个信号的响应会触发进程执行相应的信号处理函数&#xff0c;杀掉进程就是在这个函数中进行的。信号分发是内核实现的&#xff0c;信号处理函数可以是一个用户态的函数&#xff0c;也存在放在内核中的系统缺省信号处理函数。详细信息可参考“信号”相关的章节。</p>\n<p></p>\n<p>如果还有疑问&#xff0c;请继续提出。如果明白&#xff0c;建议你对照Linux的实现&#xff0c;在本贴后面详细回复kill命令的处理流程。</p>\n<p></p>\n<p>[陈渝老师] 根据<a href=\"https://www.piazza.com/class/i5j09fnsl7k5x0?cid=1026\">Kaixiang Lei</a>的下述回答&#xff0c;应该存在“不客气的” SIGKILL的处理方式&#xff0c;即用户进程没有得到通知和处理的机会就被kill了。</p>\n<p></p>\n<p></p>"}, {"anon": "no", "uid": "hcrrjuyequh4bt", "subject": "", "created": "2017-04-01T13:21:55Z", "content": "<p>这个问题涉及kill命令的处理流程。kill命令会导致操作系统给指定进程发一个信号signal&#xff0c;这个信号的响应会触发进程执行相应的信号处理函数&#xff0c;杀掉进程就是在这个函数中进行的。这是一个用户态的函数。详细信息可参考“信号”相关的章节。</p>\n<p></p>\n<p>如果还有疑问&#xff0c;请继续提出。如果明白&#xff0c;建议你对照Linux的实现&#xff0c;在本贴后面详细回复kill命令的处理流程。</p>\n<p></p>\n<p>[陈渝老师] 根据<a href=\"/class/i5j09fnsl7k5x0?cid=1026\">Kaixiang Lei</a>的下述回答&#xff0c;应该存在“不客气的” SIGKILL的处理方式&#xff0c;即用户进程没有得到通知和处理的机会就被kill了。</p>"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "", "created": "2017-03-30T09:16:44Z", "content": "<p>这个问题涉及kill命令的处理流程。kill命令会导致操作系统给指定进程发一个信号signal&#xff0c;这个信号的响应会触发进程执行相应的信号处理函数&#xff0c;杀掉进程就是在这个函数中进行的。这是一个用户态的函数。详细信息可参考“信号”相关的章节。</p>\n<p></p>\n<p>如果还有疑问&#xff0c;请继续提出。如果明白&#xff0c;建议你对照Linux的实现&#xff0c;在本贴后面详细回复kill命令的处理流程。</p>"}], "type": "i_answer", "tag_endorse_arr": [], "config": {}, "is_tag_endorse": false}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>Linux 中干掉其他进程的 signal 也有三六九等&#xff0c;有温和的 SIGINT, SIGTERM&#xff0c;也有“不客气的” SIGKILL。</p>\n<p></p>\n<p>考虑以下程序</p>\n<p></p>\n<pre>#include &lt;stdio.h&gt;\n#include &lt;signal.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;unistd.h&gt;\n\nint main()\n{\n\tint fpid = getpid();\n\n\tif(fork() == 0)\n\t{\n\t\tsleep(2);\n\t\tkill(fpid, SIGKILL);\n\t}\n\telse\n\t{\n\t\tfor(;;)\n\t\t\tsleep(10);\n\t}\n}</pre>\n<p></p>\n<p>用 sstrace 跟踪之</p>\n<pre>linux&gt; strace ./test\n// ...\ngetpid()                                = 3389\nclone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f967b867a10) = 3390\nrt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0\nrt_sigaction(SIGCHLD, NULL, {SIG_DFL, [], 0}, 8) = 0\nrt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0\nnanosleep({10, 0},  &lt;unfinished ...&gt;\n&#43;&#43;&#43; killed by SIGKILL &#43;&#43;&#43;\nfish: Job 1, “strace ./test” terminated by signal SIGKILL (Forced quit)</pre>\n<p></p>\n<p>通过 strace 的输出&#xff0c;我们猜测&#xff0c;父进程应该是在等待 sleep&#xff0c;但还没等到被唤醒之时&#xff08;有可能还没回到用户态&#xff09;&#xff0c;就被干掉了。</p>", "created": "2017-04-01T02:06:52Z", "bucket_order": 161, "bucket_name": "Week 3/26 - 4/1", "type": "followup", "tag_good": [], "uid": "ie7xxyhe7dp1jr", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>考虑用 SIGTERM 干掉父进程</p>\n<p></p>\n<pre>#include &lt;stdio.h&gt;\n#include &lt;signal.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;unistd.h&gt;\n\nint main()\n{\n\tint fpid = getpid();\n\n\tif(fork() == 0)\n\t{\n\t\tsleep(2);\n\t\tkill(fpid, SIGTERM);\n\t}\n\telse\n\t{\n\t\tfor(;;)\n\t\t\tsleep(10);\n\t}\n}</pre>\n<p></p>\n<p>用 strace 跟踪之</p>\n<p></p>\n<pre>linux&gt; strace ./test\n// ...\ngetpid()                                = 3589\nclone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f8d69233a10) = 3590\nrt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0\nrt_sigaction(SIGCHLD, NULL, {SIG_DFL, [], 0}, 8) = 0\nrt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0\nnanosleep({10, 0}, {8, 140362})         = ? ERESTART_RESTARTBLOCK (Interrupted by signal)\n--- SIGTERM {si_signo=SIGTERM, si_code=SI_USER, si_pid=3590, si_uid=1000} ---\n&#43;&#43;&#43; killed by SIGTERM &#43;&#43;&#43;</pre>\n<p>通过 strace 的输出&#xff0c;我们猜测&#xff0c;父进程等待 sleep 的过程中&#xff0c;因为 SIGTERM signal 而提前返回了&#xff08;用户态&#xff09;。</p>\n<p>之后有可能因为其受到了 SIGTERM signal&#xff0c;而执行了默认的 SIGTERM handler&#xff0c;做了些收尾工作后就结束了。</p>", "created": "2017-04-01T02:13:49Z", "bucket_order": 161, "bucket_name": "Week 3/26 - 4/1", "type": "feedback", "tag_good": [], "uid": "ie7xxyhe7dp1jr", "children": [], "tag_good_arr": [], "id": "j0ymjiii1n135a", "updated": "2017-04-01T02:13:49Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>   </p>\n<p>    不管是SIGTERM还是SIGKILL信号&#xff0c;当子进程发出kill命令之后&#xff0c;父进程都没有返回到用户态&#xff0c;全部都是在内核态完成处理。</p>\n<p>    如果进程当时没有处于运行状态&#xff0c;当接受到以上的两种信号后&#xff0c;内核会调度该进程&#xff0c;即本例中的父进程会再次执行&#xff0c;但不会回到用户态。</p>\n<p></p>\n<p>下面是ftrace跟踪出来的结果&#xff0c;可以看到sys_kill系统调用之后&#xff0c;会去调用try_to_wake_up()函数来唤醒进程。</p>\n<pre>3148   0)               |  SyS_kill() {\n3149   0)   0.605 us    |    pid_vnr();\n3150   0)   0.418 us    |    from_kuid_munged();\n3151   0)               |    find_vpid() {\n3152   0)   0.694 us    |      find_pid_ns();\n3153   0)   2.566 us    |    }\n3154   0)               |    kill_pid_info() {\n3155   0)   0.169 us    |      pid_task();\n3156   0)               |      group_send_sig_info() {\n3157   0)               |        check_kill_permission() {\n3158   0)               |          security_task_kill() {\n3159   0)               |            apparmor_task_kill() {\n3160   0)   0.598 us    |              aa_get_task_label();\n3161   0)   0.971 us    |              aa_may_signal();\n3162   0)   5.180 us    |            }\n3163   0)   7.263 us    |          }\n3164   0)   9.622 us    |        }\n3165   0)               |        do_send_sig_info() {\n3166   0)               |          __lock_task_sighand() {\n3167   0)   0.426 us    |            _raw_spin_lock();\n3168   0)   1.764 us    |          }\n3169   0)               |          send_signal() {\n3170   0)   0.293 us    |            task_active_pid_ns();\n3171   0)   0.353 us    |            __task_pid_nr_ns();\n3172   0)               |            __send_signal() {\n3173   0)   0.461 us    |              prepare_signal();\n3174   0)               |              __sigqueue_alloc() {\n3175   0)   0.721 us    |                kmem_cache_alloc();\n3176   0)   2.717 us    |              }\n3177   0)               |              complete_signal() {\n3178   0)               |                signal_wake_up_state() {\n3179   0)               |                  wake_up_state() {\n3180   0)               |                    try_to_wake_up() {\n3181   0)   0.281 us    |                      _raw_spin_lock_irqsave();\n3182   0)   0.296 us    |                      task_waking_fair();\n3183   0)               |                      select_task_rq_fair() {\n3184   0)               |                        select_idle_sibling() {\n3185   0)   0.264 us    |                          idle_cpu();\n3186   0)   0.144 us    |                          cpus_share_cache();\n3187   0)   0.241 us    |                          idle_cpu();         </pre>\n<p>接下来看看信号处理的过程&#xff1a;</p>\n<p>Linux/i386 中SIGTERM、SIGKILL等系统自带的信号有自己的缺省操作&#xff0c;SIGTERM、SIGKILL缺省操作是terminate&#xff08;结束&#xff09;&#xff0c;注意terminate与stop不一样。</p>\n<p>下面看看arch/x86/kernel/signal.c&#xff08;注&#xff1a;linux-3.5.4&#xff09;</p>\n<pre>static void do_signal(struct pt_regs *regs)\n{\n    struct k_sigaction ka; \n    siginfo_t info;\n    int signr;\n\n    signr = get_signal_to_deliver(&amp;info, &amp;ka, regs, NULL);                                                                                                                   \n    if (signr &gt; 0) {\n        /* Whee! Actually deliver the signal.  */\n        handle_signal(signr, &amp;info, &amp;ka, regs);\n        return;\n    }   \n...</pre>\n<p>do_signal是信号处理函数的入口&#xff0c;操作系统从内核态进入用户态时会检查存在挂起信号&#xff0c;并调用do_signal&#xff08;&#xff09;函数;</p>\n<p><span style=\"font-size:14px\">get_signal_to_deliver 是在进程中选择一个信号来handle&#xff0c;并交给</span>handle_signal&#xff08;&#xff09;处理&#xff0c;handle_signal()会进入用户态执行信号处理函数;</p>\n<p>但是&#xff0c;系统自带信号的处理方式执行的是信号的默认缺省操作&#xff0c;在<span style=\"font-size:14px\">get_signal_to_deliver&#xff08;&#xff09;函数中完成&#xff0c;不会进入用户态。Linux/i386前31个信号中有18个的默认操作都是terminate&#xff0c;即都执行do_group_exit&#xff08;&#xff09;函数;</span></p>\n<pre>int get_signal_to_deliver(siginfo_t *info, struct k_sigaction *return_ka,                                           struct pt_regs *regs, void *cookie)\n{\n...\n        /*\n         * Death signals, no core dump.  \n         */\n        do_group_exit(info-&gt;si_signo);\n...\n</pre>\n<p>do_group_exit()调用do_exit()结束进程</p>\n<pre>void do_group_exit(int exit_code)\n{\n    struct signal_struct *sig = current-&gt;signal;\n\n    BUG_ON(exit_code &amp; 0x80); /* core dumps don&#39;t get here */\n\n    if (signal_group_exit(sig))\n        exit_code = sig-&gt;group_exit_code;\n    else if (!thread_group_empty(current)) {\n        struct sighand_struct *const sighand = current-&gt;sighand;\n        spin_lock_irq(&amp;sighand-&gt;siglock);\n        if (signal_group_exit(sig))\n            /* Another thread got here before we took the lock.  */\n            exit_code = sig-&gt;group_exit_code;\n        else {\n            sig-&gt;group_exit_code = exit_code;\n            sig-&gt;flags = SIGNAL_GROUP_EXIT;\n            zap_other_threads(current);\n        }    \n        spin_unlock_irq(&amp;sighand-&gt;siglock);\n    }    \n\n    do_exit(exit_code);\n    /* NOTREACHED */                                                                                                                                                         \n}\n\n</pre>\n<p></p>\n<p>总结一下&#xff1a;</p>\n<ol><li>即便进程处于就绪或等待状态&#xff0c;kill进程时&#xff0c;也会调度进程&#xff0c;使之处于运行状态。</li><li>系统默认的信号处理程序在内核中完成&#xff0c;用户自定义的信号处理程序需要切换回用户态。</li><li>程序从内核态回到用户态前&#xff0c;中断、异常、系统调用后会检查信号是否存在挂起信号&#xff0c;调用do_notify_resume&#xff08;汇编函数&#xff09;--&gt;do_signal</li><li>进程切换到被杀进程后&#xff0c;先调用hrtimer_try_to_cancel&#xff08;&#xff09;取消了计时器&#xff0c;以便程序可以运行&#xff0c;至于SIGKILL如何影响该动作&#xff0c;还未弄清。</li></ol>\n<p></p>\n<p>欢迎同学们尝试和补充</p>\n<p></p>", "created": "2017-04-04T03:03:37Z", "bucket_order": 160, "bucket_name": "Week 4/2 - 4/8", "type": "feedback", "tag_good": [], "uid": "in11o0jsfdy4z2", "children": [], "tag_good_arr": [], "id": "j12yn3maecw3ed", "updated": "2017-04-04T03:03:37Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "j0ymakrrif864n", "updated": "2017-04-01T02:06:52Z", "config": {}}], "tag_good_arr": ["hdjonbiyfs62ie"], "no_answer": 0, "id": "j0w62iezjlb53y", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 10, "num_favorites": 0, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643168996548, "default_anonymity": "no"}, "error": null, "aid": "kyv0e85g9yl1r4"}