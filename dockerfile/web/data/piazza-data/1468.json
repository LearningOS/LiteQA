{"result": {"history_size": 1, "folders": ["特权级", "lab1"], "nr": 1468, "data": {"embed_links": []}, "created": "2020-05-29T00:02:18Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "k1r6zegdsqw5gg", "data": "karfzes1ps77dd", "v": "all", "type": "create", "when": "2020-05-29T00:02:18Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "k1r6zegdsqw5gg", "subject": "Lab1 Challenge1中关于 mov %ebp, %esp 意义的讨论", "created": "2020-05-29T00:02:18Z", "content": "<md>我在自己做Lab1 Challenge1的实验时，在`lab1_switch_to_user`和`lab1_switch_to_kernel`函数中，只写了正常调整栈和正常引发中断的代码，并没有像参考答案一样在最后添加`movl %ebp, %esp`语句，最终也能得到正确的输出，但是在执行`make grade`时却得不了满分，这引起了我的思考：\n\n* `movl %ebp, %esp`这个指令是否有必要？\n* 不加`movl %ebp, %esp`指令是不是就会引发错误？\n\n先说结论，这条指令是有必要的，不加的确会引发错误。\n\n我针对这个问题查了一系列资料，也在群中咨询了群友，我发现在*GCC*编译一个函数的过程中，会在函数头部添加`push %ebp`和`mov %esp, %ebp`这两条指令，来保证栈内存的安全；同时也会在函数尾部`ret`指令返回之前添加`mov %ebp, %esp`和`pop %ebp`语句来还原执行函数前栈的状态，当然这时在编译器发现正常的代码编译成汇编指令时有涉及到对栈的操作（`push`、`pop`）才会添加`mov %ebp, %esp`，如果没有对栈的操作，ESP寄存器没有变化，这个语句就没有必要，这也是为了节省开销。\n\n但是，我们在处理中断的过程中，是对栈进行了一系列操作的，然而由于这发生在内联汇编中，编译器并没有意识到，所以就给省略了`mov %ebp, %esp`语句，省略后在下一个函数执行时就可能会出现问题。\n\n那么如何解决这个问题了？有两个解决方案。\n\n第一种方法，像参考答案一样，手动在内联汇编语句中添加`movl %%ebp, %%esp`来对栈进行恢复，这样是完全没有问题的。代码如下：\n\n```c\nstatic void\nlab1_switch_to_user(void) {\n    //LAB1 CHALLENGE 1 : TODO\n\tasm volatile (\n\t    \"sub $0x8, %%esp \\n\"\n\t    \"int %0 \\n\"\n\t    \"movl %%ebp, %%esp\"\n\t    : \n\t    : \"i\"(T_SWITCH_TOU)\n\t);\n}\n```\n\n第二种方法，在内联汇编语句的参数中声明我们对ESP寄存器进行了操作，这时编译器会意识到这一点，然后自动在函数尾部补上`mov %ebp, %esp`这一指令。代码如下：\n\n```c\nstatic void\nlab1_switch_to_user(void) {\n    //LAB1 CHALLENGE 1 : TODO\n\tasm volatile (\n\t    \"sub $0x8, %%esp \\n\"\n\t    \"int %0 \\n\"\n\t    : \n\t    : \"i\"(T_SWITCH_TOU)\n\t    : \"%esp\"\n\t);\n}\n```\n\n以下是原始代码和两种方法反汇编之后的代码，也作为对这一方案是否成功的验证：\n\n不作任何操作时的反汇编结果：\n\n> 000001a3 <lab1_switch_to_user>:\n>  1a3:\t55                   \tpush   %ebp\n>  1a4:\t89 e5                \tmov    %esp,%ebp\n>  1a6:\t83 ec 08             \tsub    $0x8,%esp\n>  1a9:\tcd 78                \tint    $0x78\n>  1ab:\t90                   \tnop\n>  1ac:\t5d                   \tpop    %ebp\n>  1ad:\tc3                   \tret    \n> \n> 000001ae <lab1_switch_to_kernel>:\n>  1ae:\t55                   \tpush   %ebp\n>  1af:\t89 e5                \tmov    %esp,%ebp\n>  1b1:\tcd 79                \tint    $0x79\n>  1b3:\t90                   \tnop\n>  1b4:\t5d                   \tpop    %ebp\n>  1b5:\tc3                   \tret\n\n显然可以看到，进入函数时的操作都有，但是退出函数时的操作少了一步。\n\n下面是第一种方法反汇编后的结果：\n\n> 000001a3 <lab1_switch_to_user>:\n>  1a3:\t55                   \tpush   %ebp\n>  1a4:\t89 e5                \tmov    %esp,%ebp\n>  1a6:\t83 ec 08             \tsub    $0x8,%esp\n>  1a9:\tcd 78                \tint    $0x78\n>  1ab:\t89 ec                \tmov    %ebp,%esp\n>  1ad:\t90                   \tnop\n>  1ae:\t5d                   \tpop    %ebp\n>  1af:\tc3                   \tret    \n> \n> 000001b0 <lab1_switch_to_kernel>:\n>  1b0:\t55                   \tpush   %ebp\n>  1b1:\t89 e5                \tmov    %esp,%ebp\n>  1b3:\tcd 79                \tint    $0x79\n>  1b5:\t89 ec                \tmov    %ebp,%esp\n>  1b7:\t90                   \tnop\n>  1b8:\t5d                   \tpop    %ebp\n>  1b9:\tc3                   \tret\n\n可以看到，这一指令被我们手动补上了（好像是废话）\n\n接下来是第二种方法反汇编后的结果：\n\n> 000001a3 <lab1_switch_to_user>:\n>  1a3:\t55                   \tpush   %ebp\n>  1a4:\t89 e5                \tmov    %esp,%ebp\n>  1a6:\t83 ec 08             \tsub    $0x8,%esp\n>  1a9:\tcd 78                \tint    $0x78\n>  1ab:\t90                   \tnop\n>  1ac:\tc9                   \tleave  \n>  1ad:\tc3                   \tret    \n> \n> 000001ae <lab1_switch_to_kernel>:\n>  1ae:\t55                   \tpush   %ebp\n>  1af:\t89 e5                \tmov    %esp,%ebp\n>  1b1:\tcd 79                \tint    $0x79\n>  1b3:\t90                   \tnop\n>  1b4:\tc9                   \tleave  \n>  1b5:\tc3                   \tret\n\n可以看到，在`ret`指令返回前有了一条`leave`指令，查阅Intel的文档可以了解到，这条指令的作用跟`mov %ebp, %esp`和`pop %ebp`两条指令是等效的（而且还省了两个字节）。\n\n至于最终结果如何，至少以上两种方法`make grade`是满分的，而且理论上这两种方法是等效的。\n\n但是为什么不加`mov %ebp, %esp`的话输出是正确的，`make grade`却不是满分，这就需要进一步的研究了。\n\n注：反汇编的指令为`objdump -d obj/kern/init/init.o`\n\n#### 参考文献\n\n* [函数栈&EIP、EBP、ESP寄存器的作用 | kTWO-个人博客](https://www.k2zone.cn/?p=1911)\n* [Intel 64 and IA-32 Architectures Software Developer's Manual](https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf)\n\n#### 致谢\n\n感谢群友 *阿日哥i*、*380169993*、*红色石头* 对我的帮助、指点。</md>"}], "type": "note", "tags": ["lab1", "student", "特权级"], "tag_good": [{"role": "student", "name": "xzmsybzx", "endorser": {}, "admin": false, "photo": null, "id": "kbkuu50z39x67", "photo_url": null, "published": true, "us": false, "facebook_id": null}, {"role": "student", "name": "yanglei", "endorser": {}, "admin": false, "photo": null, "id": "korxkw8knhl7c1", "photo_url": null, "us": false, "facebook_id": null}], "unique_views": 131, "children": [], "tag_good_arr": ["kbkuu50z39x67", "korxkw8knhl7c1"], "id": "karfzerzmav7dc", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 2, "num_favorites": 3, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643170126054, "default_anonymity": "no"}, "error": null, "aid": "kyv12fomb5g3lf"}