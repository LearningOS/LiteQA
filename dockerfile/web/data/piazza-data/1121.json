{"result": {"folders": ["lecture12"], "nr": 1121, "data": {"embed_links": []}, "created": "2018-02-08T03:35:05Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "j8ik4z78uIx", "data": "jddy9n5f2yodo", "type": "create", "when": "2018-02-08T03:35:05Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "data": "jddyt5sl6zj4o", "type": "update", "when": "2018-02-08T03:50:15Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "jddy9n5c1pwdn", "type": "followup", "when": "2018-02-08T03:59:31Z"}, {"anon": "no", "uid": "jd612gjswfy2qt", "to": "jddy9n5c1pwdn", "type": "followup", "when": "2018-02-26T16:57:47Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "关于fork进程创建和进程上下文切换时现场保存的个人理解", "created": "2018-02-08T03:50:15Z", "content": "<p></p>\n<p>本文针对以下三个容易混淆和出错的问题&#xff1a;</p>\n<p>&#xff08;1&#xff09;Unix系统中用fork()创建新进程时&#xff0c;要复制父进程内存&#xff0c;父进程的页表是不能完全复制的吧&#xff1f;</p>\n<p>&#xff08;2&#xff09;进程切换过程中的上下文信息保存与恢复&#xff0c;必须在内核态吗&#xff1f;</p>\n<p>&#xff08;3&#xff09;信号量和管程机制是否可以相互实现&#xff0c;有没有确定的答案和证明&#xff1f;</p>\n<p>首先理解以下概念&#xff1a;</p>\n<p><b>一、进程控制块</b><b></b></p>\n<p>进程控制块&#xff1a;PCB是操作系统管理控制进程运行所有的信息集合&#xff0c;主要包括进程描述信息、进程控制和管理信息、资源分配清单和处理机相关信息等&#xff0c;是进程实体的一部分&#xff0c;进程存在的唯一标志。</p>\n<p>PCB是进程在内存中的静态存在方式&#xff0c;因此进程的静态描述符必须保证一个进程在获得CPU并重新进入运行态时&#xff0c;能够精确的接着上次运行的位置继续运行&#xff0c;相关的程序段、数据以及CPU现场信息都要保存下来&#xff0c;CPU的现场信息主要包括内部寄存器和堆栈的基本数据。</p>\n<p><b>二、进程上下文</b><b></b></p>\n<p>进程上下文&#xff1a;当程序执行了系统调用或中断而进入内核态时&#xff0c;进程切换现场就称为进程上下文&#xff0c;包含了一个进程所具有的全部信息&#xff0c;一般包括&#xff1a;进程控制块&#xff08;PCB&#xff09;、有关程序段和相应的数据集。</p>\n<p><b>三、进程堆栈</b><b></b></p>\n<p>进程的堆栈&#xff1a;内核在创建进程的时候&#xff0c;会为进程创建相应的堆栈。每个进程会有两个栈&#xff0c;一个用户栈&#xff0c;存在于用户空间&#xff0c;一个内核栈&#xff0c;存在于内核空间。当进程在用户空间运行时&#xff0c;cpu堆栈指针寄存器里面的内容是用户堆栈地址&#xff0c;使用用户栈&#xff1b;当进程在内核空间时&#xff0c;cpu堆栈指针寄存器里面的内容是内核栈空间地址&#xff0c;使用内核栈。</p>\n<p>进程用户栈和内核栈的切换&#xff1a;当进程因中断或系统调用而陷入内核态运行时&#xff0c;进程所使用的堆栈也要从用户栈转到内核栈。</p>\n<p>进程进入内核态后&#xff0c;先把用户态堆栈的地址保存在内核栈之中&#xff0c;然后设置堆栈指针寄存器的内容为内核栈的地址&#xff0c;完成用户栈向内核栈的转换&#xff1b;当进程从内核态恢复到用户态之行时&#xff0c;在内核态之行的最后将保存在内核栈里面的用户栈的地址恢复到堆栈指针寄存器&#xff0c;实现内核栈和用户栈的互转。</p>\n<p>那么&#xff0c;我们知道从内核转到用户态时用户栈的地址是在陷入内核的时候保存在内核栈里面的&#xff0c;但是在陷入内核的时候&#xff0c;我们是如何知道内核栈的地址的呢&#xff1f;</p>\n<p>关键在进程从用户态转到内核态的时候&#xff0c;进程的内核栈总是空的。这是因为&#xff0c;当进程在用户态运行时&#xff0c;使用的是用户栈&#xff0c;当进程陷入到内核态时&#xff0c;内核栈保存进程在内核态运行的相关信息&#xff0c;但是一旦进程返回到用户态后&#xff0c;内核栈中保存的信息无效&#xff0c;会全部恢复&#xff0c;因此每次进程从用户态陷入内核的时候得到的内核栈都是空的。所以在进程陷入内核的时候&#xff0c;直接把内核栈的栈顶地址给堆栈指针寄存器就可以了。</p>\n<p><b>对三个问题的分析如下&#xff1a;</b><b></b></p>\n<p>&#xff08;1&#xff09;Unix系统中用fork()创建新进程时&#xff0c;要复制父进程内存&#xff0c;父进程的页表是不能完全复制的吧&#xff1f;</p>\n<p>解析&#xff1a;</p>\n<p>Unix进程创建系统调用fork()在创建一个继承的子进程时&#xff0c;需要复制父进程的相关信息&#xff0c;包括父进程的所有变量和内存、父进程的所有cpu寄存器。但是父进程在创建子进程时&#xff0c;肯定会创建子进程的PCB和内核堆栈等与父进程不一样的信息&#xff0c;这些信息在内存中的页面与进程是不一样的&#xff0c;因为父进程的页表存储的是父进程的内存地址空间&#xff0c;既然子进程的内存地址空间发生了变化&#xff0c;子进程就不能完全复制父进程的页表。</p>\n<p> </p>\n<p>&#xff08;2&#xff09;进程切换过程中的上下文信息保存与恢复&#xff0c;必须在内核态吗&#xff1f;</p>\n<p>解析&#xff1a;</p>\n<p>用户进程既有用户空间信息也有内核空间信息&#xff0c;在进程切换过程中&#xff0c;进程的所有信息都要保存&#xff0c;但用户空间的信息&#xff08;用户堆栈、用户数据等&#xff09;是保存存在用户空间&#xff0c;传递地址给内核&#xff0c;只有内核空间的信息保存在内核态。因此&#xff0c;我的理解是进程切换肯定是要内核参与&#xff0c;但上下文信息并非全部保存在内核空间。</p>\n<p>鉴于此&#xff0c;一、进程切换时的现场保存一定在内核中的进程控制块中&#xff1b;二、进程切换的现场保存必须在内核态。这两种说法都是不对的。</p>\n<p>&#xff08;3&#xff09;信号量和管程机制是否可以相互实现&#xff0c;有没有确定的答案和证明&#xff1f;</p>\n<p>解析&#xff1a;</p>\n<p>信号量和管程机制在使用上可以等价&#xff0c;可以基于一种机制来实现另外一种机制&#xff0c;具体实现和证明咱略。</p>\n<p><b>鉴于自身对操作系统的理解有限&#xff0c;对概念和问题的解析若有不足之处&#xff0c;欢迎留言指正。</b></p>\n<p><b></b></p>\n<p><b><a href=\"https://www.piazza.com/class/i5j09fnsl7k5x0?cid=1121\">https://piazza.com/class/i5j09fnsl7k5x0?cid=1121</a></b></p>\n<p><b></b></p>\n<p><b><a href=\"http://blog.csdn.net/feixuedongji/article/details/79287891\">http://blog.csdn.net/feixuedongji/article/details/79287891</a></b></p>\n<p><b></b></p>"}, {"anon": "no", "uid": "j8ik4z78uIx", "subject": "关于fork进程创建和进程上下文切换时现场保存的个人理解", "created": "2018-02-08T03:35:05Z", "content": "<p></p><p>本文针对以下三个容易混淆和出错的问题&#xff1a;</p>\n<p>&#xff08;1&#xff09;Unix系统中用fork()创建新进程时&#xff0c;要复制父进程内存&#xff0c;父进程的页表是不能完全复制的吧&#xff1f;</p>\n<p>&#xff08;2&#xff09;进程切换过程中的上下文信息保存与恢复&#xff0c;必须在内核态吗&#xff1f;</p>\n<p>&#xff08;3&#xff09;信号量和管程机制是否可以相互实现&#xff0c;有没有确定的答案和证明&#xff1f;</p>\n<p>首先理解以下概念&#xff1a;</p>\n<p><b>一、进程控制块</b><b></b></p>\n<p>进程控制块&#xff1a;PCB是操作系统管理控制进程运行所有的信息集合&#xff0c;主要包括进程描述信息、进程控制和管理信息、资源分配清单和处理机相关信息等&#xff0c;是进程实体的一部分&#xff0c;进程存在的唯一标志。</p>\n<p>PCB是进程在内存中的静态存在方式&#xff0c;因此进程的静态描述符必须保证一个进程在获得CPU并重新进入运行态时&#xff0c;能够精确的接着上次运行的位置继续运行&#xff0c;相关的程序段、数据以及CPU现场信息都要保存下来&#xff0c;CPU的现场信息主要包括内部寄存器和堆栈的基本数据。</p>\n<p><b>二、进程上下文</b><b></b></p>\n<p>进程上下文&#xff1a;当程序执行了系统调用或中断而进入内核态时&#xff0c;进程切换现场就称为进程上下文&#xff0c;包含了一个进程所具有的全部信息&#xff0c;一般包括&#xff1a;进程控制块&#xff08;PCB&#xff09;、有关程序段和相应的数据集。</p>\n<p><b>三、进程堆栈</b><b></b></p>\n<p>进程的堆栈&#xff1a;内核在创建进程的时候&#xff0c;会为进程创建相应的堆栈。每个进程会有两个栈&#xff0c;一个用户栈&#xff0c;存在于用户空间&#xff0c;一个内核栈&#xff0c;存在于内核空间。当进程在用户空间运行时&#xff0c;cpu堆栈指针寄存器里面的内容是用户堆栈地址&#xff0c;使用用户栈&#xff1b;当进程在内核空间时&#xff0c;cpu堆栈指针寄存器里面的内容是内核栈空间地址&#xff0c;使用内核栈。</p>\n<p>进程用户栈和内核栈的切换&#xff1a;当进程因中断或系统调用而陷入内核态运行时&#xff0c;进程所使用的堆栈也要从用户栈转到内核栈。</p>\n<p>进程进入内核态后&#xff0c;先把用户态堆栈的地址保存在内核栈之中&#xff0c;然后设置堆栈指针寄存器的内容为内核栈的地址&#xff0c;完成用户栈向内核栈的转换&#xff1b;当进程从内核态恢复到用户态之行时&#xff0c;在内核态之行的最后将保存在内核栈里面的用户栈的地址恢复到堆栈指针寄存器&#xff0c;实现内核栈和用户栈的互转。</p>\n<p>那么&#xff0c;我们知道从内核转到用户态时用户栈的地址是在陷入内核的时候保存在内核栈里面的&#xff0c;但是在陷入内核的时候&#xff0c;我们是如何知道内核栈的地址的呢&#xff1f;</p>\n<p>关键在进程从用户态转到内核态的时候&#xff0c;进程的内核栈总是空的。这是因为&#xff0c;当进程在用户态运行时&#xff0c;使用的是用户栈&#xff0c;当进程陷入到内核态时&#xff0c;内核栈保存进程在内核态运行的相关信息&#xff0c;但是一旦进程返回到用户态后&#xff0c;内核栈中保存的信息无效&#xff0c;会全部恢复&#xff0c;因此每次进程从用户态陷入内核的时候得到的内核栈都是空的。所以在进程陷入内核的时候&#xff0c;直接把内核栈的栈顶地址给堆栈指针寄存器就可以了。</p>\n<p><b>对三个问题的分析如下&#xff1a;</b><b></b></p>\n<p>&#xff08;1&#xff09;Unix系统中用fork()创建新进程时&#xff0c;要复制父进程内存&#xff0c;父进程的页表是不能完全复制的吧&#xff1f;</p>\n<p>解析&#xff1a;</p>\n<p>Unix进程创建系统调用fork()在创建一个继承的子进程时&#xff0c;需要复制父进程的相关信息&#xff0c;包括父进程的所有变量和内存、父进程的所有cpu寄存器。但是父进程在创建子进程时&#xff0c;肯定会创建子进程的PCB和内核堆栈等与父进程不一样的信息&#xff0c;这些信息在内存中的页面与进程是不一样的&#xff0c;因为父进程的页表存储的是父进程的内存地址空间&#xff0c;既然子进程的内存地址空间发生了变化&#xff0c;子进程就不能完全复制父进程的页表。</p>\n<p> </p>\n<p>&#xff08;2&#xff09;进程切换过程中的上下文信息保存与恢复&#xff0c;必须在内核态吗&#xff1f;</p>\n<p>解析&#xff1a;</p>\n<p>用户进程既有用户空间信息也有内核空间信息&#xff0c;在进程切换过程中&#xff0c;进程的所有信息都要保存&#xff0c;但用户空间的信息&#xff08;用户堆栈、用户数据等&#xff09;是保存存在用户空间&#xff0c;传递地址给内核&#xff0c;只有内核空间的信息保存在内核态。因此&#xff0c;我的理解是进程切换肯定是要内核参与&#xff0c;但上下文信息并非全部保存在内核空间。</p>\n<p>鉴于此&#xff0c;一、进程切换时的现场保存一定在内核中的进程控制块中&#xff1b;二、进程切换的现场保存必须在内核态。这两种说法都是不对的。</p>\n<p>&#xff08;3&#xff09;信号量和管程机制是否可以相互实现&#xff0c;有没有确定的答案和证明&#xff1f;</p>\n<p>解析&#xff1a;</p>\n<p>信号量和管程机制在使用上可以等价&#xff0c;可以基于一种机制来实现另外一种机制&#xff0c;具体实现和证明咱略。</p>\n<p><b>鉴于自身对操作系统的理解有限&#xff0c;对概念和问题的解析若有不足之处&#xff0c;欢迎留言指正。</b></p>"}], "type": "note", "tags": ["lecture12", "student"], "tag_good": [{"role": "instructor", "name": "Yong XIANG", "endorser": {}, "admin": true, "photo": null, "id": "hdjonbiyfs62ie", "photo_url": null, "us": false, "class_sections": ["课程设计_i5j09fnsl7k5x0", "清华学生_i5j09fnsl7k5x0", "所有老师和助教_i5j09fnsl7k5x0", "os2018spring_i5j09fnsl7k5x0"], "facebook_id": null}], "unique_views": 71, "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>很好。鼓励一下。</p>\n<p></p>\n<p>其次&#xff0c;目前的这个分析还需要进一步深入。如对照ucore的代码来分析上面的问题&#xff0c;进程切换的现场保存对应的数据结构是什么&#xff1f;现场保存和恢复代码在哪&#xff1f;</p>", "created": "2018-02-08T03:59:31Z", "bucket_order": 115, "bucket_name": "Week 2/4 - 2/10", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "jddz52fsox1b5", "updated": "2018-02-08T03:59:31Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>Linux内fork进程使用的是写时复制&#xff0c;未进行写之前子进程的页表映射到的物理内存地址和父进程的是一样的。</p>", "created": "2018-02-26T16:57:47Z", "bucket_order": 112, "bucket_name": "Week 2/25 - 3/3", "type": "followup", "tag_good": [], "uid": "jd612gjswfy2qt", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "je4gv9298pj72y", "updated": "2018-02-26T16:57:47Z", "config": {}}], "tag_good_arr": ["hdjonbiyfs62ie"], "id": "jddy9n5c1pwdn", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 3, "num_favorites": 2, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169160870, "default_anonymity": "no"}, "error": null, "aid": "kyv0hqxyh272c4"}