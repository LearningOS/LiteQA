{"result": {"folders": ["lecture9", "lecture10", "课堂问答", "2017"], "nr": 1020, "data": {"embed_links": []}, "created": "2017-03-23T23:37:29Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "izb0cbqbyzd6wf", "data": "j0n1fng6tgp39s", "type": "create", "when": "2017-03-23T23:37:29Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "data": "j0n3lv421jz785", "type": "update", "when": "2017-03-24T00:38:18Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "data": "j0nb9yo47gg30z", "type": "update", "when": "2017-03-24T04:13:00Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "data": "j0nbav29vdu3g5", "type": "update", "when": "2017-03-24T04:13:42Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j0n1fng25x739r", "type": "followup", "when": "2017-03-24T04:14:11Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j0n1fng25x739r", "type": "followup", "when": "2017-03-24T04:14:52Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j0n1fng25x739r", "type": "followup", "when": "2017-03-24T04:15:16Z"}, {"anon": "no", "uid": "ie7xy0nh1811ls", "to": "j0n1fng25x739r", "type": "feedback", "when": "2017-03-24T06:53:27Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j0n1fng25x739r", "type": "followup", "when": "2017-03-24T06:53:27Z"}, {"anon": "no", "uid": "ie7xy5sipx51qz", "to": "j0n1fng25x739r", "type": "feedback", "when": "2017-03-24T06:53:41Z"}, {"anon": "no", "uid": "ie7xy1b3f61mi", "to": "j0n1fng25x739r", "type": "feedback", "when": "2017-03-24T06:55:54Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j0n1fng25x739r", "type": "followup", "when": "2017-03-24T06:57:36Z"}, {"anon": "no", "uid": "i5g31e12hcr27s", "to": "j0n1fng25x739r", "type": "feedback", "when": "2017-03-24T06:58:38Z"}, {"anon": "no", "uid": "ie7xy5cvsc61qg", "to": "j0n1fng25x739r", "type": "feedback", "when": "2017-03-24T06:59:48Z"}, {"anon": "no", "uid": "izb0cbkdd5s6w9", "to": "j0n1fng25x739r", "type": "feedback", "when": "2017-03-24T07:00:57Z"}, {"anon": "no", "uid": "j4jh19edeys5vw", "data": "j5ibuki4irc82", "type": "update", "when": "2017-07-24T15:48:42Z"}, {"anon": "no", "uid": "j4jh19edeys5vw", "data": "j5ibusvn389x", "type": "update", "when": "2017-07-24T15:48:53Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "j4jh19edeys5vw", "subject": "[总结] 虚拟存储管理中的辅助数据结构", "created": "2017-07-24T15:48:53Z", "content": "<p>虚拟页式存储管理时, 页表并不能储存所有信息且使它们便于维护, 所以需要使用额外的数据结构.</p>\n<p></p>\n<p>这些数据结构包括但不限于: 空闲页链表, 页置换算法中的各种数据结构.</p>\n<p></p>\n<p>这些数据结构往往使用内核空间中的一段内存, 在一定情况下它们可能被置换到外存.</p>\n<p></p>\n<p>对数据结构的利用视情况不同, 可以在不同的地方调用. 例如在访存时需要的算法较快, 因为访存量非常大. 而缺页中断时的算法可略复杂一些.</p>\n<p></p>\n<p>扩展: 磁盘缓存. 使用内存模拟外存, 提高外存 IO 速度. 这与虚拟内存不矛盾. 都是为了提高硬件利用效率. LRU 算法在这里会被用到.</p>\n<p></p>\n<p>向勇的注&#xff1a;</p>\n<ul><li>请有兴趣的同学尝试枚举ucore中与虚拟存储管理相关的主要数据结构&#xff0c;并说明它们会在什么时候被哪些代码所访问。</li><li></li></ul>"}, {"anon": "no", "uid": "j4jh19edeys5vw", "subject": "[总结] 虚拟存储管理中的辅助数据结构", "created": "2017-07-24T15:48:42Z", "content": "<p>虚拟页式存储管理时, 页表并不能储存所有信息且使它们便于维护, 所以需要使用额外的数据结构.</p>\n<p></p>\n<p>这些数据结构包括但不限于: 空闲页链表, 页置换算法中的各种数据结构.</p>\n<p></p>\n<p>这些数据结构往往使用内核空间中的一段内存, 在一定情况下它们可能被置换到外存.</p>\n<p></p>\n<p>对数据结构的利用视情况不同, 可以在不同的地方调用. 例如在访存时需要的算法较快, 因为访存量非常大. 而缺页中断时的算法可略复杂一些.</p>\n<p></p>\n<p>扩展: 磁盘缓存. 使用内存模拟外存, 提高外存 IO 速度. 这与虚拟内存不矛盾. 都是为了提高硬件利用效率. LRU 算法在这里会被用到.</p>\n<p></p>\n<p>向勇的注&#xff1a;</p>\n<ul><li>请有兴趣的同学尝试枚举ucore中与虚拟存储管理相关的主要数据结构&#xff0c;并说明它们会在什么时候被哪些代码所访问。</li><li></li></ul>"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "[总结] 虚拟存储管理中的辅助数据结构", "created": "2017-03-24T04:13:42Z", "content": "<p>虚拟页式存储管理时, 页表并不能储存所有信息且使它们便于维护, 所以需要使用额外的数据结构.</p>\n<p></p>\n<p>这些数据结构包括但不限于: 空闲页链表, 页置换算法中的各种数据结构.</p>\n<p></p>\n<p>这些数据结构往往使用内核空间中的一段内存, 在一定情况下它们可能被置换到外存.</p>\n<p></p>\n<p>对数据结构的利用视情况不同, 可以在不同的地方调用. 例如在访存时需要的算法较快, 因为访存量非常大. 而缺页中断时的算法可略复杂一些.</p>\n<p></p>\n<p>扩展: 磁盘缓存. 使用内存模拟外存, 提高外存 IO 速度. 这与虚拟内存不矛盾. 都是为了提高硬件利用效率. LRU 算法在这里会被用到.</p>\n<p></p>\n<p>向勇的注&#xff1a;</p>\n<ul><li>请有兴趣的同学尝试枚举ucore中与虚拟存储管理相关的主要数据结构&#xff0c;并说明它们会在什么时候被哪些代码所访问。</li><li></li></ul>"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "[总结] 虚拟存储管理中的辅助数据结构", "created": "2017-03-24T04:13:00Z", "content": "<p>虚拟页式存储管理时, 页表并不能储存所有信息且使它们便于维护, 所以需要使用额外的数据结构.</p>\n<p></p>\n<p>这些数据结构包括但不限于: 空闲页链表, 页置换算法中的各种数据结构.</p>\n<p></p>\n<p>这些数据结构往往使用内核空间中的一段内存, 在一定情况下它们可能被置换到外存.</p>\n<p></p>\n<p>对数据结构的利用视情况不同, 可以在不同的地方调用. 例如在访存时需要的算法较快, 因为访存量非常大. 而缺页中断时的算法可略复杂一些.</p>\n<p></p>\n<p>扩展: 磁盘缓存. 使用内存模拟外存, 提高外存 IO 速度. 这与虚拟内存不矛盾. 都是为了提高硬件利用效率. LRU 算法在这里会被用到.</p>\n<p></p>\n<p>向勇的注&#xff1a;</p>\n<ul><li>请有兴趣的同学尝试枚举ucore中与虚拟存储管理相关的主要数据结构&#xff0c;并说明它们会在什么时候被哪些代码所访问。</li></ul>"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "[总结] 虚拟存储管理中的辅助数据结构", "created": "2017-03-24T00:38:18Z", "content": "<p>虚拟页式存储管理时, 页表并不能储存所有信息且使它们便于维护, 所以需要使用额外的数据结构.</p>\n<p></p>\n<p>这些数据结构包括但不限于: 空闲页链表, 页置换算法中的各种数据结构.</p>\n<p></p>\n<p>这些数据结构往往使用内核空间中的一段内存, 在一定情况下它们可能被置换到外存.</p>\n<p></p>\n<p>对数据结构的利用视情况不同, 可以在不同的地方调用. 例如在访存时需要的算法较快, 因为访存量非常大. 而缺页中断时的算法可略复杂一些.</p>\n<p></p>\n<p>扩展: 磁盘缓存. 使用内存模拟外存, 提高外存 IO 速度. 这与虚拟内存不矛盾. 都是为了提高硬件利用效率. LRU 算法在这里会被用到.</p>\n<p></p>\n<p>向勇的注&#xff1a;</p>\n<ul><li>请有兴趣的同学尝试枚举ucore中与虚拟存储管理相关的主要数据结构&#xff0c;并说明它们会在什么时候被哪些代码所访问。</li></ul>"}, {"anon": "no", "uid": "izb0cbqbyzd6wf", "subject": "[总结] 内存管理中的辅助数据结构", "created": "2017-03-23T23:37:29Z", "content": "<p>内存管理时, 页表有时候不能储存所有信息且使它们便于维护, 所以需要使用额外的数据结构.</p>\n<p></p>\n<p>这些数据结构包括但不限于: 空闲页链表, 页置换算法中的各种数据结构.</p>\n<p></p>\n<p>这些数据结构往往使用内核空间中的一段内存, 在一定情况下它们可能被置换到外存.</p>\n<p></p>\n<p>对数据结构的利用视情况不同, 可以在不同的地方调用. 例如在访存时需要的算法较快, 因为访存量非常大. 而缺页中断时的算法可略复杂一些.</p>\n<p></p>\n<p>扩展: 磁盘缓存. 使用内存模拟外存, 提高外存 IO 速度. 这与虚拟内存不矛盾. 都是为了提高硬件利用效率. LRU 算法在这里会被用到.</p>"}], "type": "note", "tags": ["2017", "lecture10", "lecture9", "student", "课堂问答"], "tag_good": [{"role": "instructor", "name": "Yong XIANG", "endorser": {}, "admin": true, "photo": null, "id": "hdjonbiyfs62ie", "photo_url": null, "us": false, "class_sections": ["课程设计_i5j09fnsl7k5x0", "清华学生_i5j09fnsl7k5x0", "所有老师和助教_i5j09fnsl7k5x0", "os2018spring_i5j09fnsl7k5x0"], "facebook_id": null}], "unique_views": 168, "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>swap_manager</p>", "created": "2017-03-24T04:14:11Z", "bucket_order": 166, "bucket_name": "Week 3/19 - 3/25", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>swap_manager出现于</p>\n<ul><li>kern/mm/swap.h</li><li>kern/mm/swap.c</li><li>kern/mm/swap_fifo.h</li><li>kern/mm/swap_fifo.c</li></ul>\n<p>性质类似于在lab2中填空的pmm_manager&#xff0c;是一组抽象的接口&#xff0c;需要具体实现。在lab3中实现为swap_manager_fifo。</p>", "created": "2017-03-24T06:53:27Z", "bucket_order": 166, "bucket_name": "Week 3/19 - 3/25", "type": "feedback", "tag_good": [], "uid": "ie7xy0nh1811ls", "children": [], "tag_good_arr": [], "id": "j0nh0b0kydc551", "updated": "2017-03-24T06:53:27Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<code>swap_manager</code>在<code>swap.h</code>中的定义为&#xff1a;\n<pre>struct swap_manager\n{\n     const char *name;\n     /* Global initialization for the swap manager */\n     int (*init)            (void);\n     /* Initialize the priv data inside mm_struct */\n     int (*init_mm)         (struct mm_struct *mm);\n     /* Called when tick interrupt occured */\n     int (*tick_event)      (struct mm_struct *mm);\n     /* Called when map a swappable page into the mm_struct */\n     int (*map_swappable)   (struct mm_struct *mm, uintptr_t addr, struct Page *page, int swap_in);\n     /* When a page is marked as shared, this routine is called to\n      * delete the addr entry from the swap manager */\n     int (*set_unswappable) (struct mm_struct *mm, uintptr_t addr);\n     /* Try to swap out a page, return then victim */\n     int (*swap_out_victim) (struct mm_struct *mm, struct Page **ptr_page, int in_tick);\n     /* check the page relpacement algorithm */\n     int (*check_swap)(void);     \n};</pre>\n\n在<code>swap_init()</code>中&#xff0c;会访问<code>sm-&gt;init()</code>函数&#xff0c;初始化<code>swap_manager</code>。", "created": "2017-03-24T06:53:41Z", "bucket_order": 166, "bucket_name": "Week 3/19 - 3/25", "type": "feedback", "tag_good": [], "uid": "ie7xy5sipx51qz", "children": [], "tag_good_arr": [], "id": "j0nh0lpbbrf1wc", "updated": "2017-03-24T06:53:41Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "j0nbbh431ot59a", "updated": "2017-03-24T04:14:11Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>vma_struct</p>", "created": "2017-03-24T04:14:52Z", "bucket_order": 166, "bucket_name": "Week 3/19 - 3/25", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>kern/mm/vmm.c: vma_create, find_vma, insert_vma_struct, mm_destroy, do_pagefault</p>", "created": "2017-03-24T06:59:48Z", "bucket_order": 166, "bucket_name": "Week 3/19 - 3/25", "type": "feedback", "tag_good": [], "uid": "ie7xy5cvsc61qg", "children": [], "tag_good_arr": [], "id": "j0nh8gv7iz36bb", "updated": "2017-03-24T06:59:48Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<pre>// the virtual continuous memory area(vma)\nstruct vma_struct {\n    struct mm_struct *vm_mm; // the set of vma using the same PDT \n    uintptr_t vm_start;      //    start addr of vma    \n    uintptr_t vm_end;        // end addr of vma\n    uint32_t vm_flags;       // flags of vma\n    list_entry_t list_link;  // linear list link which sorted by start addr of vma\n};</pre>\n<p>以上是vmm.h中对vma_struct的定义&#xff0c;包含了一个mm_struct的对象和一个list_entry_t的对象</p>\n<pre>struct vma_struct *find_vma(struct mm_struct *mm, uintptr_t addr);\nstruct vma_struct *vma_create(uintptr_t vm_start, uintptr_t vm_end, uint32_t vm_flags);\nvoid insert_vma_struct(struct mm_struct *mm, struct vma_struct *vma);</pre>\n<p>以上是vma_struct的3个重要的函数接口</p>", "created": "2017-03-24T07:00:57Z", "bucket_order": 166, "bucket_name": "Week 3/19 - 3/25", "type": "feedback", "tag_good": [], "uid": "izb0cbkdd5s6w9", "children": [], "tag_good_arr": [], "id": "j0nh9ybqqes79n", "updated": "2017-03-24T07:00:57Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "j0nbccu2ria43x", "updated": "2017-03-24T04:14:52Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>mm_struct</p>", "created": "2017-03-24T04:15:16Z", "bucket_order": 166, "bucket_name": "Week 3/19 - 3/25", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>mm_struct定义在vmm.h中</p>\n<pre>// the control struct for a set of vma using the same PDT\nstruct mm_struct {\nlist_entry_t mmap_list; // linear list link which sorted by start addr of vma\nstruct vma_struct *mmap_cache; // current accessed vma, used for speed purpose\npde_t *pgdir; // the PDT of these vma\nint map_count; // the count of these vma\nvoid *sm_priv; // the private data for swap manager\n};</pre>\n<p></p>", "created": "2017-03-24T06:58:38Z", "bucket_order": 166, "bucket_name": "Week 3/19 - 3/25", "type": "feedback", "tag_good": [], "uid": "i5g31e12hcr27s", "children": [], "tag_good_arr": [], "id": "j0nh6yuop1j5m6", "updated": "2017-03-24T06:58:38Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "j0nbcvzn5cw64x", "updated": "2017-03-24T04:15:16Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>struct Page</p>", "created": "2017-03-24T06:53:27Z", "bucket_order": 166, "bucket_name": "Week 3/19 - 3/25", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>struct Page结构定义在&#96;mm/memlayout.h&#96;中</p>\n<p></p>\n<pre>struct Page {\n\tint ref; \t\t// page frame&#39;s reference counter\n\tuint32_t flags; \t// array of flags that describe the status of the page frame\n\tunsigned int property; \t// the num of free block, used in first fit pm manager\n\tlist_entry_t page_link; // free list link\n};</pre>\n<p>每个Page的对象对应一个实际的物理页面&#xff0c;因此在涉及到物理页相关操作时&#xff0c;都会涉及到此结构&#xff0c;例如&#xff1a;</p>\n<pre> - uintptr_t page2pa(struct Page *page) \t// get the physical address of memory which this (struct Page *) page  manages\n - struct Page * pa2page(uintptr_t pa) \t// get the according page from the value of a va\n - void *page2kva(struct Page *page) \t\t// get the kernel virtual address of memory which this (struct Page *) page  manages\n - struct Page *kva2page(void *kva) \t\t//get the according page from the value of a kva\n - struct Page *pte2page(pte_t pte) \t\t//get the according page from the value of a pte\n - struct Page *pde2page(pde_t pde) \t\t// get the according page from the value of a pde</pre>\n<p></p>", "created": "2017-03-24T06:55:54Z", "bucket_order": 166, "bucket_name": "Week 3/19 - 3/25", "type": "feedback", "tag_good": [], "uid": "ie7xy1b3f61mi", "children": [], "tag_good_arr": [], "id": "j0nh3g6qevp5lb", "updated": "2017-03-24T06:55:54Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "j0nh0b3anp8552", "updated": "2017-03-24T06:53:27Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>typedef uintptr_t pte_t;<br />typedef uintptr_t pde_t;<br />typedef uintptr_t pud_t;<br />typedef uintptr_t pmd_t;<br />typedef uintptr_t pgd_t;<br />typedef pte_t swap_entry_t; //the pte can also be a swap entry</p>", "created": "2017-03-24T06:57:36Z", "bucket_order": 166, "bucket_name": "Week 3/19 - 3/25", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "j0nh5n52nfl5a3", "updated": "2017-03-24T06:57:36Z", "config": {}}], "tag_good_arr": ["hdjonbiyfs62ie"], "id": "j0n1fng25x739r", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 14, "num_favorites": 3, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643168987624, "default_anonymity": "no"}, "error": null, "aid": "kyv0e19k8reol"}