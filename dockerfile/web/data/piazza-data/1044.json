{"result": {"folders": ["lecture13", "2017"], "nr": 1044, "data": {"embed_links": []}, "created": "2017-04-11T05:40:48Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "ikjdo9jtz0e2jq", "data": "j1d4c7s9yny18i", "type": "create", "when": "2017-04-11T05:40:48Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "data": "j1dpam2suczaw", "type": "update", "when": "2017-04-11T15:27:26Z"}, {"anon": "no", "uid": "jsl9bhefCIIS", "to": "j1d4c7s76qf18h", "type": "followup", "when": "2019-04-11T01:12:37Z"}, {"anon": "no", "uid": "jsl9bhefCIIS", "to": "j1d4c7s76qf18h", "type": "feedback", "when": "2019-04-14T16:49:29Z"}, {"anon": "no", "uid": "k6oh4mhvehk4r5", "to": "j1d4c7s76qf18h", "type": "followup", "when": "2020-03-23T12:28:14Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "理解Lab4中的第一次线程切换", "created": "2017-04-11T15:27:26Z", "content": "<p>一、在kern_init--&gt;proc_init--&gt;kernel_thread函数中&#xff0c;创建了一个虚假的trapframe tf&#xff0c;并做了几件重要事情&#xff1a;</p>\n<p>1. 将tf中的reg_ebx设为fn&#xff08;即init_main&#xff09;&#xff0c;</p>\n<p>2. 将tf中的reg_edx设为fn的args&#xff0c;</p>\n<p>3. 将tf中的tf_eip设为kernel_thread_entry&#xff1b;</p>\n<p>二、然后在do_fork--&gt;copy_thread函数中&#xff0c;将以上tf拷贝给子进程的proc-&gt;tf&#xff0c;并将proc-&gt;context.eip设为forkret。&#xff08;注意tf.tf_eip和proc-&gt;context.eip不同&#xff09;</p>\n<p>三、然后在kern_init--&gt;cpu_idle--&gt;schedule--&gt;proc_run--&gt;switch_to函数中&#xff0c;通过汇编next-&gt;context.eip压栈&#xff0c;即将返回地址的内容篡改成forkret。通过switch_to函数最后的ret指令&#xff0c;执行流程到达forkret。</p>\n<p>四、forkret调用forkerts&#xff0c;这个汇编函数将esp设为了上述的虚假trapframe&#xff0c;用popal指令将寄存器值设成了该trapframe中的值&#xff0c;然后iret指令返回到了tf.tf_eip即kernel_thread_entry。</p>\n<p>五、在kernel_thread_entry中先将edx&#xff08;即args&#xff09;压栈&#xff0c;然后调用ebx函数&#xff08;即init_main&#xff09;函数&#xff0c;最后调用do_exit函数。</p>\n<p>六、不敢说以上过程全面透彻&#xff0c;欢迎补充。</p>"}, {"anon": "no", "uid": "ikjdo9jtz0e2jq", "subject": "理解Lab4中的第一次线程切换", "created": "2017-04-11T05:40:48Z", "content": "<p>一、在kern_init--&gt;proc_init--&gt;kernel_thread函数中&#xff0c;创建了一个虚假的trapframe tf&#xff0c;并做了几件重要事情&#xff1a;</p>\n<p>1. 将tf中的reg_ebx设为fn&#xff08;即init_main&#xff09;&#xff0c;</p>\n<p>2. 将tf中的reg_edx设为fn的args&#xff0c;</p>\n<p>3. 将tf中的tf_eip设为kernel_thread_entry&#xff1b;</p>\n<p>二、然后在do_fork--&gt;copy_thread函数中&#xff0c;将以上tf拷贝给子进程的proc-&gt;tf&#xff0c;并将proc-&gt;context.eip设为forkret。&#xff08;注意tf.tf_eip和proc-&gt;context.eip不同&#xff09;</p>\n<p>三、然后在kern_init--&gt;cpu_idle--&gt;schedule--&gt;proc_run--&gt;switch_to函数中&#xff0c;通过汇编next-&gt;context.eip压栈&#xff0c;即将返回地址的内容篡改成forkret。通过switch_to函数最后的ret指令&#xff0c;执行流程到达forkret。</p>\n<p>四、forkret调用forkerts&#xff0c;这个汇编函数将esp设为了上述的虚假trapframe&#xff0c;用popal指令将寄存器值设成了该trapframe中的值&#xff0c;然后iret指令返回到了tf.tf_eip即kernel_thread_entry。</p>\n<p>五、在kernel_thread_entry中先将edx&#xff08;即args&#xff09;压栈&#xff0c;然后调用ebx函数&#xff08;即init_main&#xff09;函数&#xff0c;最后调用do_exit函数。</p>\n<p>六、不敢说以上过程全面透彻&#xff0c;欢迎补充。</p>"}], "type": "note", "tags": ["2017", "lecture13", "student"], "tag_good": [{"role": "instructor", "name": "Yong XIANG", "endorser": {}, "admin": true, "photo": null, "id": "hdjonbiyfs62ie", "photo_url": null, "us": false, "class_sections": ["课程设计_i5j09fnsl7k5x0", "清华学生_i5j09fnsl7k5x0", "所有老师和助教_i5j09fnsl7k5x0", "os2018spring_i5j09fnsl7k5x0"], "facebook_id": null}, {"role": "student", "name": "twinsnan", "endorser": {}, "admin": false, "photo": null, "id": "jozr6mfkHcxR", "photo_url": null, "published": true, "us": false, "facebook_id": null}], "unique_views": 157, "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p></p>", "created": "2019-04-11T01:12:37Z", "bucket_order": 77, "bucket_name": "Week 4/7 - 4/13", "type": "followup", "tag_good": [], "uid": "jsl9bhefCIIS", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>在这里对第一次线程切换与kernel_thread函数在代码层面上进行较为详细的分析</p>\n<p>先找到./kern/process/proc.c中的kernel_thread函数&#xff0c;代码如下&#xff1a;</p>\n<p>int<br />kernel_thread(int (*fn)(void *), void *arg, uint32_t clone_flags) {<br />    struct trapframe tf;<br />    memset(&amp;tf, 0, sizeof(struct trapframe));<br />    tf.tf_cs = KERNEL_CS;<br />    tf.tf_ds = tf.tf_es = tf.tf_ss = KERNEL_DS;<br />    tf.tf_regs.reg_ebx = (uint32_t)fn;<br />    tf.tf_regs.reg_edx = (uint32_t)arg;<br />    tf.tf_eip = (uint32_t)kernel_thread_entry;<br />    return do_fork(clone_flags | CLONE_VM, 0, &amp;tf);<br />}</p>\n<p>发现传入了三个参数fn、arg、clone_flags。我想了解一下传入的这三个参数的含义&#xff0c;就去找了调用它的位置&#xff0c;代码如下&#xff1a;</p>\n<p>void<br />proc_init(void) {</p>\n<p>    ...</p>\n<p>    int pid = kernel_thread(init_main, &#34;Hello world!!&#34;, 0);</p>\n<p>    ...</p>\n<p>}</p>\n<p>第一个参数是./kern/process/proc.c中的一个函数&#xff0c;找到其代码&#xff1a;</p>\n<p>static int<br />init_main(void *arg) {<br />    cprintf(&#34;this initproc, pid = %d, name = \\&#34;%s\\&#34;\\n&#34;, current-&gt;pid, get_proc_name(current));<br />    cprintf(&#34;To U: \\&#34;%s\\&#34;.\\n&#34;, (const char *)arg);<br />    cprintf(&#34;To U: \\&#34;en.., Bye, Bye. :)\\&#34;\\n&#34;);<br />    return 0;<br />}</p>\n<p>没有实际作用&#xff0c;只是表示第二个内核线程init_main在proc_init函数中被创建成功</p>\n<p>第二个参数是一个字符串&#xff0c;第三个参数为0</p>\n<p>再回到kernel_thread函数&#xff0c;先创建了一个虚假的trapframe tf&#xff0c;然后用memset对tf进行初始化&#xff0c;接下来是对CS、DS、ES、FS进行初始化&#xff0c;将内核中的段寄存器赋值给tf的段寄存器。接下来是将tf中的reg_ebx设为fn&#xff0c;将tf中的reg_edx设为arg&#xff0c;将eip设为kernel_thread_entry&#xff0c;即CPU下一条即将读取的指令&#xff0c;该指令在./kern/process/entry.S中&#xff0c;代码如下&#xff1a;</p>\n<p>.text<br />.globl kernel_thread_entry<br />kernel_thread_entry: # void kernel_thread(void)</p>\n<p>pushl %edx # push arg<br /> call *%ebx # call fn</p>\n<p>pushl %eax # save the return value of fn(arg)<br /> call do_exit # call do_exit to terminate current thread</p>\n<p>可以看到该函数将刚存入edx的字符串压栈&#xff0c;并调用存入ebx的init_main函数&#xff0c;表示创建第二个内核线程init_main。</p>\n<p>最后返回do_fork(clone_flags | CLONE_VM, 0, &amp;tf)进行线程的复制&#xff0c;并将刚初始化的trapframe tf作为父进程传入do_fork函数&#xff0c;代码如下&#xff1a;</p>\n<p>do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf) {</p>\n<p>    struct proc_struct *proc;</p>\n<p>    ...</p>\n<p>    copy_thread(proc, stack, tf)</p>\n<p>    ...</p>\n<p>}</p>\n<p>在do_fork函数中先创建了一个进程控制块struct proc_struct *proc作为子线程的TCB&#xff0c;调用copy_thread(proc, stack, tf)进行具体的复制过程。copy_thread函数代码如下&#xff1a;</p>\n<p>static void<br />copy_thread(struct proc_struct *proc, uintptr_t esp, struct trapframe *tf) {<br />    proc-&gt;tf = (struct trapframe *)(proc-&gt;kstack &#43; KSTACKSIZE) - 1;<br />    *(proc-&gt;tf) = *tf;<br />    proc-&gt;tf-&gt;tf_regs.reg_eax = 0;<br />    proc-&gt;tf-&gt;tf_esp = esp;<br />    proc-&gt;tf-&gt;tf_eflags |= FL_IF;</p>\n<p>    proc-&gt;context.eip = (uintptr_t)forkret;<br />    proc-&gt;context.esp = (uintptr_t)(proc-&gt;tf);<br />}</p>\n<p>可以看到这里先是对子线程的proc_struct proc进行初始化&#xff0c;然后将proc-&gt;context.eip设为forkret。之后在switch_to函数中将返回地址的内容修改成forkret&#xff0c;通过switch_to函数最后的ret指令&#xff0c;执行流程到达forkret。forkret调用forkerts函数&#xff0c;该函数将esp设为了上述的虚假trapframe&#xff0c;用popal指令将寄存器值设成了该trapframe中的值。</p>\n<p>在上述流程结束后&#xff0c;kernel_thread函数结束&#xff0c;CPU跳到eip寄存器保存的kernel_thread_entry函数&#xff0c;在该函数中调用init_main&#xff0c;线程切换结束。</p>", "created": "2019-04-14T16:49:29Z", "bucket_order": 76, "bucket_name": "Week 4/14 - 4/20", "type": "feedback", "tag_good": [], "uid": "jsl9bhefCIIS", "children": [], "tag_good_arr": [], "id": "juh5zjw6btz4c4", "updated": "2019-04-14T16:49:29Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "juby76igjq14h6", "updated": "2019-04-11T01:12:37Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<md>这里对第一个用户进程从进入运行态到开始执行用户态主函数&#96;main()&#96;的过程中所执行的函数做一个简要分析:  \n 1.第二个内核线程(在init_main中)创建第一个用户进程userproc,创建完成后&#xff0c;循环执行do_wait函数进行判定&#xff0c;当do_wait返回0后&#xff0c;调用schedule();\n 2.schedule函数调用proc_run(next)来运行用户线程;proc_run完成一些加载项之后切换进程上下文,跳转到了forkret();\n 3.forkret()调用forkrets(current-&gt;tf);\n 4.forkrets在trapentry.S里&#xff0c;有两条命令&#xff0c;先将栈指针指向current-&gt;tf的地址&#xff0c;然后跳转到trap/__trapret;\n 5.__trapret加载多个寄存器,然后通过iret指令&#xff0c;跳转到userproc-&gt;tf.tf_eip&#xff0c;即process/entry.S中的kernel_thread_entry;\n 6.kernel_thread_entry跳转到ebx指向的函数&#xff0c;即user_main;\n 7.user_main打印一些信息后调用kernel_execve();\n 8.kernel_execve()执行系统调用exec;\n 9.进入中断处理,跳转到vector128处&#xff08;trap/vectors.S&#xff09;;\n 10.vector128跳转__alltraps(trap/trapentry.S);\n 11.__alltraps跳转trap;\n 12.trap调用trap_dispatch(tf);\n 13.trap_dispatch调用syscall(syscall/syscall.c);\n 14.syscall()跳转sys_exec;\n 15.sys_exec调用do_execve(process/proc.c);\n 16.do_execve首先为加载新的执行码做好用户态内存空间清空准备,然后调用load_icode函数来加载应用程序执行码到当前进程的新创建的用户态虚拟空间中\n 17.load_icode执行完一系列工作后,返回到do_exevce,而后do_execve执行set_proc_name,并一路return到__alltraps的call trap处,程序往下执行,进入__trapret函数;\n 18.__trapret跳转到userproc-&gt;tf.tf_eip,此时userproc-&gt;tf.tf_eip已被修改为应用程序的入口,即main()函数;\n 19.开始执行main();</md>", "created": "2020-03-23T12:28:14Z", "bucket_order": 27, "bucket_name": "Week 3/22 - 3/28", "type": "followup", "tag_good": [{"role": "student", "name": "KaoYanGou007", "endorser": {}, "admin": false, "photo": null, "id": "kdlddkg52eu4ns", "photo_url": null, "published": true, "us": false, "facebook_id": null}], "uid": "k6oh4mhvehk4r5", "children": [], "tag_good_arr": ["kdlddkg52eu4ns"], "no_answer": 0, "id": "k84g4m6jp9b6t3", "updated": "2020-03-23T12:28:14Z", "config": {}}], "tag_good_arr": ["hdjonbiyfs62ie", "jozr6mfkHcxR"], "id": "j1d4c7s76qf18h", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 5, "num_favorites": 3, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169026012, "default_anonymity": "no"}, "error": null, "aid": "kyv0euvwk3v4ia"}