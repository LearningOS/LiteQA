{"result": {"folders": ["lab1"], "nr": 1408, "data": {"embed_links": []}, "created": "2020-03-01T04:56:22Z", "bucket_order": 3, "no_answer_followup": 1, "change_log": [{"anon": "no", "uid": "k6yl52uxyz02x2", "data": "k78karsfi1q5mp", "type": "create", "when": "2020-03-01T04:56:22Z"}, {"anon": "full", "data": "k78q55mjhjo3f9", "to": "k78karsdolj5mo", "type": "s_answer", "when": "2020-03-01T07:39:58Z", "uid_a": "a_0"}, {"anon": "no", "uid": "k6yl52uxyz02x2", "to": "k78karsdolj5mo", "type": "followup", "when": "2020-03-01T08:38:21Z"}, {"anon": "full", "to": "k78karsdolj5mo", "type": "feedback", "when": "2020-03-01T09:36:32Z", "uid_a": "a_0"}, {"anon": "no", "uid": "k6yl52uxyz02x2", "to": "k78karsdolj5mo", "type": "feedback", "when": "2020-03-01T09:58:05Z"}, {"anon": "full", "to": "k78karsdolj5mo", "type": "feedback", "when": "2020-03-01T10:13:19Z", "uid_a": "a_0"}, {"anon": "no", "uid": "k6yl52uxyz02x2", "to": "k78karsdolj5mo", "type": "feedback", "when": "2020-03-01T10:27:39Z"}, {"anon": "full", "to": "k78karsdolj5mo", "type": "feedback", "when": "2020-03-01T11:14:33Z", "uid_a": "a_0"}, {"anon": "full", "to": "k78karsdolj5mo", "type": "feedback", "when": "2020-03-01T11:16:00Z", "uid_a": "a_0"}, {"anon": "no", "uid": "k6yl52uxyz02x2", "to": "k78karsdolj5mo", "type": "feedback", "when": "2020-03-01T11:29:27Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "k6yl52uxyz02x2", "subject": "关于程序加载运行的问题", "created": "2020-03-01T04:56:22Z", "content": "<p>自学操作系统&#xff0c;有几点问题&#xff0c;搞了很久&#xff0c;看了很多资料也没弄明白&#xff0c;耽误下大家的时间&#xff0c;希望能得到解决</p>\n<p>1.ELF文件中各个段的VMA&#xff0c;和LMA到底是用来干什么的&#xff0c;看到的解释都是一个是虚拟地址&#xff08;VMA&#xff09;&#xff0c;一个是加载地址&#xff08;LMA&#xff09;。</p>\n<p>到底程序如何被加载到内存中&#xff0c;加载到什么位置。有的说LMA就是加载的物理地址&#xff0c;但是ELF程序未运行的时候这个LMA就已经有了&#xff0c;如果按这个地址加载的话&#xff0c;如果当时的内存中这个地址已经有数据在用了&#xff0c;该怎么办。希望哪位同学或老师能给我讲讲具体的过程</p>\n<p>2.虚拟地址是在什么时候起作用&#xff0c;也就是地址的转换在什么时候才发生&#xff0c;什么时候不转换&#xff0c;是不是开启分页后所有地址都按照虚拟地址处理。</p>\n<p>什么过程是按照虚拟地址来的&#xff0c;用到虚拟地址的地方体现在C语言代码中的何处&#xff0c;地址在何处提出。</p>\n<p>问题可能比较简单&#xff0c;但我比较笨就是明白不了&#xff0c;希望能有人给我讲一讲&#xff0c;谢谢&#xff01;</p>\n<p></p>\n<p></p>"}], "type": "question", "tags": ["lab1", "student"], "tag_good": [], "unique_views": 140, "children": [{"folders": [], "data": {"embed_links": []}, "children": [], "created": "2020-03-01T07:39:58Z", "bucket_order": 3, "tag_endorse": [{"role": "student", "name": "xiaoyao", "endorser": {}, "admin": false, "photo": null, "id": "k6yl52uxyz02x2", "photo_url": null, "published": true, "us": false, "facebook_id": null}], "bucket_name": "Today", "id": "k78q55mfko03f8", "history": [{"anon": "full", "uid_a": "a_0", "subject": "", "created": "2020-03-01T07:39:58Z", "content": "<p>1. 我的理解是&#xff1a;在绝大部分情况下&#xff0c;LMA == VMA&#xff0c;在建立了虚拟存储后&#xff0c;可以认为一个进程独占整个虚存&#xff0c;程序加载时会按照ELF的要求把相应的段加载到虚存的对应位置&#xff0c;至于物理地址是多少&#xff0c;看os当时的分配。在该课程的学习中&#xff0c;我还没有碰到过二者不等的情况&#xff0c;有的博客表示嵌入式等场景下可能不同&#xff0c;至于中途如何转移等细节&#xff0c;我不知道&#xff0c;但不需要死扣&#xff0c;期待大佬的后续回答。</p>\n<p>2. CPU执行某一条需要访存的指令后&#xff0c;在地址信息发送到总线之前会先经过MMU&#xff0c;MMU会完成虚实转化并把转化后的地址放到总线上提供给内存&#xff0c;开启虚存的情况下&#xff0c;所有CPU发出的访存请求都要经过虚实转换&#xff0c;不管运行在什么状态&#xff08;x86 时这样的&#xff0c;rv M模式不支持虚存&#xff0c;不过该课程几乎用不到&#xff09;。所有的用户程序运行都是在虚存下的&#xff0c;os绝大部分指令是执行在虚存下的&#xff08;刚启动一小部分代码还未开启虚存&#xff0c;用来做一些基础的准备工作&#xff09;。至于语言&#xff0c;它并不知道自己到底会在一个有虚存还是没有虚存的环境下执行&#xff0c;它仅仅认为自己编写的程序独占了内存&#xff0c;不管是不是虚存。</p>"}], "type": "s_answer", "tag_endorse_arr": ["k6yl52uxyz02x2"], "config": {}, "is_tag_endorse": false}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>上面的解释我还是搞不懂。。。。。。。。。。。。</p>\n<p>既然有LMA和VMA两个概念&#xff0c;而不是只有一个&#xff0c;那说明肯定是各有各的作用&#xff0c;希望哪位大佬能够解释下</p>\n<p>“加载”到底是一个什么概念&#xff0c;由谁来完成&#xff0c;按照什么加载到哪里&#xff1f;</p>", "created": "2020-03-01T08:38:21Z", "bucket_order": 3, "bucket_name": "Today", "type": "followup", "tag_good": [], "uid": "k6yl52uxyz02x2", "children": [{"anon": "full", "folders": [], "data": {"embed_links": null}, "subject": "<p>所谓加载就是把ELF文件从磁盘拷贝到内存的过程&#xff0c;一般由操统结合一些加载程序完成&#xff08;动态链接的程序加载需要动态链接库程序辅助&#xff0c;如果没有os的情况下&#xff0c;由一些其他程序控制完成加载&#xff09;。一个ELF格式的可执行程序会在ELF头中描述各个段在磁盘上的offset、长度以及需要加载到的虚存位置&#xff08;LMA&#xff09;。<br />我刚才简单查阅了一些博客&#xff0c;我说一下我的看法。程序加载的时候&#xff0c;加载器会把各个段放到内存(一般是虚存&#xff0c;但是如果是嵌入式的小板子&#xff0c;跑的程序都固定了&#xff0c;可能就是物理内存)的LMA。但是程序运行的时候会认为这些段位于VMA&#xff0c;比如找一个数据&#xff0c;回到对应的VMA&#43;offset处找&#xff0c;在VMA=LMA的情境下不会出问题&#xff0c;但是如果VMA!=LMA&#xff0c;直接跑程序就会出错&#xff0c;这类程序会在执行的开头&#xff0c;进行reload的过程&#xff0c;将相应数据从LMA搬运到VMA出&#xff0c;这个reload可以是程序自己完成&#xff0c;也可以是程序在头中给出一些信息&#xff0c;由操统等辅助完成。那么为什么需要多次一举进行一次搬运呢&#xff1f;直接放到VMA不好吗&#xff1f;这就是一些特殊情况下的特殊需求&#xff0c;我看到的一个例子是&#xff0c;在一块嵌入式板子上烧一个程序&#xff0c;该板子有ROM段和RAM段&#xff0c;程序的代码段LMA=VMA并放在ROM中&#xff0c;但数据段呢 LMA在ROM段&#xff0c;VMA在RAM段&#xff0c;应为一方面数据段需要读写&#xff0c;运行时必须在RAM段&#xff0c;然后数据段是有初始化的&#xff0c;如果烧在RAM中&#xff0c;一断电初始化的数据就丢了&#xff0c;所以烧的时候必须在ROM段&#xff0c;在这种情况下&#xff0c;就必须要有LMA!=VMA&#xff0c;也就有了reload的过程。</p>", "created": "2020-03-01T09:36:32Z", "bucket_order": 3, "bucket_name": "Today", "type": "feedback", "tag_good": [], "uid_a": "a_0", "children": [], "tag_good_arr": [], "id": "k78ub2by2kd49x", "updated": "2020-03-01T09:36:32Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>虽然还是有些疑问&#xff0c;但还是谢谢你&#xff01;</p>\n<p>希望有大佬来详细解释一下</p>", "created": "2020-03-01T09:58:05Z", "bucket_order": 3, "bucket_name": "Today", "type": "feedback", "tag_good": [], "uid": "k6yl52uxyz02x2", "children": [], "tag_good_arr": [], "id": "k78v2rrbu6t7d3", "updated": "2020-03-01T09:58:05Z", "config": {}}, {"anon": "full", "folders": [], "data": {"embed_links": null}, "subject": "<p>加载器&#xff08;本质是一段程序&#xff09;通过磁盘驱动来完成加载&#xff0c;程序提供文件在磁盘中的位置和加载到的内存位置&#xff0c;磁盘驱动会完成从磁盘到内存的拷贝&#xff0c;再具体就是驱动读写一些映射过的的内存位置&#xff0c;这些内存位置和磁盘硬件相应的端口绑定&#xff08;类似组成原理读写特殊内存可读写串口&#xff09;&#xff0c;以此来完成对磁盘硬件读取&#xff0c;然后再写到对应的内存&#xff0c;当然我描述的这个过程是十分简化的模型&#xff0c;具体实现需要进一步学习。<br />LMA和VMA都可以是虚存&#xff0c;也可以不是虚存&#xff0c;LMA指&#xff1a;加载器将各个段加载的位置&#xff0c;VMA指实际运行时程序&#xff08;或者是编译它的编译器&#xff09;认为的某个段在的位置。<br />这样看来&#xff0c;VMA这个名字是不十分准确的。</p>", "created": "2020-03-01T10:13:19Z", "bucket_order": 3, "bucket_name": "Today", "type": "feedback", "tag_good": [], "uid_a": "a_0", "children": [], "tag_good_arr": [], "id": "k78vmd6jx3r4fl", "updated": "2020-03-01T10:13:19Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>“程序提供文件在磁盘中的位置和加载到的内存位置”</p>\n<p>那这个提供的加载到的内存位置到底是哪个啊。。。。。</p>\n<p>如果程序提供的是物理地址&#xff0c;那么如果这个物理地址上已经有程序了&#xff08;毕竟程序在没有运行之前给出加载的位置&#xff0c;它也不知道内存中是什么状况&#xff09;&#xff0c;那么该怎么办。</p>\n<p>加载器也是一段程序&#xff0c;那它从程序那读到加载地址&#xff0c;假设是read&#xff08;address&#xff09;,然后它要将程序放到内存中&#xff0c;假如是write&#xff08;address&#xff09;&#xff0c;那这个address放到地址线上要不要经过转换啊。</p>\n<p></p>\n<p></p>", "created": "2020-03-01T10:27:39Z", "bucket_order": 3, "bucket_name": "Today", "type": "feedback", "tag_good": [], "uid": "k6yl52uxyz02x2", "children": [], "tag_good_arr": [], "id": "k78w4taecya3kq", "updated": "2020-03-01T10:27:39Z", "config": {}}, {"anon": "full", "folders": [], "data": {"embed_links": null}, "subject": "<p>驱动本质也是一段程序&#xff0c;所以也是要经过虚实转化的。加载程序会给一个buffer指针&#xff0c;这个指针代表了一个虚拟地址&#xff0c;驱动程序和硬件交互的时候会在特定的一块物理内存中读写&#xff0c;驱动通过某些手段访问到这个物理地址&#xff08;这个物理地址的虚实映射是特殊建立的&#xff0c;驱动可以知道映射规则&#xff0c;进而推出虚拟地址&#xff09;&#xff0c;然后将结果写入给定的buffer&#xff08;虚存&#xff09;中。<br />这是最基本的做法&#xff0c;磁盘和内存分别只和CPU交互&#xff0c;先进的硬件应该可以直接在磁盘和内存中转移数据&#xff0c;可能是借助了MMU推导出buffer的物理地址。</p>", "created": "2020-03-01T11:14:33Z", "bucket_order": 3, "bucket_name": "Today", "type": "feedback", "tag_good": [], "uid_a": "a_0", "children": [], "tag_good_arr": [], "id": "k78xt3zbikw1l2", "updated": "2020-03-01T11:14:33Z", "config": {}}, {"anon": "full", "folders": [], "data": {"embed_links": null}, "subject": "<p>只要是程序&#xff0c;在开启虚存的情况下&#xff0c;无法绕开虚实转化&#xff0c;如果你非要访问物理地址&#xff0c;必须知道映射规则&#xff0c;然后倒推。</p>", "created": "2020-03-01T11:16:00Z", "bucket_order": 3, "bucket_name": "Today", "type": "feedback", "tag_good": [], "uid_a": "a_0", "children": [], "tag_good_arr": [], "id": "k78xuz6x59n2da", "updated": "2020-03-01T11:16:00Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>啊。。。越来越听不懂了。。。。</p>\n<p>还是谢谢你&#xff01;</p>", "created": "2020-03-01T11:29:27Z", "bucket_order": 3, "bucket_name": "Today", "type": "feedback", "tag_good": [], "uid": "k6yl52uxyz02x2", "children": [], "tag_good_arr": [], "id": "k78yca9xnh31jv", "updated": "2020-03-01T11:29:27Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "k78s88rq1ch1bb", "updated": "2020-03-01T08:38:21Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "k78karsdolj5mo", "config": {"seen": {"33": 1, "1327": 9, "1138": 8, "1399": 7, "501": 5, "545": 0, "503": 4, "1230": 2, "967": 3, "968": 6}}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 3, "num_favorites": 1, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169968984, "default_anonymity": "no"}, "error": null, "aid": "kyv0z2hk1z3491"}