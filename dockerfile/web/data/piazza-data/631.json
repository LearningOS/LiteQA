{"result": {"folders": ["lecture3", "课堂问答"], "nr": 631, "data": {"embed_links": []}, "created": "2016-02-29T00:56:12Z", "bucket_order": 3, "no_answer_followup": 6, "change_log": [{"uid": "hdjonbiyfs62ie", "anon": "no", "when": "2016-02-29T00:56:12Z", "data": "il79yhxy6y843k", "type": "create"}, {"to": "il79yhxvw5743j", "uid": "hdjonbiyfs62ie", "anon": "no", "when": "2016-02-29T00:57:52Z", "type": "followup"}, {"to": "il79yhxvw5743j", "uid": "hdjonbiyfs62ie", "anon": "no", "when": "2016-02-29T00:58:17Z", "type": "followup"}, {"to": "il79yhxvw5743j", "uid": "hdjonbiyfs62ie", "anon": "no", "when": "2016-02-29T00:58:38Z", "type": "followup"}, {"to": "il79yhxvw5743j", "uid": "hdjonbiyfs62ie", "anon": "no", "when": "2016-02-29T00:58:56Z", "type": "followup"}, {"to": "il79yhxvw5743j", "uid": "hdjonbiyfs62ie", "anon": "no", "when": "2016-02-29T00:59:15Z", "type": "followup"}, {"to": "il79yhxvw5743j", "uid": "hdjonbiyfs62ie", "anon": "no", "when": "2016-02-29T00:59:28Z", "type": "followup"}, {"to": "il79yhxvw5743j", "uid": "i0f9pvv0uxm6ko", "anon": "no", "when": "2016-02-29T01:02:14Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0nuu5yhgno5tv", "anon": "no", "when": "2016-02-29T01:03:17Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0nan8i4g0o3s3", "anon": "no", "when": "2016-02-29T01:03:53Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "ikvcvnzpzq7j7", "anon": "no", "when": "2016-02-29T01:06:53Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0f24oie8102cr", "anon": "no", "when": "2016-02-29T01:08:14Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i242q8ug7vw40x", "anon": "no", "when": "2016-02-29T01:08:19Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0minzvpea57bu", "anon": "no", "when": "2016-02-29T01:09:20Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0ccfx63sir1e", "anon": "no", "when": "2016-02-29T01:10:08Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "ierwkwbinsj2t8", "anon": "no", "when": "2016-02-29T01:10:32Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0gkdbms5ie20o", "anon": "no", "when": "2016-02-29T01:11:15Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i18riqkwrl225m", "anon": "no", "when": "2016-02-29T01:11:41Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "ie7xy71bn7b1s2", "anon": "no", "when": "2016-02-29T01:12:34Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0ayxqk6wry734", "anon": "no", "when": "2016-02-29T01:13:08Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0em4o8wvj34lb", "anon": "no", "when": "2016-02-29T01:13:25Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0minzvpea57bu", "anon": "no", "when": "2016-02-29T01:14:06Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0dlq4m0wjn5eo", "anon": "no", "when": "2016-02-29T01:14:12Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0c1nsm3911wc", "anon": "no", "when": "2016-02-29T01:14:32Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i6w84pnmjCQ", "anon": "no", "when": "2016-02-29T01:14:37Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "ikx8y1dzPrM", "anon": "no", "when": "2016-02-29T01:14:41Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i11v1az5sf83l2", "anon": "no", "when": "2016-02-29T01:14:52Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0f7v0qgfm61s6", "anon": "no", "when": "2016-02-29T01:15:23Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i1bzj2xilgm4uk", "anon": "no", "when": "2016-02-29T01:15:52Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "ikvcvq38pa7l6", "anon": "no", "when": "2016-02-29T01:17:09Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0em4o8wvj34lb", "anon": "no", "when": "2016-02-29T01:17:51Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0zaci5voig5h", "anon": "no", "when": "2016-02-29T01:18:11Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0gl5kctugw3xi", "anon": "no", "when": "2016-02-29T01:18:16Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0gkdbms5ie20o", "anon": "no", "when": "2016-02-29T01:18:59Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i28skba6cd976f", "anon": "no", "when": "2016-02-29T01:21:08Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0d4mr9tga62ki", "anon": "no", "when": "2016-02-29T01:21:29Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "ikvcvo2cckb7jb", "anon": "no", "when": "2016-02-29T01:21:35Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0c9nvk0xzc2n3", "anon": "no", "when": "2016-02-29T01:21:40Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0brpl1lbyui6", "anon": "no", "when": "2016-02-29T01:22:06Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0f24oie8102cr", "anon": "no", "when": "2016-02-29T01:23:52Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0eqqq6jvng408", "anon": "no", "when": "2016-02-29T01:24:07Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0i7rzz9iau2gd", "anon": "no", "when": "2016-02-29T01:24:10Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i3qk2vs65x276j", "anon": "no", "when": "2016-02-29T01:24:43Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0evrfcnckf5dt", "anon": "no", "when": "2016-02-29T01:25:20Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i6ub4vwhQXd", "anon": "no", "when": "2016-02-29T01:25:50Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0b7d04pl3y6c0", "anon": "no", "when": "2016-02-29T01:26:06Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i11dx198ive25r", "anon": "no", "when": "2016-02-29T01:26:48Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0f9pvv0uxm6ko", "anon": "no", "when": "2016-02-29T01:27:38Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0c1nsm3911wc", "anon": "no", "when": "2016-02-29T01:27:55Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0yuo4o74sx70w", "anon": "no", "when": "2016-02-29T01:28:01Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0f7v0qgfm61s6", "anon": "no", "when": "2016-02-29T01:28:35Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0c9nvk0xzc2n3", "anon": "no", "when": "2016-02-29T01:29:10Z", "type": "followup"}, {"to": "il79yhxvw5743j", "uid": "i1569mw0xp954u", "anon": "no", "when": "2016-02-29T01:29:27Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0c9nvk0xzc2n3", "anon": "no", "when": "2016-02-29T01:29:36Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i21zpwab2z775p", "anon": "no", "when": "2016-02-29T01:29:36Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i17iy2ly5py3ad", "anon": "no", "when": "2016-02-29T01:29:48Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i6ugy67km5b", "anon": "no", "when": "2016-02-29T01:29:55Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0dlq4m0wjn5eo", "anon": "no", "when": "2016-02-29T01:29:58Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "ibz6vywnw6g7nl", "anon": "no", "when": "2016-02-29T01:30:12Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0b7d04pl3y6c0", "anon": "no", "when": "2016-02-29T01:30:23Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0nan8i4g0o3s3", "anon": "no", "when": "2016-02-29T01:30:52Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "ie7xy3iwuug1os", "anon": "no", "when": "2016-02-29T01:31:26Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i701mss708y", "anon": "no", "when": "2016-02-29T01:31:35Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "ie7xy71bn7b1s2", "anon": "no", "when": "2016-02-29T01:31:50Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "ie7xy3iwuug1os", "anon": "no", "when": "2016-02-29T01:32:10Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0nuu5yhgno5tv", "anon": "no", "when": "2016-02-29T01:32:18Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i18riqkwrl225m", "anon": "no", "when": "2016-02-29T01:33:17Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0hjdkesg9c5z7", "anon": "no", "when": "2016-02-29T01:34:38Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i6ub4vwhQXd", "anon": "no", "when": "2016-02-29T01:34:51Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i11dx198ive25r", "anon": "no", "when": "2016-02-29T01:35:01Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "ie7xy4gmt1p1pp", "anon": "no", "when": "2016-02-29T01:35:40Z", "type": "followup"}, {"to": "il79yhxvw5743j", "uid": "i701mss708y", "anon": "no", "when": "2016-02-29T01:37:33Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "ikvcvq38pa7l6", "anon": "no", "when": "2016-02-29T01:37:43Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0brpl1lbyui6", "anon": "no", "when": "2016-02-29T01:39:08Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i242q8ug7vw40x", "anon": "no", "when": "2016-02-29T01:40:47Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i3qk2vs65x276j", "anon": "no", "when": "2016-02-29T01:46:55Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0ccqbaxwdz75c", "anon": "no", "when": "2016-02-29T01:47:28Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0ccqbaxwdz75c", "anon": "no", "when": "2016-02-29T01:50:24Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0nu5by9l7v7of", "anon": "no", "when": "2016-02-29T01:58:06Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i1569mw0xp954u", "anon": "no", "when": "2016-02-29T01:58:15Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0evrfcnckf5dt", "anon": "no", "when": "2016-02-29T02:01:45Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i6uiksj895B", "anon": "no", "when": "2016-02-29T02:08:27Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "ikx8y1dzPrM", "anon": "no", "when": "2016-02-29T02:12:02Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0f9pvv0uxm6ko", "anon": "no", "when": "2016-02-29T02:14:46Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "ic226rac4j5jw", "anon": "no", "when": "2016-02-29T02:18:43Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0nu5by9l7v7of", "anon": "no", "when": "2016-02-29T02:21:27Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "ic226rac4j5jw", "anon": "no", "when": "2016-02-29T02:23:17Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i1oqryfapik22", "anon": "no", "when": "2016-02-29T02:23:22Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i1oqryfapik22", "anon": "no", "when": "2016-02-29T02:47:55Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "ikvcvnzpzq7j7", "anon": "no", "when": "2016-02-29T02:53:26Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "ikvcvnzpzq7j7", "anon": "no", "when": "2016-02-29T03:46:16Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "ikvcvr6di5i7ma", "anon": "no", "when": "2016-02-29T04:16:57Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i6uuj5n1v5y2t6", "anon": "no", "when": "2016-02-29T05:26:57Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i6uaz437IKR", "anon": "no", "when": "2016-02-29T06:49:52Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i6vjwdpfniF", "anon": "no", "when": "2016-02-29T06:56:07Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i6vjwdpfniF", "anon": "no", "when": "2016-02-29T06:57:04Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i6uaz437IKR", "anon": "no", "when": "2016-02-29T06:59:28Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "iem550jbpyn515", "anon": "no", "when": "2016-02-29T07:37:58Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "iem550jbpyn515", "anon": "no", "when": "2016-02-29T07:43:47Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "iem550jbpyn515", "anon": "no", "when": "2016-02-29T07:44:22Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "ikvcvmzbvlf7i6", "anon": "no", "when": "2016-02-29T08:00:22Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i6vir34gLfK", "anon": "no", "when": "2016-02-29T08:10:46Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "ibz6vywnw6g7nl", "anon": "no", "when": "2016-02-29T08:11:12Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "ibz6vywnw6g7nl", "anon": "no", "when": "2016-02-29T08:22:33Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "ic226rq2vask0", "anon": "no", "when": "2016-02-29T08:30:56Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "ic226rq2vask0", "anon": "no", "when": "2016-02-29T08:31:22Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "ikvcvo2cckb7jb", "anon": "no", "when": "2016-02-29T08:40:15Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "ikvcvo2cckb7jb", "anon": "no", "when": "2016-02-29T08:40:50Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "ikvcvo2cckb7jb", "anon": "no", "when": "2016-02-29T08:41:14Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "ikvcvo2cckb7jb", "anon": "no", "when": "2016-02-29T08:41:23Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "ikvcvo2cckb7jb", "anon": "no", "when": "2016-02-29T08:41:37Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i6vir34gLfK", "anon": "no", "when": "2016-02-29T08:52:58Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "ibz6vywnw6g7nl", "anon": "no", "when": "2016-02-29T08:59:50Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i6uuj5n1v5y2t6", "anon": "no", "when": "2016-02-29T09:00:13Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "ibz6vywnw6g7nl", "anon": "no", "when": "2016-02-29T09:08:35Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "ibz6vywnw6g7nl", "anon": "no", "when": "2016-02-29T09:21:51Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i70lz5f0QKm", "anon": "no", "when": "2016-02-29T09:29:03Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i70lz5f0QKm", "anon": "no", "when": "2016-02-29T09:37:17Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i2om0jwie732m1", "anon": "no", "when": "2016-02-29T09:50:54Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i2om0jwie732m1", "anon": "no", "when": "2016-02-29T09:57:33Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "ierwkwbinsj2t8", "anon": "no", "when": "2016-02-29T09:58:32Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i2om0jwie732m1", "anon": "no", "when": "2016-02-29T10:01:16Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i2olyyl8swl1we", "anon": "no", "when": "2016-02-29T10:08:45Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i2olyyl8swl1we", "anon": "no", "when": "2016-02-29T10:15:19Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i2g664y8vve6h4", "anon": "no", "when": "2016-02-29T10:29:25Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i2g664y8vve6h4", "anon": "no", "when": "2016-02-29T10:40:29Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "ikvcvonk6wj7k1", "anon": "no", "when": "2016-02-29T10:41:12Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "ikx8y1dzPrM", "anon": "no", "when": "2016-02-29T10:43:55Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0i7rzz9iau2gd", "anon": "no", "when": "2016-02-29T11:12:09Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i6ub5at2geM", "anon": "no", "when": "2016-02-29T11:16:35Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i6ub5at2geM", "anon": "no", "when": "2016-02-29T11:24:43Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i11v1az5sf83l2", "anon": "no", "when": "2016-02-29T11:30:41Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i0hjdkesg9c5z7", "anon": "no", "when": "2016-02-29T11:31:21Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "ikvcvmzbvlf7i6", "anon": "no", "when": "2016-02-29T11:42:04Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "i17iy2ly5py3ad", "anon": "no", "when": "2016-02-29T11:54:54Z", "type": "feedback"}, {"to": "il79yhxvw5743j", "uid": "ikvcvr6di5i7ma", "anon": "no", "when": "2016-02-29T12:15:50Z", "type": "feedback"}, {"uid": "hdjonbiyfs62ie", "anon": "no", "when": "2016-02-29T15:38:10Z", "data": "il85gpt14nk5zk", "type": "update"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "data": "izh20uv7sta104", "type": "update", "when": "2017-02-22T14:27:39Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "2016春季-第三讲课堂思考题回答-向勇班", "created": "2017-02-22T14:27:39Z", "content": "<p>请向勇班的同学把“第三讲 启动、中断、异常和系统调用-思考题”中指定小题的回答结果写在此贴中对应题目后面。</p>\n<p></p>\n<p><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/02-1-spoc-discussion.md#第三讲-启动中断异常和系统调用-思考题\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/02-1-spoc-discussion.md#第三讲-启动中断异常和系统调用-思考题</a></p>\n<p></p>\n<p>第三讲的回答的截止时间是今天&#xff08;20160229&#xff09;晚20点前。</p>\n<p></p>\n<p>要求&#xff1a;</p>\n<p>1. 第一题是每个人独立回答&#xff1b;</p>\n<p>2. 第2到6题&#xff1a;两个人一组或独立回答&#xff0c;每组只需要完成指定的一个题目。题目指定方法是&#xff0c;小组成员学号最小值与题号除5后余数相同。</p>\n<p></p>\n<p>题目&#xff1a;<br />1. 3.3中的第4小题&#xff1a;以ucore lab8的answer为例&#xff0c;uCore的时钟中断处理流程。<br />2. 3.1中的第1小题&#xff1a;比较UEFI和BIOS的区别。<br />3. 3.3中的第5小题&#xff1a;Linux的系统调用有哪些&#xff1f;大致的功能分类有哪些&#xff1f;<br />4. 3.3中的第6小题&#xff1a;以ucore lab8的answer为例&#xff0c;uCore的系统调用有哪些&#xff1f;大致的功能分类有哪些&#xff1f;<br />5. 3.5中的第2小题&#xff1a;以getpid为例&#xff0c;分析ucore的系统调用中返回结果的传递代码。<br />6. 3.6题&#xff1a;分析函数调用和系统调用的区别</p>\n<p></p>\n<p>优胜者&#xff1a;</p>\n<p></p>\n<p>1.<br />DichenQian<br />Liu Xiaohong<br />乔奕 2013011324<br />杨青霖2013011297<br />朱俸民</p>\n<p></p>\n<p>2.<br />贺子松2013011296<br />孟凡航2013011312</p>\n<p></p>\n<p>3.<br />何钦尧<br />李宇轩</p>\n<p></p>\n<p>4.<br />朱俸民 2012011894 &amp; 朱新瑞 2013011411</p>\n<p></p>\n<p>5.<br />谭思楠2013011720<br />马志明2013011395 杨明</p>\n<p></p>\n<p>6.<br />沈哲言2013011371 叶子鹏2013011404<br />梁泽宇 2014011381<br />王奥丞 2014011367</p>"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "2016春季-第三讲课堂思考题回答-向勇班", "created": "2016-02-29T15:38:10Z", "content": "<p>请向勇班的同学把“第三讲 启动、中断、异常和系统调用-思考题”中指定小题的回答结果写在此贴中对应题目后面。</p>\n<p></p>\n<p><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/02-1-spoc-discussion.md#第三讲-启动中断异常和系统调用-思考题\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/02-1-spoc-discussion.md#第三讲-启动中断异常和系统调用-思考题</a></p>\n<p></p>\n<p>第三讲的回答的截止时间是今天&#xff08;20160229&#xff09;晚20点前。</p>\n<p></p>\n<p>要求&#xff1a;</p>\n<p>1. 第一题是每个人独立回答&#xff1b;</p>\n<p>2. 第2到6题&#xff1a;两个人一组或独立回答&#xff0c;每组只需要完成指定的一个题目。题目指定方法是&#xff0c;小组成员学号最小值与题号除5后余数相同。</p>\n<p></p>\n<p>题目&#xff1a;<br />1. 3.3中的第4小题&#xff1a;以ucore lab8的answer为例&#xff0c;uCore的时钟中断处理流程。<br />2. 3.1中的第1小题&#xff1a;比较UEFI和BIOS的区别。<br />3. 3.3中的第5小题&#xff1a;Linux的系统调用有哪些&#xff1f;大致的功能分类有哪些&#xff1f;<br />4. 3.3中的第6小题&#xff1a;以ucore lab8的answer为例&#xff0c;uCore的系统调用有哪些&#xff1f;大致的功能分类有哪些&#xff1f;<br />5. 3.5中的第2小题&#xff1a;以getpid为例&#xff0c;分析ucore的系统调用中返回结果的传递代码。<br />6. 3.6题&#xff1a;分析函数调用和系统调用的区别</p>\n<p></p>\n<p>优胜者&#xff1a;</p>\n<p></p>\n<p>1.<br />DichenQian<br />Liu Xiaohong<br />乔奕 2013011324<br />杨青霖2013011297<br />朱俸民</p>\n<p></p>\n<p>2.<br />贺子松2013011296<br />孟凡航2013011312</p>\n<p></p>\n<p>3.<br />何钦尧<br />李宇轩</p>\n<p></p>\n<p>4.<br />朱俸民 2012011894 &amp; 朱新瑞 2013011411</p>\n<p></p>\n<p>5.<br />谭思楠2013011720<br />马志明2013011395 杨明</p>\n<p></p>\n<p>6.<br />沈哲言2013011371 叶子鹏2013011404<br />梁泽宇 2014011381<br />王奥丞 2014011367</p>"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "2016春季-第三讲课堂思考题回答-向勇班", "created": "2016-02-29T00:56:12Z", "content": "<p>请向勇班的同学把“第三讲 启动、中断、异常和系统调用-思考题”中指定小题的回答结果写在此贴中对应题目后面。</p>\n<p></p>\n<p><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/02-1-spoc-discussion.md#第三讲-启动中断异常和系统调用-思考题\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/02-1-spoc-discussion.md#第三讲-启动中断异常和系统调用-思考题</a></p>\n<p></p>\n<p>第三讲的回答的截止时间是今天&#xff08;20160229&#xff09;晚20点前。</p>\n<p></p>\n<p>要求&#xff1a;</p>\n<p>1. 第一题是每个人独立回答&#xff1b;</p>\n<p>2. 第2到6题&#xff1a;两个人一组或独立回答&#xff0c;每组只需要完成指定的一个题目。题目指定方法是&#xff0c;小组成员学号最小值与题号除5后余数相同。</p>\n<p></p>\n<p>题目&#xff1a;<br />1. 3.3中的第4小题&#xff1a;以ucore lab8的answer为例&#xff0c;uCore的时钟中断处理流程。<br />2. 3.1中的第1小题&#xff1a;比较UEFI和BIOS的区别。<br />3. 3.3中的第5小题&#xff1a;Linux的系统调用有哪些&#xff1f;大致的功能分类有哪些&#xff1f;<br />4. 3.3中的第6小题&#xff1a;以ucore lab8的answer为例&#xff0c;uCore的系统调用有哪些&#xff1f;大致的功能分类有哪些&#xff1f;<br />5. 3.5中的第2小题&#xff1a;以getpid为例&#xff0c;分析ucore的系统调用中返回结果的传递代码。<br />6. 3.6题&#xff1a;分析函数调用和系统调用的区别</p>"}], "type": "note", "tags": ["instructor-note", "lecture3", "课堂问答"], "tag_good": [], "unique_views": 304, "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>题目&#xff1a;<br />1. 3.3中的第4小题&#xff1a;以ucore lab8的answer为例&#xff0c;uCore的时钟中断处理流程。</p>\n<p></p>\n<p>回答结果写在此贴中对应题目后面。</p>", "created": "2016-02-29T00:57:52Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>检测到时钟中断以后&#xff0c;由CPU跳转到trapentry.S异常入口&#xff0c;然后进入trap异常处理函数&#xff0c;在trap_dispatch中识别中断位为时钟中断&#xff0c;进入到run_timer_list具体处理&#xff0c;在sched.c中。</p>\n<p>之后可能进行进程切换&#xff0c;交换了进程印象中的处理器信息部分&#xff0c;完成进程切换&#xff0c;最终返回到trapentry&#xff0c;重新开始一个进程。</p>\n<p></p>\n<p>补充&#xff1a;我之前这段描述是从代码中找出来的&#xff0c;只是写的比较急没有说清楚&#xff0c;只说明了文件名&#xff0c;没有指明路径。trapentry.S位于kern/trap/trapentry.S&#xff0c;之后进入的是kern/trap/trap.c&#xff0c;中间有一个叫做trap的函数&#xff0c;会调用trap_dispatch函数&#xff0c;如名字所示&#xff0c;就是一个trap的分配函数&#xff0c;在这个函数里&#xff0c;会被识别为时钟中断&#xff0c;从而进入run_timer_list。</p>", "created": "2016-02-29T01:02:14Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0f9pvv0uxm6ko", "children": [], "tag_good_arr": [], "id": "il7a69mfvmr67d", "updated": "2016-02-29T01:02:14Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>系统通过vector.S 压入trapno&#xff0c;然后进入trapentry.S&#xff0c;用来进入函数处理。</p>\n<pre>__alltraps:\n    # push registers to build a trap frame\n    # therefore make the stack look like a struct trapframe\n    pushl %ds\n    pushl %es\n    pushl %fs\n    pushl %gs\n    pushal\n\n    # load GD_KDATA into %ds and %es to set up data segments for kernel\n    movl $GD_KDATA, %eax\n    movw %ax, %ds\n    movw %ax, %es\n\n    # push %esp to pass a pointer to the trapframe as an argument to trap()\n    pushl %esp\n\n    # call trap(tf), where tf=%esp\n    call trap\n\n    # pop the pushed stack pointer\n    popl %esp\n\n    # return falls through to trapret...</pre>\n<p>在trap.c中有trap函数&#xff0c;用来处理中断。</p>\n<pre>void\ntrap(struct trapframe *tf) {\n    // dispatch based on what type of trap occurred\n    // used for previous projects\n    if (current == NULL) {\n        trap_dispatch(tf);\n    }\n    else {\n        // keep a trapframe chain in stack\n        struct trapframe *otf = current-&gt;tf;\n        current-&gt;tf = tf;\n    \n        bool in_kernel = trap_in_kernel(tf);\n    \n        trap_dispatch(tf);\n    \n        current-&gt;tf = otf;\n        if (!in_kernel) {\n            if (current-&gt;flags &amp; PF_EXITING) {\n                do_exit(-E_KILLED);\n            }\n            if (current-&gt;need_resched) {\n                schedule();\n            }\n        }\n    }\n}\n</pre>\n<p>trap函数里面调用trap_dispatcher进行功能分配。</p>\n<p>可以看到</p>\n<pre>case IRQ_OFFSET &#43; IRQ_TIMER:\n        ticks &#43;&#43;;\n        assert(current != NULL);\n        run_timer_list();\n        break;</pre>\n<p>case IRQ_OFFSET &#43; IRQ_TIMER: 就是时钟中断的种类。</p>\n<p>这里面tick&#43;&#43;&#xff0c;用来记录。</p>\n<p>然后调用run_timer_list函数&#xff0c;在sched.c里面进行处理。</p>\n<pre>void\nrun_timer_list(void) {\n    bool intr_flag;\n    local_intr_save(intr_flag);\n    {\n        list_entry_t *le = list_next(&amp;timer_list);\n        if (le != &amp;timer_list) {\n            timer_t *timer = le2timer(le, timer_link);\n            assert(timer-&gt;expires != 0);\n            timer-&gt;expires --;\n            while (timer-&gt;expires == 0) {\n                le = list_next(le);\n                struct proc_struct *proc = timer-&gt;proc;\n                if (proc-&gt;wait_state != 0) {\n                    assert(proc-&gt;wait_state &amp; WT_INTERRUPTED);\n                }\n                else {\n                    warn(&#34;process %d&#39;s wait_state == 0.\\n&#34;, proc-&gt;pid);\n                }\n                wakeup_proc(proc);\n                del_timer(timer);\n                if (le == &amp;timer_list) {\n                    break;\n                }\n                timer = le2timer(le, timer_link);\n            }\n        }\n        sched_class_proc_tick(current);\n    }\n    local_intr_restore(intr_flag);\n}</pre>\n<p>具体根据clock一个列表&#xff0c;可以看到里面会进行选择第一个timer_list的entry且其time_expire != 0&#xff0c;然后time_expire--&#xff0c;如果为0则唤醒一个进程进行处理对应的内容。</p>\n<p>最后通过trapentry.S中的汇编代码返回。</p>", "created": "2016-02-29T01:03:17Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0nuu5yhgno5tv", "children": [], "tag_good_arr": [], "id": "il7a7m5t92v9", "updated": "2016-02-29T01:03:17Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>首先CPU会查中断描述符表进入__alltraps入口&#xff0c;经过现场保存和多层跳转最终进入trap_dispatch函数。</p>\n<p>uCore的时钟中断处理流程如下&#xff1a;首先进行时钟计数自增&#xff08;ticks&#43;&#43;&#xff09;&#xff0c;然后主要的代码位于run_timer_list函数之中&#xff0c;该函数一方面处理所有已知的正在wait的进程的系统调用&#xff0c;如果有函数的wait已经到期则唤醒该进程</p>\n<pre>            while (timer-&gt;expires == 0) {\n                le = list_next(le);\n                struct proc_struct *proc = timer-&gt;proc;\n                if (proc-&gt;wait_state != 0) {\n                    assert(proc-&gt;wait_state &amp; WT_INTERRUPTED);\n                }\n                else {\n                    warn(&#34;process %d&#39;s wait_state == 0.\\n&#34;, proc-&gt;pid);\n                }\n                wakeup_proc(proc);\n                del_timer(timer);\n                if (le == &amp;timer_list) {\n                    break;\n                }\n                timer = le2timer(le, timer_link);\n            }</pre>\n<p>另外则是处理的进程的调度和切换&#xff0c;代码如下&#xff1a;</p>\n<pre>sched_class_proc_tick(current);</pre>\n<p></p>", "created": "2016-02-29T01:03:53Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0nan8i4g0o3s3", "children": [], "tag_good_arr": [], "id": "il7a8dn4min39z", "updated": "2016-02-29T01:03:53Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>中断处理程序为trap/trap.c中的trap_dispatch函数&#xff0c;搜索和时间有关的宏&#xff0c;发现IRQ_TIMER。也就是219行的case IRQ_OFFSET &#43; IRQ_TIMER:即为时钟中断处理程序&#xff0c;程序为&#xff08;242~245行&#xff09;&#xff1a;</p>\n<p>ticks &#43;&#43;;<br /> assert(current != NULL);<br /> run_timer_list();<br /> break;</p>\n<p>首先计数器加1&#xff0c;然后输出信息&#xff0c;run_timer_list为执行队列中注册的事件。</p>\n<p>注册事件使用函数add_timer&#xff0c;del_timer等函数。&#xff08;在schedule/sched.c中&#xff09;</p>\n<p></p>\n<p>run_timer_list(void) {<br /> bool intr_flag;<br /> local_intr_save(intr_flag);<br /> {<br /> list_entry_t *le = list_next(&amp;timer_list);<br /> if (le != &amp;timer_list) {<br /> timer_t *timer = le2timer(le, timer_link);<br /> assert(timer-&gt;expires != 0);<br /> timer-&gt;expires --;<br /> while (timer-&gt;expires == 0) {<br /> le = list_next(le);<br /> struct proc_struct *proc = timer-&gt;proc;<br /> if (proc-&gt;wait_state != 0) {<br /> assert(proc-&gt;wait_state &amp; WT_INTERRUPTED);<br /> }<br /> else {<br /> warn(&#34;process %d&#39;s wait_state == 0.\\n&#34;, proc-&gt;pid);<br /> }<br /> wakeup_proc(proc);<br /> del_timer(timer);<br /> if (le == &amp;timer_list) {<br /> break;<br /> }<br /> timer = le2timer(le, timer_link);<br /> }<br /> }<br /> sched_class_proc_tick(current);<br /> }<br /> local_intr_restore(intr_flag);<br />}</p>\n<p></p>", "created": "2016-02-29T01:08:14Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0f24oie8102cr", "children": [], "tag_good_arr": [], "id": "il7adz994de25h", "updated": "2016-02-29T01:08:14Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "中断处理从trapentry.S开始(其中有一些保存现场和恢复现场的操作), 并且调用trap, trap函数是处理异常的通用函数, 会调用trap_dispatch, trap_dispatch会查看异常号, 对于时钟中断, 会执行这段代码:\ncase IRQ_OFFSET &#43; IRQ_TIMER:\n    ticks &#43;&#43;;\n    assert(current != NULL);\n    run_timer_list();\n    break;\nrun_timer_list() 函数在.../kern/schedule/sched.c中", "created": "2016-02-29T01:08:19Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i242q8ug7vw40x", "children": [], "tag_good_arr": [], "id": "il7ae2xlpr96v8", "updated": "2016-02-29T01:08:19Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<pre>时钟驱动\n    主要在kern/driver/clock.h&#xff0c;kern/driver/clock.c\n\n使能\n    在kern/init/init.c中&#xff0c;调用clock_init();&#xff0c;初始化时钟中断&#xff0c;如触发频率\n    在kern/init/init.c中&#xff0c;调用intr_enable();&#xff0c;使能中断\n\n触发和处理\n    每一定时钟周期频率&#xff0c;触发时钟中断\n    过程如下&#xff1a;\n    CPU收到中断信号&#xff0c;跳转到trap入口&#xff1a;kern/trap/trapentry.S\n        负责保护现场&#xff0c;处理&#xff08;进入kern/trap/trap.c的trap()&#xff09;&#xff0c;恢复现场和返回\n    trap处理 kern/trap/trap.c\n        根据数据转发trap()的trap_dispatch(tf);\n    trap_dispatch\n        case IRQ_TIMER:\n        时钟处理&#xff0c;如进程调度等</pre>\n<p></p>", "created": "2016-02-29T01:10:08Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0ccfx63sir1e", "children": [], "tag_good_arr": [], "id": "il7agezgs856ir", "updated": "2016-02-29T01:10:08Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>kern/trap/vectors.S</p>\n<p>-&gt; kern/trap/trapentry.S (build trap frame, etc.)</p>\n<p>-&gt; kern/trap/trap.c: 285: void trap(struct trapframe* tf) (dispatch)</p>\n<p>-&gt; kern/trap/trap.c: 219:</p>\n<pre>case IRQ_OFFSET &#43; IRQ_TIMER:        \n        ticks &#43;&#43;;\n        assert(current != NULL);\n        run_timer_list();\n        break;</pre>\n<p></p>\n<p></p>", "created": "2016-02-29T01:10:32Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "ierwkwbinsj2t8", "children": [], "tag_good_arr": [], "id": "il7agxzynpo44l", "updated": "2016-02-29T01:10:32Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<p>乔奕 2013011324</p>\n<p>发生中断后&#xff0c;由于vectors.S指向了trapentry.S&#xff0c;所以cpu执行完当前指令后&#xff0c;pc指向trapentry.S的第一条指令。并且保存原来的pc。</p>\n<p>在trapentry.S中&#xff0c;进行了一个保存现场的工作&#xff08;把寄存器push到栈上&#xff09;,同时也在栈上构造了trapframe&#xff08;作为trap的参数&#xff09;</p>\n<pre>pushl %ds\n……\ncall trap\npopl %gs\n……\niret</pre>\n<p>然后执行call trap指令&#xff0c;进入kern/trap/trap.c/trap(trap frame) 287行</p>\n<p>trap(tf)中&#xff0c;最终会执行trap_dispatch(tf)&#xff0c;291或300行</p>\n<pre>trap_dispatch(tf)</pre>\n<p>在trap_dispatch(tf)中&#xff0c;查看tf中trapno。248行。</p>\n<pre>switch (tf-&gt;tf_trapno)\n……\ncase IRQ_OFFSET &#43; IRQ_TIMER:\n\tticks &#43;&#43;;\n        assert(current != NULL);\n        run_timer_list();\n        break;\n……</pre>\n<p>本题中&#xff0c;trapno是<b>IRQ_OFFSET </b>&#43; IRQ_TIME时&#xff0c;会执行run_timer_list&#xff0c;进行进程相关的子例程。</p>\n<p>trap_dispatch和trap结束后&#xff0c;回到trapentry.S&#xff0c;然后恢复现场&#xff08;通过popl)&#xff0c;最后执行iret。cpu会回到原来的pc继续执行。</p>\n<p></p>\n<p></p>", "created": "2016-02-29T01:11:15Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0gkdbms5ie20o", "children": [], "tag_good_arr": [], "id": "il7ahuqckq9rm", "updated": "2016-02-29T01:11:15Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>杨青霖2013011297</p>\n<p>trap函数&#xff08;定义在trap.c中&#xff09;是对中断进行处理的过程&#xff0c;所有的中断在经过中断入口函数__alltraps预处理后 (定义在 trapasm.S中) &#xff0c;都会跳转到这里。在处理过程中&#xff0c;根据不同的中断类型&#xff0c;进行相应的处理。在相应的处理过程结束以后&#xff0c;trap将会返回&#xff0c;被中断的程序会继续运行。具体如下&#xff1a;</p>\n<p>产生中断后&#xff0c;CPU 跳转到相应的中断处理入口 (vectors)&#xff0c;并在桟中压入相应的 error_code&#xff08;是否存在与异常号相关&#xff09; 以及 trap_no&#xff0c;然后跳转到 alltraps 函数入口。</p>\n<p>在栈中保存当前被打断程序的 trapframe 结构(参见过程trapasm.S)。设置 kernel (内核) 的数据段寄存器&#xff0c;最后压入 esp&#xff0c;作为 trap 函数参数(struct trapframe * tf) 并跳转到中断处理函数 trap 处。</p>\n<p></p>\n<p>根据中断号对不同的中断进行处理。其中&#xff0c;若中断号是IRQ_OFFSET &#43; IRQ_TIMER 为时钟中断&#xff0c;则把ticks 将增加一&#xff0c;<br />若中断号是IRQ_OFFSET &#43; IRQ_COM1 为串口中断&#xff0c;则显示收到的字符&#xff0c;<br />若中断号是IRQ_OFFSET &#43; IRQ_KBD 为键盘中断&#xff0c;则显示收到的字符&#xff0c;<br />若为其他中断且产生在内核状态&#xff0c;则挂起系统。</p>\n<p>结束 trap 函数的执行后&#xff0c;通过 ret 指令返回到 alltraps 执行过程。 <br />从栈中恢复所有寄存器的值。 <br />调整 esp 的值&#xff1a;跳过栈中的 trap_no 与 error_code&#xff0c;使esp指向中断返回 eip&#xff0c;通过 iret 调用恢复 cs、eflag以及 eip&#xff0c;继续执行。</p>", "created": "2016-02-29T01:11:41Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i18riqkwrl225m", "children": [], "tag_good_arr": [], "id": "il7aiezzxvc4u1", "updated": "2016-02-29T01:11:41Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>CPU首先会将中断信息压栈<br />在加载intel x86系统的中断vector基址的时候就将符号vector0(kern/trap/vectors.S)的地址装入。所以所有的中断/异常服务函数的跳转位置都指向了__alltraps(kern/trap/trapentry.S)<br />之后现场保存装入cpu放入的寄存器的异常信息形成trap frame。压栈给处理函数trap传参。<br />然后进行段切换完成内核态地址翻译的转换。<br />然后在trap函数(trap.c)内进行处理。trapframe本身的作用是为了进行嵌套中断的处理(用一种压栈的方式)。然后trap_dispatch函数分配。<br />tf-&gt;trapno是CPU在异常/中断自动压栈的值。然后根据trapno做判断&#xff0c;确认为时钟中断后进行&#xff1a;<br />1. ticks&#43;&#43;<br />2. 进行进程调度<br />然后开始返回:(trapentry.S)<br />将我们自己进行现场保存的寄存器弹出<br />iret告知CPU进行返回</p>\n<p></p>", "created": "2016-02-29T01:12:34Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "ie7xy71bn7b1s2", "children": [], "tag_good_arr": [], "id": "il7ajjs81v21gb", "updated": "2016-02-29T01:12:34Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>时钟中断在clock.c中产生&#xff0c;产生时钟中断之后CPU跳转到kern/trap/trapentry.s中</p>\n<pre>.text\n.globl __alltraps\n__alltraps:\n    # push registers to build a trap frame\n    # therefore make the stack look like a struct trapframe\n    pushl %ds\n    pushl %es\n    pushl %fs\n    pushl %gs\n    pushal</pre>\n<p>在.s中有__alltraps函数负责处理所有中断&#xff0c;保存一些段寄存器和上写文信息&#xff0c;之后调用trap函数</p>\n<pre>trap(struct trapframe *tf) {\n    // dispatch based on what type of trap occurred\n    // used for previous projects\n    if (current == NULL) {\n        trap_dispatch(tf);\n    }\n    else {\n        // keep a trapframe chain in stack\n        struct trapframe *otf = current-&gt;tf;\n        current-&gt;tf = tf;\n    \n        bool in_kernel = trap_in_kernel(tf);\n    \n        trap_dispatch(tf);\n    \n        current-&gt;tf = otf;\n        if (!in_kernel) {\n            if (current-&gt;flags &amp; PF_EXITING) {\n                do_exit(-E_KILLED);\n            }\n            if (current-&gt;need_resched) {\n                schedule();\n            }\n        }\n    }\n}</pre>\n<p>这个中断处理的函数在 kern/trap/trap.c 中&#xff0c;trap函数进而调用trap_dispatch函数进行分派</p>\n<p>在dispatch函数中根据中断号进行判断&#xff0c;当符合IRQ_OFFSET &#43; IRQ_TIMER&#xff08;即时钟中断时&#xff09;</p>\n<pre>case IRQ_OFFSET &#43; IRQ_TIMER:\n        ticks &#43;&#43;;\n        assert(current != NULL);\n        run_timer_list();\n        break;\n   </pre>\n<p>进而进入run_timer_list进行处理</p>", "created": "2016-02-29T01:13:08Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0ayxqk6wry734", "children": [], "tag_good_arr": [], "id": "il7ak9xirbx3e7", "updated": "2016-02-29T01:13:08Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>trap/trap.c trap_dispatch 为中断处理函数 具体处理时钟中断的异常号为IRQ_OFFSET &#43; IRQ_TIMER</p>\n<p>该部分代码如下&#xff1a;</p>\n<p>case IRQ_OFFSET &#43; IRQ_TIMER:<br />ticks &#43;&#43;;<br /> assert(current != NULL);<br /> run_timer_list();<br /> break;</p>", "created": "2016-02-29T01:13:25Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0em4o8wvj34lb", "children": [], "tag_good_arr": [], "id": "il7akmzw35c2fq", "updated": "2016-02-29T01:13:25Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<p>在kern/driver/clock.c中<br />第39行</p>\n<pre>outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);\noutb(IO_TIMER1, TIMER_DIV(100) % 256);\noutb(IO_TIMER1, TIMER_DIV(100) / 256);</pre>\n<p>用于设置8253时钟控制器的初始化&#xff0c;设置触发频率等。</p>\n<p></p>\n<p>在第47行&#xff1a;</p>\n<pre>pic_enable(IRQ_TIMER);</pre>\n<p>用于设置IO中断使能。</p>\n<p></p>\n<p>中断处理时首先进入中断向量表&#xff0c;在kern/trap/vector.S中。这里面push进栈两个参数后&#xff0c;跳转到kern/trap/trapentry.S中的__alltraps函数中。这个函数中调用kern/trap/trap.c中的trap函数。在这里面调用trap_dispatch函数&#xff0c;该函数用于中断处理的分发。</p>\n<pre>case IRQ_OFFSET &#43; IRQ_TIMER:\n    ticks &#43;&#43;;\n    assert(current != NULL);\n    run_timer_list();\n    break;</pre>\n<p>这段代码为处理时钟中断。可以看出时钟中断的中断号为IRQ_OFFSET &#43; IRQ_TIMER。</p>\n<p></p>\n<p>处理完毕后&#xff0c;在trapentry.S中有iret指令返回。</p>", "created": "2016-02-29T01:14:06Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0minzvpea57bu", "children": [], "tag_good_arr": [], "id": "il7alj7we8a2uz", "updated": "2016-02-29T01:14:06Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>ucore的时钟中断处理流程如下&#xff0c;当检测到时钟中断后&#xff0c;首先跳转到trapentry.s&#xff0c;</p>\n<pre> call trap</pre>\n<p>然后进入异常处理函数trap&#xff0c;随后在trap_dispatch中对通过中断号发现时钟中断&#xff0c;</p>\n<pre>    case IRQ_OFFSET &#43; IRQ_TIMER:\n        ticks &#43;&#43;;\n        assert(current != NULL);\n        run_timer_list();\n        break;</pre>\n<p></p>\n<p>给ticks&#43;1&#xff0c;然后跳入run_timer_list()(kern/schedule/sched.c)进行进一步处理。</p>\n<pre>void\nrun_timer_list(void) {\n    bool intr_flag;\n    local_intr_save(intr_flag);\n    {\n        list_entry_t *le = list_next(&amp;timer_list);\n        if (le != &amp;timer_list) {\n            timer_t *timer = le2timer(le, timer_link);\n            assert(timer-&gt;expires != 0);\n            timer-&gt;expires --;\n            while (timer-&gt;expires == 0) {\n                le = list_next(le);\n                struct proc_struct *proc = timer-&gt;proc;\n                if (proc-&gt;wait_state != 0) {\n                    assert(proc-&gt;wait_state &amp; WT_INTERRUPTED);\n                }\n                else {\n                    warn(&#34;process %d&#39;s wait_state == 0.\\n&#34;, proc-&gt;pid);\n                }\n                wakeup_proc(proc);\n                del_timer(timer);\n                if (le == &amp;timer_list) {\n                    break;\n                }\n                timer = le2timer(le, timer_link);\n            }\n        }\n        sched_class_proc_tick(current);\n    }\n    local_intr_restore(intr_flag);\n}</pre>\n<p>在run_timer_list()中&#xff0c;首先用local_intr_save()关闭中断&#xff0c;然后对系统内部保存的一个timer列表进行处理&#xff0c;将每个timer的expire都-1&#xff0c;一旦发现有timer已经expired&#xff0c;就唤醒等待对应timer的进程&#xff0c;并删除该timer.系统会对整个列表都进行遍历&#xff0c;结束后再打开中断。</p>\n<p></p>", "created": "2016-02-29T01:14:12Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0dlq4m0wjn5eo", "children": [], "tag_good_arr": [], "id": "il7alnj4kab52t", "updated": "2016-02-29T01:14:12Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>driver/clock.c为8253 timer的驱动程序&#xff0c;clock_init里面</p>\n<pre>    // set 8253 timer-chip\n    outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);\n    outb(IO_TIMER1, TIMER_DIV(100) % 256);\n    outb(IO_TIMER1, TIMER_DIV(100) / 256);\n\n    // initialize time counter &#39;ticks&#39; to zero\n    ticks = 0;\n\n    cprintf(&#34;&#43;&#43; setup timer interrupts\\n&#34;);\n    pic_enable(IRQ_TIMER);</pre>\n<p>pic_enable设置使能。</p>\n<p></p>\n<p>kern/trap/trapentry.S为trap处理例程&#xff0c;在发生中断时&#xff0c;首先保护现场、构造栈帧&#xff0c;然后</p>\n<pre>call trap</pre>\n<p>进入到kern/trap/trap.c&#xff0c;里面调用了trap_dispatch&#xff1a;</p>\n<pre>case IRQ_OFFSET &#43; IRQ_TIMER:\n    ticks &#43;&#43;;\n    assert(current != NULL);\n    run_timer_list();\n    break;</pre>\n<p></p>", "created": "2016-02-29T01:14:32Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0c1nsm3911wc", "children": [], "tag_good_arr": [], "id": "il7am314jpe63", "updated": "2016-02-29T01:14:32Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<p><img src=\"/img/631-7222bb3e5eddde87.png\" height=\"160\" width=\"502\" /></p>\n<p>trap.h中&#xff0c;找到时钟中断对应的宏IRQ_TIMER</p>\n<p><img src=\"/img/631-f7e0f3184f19228e.png\" height=\"440\" width=\"254\" /></p>\n<p>trap.c中&#xff0c;找到IRQ_TIMER对应的处理代码片段。找到run_timer_list()&#xff0c;</p>\n<p><img src=\"/img/631-1e4a0f01a4240638.png\" height=\"480\" width=\"486\" /></p>\n<p>ucore应该是维护了一个timer_list&#xff0c;时钟中断之后在这个timer_list里面寻找一个进程去处理。</p>\n<p>时钟中断的初始化&#xff1a;</p>\n<p><img src=\"/img/631-48cc3382b881ef25.png\" height=\"188\" width=\"397\" /></p>", "created": "2016-02-29T01:14:37Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i6w84pnmjCQ", "children": [], "tag_good_arr": [], "id": "il7am6mfymb38u", "updated": "2016-02-29T01:14:37Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p><strong>krajna 2014010527</strong></p>\n<p>时钟中断检测到之后cpu跳转到中断向量表&#xff0c;取出一个vector的handler的地址&#xff0c;在kern/trap/vector.s中&#xff0c;再统一跳转到kern/trap/trapentry.s的__alltraps:中接着调用C代码kern/trap/trap.c中的trap();在trap()中根据trapframe的信息跳转到trap.c中的trap_dispatch()中找到IRQ_OFFSET&#43;IRQ_TIMER的地址进行相应中断的处理。最后返回汇编代码&#xff0c;iret返回。</p>", "created": "2016-02-29T01:14:41Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "ikx8y1dzPrM", "children": [], "tag_good_arr": [], "id": "il7am9m0jo27fy", "updated": "2016-02-29T01:14:41Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>trap函数是处理中断的入口函数&#xff0c;在trap函数中调用trap_dispatch()函数&#xff1b;在trap_dispatch中时钟中断异常号为IRQ_OFFSET &#43; IRQ_TIMER&#xff0c;处理代码如下&#xff1a;</p>\n<p>case IRQ_OFFSET &#43; IRQ_TIMER:<br />    ticks &#43;&#43;;<br />    assert(current != NULL);<br />    run_timer_list();<br />    break;</p>\n<p></p>\n<p>调用kern\\schedule\\sched.c\\run_timer_list()进行处理</p>", "created": "2016-02-29T01:15:23Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0f7v0qgfm61s6", "children": [], "tag_good_arr": [], "id": "il7an66qumtsv", "updated": "2016-02-29T01:15:23Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>kern/driver/clock.c对时钟进行初始化</p>\n<pre>void\nclock_init(void) {\n    // set 8253 timer-chip\n    outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);\n    outb(IO_TIMER1, TIMER_DIV(100) % 256);\n    outb(IO_TIMER1, TIMER_DIV(100) / 256);\n\n    // initialize time counter &#39;ticks&#39; to zero\n    ticks = 0;\n\n    cprintf(&#34;&#43;&#43; setup timer interrupts\\n&#34;);\n    pic_enable(IRQ_TIMER);\n}</pre>\n<p>outb函数定义在x86.h中&#xff0c;初始化的主要工作是将时钟计数器置零&#xff0c;定义触发频率等。</p>\n<p>当中断发生时&#xff0c;系统会调用kern/trap/trap.c&#xff0c;来处理时钟中断。</p>\n<pre>case IRQ_OFFSET &#43; IRQ_TIMER:\n        ticks &#43;&#43;;\n        assert(current != NULL);\n        run_timer_list();\n        break;</pre>\n<p>run_timer_list()的实现在kern/schedule/sched.c中实现</p>", "created": "2016-02-29T01:15:52Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i1bzj2xilgm4uk", "children": [], "tag_good_arr": [], "id": "il7anslpnf69m", "updated": "2016-02-29T01:15:52Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>中断发生后&#xff0c;系统先进到<span style=\"color:#333333\">vector.S中&#xff0c;通过<span style=\"color:#333333\">vector.S跳转到trap.c中的trap函数&#xff0c;再通过trap函数转到trap_dispatch函数中&#xff0c;</span></span></p>\n<p><span style=\"color:#333333\"><span style=\"color:#333333\">在trap_dispatch函数里&#xff0c;判断时间中断的语句如下&#xff1a;</span></span></p>\n<p><span style=\"color:#333333\"><span style=\"color:#333333\">case IRQ_OFFSET &#43; IRQ_TIMER:</span></span></p>\n<p><span style=\"color:#333333\"><span style=\"color:#333333\">        ticks &#43;&#43;;<br />        assert(current != NULL);<br />        run_timer_list();<br />        break;</span></span></p>\n<p><span style=\"color:#333333\"><span style=\"color:#333333\">由此处&#xff0c;跳转到<span style=\"color:#333333\">sched.c的run_timer_list函数&#xff0c;处理执行中的队列事件</span></span></span></p>\n<p><span style=\"color:#333333\"><span style=\"color:#333333\"></span></span></p>\n<p></p>", "created": "2016-02-29T01:17:09Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "ikvcvq38pa7l6", "children": [], "tag_good_arr": [], "id": "il7apfz887y7b7", "updated": "2016-02-29T01:17:09Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>检测到时钟中断之后&#xff0c;系统会得到时钟中断相关的信息&#xff0c;作为一个trapframe传入trap.c的trap_dispatch函数中&#xff0c;然后根据中断规则进行处理&#xff1a;</p>\n<p>static void<br />trap_dispatch(struct trapframe *tf) {<br /> char c;</p>\n<p>int ret=0;</p>\n<p>switch (tf-&gt;tf_trapno) {</p>\n<p>    case IRQ_OFFSET &#43; IRQ_TIMER:</p>\n<p>        ticks &#43;&#43;;<br />        assert(current != NULL);<br />        run_timer_list();  <br />        break;</p>\n<p>然后再进入sched.c的        run_timer_list()函数进行处理。</p>\n<p></p>\n<p></p>", "created": "2016-02-29T01:18:11Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0zaci5voig5h", "children": [], "tag_good_arr": [], "id": "il7aqrxozw82ol", "updated": "2016-02-29T01:18:11Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>发生中断之后&#xff0c;首先执行trapentry.S中的汇编代码进入中断处理逻辑。</p>\n<p></p>\n<p>在kern/trap.c中的trap函数&#xff0c;检查当前进程之后&#xff0c;会进入trap_dispatch函数&#xff0c;进行中断类型的判断。</p>\n<p>其中的参数是一个trapframe类型的结构体&#xff0c;包含了中断处理中需要的全部信息。</p>\n<p>检查其中的trapno&#xff0c;也就是中断号&#xff0c;第219行&#xff0c;就是时钟中断&#xff1a;</p>\n<pre>case IRQ_OFFSET &#43; IRQ_TIMER:\n        ticks &#43;&#43;;\n        assert(current != NULL);\n        run_timer_list();\n        break;</pre>\n<p>具体处理流程在run_timer_list()中</p>", "created": "2016-02-29T01:18:16Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0gl5kctugw3xi", "children": [], "tag_good_arr": [], "id": "il7aqvs83t26k4", "updated": "2016-02-29T01:18:16Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>在kern/trap/trap.c中</p>\n<p>通过trap函数对中断进行处理&#xff0c;调用trap_dispatch()函数&#xff0c;在trap_dispatch()中检测中断类型。</p>\n<p>其中&#xff0c;一下代码为时钟中断的处理代码。</p>\n<p>case IRQ_OFFSET &#43; IRQ_TIMER:</p>\n<p>        ticks &#43;&#43;;<br />        assert(current != NULL);<br />        run_timer_list();<br />        break;</p>\n<p>计数器&#43;1&#xff0c;之后调用run_timer_list()。</p>\n<p>张殿炎2013011328</p>", "created": "2016-02-29T01:21:08Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i28skba6cd976f", "children": [], "tag_good_arr": [], "id": "il7aukl1rni1v7", "updated": "2016-02-29T01:21:08Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>在 kern/driver/clock.c 中 clock_init 函数实现时钟的初始化</p>\n<pre>void\nclock_init(void) {\n    // set 8253 timer-chip\n    outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);\n    outb(IO_TIMER1, TIMER_DIV(100) % 256);\n    outb(IO_TIMER1, TIMER_DIV(100) / 256);\n\n    // initialize time counter &#39;ticks&#39; to zero\n    ticks = 0;\n\n    cprintf(&#34;&#43;&#43; setup timer interrupts\\n&#34;);\n    pic_enable(IRQ_TIMER);\n}</pre>\n<p>在kern/trap/trap.c 中的trap_dispatch函数来处理中断&#xff0c;其中时钟中断为</p>\n<pre>case IRQ_OFFSET &#43; IRQ_TIMER:\n        ticks &#43;&#43;;\n        assert(current != NULL);\n        run_timer_list();\n        break;</pre>\n<p></p>", "created": "2016-02-29T01:21:29Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0d4mr9tga62ki", "children": [], "tag_good_arr": [], "id": "il7av1015ar3uf", "updated": "2016-02-29T01:21:29Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>#2013011302</p>\n<p>trap处理中断。在此函数中调用trap_dispatch()。处理代码<br />case IRQ_OFFSET &#43; IRQ_TIMER:<br />    ticks &#43;&#43;;<br />    assert(current != NULL);<br />    run_timer_list();<br />    break;<br />再调用run_timer_list()</p>", "created": "2016-02-29T01:21:35Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "ikvcvo2cckb7jb", "children": [], "tag_good_arr": [], "id": "il7av5puvmm2cn", "updated": "2016-02-29T01:21:35Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>1. Cpu 跳转到 trapentry.S 中的alltraps&#xff0c;之后再跳转到trap.c 在其中的trap_dispatch函数处理中断&#xff0c;然后返回到alltraps函数&#xff0c;恢复寄存器的值&#xff0c;然后返回程序继续执行</p>", "created": "2016-02-29T01:21:40Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0c9nvk0xzc2n3", "children": [], "tag_good_arr": [], "id": "il7av9jgxz32gu", "updated": "2016-02-29T01:21:40Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>CPU收到时钟中断信号&#xff0c;时钟中断定义在clock.h&#xff0c;并于init.c初始化时钟&#xff0c;CPU处理机器码在trapentry.s</p>\n<p>if (current == NULL) {<br />        trap_dispatch(tf);<br />    }<br />    else {<br />        // keep a trapframe chain in stack<br />        struct trapframe *otf = current-&gt;tf;<br />        current-&gt;tf = tf;<br />    <br />        bool in_kernel = trap_in_kernel(tf);<br />    <br />        trap_dispatch(tf);<br />    <br />        current-&gt;tf = otf;<br />        if (!in_kernel) {<br />            if (current-&gt;flags &amp; PF_EXITING) {<br />                do_exit(-E_KILLED);<br />            }<br />            if (current-&gt;need_resched) {<br />                schedule();<br />            }<br />        }<br />    }</p>\n<p>上面是trap函数片段&#xff0c;调入trap_dispatch(tf)&#xff0c;分析中断类型为时钟中断&#xff0c;转到run_timer_list()处理中断</p>\n<p></p>\n<p></p>", "created": "2016-02-29T01:22:06Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0brpl1lbyui6", "children": [], "tag_good_arr": [], "id": "il7avt6znyg2v0", "updated": "2016-02-29T01:22:06Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p><p>kern/init/init.c的init()函数初始化时钟中断触发频率</p>\n<pre>void\nclock_init(void) {\n    // set 8253 timer-chip\n    outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);\n    outb(IO_TIMER1, TIMER_DIV(100) % 256);\n    outb(IO_TIMER1, TIMER_DIV(100) / 256);\n\n    // initialize time counter &#39;ticks&#39; to zero\n    ticks = 0;\n\n    cprintf(&#34;&#43;&#43; setup timer interrupts\\n&#34;);\n    pic_enable(IRQ_TIMER);\n}</pre>\n<p>中断到来时&#xff0c;进入trap.S&#xff0c;保存现场&#xff0c;跳转到trap.c的trap()函数&#xff0c;</p>\n<p>之后进入trap_dispatch函数&#xff0c;再进入run_timer_list()处理时钟中断</p>", "created": "2016-02-29T01:24:07Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0eqqq6jvng408", "children": [], "tag_good_arr": [], "id": "il7ayevkaj76bg", "updated": "2016-02-29T01:24:07Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>出现中断后&#xff0c;先保存现场&#xff0c;在trapentry.s</p>\n<p>__alltraps:</p>\n<p>    # push registers to build a trap frame</p>\n<p>    # therefore make the stack look like a struct trapframe</p>\n<p>    pushl %ds</p>\n<p>    pushl %es</p>\n<p>    pushl %fs</p>\n<p>    pushl %gs</p>\n<p>    pushal</p>\n<p>    # load GD_KDATA into %ds and %es to set up data segments for kernel</p>\n<p>    movl $GD_KDATA, %eax</p>\n<p>    movw %ax, %ds</p>\n<p>    movw %ax, %es</p>\n<p>    # push %esp to pass a pointer to the trapframe as an argument to trap()</p>\n<p>pushl %esp</p>\n<p>然后执行trap()</p>\n<p>call trap</p>\n<p>进入trap_dispatch(),根据不同类型的中断来处理</p>\n<p>时钟中断的处理如下&#xff1a;</p>\n<p>ticks &#43;&#43;;</p>\n<p>assert(current != NULL);</p>\n<p>run_timer_list();</p>", "created": "2016-02-29T01:24:43Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i3qk2vs65x276j", "children": [], "tag_good_arr": [], "id": "il7az62g1x76wa", "updated": "2016-02-29T01:24:43Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>在ucore的lab8/kern/trapentry.S中可以看到,中断产生后从vectors.S转入trapentry.S.<br />由_alltraps进入&#xff0c;首先保存现场&#xff0c;将寄存器压栈&#xff0c;之后call trap调用lab8/kern/trap.c<br />存在trap函数是处理中断的通用函数。其首先执行</p>\n<pre><br />if (current == NULL) {<br />        trap_dispatch(tf);<br />    }</pre>\n<p>使用trap_dispath函数来确定中断类型。<br />在trap_dispath中 IRQ_OFFSET &#43; IRQ_TIMER表示时钟中断。<br />执行</p>\n<pre>case IRQ_OFFSET &#43; IRQ_TIMER:<br />\tticks&#43;&#43;;<br />\tassert(current != NULL);<br />\trun_timer_list();<br />\tbreak;</pre>\n<p>根据调用执行run_timer_list()。</p>", "created": "2016-02-29T01:25:20Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0evrfcnckf5dt", "children": [], "tag_good_arr": [], "id": "il7azzdd4oe2wj", "updated": "2016-02-29T01:25:20Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>徐捷 2012011371</p>\n<p>trap.h/trap.c是用来处理异常和中断的&#xff0c;可以看到IRQ_TIMER是时钟中断信号的宏定义。找到trap.c的第219行开始:</p>\n<pre>case IRQ_OFFSET &#43; IRQ_TIMER:<br />        ticks &#43;&#43;;<br />        assert(current != NULL);<br />        run_timer_list();<br />        break;</pre>\n<p>用一个计数器ticks来进行时钟中断计数&#xff1b;然后运行到run_timer_list()中去对相应的中断进行处理。</p>\n<p></p>\n<p></p>", "created": "2016-02-29T01:25:50Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i6ub4vwhQXd", "children": [], "tag_good_arr": [], "id": "il7b0ly3uv75ti", "updated": "2016-02-29T01:25:50Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>Call Graph: trap—&gt;trap_dispatch—&gt;run_timer_list</p>\n<p>     0. </p>\n<p>内核初始化时对时钟中断使能</p>\n<p><b>int</b> kern_init<b>(void) </b><b>&#xff5b;</b></p>\n<p>  …</p>\n<p>  clock_init<b>();</b>               <i>// init clock interrupt</i></p>\n<p><i>  …</i></p>\n<p><i>} // from /kern/driver/init.c</i></p>\n<p><b>void</b> clock_init<b>(void)</b> <b>{</b></p>\n<p>  …</p>\n<p>  pic_enable<b>(IRQ_TIMER); // </b><b>使能时钟中断</b></p>\n<p>  …</p>\n<p>} // from /kern/driver/clock.c</p>\n<ol><li>trap()是各中断处理的入口(/kern/trap/trap.c)</li><li>trap_dispatch()判断中断类型&#xff0c;这里选择case <b>IRQ_OFFSET</b> <b>&#43;</b> <b>IRQ_TIMER</b>(/kern/trap/trap.c)</li><li>run_timer_list()函数中&#xff0c;使用结构体list_entry_t创建了一个双向列表&#xff0c;遍历之&#xff0c;唤醒timer到期的线程wakeup_proc<b>(</b>proc<b>);</b> (文件/kern/schedule/sched.c)</li></ol>", "created": "2016-02-29T01:26:06Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0b7d04pl3y6c0", "children": [], "tag_good_arr": [], "id": "il7b0ycrlrs21f", "updated": "2016-02-29T01:26:06Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>CPU收到时钟中断信号&#xff0c;跳转到vector.S中相应的中断向量处&#xff0c;从那里再跳转到trapentry.S中的__alltraps处&#xff0c;在那里保存现场后调用trap.c的trap函数&#xff0c;trap函数调用trap_dispatch函数&#xff0c;后者根据trapframe调用相应的中断处理函数。</p>", "created": "2016-02-29T01:26:48Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i11dx198ive25r", "children": [], "tag_good_arr": [], "id": "il7b1uo2zz0179", "updated": "2016-02-29T01:26:48Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>中断触发后&#xff0c;首先执行trapentry.s中的代码&#xff0c;然后会进入kern/trap.c中的trap_dispatch函数&#xff0c;然后会进行中断类型的判断&#xff0c;</p>\n<p>从这个分支case IRQ_OFFSET &#43; IRQ_TIMER:进入&#xff0c;执行run_timer_list函数&#xff0c;进行时钟中断的相关处理</p>", "created": "2016-02-29T01:28:01Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0yuo4o74sx70w", "children": [], "tag_good_arr": [], "id": "il7b3fg9yq71d3", "updated": "2016-02-29T01:28:01Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>先在clock.c中实现时钟的初始化&#xff0c;然后在trap.c里面实现处理异常和时钟中断</p>\n<pre>    case IRQ_OFFSET &#43; IRQ_TIMER:\n        ticks &#43;&#43;;\n        assert(current != NULL);\n        run_timer_list();\n        break;</pre>\n<p>用ticks进行时钟中断计数&#xff0c;然后在run_tiimer_list里面进行处理。</p>\n<p></p>\n<p>程凯 2013011303</p>", "created": "2016-02-29T01:29:27Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i1569mw0xp954u", "children": [], "tag_good_arr": [], "id": "il7b59ydwxf4ud", "updated": "2016-02-29T01:29:27Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>马志明 2013011395<br />在kern/trap/trapentry.S中进入中断&#xff0c;然后调用kern/trap/trap.c中的trap函数&#xff08;第284行&#xff09;&#xff0c;该函数会自检当前的进程之后调用该文件中trap_dispatch函数进行中断类型检查&#xff0c;如果是时钟中断的话&#xff0c;转到run_timer_list函数执行。</p>", "created": "2016-02-29T01:29:36Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i21zpwab2z775p", "children": [], "tag_good_arr": [], "id": "il7b5ghi6er6s7", "updated": "2016-02-29T01:29:36Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>在trapentry.S里call trap调用trap.c中的trap函数&#xff0c;trap调用trap_dispatch函数&#xff0c;处理时钟中断</p>\n<pre>    case IRQ_OFFSET &#43; IRQ_TIMER:<br />        ticks &#43;&#43;;<br />        assert(current != NULL);<br />        run_timer_list();<br />        break;</pre>\n<p></p>", "created": "2016-02-29T01:29:48Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i17iy2ly5py3ad", "children": [], "tag_good_arr": [], "id": "il7b5poo7aq51h", "updated": "2016-02-29T01:29:48Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>CPU接受到中断信号后&#xff0c;都会跳转到kern/trap/trapentry.S的_alltraps&#xff0c;保存了现场后&#xff0c;会进入到kern/trap/trap.c的trap()函数中&#xff0c;在该函数中直接调用trap_dispatcher()分配&#xff0c;查看trap_dispatcher()函数&#xff0c;可以找到对应处理时钟中断的代码&#xff1a;</p>\n<pre>case IRQ_OFFSET &#43; IRQ_TIMER:<br />        ticks &#43;&#43;;<br />        assert(current != NULL);<br />        run_timer_list();<br />        break;</pre>\n<p>最后进入run_timer_list()进行处理。</p>", "created": "2016-02-29T01:29:55Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i6ugy67km5b", "children": [], "tag_good_arr": [], "id": "il7b5vinbm35rb", "updated": "2016-02-29T01:29:55Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>大体流程&#xff1a;trap-&gt;trap_dispatch-&gt;run_timer_list</p>\n<p>其中trap和trap_dispatch中的参数trapframe&#xff0c;关键的成员trapno中断号&#xff0c;当trapno的值为IRQ_OFFSET &#43; IRQ_TIMER&#xff0c;代表时钟中断&#xff0c;trap_dispatch会做以下处理&#xff1a;</p>\n<p>&#xff08;1&#xff09;计数器ticks累加1.</p>\n<p>&#xff08;2&#xff09;检查当前进程是否为空。</p>\n<p>&#xff08;3&#xff09;若不为空&#xff0c;调用run_timer_list进行时钟中断的处理。</p>\n<p>在run_timer_list里&#xff0c;检查所有delay的进程&#xff0c;delay ticks减1&#xff0c;当delay ticks的值为0时&#xff0c;判断该进程是否在wait状态&#xff0c;若不是则唤醒该进程。</p>", "created": "2016-02-29T01:30:12Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "ibz6vywnw6g7nl", "children": [], "tag_good_arr": [], "id": "il7b688ox8j78v", "updated": "2016-02-29T01:30:12Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p> 梁泽宇 2014011381</p>\n<p></p>\n<p></p>\n<p>&#xff08;1&#xff09;在/kern/driver/clock.c中&#xff0c;时钟初始化&#xff08;clock_init()&#xff09;中&#xff0c;每秒触发100次时钟中断&#xff08;初始时钟计数ticks为0&#xff09;&#xff1a;</p>\n<pre>void\nclock_init(void) {\n    // set 8253 timer-chip\n    outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);\n    outb(IO_TIMER1, TIMER_DIV(100) % 256);\n    outb(IO_TIMER1, TIMER_DIV(100) / 256);\n\n    // initialize time counter &#39;ticks&#39; to zero\n    ticks = 0;\n\n    cprintf(&#34;&#43;&#43; setup timer interrupts\\n&#34;);\n    pic_enable(IRQ_TIMER);\n}</pre>\n<p>&#xff08;2&#xff09;在/kern/trap/trap.c中&#xff0c;trap_dispatch()函数进行中断处理&#xff0c;其中中断号为IRQ_OFFSET &#43; IRQ_TIMER表示时钟中断&#xff1b;</p>\n<p>&#xff08;3&#xff09;处理时钟中断时&#xff0c;首先时钟计数ticks加1&#xff0c;并确保当前进程不为空&#xff0c;然后交run_timer_list()函数&#xff08;在/kern/schedule/sched.c中&#xff09;&#xff1a;</p>\n<pre>    case IRQ_OFFSET &#43; IRQ_TIMER:\n#if 0\n    LAB3 : If some page replacement algorithm(such as CLOCK PRA) need tick to change the priority of pages, \n    then you can add code here. \n#endif\n        ticks &#43;&#43;;\n        assert(current != NULL);\n        run_timer_list();\n        break;</pre>\n<p>&#xff08;4&#xff09;run_timer_list()函数中&#xff0c;获取时钟列表&#xff08;timer_list&#xff09;中所有等待时间已到的时钟&#xff0c;并唤醒这些时钟对应的进程&#xff0c;其余进程的等待时间减1&#xff0c;最后将当前进程加入时钟列表&#xff1a;</p>\n<pre>void\nrun_timer_list(void) {\n    bool intr_flag;\n    local_intr_save(intr_flag);\n    {\n        list_entry_t *le = list_next(&amp;timer_list);\n        if (le != &amp;timer_list) {\n            timer_t *timer = le2timer(le, timer_link);\n            assert(timer-&gt;expires != 0);\n            timer-&gt;expires --;\n            while (timer-&gt;expires == 0) {\n                le = list_next(le);\n                struct proc_struct *proc = timer-&gt;proc;\n                if (proc-&gt;wait_state != 0) {\n                    assert(proc-&gt;wait_state &amp; WT_INTERRUPTED);\n                }\n                else {\n                    warn(&#34;process %d&#39;s wait_state == 0.\\n&#34;, proc-&gt;pid);\n                }\n                wakeup_proc(proc);\n                del_timer(timer);\n                if (le == &amp;timer_list) {\n                    break;\n                }\n                timer = le2timer(le, timer_link);\n            }\n        }\n        sched_class_proc_tick(current);\n    }\n    local_intr_restore(intr_flag);\n}</pre>\n<p></p>", "created": "2016-02-29T01:31:26Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "ie7xy3iwuug1os", "children": [], "tag_good_arr": [], "id": "il7b7tglos36uy", "updated": "2016-02-29T01:31:26Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<p>首先在kern/trap/trapentry.s中的alltraps中保存寄存器的值&#xff0c;然后调用</p>\n<p>kern/trap/trap.c中的trap函数来处理中断。在trap函数中调用trap_dispatch函数。然后再trap_dispatch函数中判断时钟中断&#xff1a;</p>\n<pre>    case IRQ_OFFSET &#43; IRQ_TIMER:<br />        ticks &#43;&#43;;<br />        assert(current != NULL);<br />        run_timer_list();<br />        break;</pre>\n<p>首先让计数器加一&#xff0c;然后判断当前进程若不为空&#xff0c;则调用run_timer_list函数。</p>\n<p>最后返回alltraps函数</p>", "created": "2016-02-29T01:34:38Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0hjdkesg9c5z7", "children": [], "tag_good_arr": [], "id": "il7bbx9ijfg3r8", "updated": "2016-02-29T01:34:38Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<p>首先在发生中断时&#xff0c;在trapentry.S中&#xff0c;进行了一个保存现场的工作。</p>\n<p></p>\n<p>然后在trap.c/trap.h中进行了处理终中断的操作&#xff1a;</p>\n<p>检测到IRQ_TIMER&#xff0c;即发生时钟中断是发生如下操作</p>\n<pre>case IRQ_OFFSET &#43; IRQ_TIMER:\n        ticks &#43;&#43;;\n        assert(current != NULL);\n        run_timer_list();\n        break;</pre>\n<p>首先是计数器加1&#xff0c;然后调用run_timer_list函数&#xff0c;调用注册时钟对应的进程。</p>\n<p></p>", "created": "2016-02-29T01:37:33Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i701mss708y", "children": [], "tag_good_arr": [], "id": "il7bfocycrp53n", "updated": "2016-02-29T01:37:33Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>在trapentry.s中保存现场&#xff0c;在trap.c中处理中断。</p>\n<p>case IRQ_OFFSET &#43; IRQ_TIMER: 就是时钟中断的种类。</p>\n<p>这里面tick&#43;&#43;&#xff0c;计数。</p>\n<p>然后调用run_timer_list函数&#xff0c;在sched.c里面进行处理。</p>\n<p></p>\n<p></p>\n<p></p>", "created": "2016-02-29T01:50:24Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0ccqbaxwdz75c", "children": [], "tag_good_arr": [], "id": "il7bw7h9qcn3bh", "updated": "2016-02-29T01:50:24Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>中断处理在 kern/trap/trap.c 中&#xff0c;第219行<br />case IRQ_OFFSET &#43; IRQ_TIMER:<br /> ticks &#43;&#43;;<br /> assert(current != NULL);<br /> run_timer_list();<br /> break;</p>\n<p></p>\n<p>2013011409 王启圣</p>", "created": "2016-02-29T01:58:06Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0nu5by9l7v7of", "children": [], "tag_good_arr": [], "id": "il7c649otfm4f2", "updated": "2016-02-29T01:58:06Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>赖国堃 2012011372</p>\n<p></p>\n<p>在ucore的lab8中&#xff0c;cpu接到中断信号之后&#xff0c;会用trapentry.S保存现场&#xff0c;然后跳转进trap.c中的trap()函数&#xff0c;由时钟中断的宏的定义可以找到代码&#xff0c;<br /><br />case IRQ_OFFSET &#43; IRQ_TIMER:<br /> ticks &#43;&#43;;<br /> assert(current != NULL);<br /> run_timer_list();<br /> break;<br /><br />这里可以看到有个计数器对中断技术&#xff0c;然后跳转至run_timer_list()处理相应中断。</p>", "created": "2016-02-29T02:08:27Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i6uiksj895B", "children": [], "tag_good_arr": [], "id": "il7cjeuqohg1aj", "updated": "2016-02-29T02:08:27Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>高博</p>\n<p>2012012139</p>\n<pre style=\"text-align:left\">中断处理从trapentry.S开始(其中有一些保存现场以及恢复现场的操作), 并且调用trap, trap函数是处理异常的通用函数, 会调用trap_dispatch, trap_dispatch会查看异常号, 对于时钟中断, 会执行这段代码:<br />case IRQ_OFFSET &#43; IRQ_TIMER:<br />\tticks &#43;&#43;;<br />\tassert(current != NULL);<br />\trun_timer_list();<br />\tbreak;<br />run_timer_list() 函数在.../kern/schedule/sched.c中</pre>\n<p></p>", "created": "2016-02-29T02:18:43Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "ic226rac4j5jw", "children": [], "tag_good_arr": [], "id": "il7cwm2ph1y4gq", "updated": "2016-02-29T02:18:43Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>在kern/driver/clock.c中</p>\n<pre>clock_init(void)</pre>\n<p>在这个函数中初始化了时钟控制控制器&#xff0c;并设置了IO中断使能。</p>\n<p>之后执行kern/trap/trapentry.S中的__alltraps函数中&#xff0c;</p>\n<p>通过call trap跳转到kern/trap/trap.c&#xff0c;执行</p>\n<pre>trap(struct trapframe *tf)</pre>\n<p>在这个函数中会调用</p>\n<pre>trap_dispatch(struct trapframe *tf)</pre>\n<p>这个函数的作用是对中断处理进行分发&#xff0c;</p>\n<p>最后通过kern/trap/trapentry.S中的iret指令返回。</p>\n<p></p>\n<p></p>", "created": "2016-02-29T02:47:55Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i1oqryfapik22", "children": [], "tag_good_arr": [], "id": "il7dy6njba61k8", "updated": "2016-02-29T02:47:55Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<ol><li>kernel.ld&#xff1a;\n<ul><li>ENTRY(kern_entry)</li></ul>\n</li><li>entry.S -&gt; kern_entry:\n<ul><li>call kern_init</li></ul>\n</li><li>init.c -&gt; int kern_init(void)\n<ul><li>idt_init(void);              # initialize IDT to each of the entry points in kern/trap/vectors.S\n<ul><li>SETGATE(idt[i], 0, GD_KTEXT, __vectors[i], DPL_KERNEL); </li><li>static struct gatedesc idt[256] = {{0}};</li><li>vectors.S\n<ul><li>jmp __alltraps</li><li>trapentry.S  -&gt; __alltraps:       # vectors.S sends all traps here.\n<ul><li>call trap                # call trap(tf), where tf=%esp</li></ul>\n</li><li>trap.c -&gt; void trap(struct trapframe *tf)\n<ul><li>trap_dispatch(tf);</li></ul>\n</li><li>trap.c -&gt; static void trap_dispatch(struct trapframe *tf) \n<ul><li>switch (tf-&gt;tf_trapno) { \n<ul><li>case IRQ_OFFSET &#43; IRQ_TIMER\n<ul><li>ticks &#43;&#43;;</li><li>run_timer_list();</li></ul>\n</li><li>sche.c -&gt; void run_timer_list(void);</li></ul>\n</li></ul>\n</li></ul>\n</li></ul>\n</li></ul>\n</li></ol><ol><li>\n<ul><li>clock_init();               // init clock interrupt\n<ul><li>ticks = 0; </li><li>pic_enable(IRQ_TIMER);      # 使能时钟中断请求</li></ul>\n</li></ul>\n</li></ol>", "created": "2016-02-29T03:46:16Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "ikvcvnzpzq7j7", "children": [], "tag_good_arr": [], "id": "il7g17nas821k2", "updated": "2016-02-29T03:46:16Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>ken/trap/vector.s存放了各种中断向量&#xff0c;所有中断向量都指向ken/trap/trapentry.s文件中的__alltraps作为中断处理程序。</p>\n<p>该程序保存现场&#xff0c;将中断相关信息压栈之后&#xff0c;调用ken/trap/trap.c的trap函数。</p>\n<p>trap函数有一参数struct trapframe *tf来取得各种中断信息。之后调用trap_dispatch函数。在该函数中&#xff0c;</p>\n<table><tbody><tr></tr><tr><td>case IRQ_OFFSET &#43; IRQ_TIMER:</td></tr><tr><td></td><td></td></tr><tr><td></td><td>ticks &#43;&#43;;</td></tr><tr><td></td><td>assert(current != NULL);</td></tr><tr><td></td><td>run_timer_list();</td></tr><tr><td></td><td>break;</td></tr><tr><td></td></tr></tbody></table>\n<p>kern/schedule/sched.c的run_timer_list()函数&#xff0c;给每个进程一个计时器&#xff0c;每个时间中断将剩余时间-1&#xff0c;变为0之后切换进程。</p>", "created": "2016-02-29T04:16:57Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "ikvcvr6di5i7ma", "children": [], "tag_good_arr": [], "id": "il7h4oifh6n39j", "updated": "2016-02-29T04:16:57Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<p>高越 2012011379</p>\n<p>中断时首先是去到kern/trap/trapentry.S中的__alltraps函数进行保存现场等一系列压栈的操作。接着这个程序调用了trap函数&#xff0c;位于kern/trap/trap.c中。在trap函数调用trap_dispatch函数去解析中断的类型。在这个函数中有如下代码</p>\n<p></p>\n<pre>case IRQ_OFFSET &#43; IRQ_TIMER:\n\tticks &#43;&#43;;\n        assert(current != NULL);\n        run_timer_list();\n        break;</pre>\n<p>其中IRQ_TIMER是时钟中断的标志。最后到run_timer_list()中去做时钟中断的处理</p>", "created": "2016-02-29T05:26:57Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i6uuj5n1v5y2t6", "children": [], "tag_good_arr": [], "id": "il7jmoyve1v2l4", "updated": "2016-02-29T05:26:57Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "出现中断后&#xff0c;先保存现场&#xff0c;在trapentry.s\n__alltraps:\n    # push registers to build a trap frame\n    # therefore make the stack look like a struct trapframe\n    pushl %ds\n    pushl %es\n    pushl %fs\n    pushl %gs\n    pushal\n    # load GD_KDATA into %ds and %es to set up data segments for kernel\n    movl $GD_KDATA, %eax\n    movw %ax, %ds\n    movw %ax, %es\n    # push %esp to pass a pointer to the trapframe as an argument to trap()\npushl %esp\n接着调用trap()函数。\ncall trap\ntrap()函数中调用trap_dispatch(),根据不同类型的中断来处理\n时钟中断的处理如下&#xff1a;\nticks &#43;&#43;;\nassert(current != NULL);\nrun_timer_list();", "created": "2016-02-29T06:49:52Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i6uaz437IKR", "children": [], "tag_good_arr": [], "id": "il7mlbw5t1t7bt", "updated": "2016-02-29T06:49:52Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>trap/trap.c中的trap_dispatch函数根据中断号来处理中断。</p>\n<p>执行ticks &#43;&#43;; assert(current != NULL); run_timer_list();</p>", "created": "2016-02-29T06:56:07Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i6vjwdpfniF", "children": [], "tag_good_arr": [], "id": "il7mtcqyvy21j7", "updated": "2016-02-29T06:56:07Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>2012011284 章彦恺<br /><br />1. 3.3中的第4小题&#xff1a;以ucore lab8的answer为例&#xff0c;uCore的时钟中断处理流程。<br /><br />由硬件触发时钟中断使能后&#xff0c;CPU通过预先在trap.c中的idt_init函数中根据ISR初始化好的IDT表&#xff0c;进行中断信号的分发。<br />在ucore中&#xff0c;由于vectors.S中预设的ISR令中断信号均被分发到__alltraps函数中&#xff0c;因此时钟中断会先进入kern/trap/trapentry.s中的__alltraps中进行保存现场</p>\n<pre>__alltraps:\n # push registers to build a trap frame\n # therefore make the stack look like a struct trapframe\n pushl %ds\n pushl %es\n pushl %fs\n pushl %gs\n pushal\n# load GD_KDATA into %ds and %es to set up data segments for kernel\n movl $GD_KDATA, %eax\n movw %ax, %ds\n movw %ax, %es\n# push %esp to pass a pointer to the trapframe as an argument to trap()\n pushl %esp\n# call trap(tf), where tf=%esp\n call trap\n# pop the pushed stack pointer\n popl %esp \n</pre>\n<p>然后kern/trap/trap.c中的trap函数就会被调用&#xff0c;将中断帧转发给trap_dispatch函数进行进一步的处理。<br />在trap_dispatch函数中&#xff0c;函数会根据tf-&gt;tf_trapno的值&#xff0c;发现这是一个时钟中断&#xff0c;最终执行case IRQ_OFFSET &#43; IRQ_TIMER:中的内容。<br /><br /></p>\n<pre>case IRQ_OFFSET &#43; IRQ_TIMER:\n ticks &#43;&#43;;\n assert(current != NULL);\n run_timer_list();\n break; \n</pre>\n<p></p>", "created": "2016-02-29T07:43:47Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "iem550jbpyn515", "children": [], "tag_good_arr": [], "id": "il7oio4g73w5fa", "updated": "2016-02-29T07:43:47Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>kern/trap/trapentry.S -&gt; __alltraps :</p>\n<p>检测到时钟中断&#xff0c;进入异常处理&#xff0c;压栈形成中断栈帧&#xff0c;调用trap异常处理函数<br />kern/trap/trap.c -&gt; trap_dispatch :</p>\n<p>判断tf-&gt;tf_trapno&#xff0c;当其为IRQ_OFFSET &#43; IRQ_TIMER时&#xff0c;进入时钟中断处理部分run_timer_list<br />kern/schedule/schedule.c -&gt; run_timer_list :</p>\n<p>关闭中断使能&#xff0c;遍历一个timer列表&#xff0c;若发现某timer的expire为0&#xff0c;即唤醒其相应的进程进行处理&#xff0c;打开中断使能。<br />kern/trap/trapentry.S -&gt; __trapret :</p>\n<p>中断处理完毕&#xff0c;恢复现场</p>\n<p></p>", "created": "2016-02-29T09:29:03Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i70lz5f0QKm", "children": [], "tag_good_arr": [], "id": "il7sa1hzal44v8", "updated": "2016-02-29T09:29:03Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>检测到时钟中断以后&#xff0c;由CPU跳转到trapentry.S异常入口&#xff0c;然后进入trap异常处理函数&#xff0c;在trap_dispatch中识别时钟中断</p>\n<p>case IRQ_OFFSET &#43; IRQ_TIMER:<br />    ticks &#43;&#43;;<br />    assert(current != NULL);<br />    run_timer_list();<br />    break;</p>\n<p> </p>\n<p>调用kern\\schedule\\sched.c\\run_timer_list()进行处理</p>\n<p></p>", "created": "2016-02-29T09:57:33Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i2om0jwie732m1", "children": [], "tag_good_arr": [], "id": "il7taowompy2ac", "updated": "2016-02-29T09:57:33Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<p>中断时首先进入trapentry.S&#xff0c;然后进入trap.c中的trap函数&#xff1b;<br />在trap函数中调用了trap_dispatcher函数&#xff0c;时钟中断&#xff0c;switch (tf-&gt;tf_trapno)&#xff0c; case IRQ_OFFSET &#43; IRQ_TIMER&#xff0c;执行&#xff1a;</p>\n<pre>ticks &#43;&#43;;<br />assert(current != NULL);<br />run_timer_list();</pre>\n<p>run_timer_list()在sched.c里&#xff1b;<br />处理完后通过trapentry.S返回&#xff1b;</p>\n<p></p>", "created": "2016-02-29T10:08:45Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i2olyyl8swl1we", "children": [], "tag_good_arr": [], "id": "il7tp2whon86p8", "updated": "2016-02-29T10:08:45Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>1. CPU会查中断描述符表进入__alltraps入口</p>\n<p>2. 经过现场保存和多层跳转最终进入trap_dispatch函数。</p>\n<p>3. 进行时钟计数自增&#xff08;ticks&#43;&#43;&#xff09;</p>\n<p>4. 调用run_timer_list函数之中&#xff0c;该函数一方面处理所有已知的正在wait的进程的系统调用&#xff0c;如果有函数的wait已经到期则唤醒该进程</p>\n<p>    其代码如下&#xff1a;</p>\n<pre>            while (timer-&gt;expires == 0) {<br />                le = list_next(le);<br />                struct proc_struct *proc = timer-&gt;proc;<br />                if (proc-&gt;wait_state != 0) {<br />                    assert(proc-&gt;wait_state &amp; WT_INTERRUPTED);<br />                }<br />                else {<br />                    warn(&#34;process %d&#39;s wait_state == 0.\\n&#34;, proc-&gt;pid);<br />                }<br />                wakeup_proc(proc);<br />                del_timer(timer);<br />                if (le == &amp;timer_list) {<br />                    break;<br />                }<br />                timer = le2timer(le, timer_link);</pre>\n<p>5. 处理的进程的调度和切换</p>\n<p></p>", "created": "2016-02-29T10:29:25Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i2g664y8vve6h4", "children": [], "tag_good_arr": [], "id": "il7ufo5jkl01rn", "updated": "2016-02-29T10:29:25Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>发生中断后&#xff0c;先在trapentry.S保存现场&#xff0c;再于trap函数中处理中断&#xff0c;调用trap_dispatcher函数&#xff0c;时钟中断代码如下。</p>\n<p>case IRQ_OFFSET &#43; IRQ_TIMER:</p>\n<p>    ticks &#43;&#43;;</p>\n<p>    assert(current != NULL);</p>\n<p>    run_timer_list();</p>\n<p>    break;</p>", "created": "2016-02-29T10:41:12Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "ikvcvonk6wj7k1", "children": [], "tag_good_arr": [], "id": "il7uutor7vf5lp", "updated": "2016-02-29T10:41:12Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>CPU收到中断信号之后&#xff0c;先跳转到vector.s中的中断向量处&#xff0c;之后进入trapentry.s中的alltraps中保存寄存器的值&#xff0c;再调用trap.c中的trap_dispatch进入时钟对应的case&#xff0c;调用&#xff1a;</p>\n<pre>case IRQ_OFFSET &#43; IRQ_TIMER:\n        ticks &#43;&#43;;\n        assert(current != NULL);\n        run_timer_list();\n        break;</pre>\n<p></p>", "created": "2016-02-29T11:12:09Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0i7rzz9iau2gd", "children": [], "tag_good_arr": [], "id": "il7vymf45qx5oq", "updated": "2016-02-29T11:12:09Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>2012080059</p>\n<p>1&#xff0c;首先在<strong>vector.s</strong>中根据vector会<strong>push</strong>进<strong>中断号</strong>&#xff0c;然后通过<strong> jmp _alltraps</strong>&#xff08;trap entry.s中&#xff09;中构造trap frame并调用trap处理&#xff1a;</p>\n<table><tbody><tr><td>__alltraps:</td></tr><tr><td></td><td># push registers to build a trap frame</td></tr><tr><td></td><td># therefore make the stack look like a struct trapframe</td></tr><tr><td></td><td>pushl %ds</td></tr><tr><td></td><td>pushl %es</td></tr><tr><td></td><td>pushl %fs</td></tr><tr><td></td><td>pushl %gs</td></tr><tr><td></td><td>pushal</td></tr><tr><td></td><td></td></tr><tr><td></td><td># load GD_KDATA into %ds and %es to set up data segments for kernel</td></tr><tr><td></td><td>movl $GD_KDATA, %eax</td></tr><tr><td></td><td>movw %ax, %ds</td></tr><tr><td></td><td>movw %ax, %es</td></tr><tr><td></td><td></td></tr><tr><td></td><td># push %esp to pass a pointer to the trapframe as an argument to trap()</td></tr><tr><td></td><td>pushl %esp</td></tr><tr><td></td><td></td></tr><tr><td></td><td># call trap(tf), where tf=%esp</td></tr><tr><td></td><td>call trap</td></tr></tbody></table>\n<p></p>\n<p>trap.c中有对应的trap()会将之前建立的trap frame传到trap_dispatch()。</p>\n<p></p>\n<p>trap_dispatch中的case中&#xff0c;<strong>case IRQ_OFFSET &#43; IRQ_TIMER </strong>就对应始终中断。</p>", "created": "2016-02-29T11:16:35Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i6ub5at2geM", "children": [], "tag_good_arr": [], "id": "il7w4bg0hk03vn", "updated": "2016-02-29T11:16:35Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>2013011310 </p>\n<p>过程如下&#xff1a;</p>\n<p> CPU收到中断信号</p>\n<p>先到vector.s 压入中断号</p>\n<p>然后跳转到trap入口&#xff1a;kern/trap/trapentry.S 保护现场</p>\n<p>最后通过trap_dispatch(tf)进入时钟处理的case语句。</p>", "created": "2016-02-29T11:30:41Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i11v1az5sf83l2", "children": [], "tag_good_arr": [], "id": "il7wmgrwc7037", "updated": "2016-02-29T11:30:41Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>在CPU收到时钟信号后&#xff0c;首先在vector中压入中断号&#xff0c;然后跳转至trapentry中&#xff0c;构造trapframe并由trap dispatch根据中断号调用相应处理&#xff0c;最后通过trapentry.s返回</p>", "created": "2016-02-29T11:42:04Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "ikvcvmzbvlf7i6", "children": [], "tag_good_arr": [], "id": "il7x13624ma6p3", "updated": "2016-02-29T11:42:04Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "il7a0n4tdpg72i", "updated": "2016-02-29T00:57:52Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>题目&#xff1a;<br />2. 3.1中的第1小题&#xff1a;比较UEFI和BIOS的区别。</p>\n<p></p>\n<p>回答结果写在此贴中对应题目后面。</p>", "created": "2016-02-29T00:58:17Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>1.UEFI已具备文件系统的支持&#xff0c;它能够直接读取FAT分区中的文件。</p>\n<p>2.可开发出直接在UEFI下运行的应用程序。</p>\n<p>3.UEFI运行于32位或64位模式&#xff0c;突破了BIOS16位代码的寻址能力&#xff0c;并且支持更多磁盘分区。</p>\n<p>4.UEFI比BIOS更安全。</p>\n<p></p>", "created": "2016-02-29T01:24:10Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0i7rzz9iau2gd", "children": [], "tag_good_arr": [], "id": "il7aygw2nwk4ps", "updated": "2016-02-29T01:24:10Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<p>组队&#xff1a;2012011302&amp;2012011309</p>\n<p></p>\n<p>BIOS下启动操作系统之前&#xff0c;必须从硬盘上指定扇区读取系统启动代码&#xff08;包含在主引导记录中&#xff09;&#xff0c;然后从活动分区中引导启动操作系统。</p>\n<p>UEFI下可以直接读取FAT分区中的文件&#xff0c;不再需要主引导记录以及活动分区&#xff0c;只要复制安装文件到一个FAT32&#xff08;主&#xff09;分区/U盘中&#xff0c;然后从这个分区/U盘启动。</p>", "created": "2016-02-29T01:31:35Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i701mss708y", "children": [], "tag_good_arr": [], "id": "il7b80hemxn12j", "updated": "2016-02-29T01:31:35Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<pre>2013011413 高思达 2013011402 钱迪晨\n1. UEFI不是读取第一个磁盘的引导扇区&#xff0c;而是在硬盘上特定的地方叫做EFI system partition&#xff0c;这个文件也包含了boot loader程序。\n2. UEFI没有BIOS1M的空间限制&#xff0c;可以达到2T的大小。\n3. UEFI的速度比BIOS快&#xff0c;由于自己本身就近似一个简单的操作系统&#xff0c;他可以对系统的启动安装进行配置&#xff08;有grub的作用&#xff09;&#xff0c;从而加速。\n4. UEFI采用了一改之前的中断、硬件端口操作的方法&#xff0c;而采用了Driver/protocol的新方式。\n5. UEFI不支持X86实模式&#xff0c;而BIOS是在实模式下运行的。\n6. UEFI输出不再是单纯的二进制code&#xff0c;改为Removable Binary Drivers。\n7. 对于第三方的开发&#xff0c;BIOS基本上做不到&#xff0c;UEFI就便利多了。\n8. UEFI支持签名验证功能。BIOS没有这个功能。这样也就提高了安全性。\n9. UEFI具有FAT的文件系统&#xff0c;BIOS由于没有文件系统从而必须使用别的引导扇区。\n10. UEFI可以搭起来和BIOS一起使用。<br />11. BIOS的启动流程包括。<br />\t上电自检。<br />\t初始化硬件。<br />\tBIOS会加载BIOS磁盘启动顺序中第一个磁盘的主引导分区的代码&#xff0c;运行。<br />\t加载的代码主引导分区代码在进行引导&#xff0c;进行启动系统。\nUEFI的启动流程包括。<br />\t上电自检&#xff0c;加载UEFI需要的固件。<br />\t初始化硬件资源。<br />\t读取可运行的EFI磁盘&#xff0c;从磁盘获得主引导分区进行系统的引导。<br />\n12. 总体来说BIOS由于要兼容过去的启动&#xff0c;比较简陋&#xff0c;他把更多的功能放到了启动磁盘上去&#xff0c;而不是自己本身。UEFI由于没有历史遗留问题&#xff0c;将更多的功能整合到了自身上&#xff0c;所以更加的灵活。\n</pre>\n<div></div>\n<p></p>\n<div></div>", "created": "2016-02-29T01:32:18Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0nuu5yhgno5tv", "children": [], "tag_good_arr": [], "id": "il7b8xhebw2gg", "updated": "2016-02-29T01:32:18Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>杨青霖 2013011297</p>\n<p></p>\n<div>1. 编码99%都是由C语言完成&#xff1b;</div>\n<div>2. 一改之前的中断、硬件端口操作的方法&#xff0c;而采用了Driver/protocol的新方式&#xff1b;</div>\n<div>3. 将不支持X86实模式&#xff0c;而直接采用Flat mode&#xff08;也就是不能用DOS了&#xff0c;现在有些 EFI 或 UEFI 能用是因为做了兼容&#xff0c;但实际上这部分不属于UEFI的定义了&#xff09;&#xff1b;</div>\n<div>4. 输出也不再是单纯的二进制code&#xff0c;改为Removable Binary Drivers&#xff1b;</div>\n<div>5. OS启动不再是调用Int19&#xff0c;而是直接利用protocol/device Path&#xff1b;</div>\n<div>6. 对于第三方的开发&#xff0c;前者基本上做不到&#xff0c;除非参与<a target=\"_blank\" href=\"http://baike.baidu.com/view/361.htm\">BIOS</a>的设计&#xff0c;但是还要受到ROM的大小限制&#xff0c;而后者就便利多了。</div>\n<div>7.弥补BIOS对新硬件的支持不足的问题</div>\n<p>8、通过保护预启动或预引导进程&#xff0c;抵御bootkit攻击&#xff0c;从而提高安全性。<br />9、缩短了启动时间和从休眠状态恢复的时间。<br />10、支持容量超过2.2 TB的驱动器。<br />11、支持64位的现代固件设备驱动程序&#xff0c;系统在启动过程中可以使用它们来对超过172亿GB的内存进行寻址。<br />12、UEFI硬件可与BIOS结合使用。</p>\n<p>13、UEFI已具备文件系统的支持&#xff0c;它能够直接读取FAT分区中的文件。</p>\n<p>14、UEFI可开发出直接在UEFI下运行的应用程序</p>", "created": "2016-02-29T01:33:17Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i18riqkwrl225m", "children": [], "tag_good_arr": [], "id": "il7ba79mqce2of", "updated": "2016-02-29T01:33:17Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>&#xff08;1&#xff09;设计与概念上的区别&#xff1a;</p>\n<p>UEFI全称“统一的可扩展固件接口”&#xff08;Unified Extensible Firmware Interface&#xff09;&#xff0c;是一种详细描述类型接口的标准。这种接口用于操作系统自动从预启动的操作环境&#xff0c;加载到一种操作系统上。其主要目的是为了提供一组在 OS 加载之前&#xff08;启动前&#xff09;在所有平台上一致的、正确指定的启动服务。</p>\n<p><a href=\"http://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=45346&amp;ss_c=ssc.citiao.link\">BIOS</a>(Basic Input/Output System的<a href=\"http://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=3564519\">缩写</a>、中文&#xff1a;基本输出<a href=\"http://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=64758833&amp;ss_c=ssc.citiao.link\">输入</a>系统)&#xff0c;是加载在<a href=\"http://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=10590452&amp;ss_c=ssc.citiao.link\">电脑硬件系统</a>上的最基本的<a href=\"http://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=4196027&amp;ss_c=ssc.citiao.link\">软件代码</a>&#xff0c;描述在开机阶段加载CP/M与<a href=\"http://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=475526&amp;ss_c=ssc.citiao.link\">硬件</a>直接沟通的部份。它的主要功能是为计算机提供最底层的、最直接的硬件设置和控制。它保存着计算机最重要的基本输入输出的<a href=\"http://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=66045&amp;ss_c=ssc.citiao.link\">程序</a>、系统设置信息、开机后自检程序和系统自启动程序。</p>\n<p>&#xff08;2&#xff09;启动流程上的区别如下&#xff1a;</p>\n<p>BIOS启动流程&#xff1a;</p>\n<ol><li>系统开机 - 上电自检&#xff08;Power On Self Test 或 POST&#xff09;。</li><li>POST过后初始化用于启动的硬件&#xff08;磁盘、键盘控制器等&#xff09;。</li><li>BIOS会运行BIOS磁盘启动顺序中第一个磁盘的首440bytes&#xff08;MBR启动代码区域&#xff09;内的代码。</li><li>启动引导代码从BIOS获得控制权&#xff0c;然后引导启动下一阶段的代码&#xff08;如果有的话&#xff09;&#xff08;一般是系统的启动引导代码&#xff09;。</li><li>再次被启动的代码&#xff08;二阶段代码&#xff09;&#xff08;即启动引导&#xff09;会查阅支持和配置文件。</li><li>根据配置文件中的信息&#xff0c;启动引导程序会将内核和initramfs文件载入系统的RAM中&#xff0c;然后开始启动内核。</li></ol>\n<p>UEFI启动流程&#xff1a;</p>\n<ol><li>系统开机 - 上电自检&#xff08;Power On Self Test 或 POST&#xff09;。</li><li>UEFI 固件被加载&#xff0c;并由它初始化启动要用的硬件。</li><li>固件读取其引导管理器以确定从何处&#xff08;比如&#xff0c;从哪个硬盘及分区&#xff09;加载哪个 UEFI 应用。</li><li>固件按照引导管理器中的启动项目&#xff0c;加载UEFI 应用。</li><li>已启动的 UEFI 应用还可以启动其他应用&#xff08;对应于 UEFI shell 或 rEFInd 之类的引导管理器的情况&#xff09;或者启动内核及initramfs&#xff08;对应于GRUB之类引导器的情况&#xff09;&#xff0c;这取决于 UEFI 应用的配置。</li></ol>\n<p>&#xff08;3&#xff09;功能上的区别&#xff08;uefi的优势&#xff09;&#xff1a;</p>\n<p>1、UEFI已具备文件系统的支持&#xff0c;它能够直接读取FAT分区中的文件。　　</p>\n<p>2、ufei缩短了启动时间和从休眠状态恢复的时间。<br /> 3、uefi支持容量超过2.2 TB的驱动器&#xff0c;支持64位的现代固件设备驱动程序&#xff0c;系统在启动过程中可以使用它们来对超过172亿GB的内存进行寻址。</p>\n<p>4、uefi可以方便地开发第三方应用</p>", "created": "2016-02-29T01:46:55Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i3qk2vs65x276j", "children": [], "tag_good_arr": [], "id": "il7brpx0e42lr", "updated": "2016-02-29T01:46:55Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>2013011307<br />1.UEFI与BIOS不同&#xff0c;不采用中断&#xff0c;硬件端口操作的方法&#xff0c;采用Driver/protocal的方式。<br />2.UEFI不支持X86模式&#xff0c;直接采用实模式<br />3.BIOS在2013011307<br />1.UEFI与BIOS不同&#xff0c;不采用中断&#xff0c;硬件端口操作的方法&#xff0c;采用Driver/protocal的方式。<br />2.UEFI不支持X86模式&#xff0c;直接采用实模式<br />3.BIOS在启动操作系统前&#xff0c;需要从硬盘上制定删去读取加载程序&#xff0c;然后从活动分区中引导启动操作系统。同时大小也有1m的限制。然而UEFI由于已经具有对文件系统的支持&#xff0c;可以直接进行对硬盘分区进行的操作。<br />4.BIOS启动由于MBR的限制&#xff0c;默认是无法引导超过2.1TB以上的硬盘的,而UEFI支持容量超过2.2TB的驱动器。<br />5.UEFI支持64位&#xff0c;系统在启动过程中可以对更大的空间进行寻址。<br />6.UEFI支持第三方应用的开发。</p>", "created": "2016-02-29T02:01:45Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0evrfcnckf5dt", "children": [], "tag_good_arr": [], "id": "il7casre8rv630", "updated": "2016-02-29T02:01:45Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>UEFI是BIOS的一种升级替代方案。</p>\n<p>       UEFI本身已经相当于一个微型操作系统,支持第三方应用开发</p>\n<p>　　UEFI已具备文件系统的支持&#xff0c;它能够直接读取FAT分区中的文件。</p>\n<p>　　可开发出直接在UEFI下运行的应用程序&#xff0c;这类程序文件通常以efi结尾。既然UEFI可以直接识别FAT分区中的文件&#xff0c;又有可直接在其 中运行的应用程序。</p>\n<p>　　UEFI不需要自检,运行速度远快于BIOS</p>\n<p>       UEFI支持大容量驱动器与64位字长</p>\n<p>     </p>", "created": "2016-02-29T08:00:22Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "ikvcvmzbvlf7i6", "children": [], "tag_good_arr": [], "id": "il7p3z8olgvcf", "updated": "2016-02-29T08:00:22Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p><p>2012011321</p>\n<div>1. UEFI编码99%都是由C语言完成&#xff1b;</div>\n<div>2. UEFI一改之前的中断、硬件端口操作的方法&#xff0c;而采用了Driver/protocol的新方式&#xff1b;</div>\n<div>3. UEFI将不支持X86实模式&#xff0c;而直接采用Flat mode&#xff0c;而BIOS实在实模式下运行的&#xff1b;</div>\n<div>4. 输出也不再是单纯的二进制code&#xff0c;改为Removable Binary Drivers&#xff1b;</div>\n<div>5. UEFI支持第三方应用的开发&#xff1b;</div>\n<div>6. UEFI已具备文件系统的支持&#xff0c;可以直接读取FAT分区。</div>", "created": "2016-02-29T08:10:46Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i6vir34gLfK", "children": [], "tag_good_arr": [], "id": "il7phcpvdyj6vq", "updated": "2016-02-29T08:10:46Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>UEFI的全称为Unified Extensible Firmware Interface&#xff08;统一的可扩展固件借口&#xff09;&#xff0c;跟改进之前的BIOS相比&#xff0c;UEFI的new feature&#xff1a;</p>\n<p>1. 采用了Driver/protocal来代替BIOS的端口操作和trap.</p>\n<p>2. UEFI不再支持X86的实模式&#xff0c;直接采用平调模式&#xff08;flat mode&#xff09;</p>\n<p>3. 用Removable Binary Drivers&#xff08;可卸二进制驱动&#xff09;来替代BIOS的Binary Code.</p>\n<p>4. 增加了可扩展性&#xff0c;支持第三者开发。</p>\n<p>5. UEFI的支持位数扩大到了64位。</p>", "created": "2016-02-29T08:11:12Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "ibz6vywnw6g7nl", "children": [], "tag_good_arr": [], "id": "il7phxcw4e548z", "updated": "2016-02-29T08:11:12Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>#2013011302&#xff08;其他的几个问题也选择性地回答了一下&#xff09;</p>\n<p>BIOS用于加载电脑最基本的程式码&#xff0c;担负着初始化硬件&#xff0c;检测硬件功能以及引导操作系统的任务。UEFI就是与BIOS相对的概念&#xff0c;这种接口用于操作系统自动从预启动的操作环境&#xff0c;加载到一种操作系统上&#xff0c;从而达到开机程序化繁为简节省时间的目的。</p>\n<p>UEFI拥有BIOS所不具备的诸多功能&#xff0c;比如图形化界面、多种多样的操作方式、允许植入硬件驱动等等。</p>\n<p>UEFI已具备文件系统的支持&#xff0c;它能够直接读取FAT分区中的文件。可开发出直接在UEFI下运行的应用程序&#xff0c;这类程序文件通常以efi结尾。</p>\n<p>这些都是BIOS做不到的。因为BIOS下启动操作系统之前&#xff0c;必须从硬盘上指定扇区读取系统启动代码&#xff08;包含在主引导记录中&#xff09;&#xff0c;然后从活动分区中引导启动操作系统。</p>\n<p></p>", "created": "2016-02-29T08:40:15Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "ikvcvo2cckb7jb", "children": [], "tag_good_arr": [], "id": "il7qja0pbf16ql", "updated": "2016-02-29T08:40:15Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>2012011307 黄必胜</p>\n<p>1. UEFI支持文件系统&#xff0c;可直接读取FAT分区中的文件&#xff1b;而BIOS需要读取磁盘主引导扇区中的MBR&#xff0c;再从活动分区中引导启动OS。<br />2. UEFI的寻址空间比BIOS的1M大得多。<br />3. 相较BIOS&#xff0c;UEFI改变了之前的中断、硬件端口操作的方法&#xff0c;而采用了Driver/protocol的新方式。对新硬件的支持较好。输出也不再是单纯的二进制code&#xff0c;改为Removable Binary Drivers。<br />4. 由于采用了EFI Byte Code&#xff0c;UEFI较BIOS有更好的向下兼容性。<br />5. UEFI内置图形驱动功能&#xff0c;可提供一个高分辨率的彩色图形环境&#xff0c;高端大气上档次。</p>", "created": "2016-02-29T09:37:17Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i70lz5f0QKm", "children": [], "tag_good_arr": [], "id": "il7skmmi1u8141", "updated": "2016-02-29T09:37:17Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "il7a16io6du2zq", "updated": "2016-02-29T00:58:17Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>题目&#xff1a;<br />3. 3.3中的第5小题&#xff1a;Linux的系统调用有哪些&#xff1f;大致的功能分类有哪些&#xff1f;</p>\n<p></p>\n<p>回答结果写在此贴中对应题目后面。</p>", "created": "2016-02-29T00:58:38Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<p>2012080060 甄显安</p>\n<p>2012011308 陆喆</p>\n<p>进程控制&#xff1a;fork、clone、wait、exit、execve等</p>\n<p>文件系统控制&#xff1a;open、read、write、create、close、chmod、chown、mkdir等</p>\n<p>系统控制&#xff1a;ioctl、outb、time、reboot等</p>\n<p>内存管理&#xff1a;brk、mmap、mlock、sync等</p>\n<p>网络管理&#xff1a;getdomainname、sethostid、sethostname等</p>\n<p>socket控制&#xff1a;bind、connect、accept、send、recv、listen等</p>\n<p>用户管理&#xff1a;getuid、getgid、setegid、setgroups等</p>\n<p>进程间通信&#xff1a;signal、kill、msgctl、msgsnd、pipe等</p>\n<p></p>", "created": "2016-02-29T01:06:53Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "ikvcvnzpzq7j7", "children": [], "tag_good_arr": [], "id": "il7ac97ksix3w2", "updated": "2016-02-29T01:06:53Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<p>参见&#xff1a;</p>\n<p><a href=\"http://www.ibm.com/developerworks/cn/linux/kernel/syscall/part1/appendix.html\">http://www.ibm.com/developerworks/cn/linux/kernel/syscall/part1/appendix.html</a></p>\n<p>有完整的Linux系统调用列表。</p>\n<p>主要包含&#xff1a;</p>\n<p>进程控制&#xff0c;文件系统控制&#xff0c;系统控制&#xff0c;内存管理&#xff0c;网络管理&#xff0c;socket控制&#xff0c;用户管理&#xff0c;进程间通信&#xff0c;这几类。</p>\n<p></p>\n<p>linux源代码中有一个头文件含有所有的系统调用的列表&#xff0c;见&#xff1a;</p>\n<p><a href=\"https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h\">https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</a></p>\n<p></p>\n<p><a href=\"https://github.com/torvalds/linux/blob/master/include/trace/syscall.h\">https://github.com/torvalds/linux/blob/master/include/trace/syscall.h</a></p>\n<p>中引用了了上面的头文件。</p>", "created": "2016-02-29T01:09:20Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0minzvpea57bu", "children": [], "tag_good_arr": [], "id": "il7afdwi3k533f", "updated": "2016-02-29T01:09:20Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>2013011310 余翔</p>\n<p>2013011308 林婕茵</p>\n<p>Linux的全部系统调用有250个左右</p>\n<p>按其功能分为六类,进程管理、文件操作、设备管理、主存管理、进程通信、信息维护。</p>\n<p></p>\n<p>这里一个网页提供了关于linux2.2内核系统调用的文件关联。</p>\n<p>http://docs.cs.up.ac.za/programming/asm/derick_tut/syscalls.html</p>", "created": "2016-02-29T01:14:52Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i11v1az5sf83l2", "children": [], "tag_good_arr": [], "id": "il7amipnzkncq", "updated": "2016-02-29T01:14:52Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>汇编课给出的linux调用表</p>\n<p>http://syscalls.kernelgrok.com</p>", "created": "2016-02-29T01:27:38Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0f9pvv0uxm6ko", "children": [], "tag_good_arr": [], "id": "il7b2xk2bll9y", "updated": "2016-02-29T01:27:38Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<p>2013011328 张殿炎</p>\n<p>2013011340 叶方轲</p>\n<p>Linux的系统调用可以在syscall.h中找到</p>\n<p>Linux系统调用的数量基本上随着内核版本的增大而增多&#xff0c;截止到4.3版本已经有三百多个系统调用了</p>\n<p>大致功能包含进程控制&#xff0c;文件系统控制&#xff0c;系统控制&#xff0c;内存管理&#xff0c;网络管理&#xff0c;socket控制&#xff0c;用户管理&#xff0c;进程间通信这几类。</p>", "created": "2016-02-29T01:35:01Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i11dx198ive25r", "children": [], "tag_good_arr": [], "id": "il7bcf0160z3zj", "updated": "2016-02-29T01:35:01Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>Linux的系统调用有上百个。</p>\n<p>按分类可分为</p>\n<p>进程控制&#xff1a;fork, clone, exit</p>\n<p>文件系统控制&#xff1a;open, read, close</p>\n<p>系统控制&#xff1a;ioctl, acct, time</p>\n<p>内存管理&#xff1a;brk, mmap, sync</p>\n<p>网络管理&#xff1a;getdominate, gethostid</p>\n<p>socket控制&#xff1a;bind, socketcall, sendfile</p>\n<p>用户管理&#xff1a;getuid, getgid</p>\n<p>进程间通信&#xff1a;ipc, kill, pipe</p>\n<p></p>\n<p>2013011303  2013012213</p>", "created": "2016-02-29T01:58:15Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i1569mw0xp954u", "children": [], "tag_good_arr": [], "id": "il7c6b80m3us6", "updated": "2016-02-29T01:58:15Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p><pre>Linux系统调用&#xff0c;包含了大部分常用系统调用和由系统调用派生出的的函数,狭义上的系统调用就有二百多个&#xff0c;不同的内核系统调用数量不同&#xff0c;但数量均十分庞大。 主要包括如下几个大类&#xff08;并举例&#xff09;&#xff1a;</pre>\n<ul><li>\n<pre>进程控制\nfork创建一个新进程\nexit中止进程</pre>\n</li><li>\n<pre>文件读写操作\nopen打开文件\nread读文件</pre>\n</li><li>\n<pre>文件系统操作\nchdir改变当前工作目录\nstat取文件状态信息</pre>\n</li><li>\n<pre>系统控制\nreboot重新启动\ntime取得系统时间</pre>\n</li><li>\n<pre>内存管理\nsync 将内存缓冲区数据写回硬盘</pre>\n</li><li>\n<pre>网络管理\ngetdomainname 取域名</pre>\n</li><li>\n<pre>socket控制\nsocket 建立socket\nbind 绑定socket到端口</pre>\n</li><li>\n<pre>用户管理\ngetuid 获取用户标识号</pre>\n</li><li>\n<pre>进程间通信\nipc 进程间通信总控制调用</pre>\n</li><li>\n<pre>信号\nkill 向进程或进程组发信号</pre>\n</li><li>\n<pre>消息\nmsgsnd 发消息\nmsgrcv 取消息</pre>\n</li><li>\n<pre>管道\npipe 创建管道</pre>\n</li><li>\n<pre>信号量\nsemget 获取一组信号量</pre>\n</li><li>\n<pre>共享内存\nshmget 获取共享内存\n等等</pre>\n</li></ul>\n<p>高博</p>\n<p>2012012139</p>", "created": "2016-02-29T02:23:17Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "ic226rac4j5jw", "children": [], "tag_good_arr": [], "id": "il7d2hojt7h5b9", "updated": "2016-02-29T02:23:17Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>进程控制&#xff0c;文件系统控制&#xff0c;系统控制&#xff0c;内存管理&#xff0c;网络管理&#xff0c;socket控制&#xff0c;用户管理&#xff0c;进程间通信<br />参见http://docs.cs.up.ac.za/programming/asm/derick_tut/syscalls.html</p>", "created": "2016-02-29T06:57:04Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i6vjwdpfniF", "children": [], "tag_good_arr": [], "id": "il7muldtacm4nd", "updated": "2016-02-29T06:57:04Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>大约有二百多条调用指令&#xff0c;分为以下几大类&#xff1a;</p>\n<p>1. 进程控制。包括创建进程fork&#xff0c;中止进程exit&#xff0c;执行程序execve等。</p>\n<p>2. 文件系统控制。包括open,close,read,write等文件读写操作&#xff0c;以及能够操作目录和符号链接的文件系统操作。</p>\n<p>3. 系统控制。包括设置资源上限&#xff0c;端口权限等系统参数等。</p>\n<p>4. 内存管理。主要是对内存页面的管理。</p>\n<p>5. 网络管理。对域名&#xff0c;主机标识号以及主机名称的管理。</p>\n<p>6. socket控制。</p>\n<p>7. 用户管理。主要是对用户和组的标识号的设置。</p>\n<p>8. 进程间通信。包括对信号&#xff0c;消息&#xff0c;管道&#xff0c;信息量和共享内存的操作。</p>", "created": "2016-02-29T08:22:33Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "ibz6vywnw6g7nl", "children": [], "tag_good_arr": [], "id": "il7pwioqkpu4gn", "updated": "2016-02-29T08:22:33Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>一、进程控制&#xff1a;</p>\n<table width=\"550\" border=\"1\" cellspacing=\"0\" cellpadding=\"5\"><tbody><tr><td width=\"30\">fork</td><td>创建一个新进程</td></tr><tr><td>clone</td><td>按指定条件创建子进程</td></tr><tr><td>execve</td><td>运行可执行文件</td></tr><tr><td>exit</td><td>中止进程</td></tr><tr><td>_exit</td><td>立即中止当前进程</td></tr><tr><td>getdtablesize</td><td>进程所能打开的最大文件数</td></tr><tr><td>getpgid</td><td>获取指定进程组标识号</td></tr><tr><td>setpgid</td><td>设置指定进程组标志号</td></tr><tr><td>getpgrp</td><td>获取当前进程组标识号</td></tr><tr><td>setpgrp</td><td>设置当前进程组标志号</td></tr><tr><td>getpid</td><td>获取进程标识号</td></tr><tr><td>getppid</td><td>获取父进程标识号</td></tr><tr><td>getpriority</td><td>获取调度优先级</td></tr><tr><td>setpriority</td><td>设置调度优先级</td></tr><tr><td>modify_ldt</td><td>读写进程的本地描述表</td></tr><tr><td>nanosleep</td><td>使进程睡眠指定的时间</td></tr><tr><td>nice</td><td>改变分时进程的优先级</td></tr><tr><td>pause</td><td>挂起进程&#xff0c;等待信号</td></tr><tr><td>personality</td><td>设置进程运行域</td></tr><tr><td>prctl</td><td>对进程进行特定操作</td></tr><tr><td>ptrace</td><td>进程跟踪</td></tr><tr><td>sched_get_priority_max</td><td>取得静态优先级的上限</td></tr><tr><td>sched_get_priority_min</td><td>取得静态优先级的下限</td></tr><tr><td>sched_getparam</td><td>取得进程的调度参数</td></tr><tr><td>sched_getscheduler</td><td>取得指定进程的调度策略</td></tr><tr><td>sched_rr_get_interval</td><td>取得按RR算法调度的实时进程的时间片长度</td></tr><tr><td>sched_setparam</td><td>设置进程的调度参数</td></tr><tr><td>sched_setscheduler</td><td>设置指定进程的调度策略和参数</td></tr><tr><td>sched_yield</td><td>进程主动让出处理器,并将自己等候调度队列队尾</td></tr><tr><td>vfork</td><td>创建一个子进程&#xff0c;以供执行新程序&#xff0c;常与execve等同时使用</td></tr><tr><td>wait</td><td>等待子进程终止</td></tr><tr><td>wait3</td><td>参见wait</td></tr><tr><td>waitpid</td><td>等待指定子进程终止</td></tr><tr><td>wait4</td><td>参见waitpid</td></tr><tr><td>capget</td><td>获取进程权限</td></tr><tr><td>capset</td><td>设置进程权限</td></tr><tr><td>getsid</td><td>获取会晤标识号</td></tr><tr><td>setsid</td><td>设置会晤标识号</td></tr></tbody></table>\n<p></p>\n<h2>二、文件系统控制</h2>\n<p>1、文件读写操作</p>\n<table width=\"100%\" border=\"1\" cellspacing=\"0\" cellpadding=\"5\"><tbody><tr><td width=\"30\">fcntl</td><td>文件控制</td></tr><tr><td>open</td><td>打开文件</td></tr><tr><td>creat</td><td>创建新文件</td></tr><tr><td>close</td><td>关闭文件描述字</td></tr><tr><td>read</td><td>读文件</td></tr><tr><td>write</td><td>写文件</td></tr><tr><td>readv</td><td>从文件读入数据到缓冲数组中</td></tr><tr><td>writev</td><td>将缓冲数组里的数据写入文件</td></tr><tr><td>pread</td><td>对文件随机读</td></tr><tr><td>pwrite</td><td>对文件随机写</td></tr><tr><td>lseek</td><td>移动文件指针</td></tr><tr><td>_llseek</td><td>在64位地址空间里移动文件指针</td></tr><tr><td>dup</td><td>复制已打开的文件描述字</td></tr><tr><td>dup2</td><td>按指定条件复制文件描述字</td></tr><tr><td>flock</td><td>文件加/解锁</td></tr><tr><td>poll</td><td>I/O多路转换</td></tr><tr><td>truncate</td><td>截断文件</td></tr><tr><td>ftruncate</td><td>参见truncate</td></tr><tr><td>umask</td><td>设置文件权限掩码</td></tr><tr><td>fsync</td><td>把文件在内存中的部分写回磁盘</td></tr></tbody></table>\n<p><br /><br /></p>\n<p>2、文件系统操作</p>\n<table width=\"100%\" border=\"1\" cellspacing=\"0\" cellpadding=\"5\"><tbody><tr><td width=\"30\">access</td><td>确定文件的可存取性</td></tr><tr><td>chdir</td><td>改变当前工作目录</td></tr><tr><td>fchdir</td><td>参见chdir</td></tr><tr><td>chmod</td><td>改变文件方式</td></tr><tr><td>fchmod</td><td>参见chmod</td></tr><tr><td>chown</td><td>改变文件的属主或用户组</td></tr><tr><td>fchown</td><td>参见chown</td></tr><tr><td>lchown</td><td>参见chown</td></tr><tr><td>chroot</td><td>改变根目录</td></tr><tr><td>stat</td><td>取文件状态信息</td></tr><tr><td>lstat</td><td>参见stat</td></tr><tr><td>fstat</td><td>参见stat</td></tr><tr><td>statfs</td><td>取文件系统信息</td></tr><tr><td>fstatfs</td><td>参见statfs</td></tr><tr><td>readdir</td><td>读取目录项</td></tr><tr><td>getdents</td><td>读取目录项</td></tr><tr><td>mkdir</td><td>创建目录</td></tr><tr><td>mknod</td><td>创建索引节点</td></tr><tr><td>rmdir</td><td>删除目录</td></tr><tr><td>rename</td><td>文件改名</td></tr><tr><td>link</td><td>创建链接</td></tr><tr><td>symlink</td><td>创建符号链接</td></tr><tr><td>unlink</td><td>删除链接</td></tr><tr><td>readlink</td><td>读符号链接的值</td></tr><tr><td>mount</td><td>安装文件系统</td></tr><tr><td>umount</td><td>卸下文件系统</td></tr><tr><td>ustat</td><td>取文件系统信息</td></tr><tr><td>utime</td><td>改变文件的访问修改时间</td></tr><tr><td>utimes</td><td>参见utime</td></tr><tr><td>quotactl</td><td>控制磁盘配额</td></tr></tbody></table>\n<p></p>\n<div></div>\n<h2>三、系统控制</h2>\n<table width=\"100%\" border=\"1\" cellspacing=\"0\" cellpadding=\"5\"><tbody><tr><td width=\"30\">ioctl</td><td>I/O总控制函数</td></tr><tr><td>_sysctl</td><td>读/写系统参数</td></tr><tr><td>acct</td><td>启用或禁止进程记账</td></tr><tr><td>getrlimit</td><td>获取系统资源上限</td></tr><tr><td>setrlimit</td><td>设置系统资源上限</td></tr><tr><td>getrusage</td><td>获取系统资源使用情况</td></tr><tr><td>uselib</td><td>选择要使用的二进制函数库</td></tr><tr><td>ioperm</td><td>设置端口I/O权限</td></tr><tr><td>iopl</td><td>改变进程I/O权限级别</td></tr><tr><td>outb</td><td>低级端口操作</td></tr><tr><td>reboot</td><td>重新启动</td></tr><tr><td>swapon</td><td>打开交换文件和设备</td></tr><tr><td>swapoff</td><td>关闭交换文件和设备</td></tr><tr><td>bdflush</td><td>控制bdflush守护进程</td></tr><tr><td>sysfs</td><td>取核心支持的文件系统类型</td></tr><tr><td>sysinfo</td><td>取得系统信息</td></tr><tr><td>adjtimex</td><td>调整系统时钟</td></tr><tr><td>alarm</td><td>设置进程的闹钟</td></tr><tr><td>getitimer</td><td>获取计时器值</td></tr><tr><td>setitimer</td><td>设置计时器值</td></tr><tr><td>gettimeofday</td><td>取时间和时区</td></tr><tr><td>settimeofday</td><td>设置时间和时区</td></tr><tr><td>stime</td><td>设置系统日期和时间</td></tr><tr><td>time</td><td>取得系统时间</td></tr><tr><td>times</td><td>取进程运行时间</td></tr><tr><td>uname</td><td>获取当前UNIX系统的名称、版本和主机等信息</td></tr><tr><td>vhangup</td><td>挂起当前终端</td></tr><tr><td>nfsservctl</td><td>对NFS守护进程进行控制</td></tr><tr><td>vm86</td><td>进入模拟8086模式</td></tr><tr><td>create_module</td><td>创建可装载的模块项</td></tr><tr><td>delete_module</td><td>删除可装载的模块项</td></tr><tr><td>init_module</td><td>初始化模块</td></tr><tr><td>query_module</td><td>查询模块信息</td></tr><tr><td>*get_kernel_syms</td><td>取得核心符号,已被query_module代替</td></tr></tbody></table>\n<p></p>\n<p></p>\n<h2>四、内存管理</h2>\n<table width=\"100%\" border=\"1\" cellspacing=\"0\" cellpadding=\"5\"><tbody><tr><td width=\"30\">brk</td><td>改变数据段空间的分配</td></tr><tr><td>sbrk</td><td>参见brk</td></tr><tr><td>mlock</td><td>内存页面加锁</td></tr><tr><td>munlock</td><td>内存页面解锁</td></tr><tr><td>mlockall</td><td>调用进程所有内存页面加锁</td></tr><tr><td>munlockall</td><td>调用进程所有内存页面解锁</td></tr><tr><td>mmap</td><td>映射虚拟内存页</td></tr><tr><td>munmap</td><td>去除内存页映射</td></tr><tr><td>mremap</td><td>重新映射虚拟内存地址</td></tr><tr><td>msync</td><td>将映射内存中的数据写回磁盘</td></tr><tr><td>mprotect</td><td>设置内存映像保护</td></tr><tr><td>getpagesize</td><td>获取页面大小</td></tr><tr><td>sync</td><td>将内存缓冲区数据写回硬盘</td></tr><tr><td>cacheflush</td><td>将指定缓冲区中的内容写回磁盘</td></tr></tbody></table>\n<p></p>\n<div></div>\n<h2>五、网络管理</h2>\n<table width=\"100%\" border=\"1\" cellspacing=\"0\" cellpadding=\"5\"><tbody><tr><td width=\"30\">getdomainname</td><td>取域名</td></tr><tr><td>setdomainname</td><td>设置域名</td></tr><tr><td>gethostid</td><td>获取主机标识号</td></tr><tr><td>sethostid</td><td>设置主机标识号</td></tr><tr><td>gethostname</td><td>获取本主机名称</td></tr><tr><td>sethostname</td><td>设置主机名称</td></tr></tbody></table>\n<p></p>\n<p></p>\n<h2>六、socket控制</h2>\n<table width=\"100%\" border=\"1\" cellspacing=\"0\" cellpadding=\"5\"><tbody><tr><td width=\"30\">socketcall</td><td>socket系统调用</td></tr><tr><td>socket</td><td>建立socket</td></tr><tr><td>bind</td><td>绑定socket到端口</td></tr><tr><td>connect</td><td>连接远程主机</td></tr><tr><td>accept</td><td>响应socket连接请求</td></tr><tr><td>send</td><td>通过socket发送信息</td></tr><tr><td>sendto</td><td>发送UDP信息</td></tr><tr><td>sendmsg</td><td>参见send</td></tr><tr><td>recv</td><td>通过socket接收信息</td></tr><tr><td>recvfrom</td><td>接收UDP信息</td></tr><tr><td>recvmsg</td><td>参见recv</td></tr><tr><td>listen</td><td>监听socket端口</td></tr><tr><td>select</td><td>对多路同步I/O进行轮询</td></tr><tr><td>shutdown</td><td>关闭socket上的连接</td></tr><tr><td>getsockname</td><td>取得本地socket名字</td></tr><tr><td>getpeername</td><td>获取通信对方的socket名字</td></tr><tr><td>getsockopt</td><td>取端口设置</td></tr><tr><td>setsockopt</td><td>设置端口参数</td></tr><tr><td>sendfile</td><td>在文件或端口间传输数据</td></tr><tr><td>socketpair</td><td>创建一对已联接的无名socket</td></tr></tbody></table>\n<p></p>\n<h2>七、用户管理</h2>\n<table width=\"100%\" border=\"1\" cellspacing=\"0\" cellpadding=\"5\"><tbody><tr><td width=\"30\">getuid</td><td>获取用户标识号</td></tr><tr><td>setuid</td><td>设置用户标志号</td></tr><tr><td>getgid</td><td>获取组标识号</td></tr><tr><td>setgid</td><td>设置组标志号</td></tr><tr><td>getegid</td><td>获取有效组标识号</td></tr><tr><td>setegid</td><td>设置有效组标识号</td></tr><tr><td>geteuid</td><td>获取有效用户标识号</td></tr><tr><td>seteuid</td><td>设置有效用户标识号</td></tr><tr><td>setregid</td><td>分别设置真实和有效的的组标识号</td></tr><tr><td>setreuid</td><td>分别设置真实和有效的用户标识号</td></tr><tr><td>getresgid</td><td>分别获取真实的,有效的和保存过的组标识号</td></tr><tr><td>setresgid</td><td>分别设置真实的,有效的和保存过的组标识号</td></tr><tr><td>getresuid</td><td>分别获取真实的,有效的和保存过的用户标识号</td></tr><tr><td>setresuid</td><td>分别设置真实的,有效的和保存过的用户标识号</td></tr><tr><td>setfsgid</td><td>设置文件系统检查时使用的组标识号</td></tr><tr><td>setfsuid</td><td>设置文件系统检查时使用的用户标识号</td></tr><tr><td>getgroups</td><td>获取后补组标志清单</td></tr><tr><td>setgroups</td><td>设置后补组标志清单</td></tr></tbody></table>\n<h2>八、进程间通信</h2>\n<table width=\"100%\" border=\"1\" cellspacing=\"0\" cellpadding=\"5\"><tbody><tr><td width=\"30\">ipc</td><td>进程间通信总控制调用</td></tr></tbody></table>\n<h2>其它不再举例</h2>", "created": "2016-02-29T08:40:50Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "ikvcvo2cckb7jb", "children": [], "tag_good_arr": [], "id": "il7qk16mo2tdf", "updated": "2016-02-29T08:40:50Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>进程控制&#xff1a;如创建一个新进程&#xff0c;中止进程等&#xff1b;<br />文件系统控制&#xff1a;如打开文件&#xff0c;创建新文件&#xff0c;读写文件等&#xff1b;<br />系统控制&#xff1a;如读写系统参数&#xff0c;重新启动&#xff0c;调整系统时钟等&#xff1b;<br />内存管理&#xff1a;改变数据段空间的分配brk&#xff0c;内存页面加解锁mlock和munlock等&#xff1b;<br />网络管理&#xff1a;取域名&#xff0c;设置域名&#xff0c;设置主机识别号等&#xff1b;<br />socket控制&#xff1a;建立socket&#xff0c;绑定socket&#xff0c;连接远程主机等&#xff1b;<br />用户管理&#xff1a;获取、设置用户标识号等&#xff1b;<br />进程间通信&#xff1a;进程间通信总控制调用。</p>", "created": "2016-02-29T10:15:19Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i2olyyl8swl1we", "children": [], "tag_good_arr": [], "id": "il7txjl5e856je", "updated": "2016-02-29T10:15:19Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "il7a1n617xiam", "updated": "2016-02-29T00:58:38Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>题目&#xff1a;<br />4. 3.3中的第6小题&#xff1a;以ucore lab8的answer为例&#xff0c;uCore的系统调用有哪些&#xff1f;大致的功能分类有哪些&#xff1f;</p>\n<p></p>\n<p>回答结果写在此贴中对应题目后面。</p>", "created": "2016-02-29T00:58:56Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>ucore的系统调用有22个。 可见syscall/syscall.c</p>\n<p>具体为&#xff1a;</p>\n<p>SYS_exit  SYS_fork SYS_wait SYS_exec SYS_yield SYS_kill SYS_getpid SYS_putc SYS_pgdir SYS_gettime SYS_lab6_set_priority SYS_sleep SYS_open SYS_close SYS_read</p>\n<p>SYS_write SYS_seek SYS_fstat SYS_fsync SYS_getcwd SYS_getdirentry SYS_dup</p>\n<p>ucore的功能分类主要有&#xff1a;</p>\n<p>进程控制 exit fork wait exec yield kill getpid sleep lab6_set_priority </p>\n<p>文件系统控制 pgdir open close read wirte seek fstat fsync getcwd getdirentry dup</p>\n<p>系统控制 gettime putc</p>", "created": "2016-02-29T01:17:51Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0em4o8wvj34lb", "children": [], "tag_good_arr": [], "id": "il7aqcjlq3v53", "updated": "2016-02-29T01:17:51Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<p>乔奕 2013011324</p>\n<p>ucore的系统调用有20几个。主要分为文件操作、进程管理、内存管理等。</p>\n<p>相比linux&#xff0c;ucore的系统调用少了很多&#xff0c;主要缺少网络、用户、进程间通信的功能。</p>\n<p></p>\n<p>ucore中&#xff0c;有两套syscall相关的函数。一类供内核使用&#xff0c;一类供用户&#xff08;或函数库使用&#xff09;。</p>\n<p>采用宏,num,和函数指针列表来区分各种syscall。</p>\n<p>在user/lib/syscall.c中&#xff0c;所有的sys_[action]都转为syscall函数&#xff0c;只是给了不同的参数。</p>\n<p>syscall函数中嵌套了汇编&#xff0c;把参数存入寄存器&#xff0c;并给出指令int。</p>\n<p>在kern/syscall/syscall.c中&#xff0c;syscall函数是trap派发来的。通过取出trapframe中的信息&#xff0c;尤其是num。使用num在一个函数指针列表里面找到对应的子程序。</p>\n<pre>#libs/unistd.h\n/* syscall number */\n#define SYS_exit            1\n#define SYS_fork            2\n#define SYS_wait            3<br />……</pre>\n<p></p>\n<p></p>\n<pre>tf-&gt;tf_regs.reg_eax = syscalls[num](arg);</pre>\n<p></p>", "created": "2016-02-29T01:18:59Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0gkdbms5ie20o", "children": [], "tag_good_arr": [], "id": "il7arso0dtb395", "updated": "2016-02-29T01:18:59Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>朱俸民 2012011894 &amp; 朱新瑞 2013011411</p>\n<p></p>\n<p>In line 160, kern/syscall/syscall.c:</p>\n<pre>static int (*syscalls[])(uint32_t arg[]) = {\n    [SYS_exit]              sys_exit,\n    [SYS_fork]              sys_fork,\n    [SYS_wait]              sys_wait,\n    [SYS_exec]              sys_exec,\n    [SYS_yield]             sys_yield,\n    [SYS_kill]              sys_kill,\n    [SYS_getpid]            sys_getpid,\n    [SYS_putc]              sys_putc,\n    [SYS_pgdir]             sys_pgdir,\n    [SYS_gettime]           sys_gettime,\n    [SYS_lab6_set_priority] sys_lab6_set_priority,\n    [SYS_sleep]             sys_sleep,\n    [SYS_open]              sys_open,\n    [SYS_close]             sys_close,\n    [SYS_read]              sys_read,\n    [SYS_write]             sys_write,\n    [SYS_seek]              sys_seek,\n    [SYS_fstat]             sys_fstat,\n    [SYS_fsync]             sys_fsync,\n    [SYS_getcwd]            sys_getcwd,\n    [SYS_getdirentry]       sys_getdirentry,\n    [SYS_dup]               sys_dup,\n};</pre>\n<p>共22个&#xff0c;分类如下</p>\n<p>进程管理&#xff1a;sys_exit, sys_fork, sys_wait, sys_yield, sys_exec, sys_kill, sys_getpid, sys_sleep, sys_lab6_set_property</p>\n<p>文件&#xff08;包含文件系统&#xff09;操作&#xff1a;sys_open, sys_close, sys_read, sys_write, sys_seek, sys_fstat, sys_fsync, sys_getcwd, sys_getdirectory, sys_dup, sys_pgdir</p>\n<p>系统控制&#xff1a;sys_putc&#xff08;输出字符&#xff09;&#xff0c;sys_gettime&#xff08;获取时间&#xff09;</p>\n<p></p>\n<p></p>", "created": "2016-02-29T01:27:55Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0c1nsm3911wc", "children": [], "tag_good_arr": [], "id": "il7b3apckwa5dy", "updated": "2016-02-29T01:27:55Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>一共有20多个系统调用&#xff0c;主要有以下分类:</p>\n<p>文件操作: sys_open/sys_close/sys_read/sys_putc(IO) etc.</p>\n<p>进程管理: sys_exit/sys_fork/sys_wait/sys_yield/lab6_set_priority</p>\n<p>系统控制: sys_pgdir/sys_gettime</p>\n<p></p>\n<p>白家松 2013011339</p>\n<p>徐涵 2013011355</p>", "created": "2016-02-29T01:28:35Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0f7v0qgfm61s6", "children": [], "tag_good_arr": [], "id": "il7b4548ei05y7", "updated": "2016-02-29T01:28:35Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>郑兆衡2013011389, 张浩天2013011416</p>\n<p>ucore的系统调用的处理函数定义在kern/syscall/syscall.c中&#xff0c;有如下的系统调用类型</p>\n<pre>    [SYS_exit]              sys_exit,\n    [SYS_fork]              sys_fork,\n    [SYS_wait]              sys_wait,\n    [SYS_exec]              sys_exec,\n    [SYS_yield]             sys_yield,\n    [SYS_kill]              sys_kill,\n    [SYS_getpid]            sys_getpid,\n    [SYS_putc]              sys_putc,\n    [SYS_pgdir]             sys_pgdir,\n    [SYS_gettime]           sys_gettime,\n    [SYS_lab6_set_priority] sys_lab6_set_priority,\n    [SYS_sleep]             sys_sleep,\n    [SYS_open]              sys_open,\n    [SYS_close]             sys_close,\n    [SYS_read]              sys_read,\n    [SYS_write]             sys_write,\n    [SYS_seek]              sys_seek,\n    [SYS_fstat]             sys_fstat,\n    [SYS_fsync]             sys_fsync,\n    [SYS_getcwd]            sys_getcwd,\n    [SYS_getdirentry]       sys_getdirentry,\n    [SYS_dup]               sys_dup,\n</pre>\n<p>共有22个系统调用&#xff0c;根据功能大致可以分为以下几类&#xff1a;</p>\n<p>进程管理相关的系统调用</p>\n<pre>sys_fork,<br />sys_wait,<br />sys_exec,<br />sys_yield,<br />sys_kill,<br />sys_getpid,<br />sys_sleep</pre>\n<p><br />文件操作相关的系统调用</p>\n<pre><br />sys_open<br />sys_close<br />sys_read<br />sys_write<br />sys_seek<br />sys_fstat<br />sys_fsync<br />sys_getcwd<br />sys_getdirentry</pre>\n<p></p>", "created": "2016-02-29T01:29:57Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0dlq4m0wjn5eo", "children": [], "tag_good_arr": [], "id": "il7b5x4bfjw3uc", "updated": "2016-02-29T01:29:57Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>成员 刘晓鸿 2013010949 杨晓成 2013011383</p>\n<pre>static int (*syscalls[])(uint32_t arg[]) = {\n    [SYS_exit]              sys_exit,\n    [SYS_fork]              sys_fork,\n    [SYS_wait]              sys_wait,\n    [SYS_exec]              sys_exec,\n    [SYS_yield]             sys_yield,\n    [SYS_kill]              sys_kill,\n    [SYS_getpid]            sys_getpid,\n    [SYS_putc]              sys_putc,\n    [SYS_pgdir]             sys_pgdir,\n    [SYS_gettime]           sys_gettime,\n    [SYS_lab6_set_priority] sys_lab6_set_priority,\n    [SYS_sleep]             sys_sleep,\n    [SYS_open]              sys_open,\n    [SYS_close]             sys_close,\n    [SYS_read]              sys_read,\n    [SYS_write]             sys_write,\n    [SYS_seek]              sys_seek,\n    [SYS_fstat]             sys_fstat,\n    [SYS_fsync]             sys_fsync,\n    [SYS_getcwd]            sys_getcwd,\n    [SYS_getdirentry]       sys_getdirentry,\n    [SYS_dup]               sys_dup,\n}; // from /kern/syscall/syscall.c</pre>\n<p></p>\n<p>共有22个系统调用&#xff0c;归类于</p>\n<p>进程控制(fork,wait,yield,getpid,sleep,exit,exec,lab6_set_priority,kill)&#xff0c;文件系统控制(read,dup,close,open,fstat,getdirentry,pgdir,write,seek,fsync,sys_getcwd)和系统控制(gettime&#xff0c;puts)</p>", "created": "2016-02-29T01:30:23Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0b7d04pl3y6c0", "children": [], "tag_good_arr": [], "id": "il7b6glas4p43z", "updated": "2016-02-29T01:30:23Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>2013011509</p>\n<p>ucore的系统调用有</p>\n<p>进程处理: exit fork wait(休眠等待) exec(执行) yield(出让调度) kill getpid set_priority sleep</p>\n<p>IO与文件: putc open read write seek fstat fsync getdwd getdirentry dup</p>\n<p>调试用: pgdir</p>\n<p>时间: gettime</p>", "created": "2016-02-29T01:31:50Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "ie7xy71bn7b1s2", "children": [], "tag_good_arr": [], "id": "il7b8c0alz06mr", "updated": "2016-02-29T01:31:50Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>在syscall实现方面&#xff0c;可以补充的是&#xff0c;对于ucore操作系统来说&#xff0c;和系统调用相关的代码不仅仅在之前同学提到的/kern/syscall/syscall.c中&#xff0c;其实在用户态/user/libs/syscall.c中也有相关代码。</p>\n<p>在功能上面来说&#xff0c;/kern/syscall/syscall.c实现了每个系统调用的具体功能&#xff0c;/user/libs/syscall.c则是用户态对于syscall的一个函数封装&#xff0c;可以让用户程序使用系统调用的时候像调用一个函数一样&#xff0c;而不是使用int指令。</p>\n<p></p>\n<p>在这两处都可以看到关于ucore所有系统调用的描述&#xff1a;</p>\n<p>在/kern/syscall/syscall.c中&#xff0c;我们可以看到所有的syscall为&#xff1a;</p>\n<pre>static int (*syscalls[])(uint32_t arg[]) = {\n    [SYS_exit]              sys_exit,\n    [SYS_fork]              sys_fork,\n    [SYS_wait]              sys_wait,\n    [SYS_exec]              sys_exec,\n    [SYS_yield]             sys_yield,\n    [SYS_kill]              sys_kill,\n    [SYS_getpid]            sys_getpid,\n    [SYS_putc]              sys_putc,\n    [SYS_pgdir]             sys_pgdir,\n    [SYS_gettime]           sys_gettime,\n    [SYS_lab6_set_priority] sys_lab6_set_priority,\n    [SYS_sleep]             sys_sleep,\n    [SYS_open]              sys_open,\n    [SYS_close]             sys_close,\n    [SYS_read]              sys_read,\n    [SYS_write]             sys_write,\n    [SYS_seek]              sys_seek,\n    [SYS_fstat]             sys_fstat,\n    [SYS_fsync]             sys_fsync,\n    [SYS_getcwd]            sys_getcwd,\n    [SYS_getdirentry]       sys_getdirentry,\n    [SYS_dup]               sys_dup,\n};</pre>\n<p></p>\n<p>在/user/libs/syscall.h中&#xff0c;我们可以看到&#xff1a;</p>\n<pre>int sys_exit(int error_code);\nint sys_fork(void);\nint sys_wait(int pid, int *store);\nint sys_exec(const char *name, int argc, const char **argv);\nint sys_yield(void);\nint sys_kill(int pid);\nint sys_getpid(void);\nint sys_putc(int c);\nint sys_pgdir(void);\nint sys_sleep(unsigned int time);\nsize_t sys_gettime(void);\n\nstruct stat;\nstruct dirent;\n\nint sys_open(const char *path, uint32_t open_flags);\nint sys_close(int fd);\nint sys_read(int fd, void *base, size_t len);\nint sys_write(int fd, void *base, size_t len);\nint sys_seek(int fd, off_t pos, int whence);\nint sys_fstat(int fd, struct stat *stat);\nint sys_fsync(int fd);\nint sys_getcwd(char *buffer, size_t len);\nint sys_getdirentry(int fd, struct dirent *dirent);\nint sys_dup(int fd1, int fd2);<br />void sys_lab6_set_priority(uint32_t priority); //only for lab6</pre>\n<p></p>\n<p>可以看到共有22个系统调用&#xff0c;一共分为4类&#xff1a;进程控制&#xff0c;文件处理&#xff0c;I/O&#xff0c;系统控制</p>\n<p>进程控制&#xff1a;yield kill getpid sleep lab6_set_priority exit fork wait exec</p>\n<p>文件处理&#xff1a;pgdir open close read write seek fstat fsync </p>\n<p>I/O          &#xff1a;putc</p>\n<p>系统相关&#xff1a;gettime</p>", "created": "2016-02-29T02:14:46Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0f9pvv0uxm6ko", "children": [], "tag_good_arr": [], "id": "il7crjw2kin366", "updated": "2016-02-29T02:14:46Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>系统调用的定义在 kern/syscall/syscall.c 中第160行&#xff0c;<br /> [SYS_exit] sys_exit,<br /> [SYS_fork] sys_fork,<br /> [SYS_wait] sys_wait,<br /> [SYS_exec] sys_exec,<br /> [SYS_yield] sys_yield,<br /> [SYS_kill] sys_kill,<br /> [SYS_getpid] sys_getpid,<br /> [SYS_putc] sys_putc,<br /> [SYS_pgdir] sys_pgdir,<br /> [SYS_gettime] sys_gettime,<br /> [SYS_lab6_set_priority] sys_lab6_set_priority,<br /> [SYS_sleep] sys_sleep,<br /> [SYS_open] sys_open,<br /> [SYS_close] sys_close,<br /> [SYS_read] sys_read,<br /> [SYS_write] sys_write,<br /> [SYS_seek] sys_seek,<br /> [SYS_fstat] sys_fstat,<br /> [SYS_fsync] sys_fsync,<br /> [SYS_getcwd] sys_getcwd,<br /> [SYS_getdirentry] sys_getdirentry,<br /> [SYS_dup] sys_dup,</p>\n<p>进程管理&#xff1a;sys_exit, sys_fork, sys_wait, sys_exec, sys_yield, sys_kill, sys_getpid, sys_lab6_set_priority, sys_sleep.</p>\n<p>文件操作&#xff1a;sys_open, sys_close, sys_read, sys_write, sys_seek, sys_fstat, sys_getcwd, sys_getdirentry, sys_dup.</p>\n<p></p>\n<p>2013011409</p>", "created": "2016-02-29T02:21:27Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0nu5by9l7v7of", "children": [], "tag_good_arr": [], "id": "il7d0592xzr7p9", "updated": "2016-02-29T02:21:27Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "ucore中的syscall.c&#xff1a;\n<pre>static int (*syscalls[])(uint32_t arg[]) = {\n [SYS_exit] sys_exit,\n [SYS_fork] sys_fork,\n [SYS_wait] sys_wait,\n [SYS_exec] sys_exec,\n [SYS_yield] sys_yield,\n [SYS_kill] sys_kill,\n [SYS_getpid] sys_getpid,\n [SYS_putc] sys_putc,\n [SYS_pgdir] sys_pgdir,\n [SYS_gettime] sys_gettime,\n [SYS_lab6_set_priority] sys_lab6_set_priority,\n [SYS_sleep] sys_sleep,\n [SYS_open] sys_open,\n [SYS_close] sys_close,\n [SYS_read] sys_read,\n [SYS_write] sys_write,\n [SYS_seek] sys_seek,\n [SYS_fstat] sys_fstat,\n [SYS_fsync] sys_fsync,\n [SYS_getcwd] sys_getcwd,\n [SYS_getdirentry] sys_getdirentry,\n [SYS_dup] sys_dup,\n};</pre>\nunistd.h&#xff1a;\n<pre>/* syscall number */\n#define SYS_exit            1\n#define SYS_fork            2\n#define SYS_wait            3\n#define SYS_exec            4\n#define SYS_clone           5\n#define SYS_yield           10\n#define SYS_sleep           11\n#define SYS_kill            12\n#define SYS_gettime         17\n#define SYS_getpid          18\n#define SYS_mmap            20\n#define SYS_munmap          21\n#define SYS_shmem           22\n#define SYS_putc            30\n#define SYS_pgdir           31\n#define SYS_open            100\n#define SYS_close           101\n#define SYS_read            102\n#define SYS_write           103\n#define SYS_seek            104\n#define SYS_fstat           110\n#define SYS_fsync           111\n#define SYS_getcwd          121\n#define SYS_getdirentry     128\n#define SYS_dup             130\n/* OLNY FOR LAB6 */\n#define SYS_lab6_set_priority 255</pre>", "created": "2016-02-29T02:53:26Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "ikvcvnzpzq7j7", "children": [], "tag_good_arr": [], "id": "il7e5a0ixmb6db", "updated": "2016-02-29T02:53:26Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>2012011284 章彦恺</p>\n<p><br />4. 3.3中的第6小题&#xff1a;以ucore lab8的answer为例&#xff0c;uCore的系统调用有哪些&#xff1f;大致的功能分类有哪些&#xff1f;<br /><br />通过查看kern/syscall/syscall.c中对系统调用的注册&#xff0c;可以得知ucore中的系统调用的数量。<br /><br /></p>\n<pre>static int (*syscalls[])(uint32_t arg[]) = {\n [SYS_exit] sys_exit,\n [SYS_fork] sys_fork,\n [SYS_wait] sys_wait,\n [SYS_exec] sys_exec,\n [SYS_yield] sys_yield,\n [SYS_kill] sys_kill,\n [SYS_getpid] sys_getpid,\n [SYS_putc] sys_putc,\n [SYS_pgdir] sys_pgdir,\n [SYS_gettime] sys_gettime,\n [SYS_lab6_set_priority] sys_lab6_set_priority,\n [SYS_sleep] sys_sleep,\n [SYS_open] sys_open,\n [SYS_close] sys_close,\n [SYS_read] sys_read,\n [SYS_write] sys_write,\n [SYS_seek] sys_seek,\n [SYS_fstat] sys_fstat,\n [SYS_fsync] sys_fsync,\n [SYS_getcwd] sys_getcwd,\n [SYS_getdirentry] sys_getdirentry,\n [SYS_dup] sys_dup,\n}; </pre>\n<p>在lab8中注册的syscall的数量是22个。<br /><br />大致的分类以及相应的函数如下&#xff1a;<br /><br />进程控制</p>\n<pre>sys_exit\n sys_fork\n sys_wait\n sys_exec\n sys_yield\n sys_kill\n sys_getpid\n sys_sleep\n sys_lab6_\n set_priority</pre>\n<p>文件系统</p>\n<pre>sys_pgdir\n sys_open\n sys_close\n sys_read\n sys_wirte\n sys_seek\n sys_fstat\n sys_fsync\n sys_getcwd\n sys_getdirentry\n sys_dup</pre>\n<p>系统控制</p>\n<pre>sys_gettime\nsys_putc</pre>", "created": "2016-02-29T07:44:22Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "iem550jbpyn515", "children": [], "tag_good_arr": [], "id": "il7ojeyb676xw", "updated": "2016-02-29T07:44:22Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>trap函数&#xff08;定义在trap.c中&#xff09;是对 中断进行处理的过程&#xff0c;所有的中断在经过中断入口函数__alltraps预处理后 (定义在 trapasm.S中) &#xff0c;都会跳转到这里。在处理过程中&#xff0c;根据不同的中断类型&#xff0c;进行相应的处理。在相应的处理过程结束以后&#xff0c;trap将会返回&#xff0c;被中断的程序会继续运行。具体如 下&#xff1a;</p>\n<p>产生中断后&#xff0c;CPU 跳转到相应的中断处理入口 (vectors)&#xff0c;并在桟中压入相应的 error_code&#xff08;是否存在与异常号相关&#xff09; 以及 trap_no&#xff0c;然后跳转到 alltraps 函数入口。</p>\n<p>在栈中保存当前被打断程序的 trapframe 结构(参见过程trapasm.S)。设置 kernel (内核) 的数据段寄存器&#xff0c;最后压入 esp&#xff0c;作为 trap 函数参数(struct trapframe * tf) 并跳转到中断处理函数 trap 处。</p>\n<p> </p>\n<p>根据中断号对不同的中断进行处理。其中&#xff0c;若中断号是IRQ_OFFSET &#43; IRQ_TIMER 为时钟中断&#xff0c;则把ticks 将增加一&#xff0c;<br />若中断号是IRQ_OFFSET &#43; IRQ_COM1 为串口中断&#xff0c;则显示收到的字符&#xff0c;<br />若中断号是IRQ_OFFSET &#43; IRQ_KBD 为键盘中断&#xff0c;则显示收到的字符&#xff0c;<br />若为其他中断且产生在内核状态&#xff0c;则挂起系统。</p>\n<p>结束 trap 函数的执行后&#xff0c;通过 ret 指令返回到 alltraps 执行过程。 <br />从栈中恢复所有寄存器的值。 <br />调整 esp 的值&#xff1a;跳过栈中的 trap_no 与 error_code&#xff0c;使esp指向中断返回 eip&#xff0c;通过 iret 调用恢复 cs、eflag以及 eip&#xff0c;继续执行。</p>\n<p></p>", "created": "2016-02-29T08:30:56Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "ic226rq2vask0", "children": [], "tag_good_arr": [], "id": "il7q7afaz8r3to", "updated": "2016-02-29T08:30:56Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<p>kern/syscall/syscall.c</p>\n<p></p>\n<p>static int (*syscalls[])(uint32_t arg[]) = { [SYS_exit] sys_exit, [SYS_fork] sys_fork, [SYS_wait] sys_wait, [SYS_exec] sys_exec, [SYS_yield] sys_yield, [SYS_kill] sys_kill, [SYS_getpid] sys_getpid, [SYS_putc] sys_putc, [SYS_pgdir] sys_pgdir, [SYS_gettime] sys_gettime, [SYS_lab6_set_priority] sys_lab6_set_priority, [SYS_sleep] sys_sleep, [SYS_open] sys_open, [SYS_close] sys_close, [SYS_read] sys_read, [SYS_write] sys_write, [SYS_seek] sys_seek, [SYS_fstat] sys_fstat, [SYS_fsync] sys_fsync, [SYS_getcwd] sys_getcwd, [SYS_getdirentry] sys_getdirentry, [SYS_dup] sys_dup, };</p>\n<p></p>\n<p>syscall数量22个&#xff0c;分类&#xff1a;</p>\n<ol><li>进程管理&#xff1a;exit, fork, wait, exec, yield, kill, getpid, lab6_set_priority, sleep</li><li>文件管理&#xff1a;pgdir&#xff0c;open, close, read, write, seek, fstat, fsync, getcwd, getdirentry, dup</li><li>系统信息&#xff1a;putc, pgdir</li></ol>\n<p></p>", "created": "2016-02-29T08:41:14Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "ikvcvo2cckb7jb", "children": [], "tag_good_arr": [], "id": "il7qkjkegpz4l4", "updated": "2016-02-29T08:41:14Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>kern/syscall/syscall.c&#xff1a;</p>\n<pre>static int (*syscalls[])(uint32_t arg[]) = {\n    [SYS_exit]              sys_exit,\t// Close process\n    [SYS_fork]              sys_fork,\t// Create process\n    [SYS_wait]              sys_wait,\t// Wait for the terminate of subprocess\n    [SYS_exec]              sys_exec,   // Execute local executable file\n    [SYS_yield]             sys_yield,  // Pause current process, and insert it at end of waiting sequence.\n    [SYS_kill]              sys_kill,   // Kill process\n    [SYS_getpid]            sys_getpid, // get process id\n    [SYS_putc]              sys_putc,  \n    [SYS_pgdir]             sys_pgdir,  \n    [SYS_gettime]           sys_gettime, // Get timer\n    [SYS_lab6_set_priority] sys_lab6_set_priority,  // Set priority of file\n    [SYS_sleep]             sys_sleep,\t\t// Sleep current process \n    [SYS_open]              sys_open,\t\t// open file\n    [SYS_close]             sys_close,\t\t// close file\n    [SYS_read]              sys_read,\t\t// read file\n    [SYS_write]             sys_write,\t\t// write file\n    [SYS_seek]              sys_seek,\t\t// Read next byte without moving reading index \n    [SYS_fstat]             sys_fstat,\t\t// Get file state\n    [SYS_fsync]             sys_fsync,\t\t// Write back to disk\n    [SYS_getcwd]            sys_getcwd,\t\t// Get the paras of current directory \n    [SYS_getdirentry]       sys_getdirentry,\t// Get current directory\n    [SYS_dup]               sys_dup,\t\t// Dup the description word\n};</pre>\n<p></p>", "created": "2016-02-29T08:59:50Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "ibz6vywnw6g7nl", "children": [], "tag_good_arr": [], "id": "il7r8gf0y6m580", "updated": "2016-02-29T08:59:50Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>在kern/syscall/syscall.c末可以看到ucore提供的系统调用的列表&#xff0c;此处不再粘贴了。大致的分类&#xff1a;</p>\n<ol><li>进程管理&#xff1a;exit, fork, wait, exec, yield, kill, getpid, lab6_set_priority, sleep</li><li>文件管理&#xff1a;open, close, read, write, seek, fstat, fsync, getcwd, getdirentry, dup</li><li>系统信息&#xff1a;putc, pgdir</li></ol>", "created": "2016-02-29T09:58:32Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "ierwkwbinsj2t8", "children": [], "tag_good_arr": [], "id": "il7tbxzqpbu68n", "updated": "2016-02-29T09:58:32Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p><p><strong>krajna 2014010527</strong></p>\n<p>在kern/syscall/syscall.c的160行有系统调用的函数指针</p>\n<pre>static int (*syscalls[])(uint32_t arg[]) = {\n    [SYS_exit]              sys_exit,\n    [SYS_fork]              sys_fork,\n    [SYS_wait]              sys_wait,\n    [SYS_exec]              sys_exec,\n    [SYS_yield]             sys_yield,\n    [SYS_kill]              sys_kill,\n    [SYS_getpid]            sys_getpid,\n    [SYS_putc]              sys_putc,\n    [SYS_pgdir]             sys_pgdir,\n    [SYS_gettime]           sys_gettime,\n    [SYS_lab6_set_priority] sys_lab6_set_priority,\n    [SYS_sleep]             sys_sleep,\n    [SYS_open]              sys_open,\n    [SYS_close]             sys_close,\n    [SYS_read]              sys_read,\n    [SYS_write]             sys_write,\n    [SYS_seek]              sys_seek,\n    [SYS_fstat]             sys_fstat,\n    [SYS_fsync]             sys_fsync,\n    [SYS_getcwd]            sys_getcwd,\n    [SYS_getdirentry]       sys_getdirentry,\n    [SYS_dup]               sys_dup,\n};<br /><br /></pre>\n<p>ucore系统共有22个系统调用&#xff0c;分为三大类</p>\n<p>1进程控制相关&#xff1a;sys_exit/sys_fork/sys_wait/sys_yield/ sys_exec/sys_kill/ sys_getpid/ / sys_lab6_set_property/sys_sleep</p>\n<p>2.文件系统管理相关&#xff1a;sys_open/ sys_close/sys_read/sys_write/ sys_seek/ sys_fstat/sys_fsync/ sys_getcwd/ sys_getdirectory/ sys_dup</p>\n<p>3.其他系统控制相关sys_putc/sys_gettime/ sys_pgdir</p>", "created": "2016-02-29T10:43:55Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "ikx8y1dzPrM", "children": [], "tag_good_arr": [], "id": "il7uybf6p3a6b0", "updated": "2016-02-29T10:43:55Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>2012080059</p>\n<p></p>\n<p>在kern/syscall/syscall.c中160-183的<strong>syscalls[]</strong>中有22个syscall。分类大致为&#xff1a;</p>\n<p></p>\n<p>进程相关的有 exit&#xff0c; fork&#xff0c; wait&#xff0c; exec&#xff0c; yield&#xff0c; kill&#xff0c; getpid&#xff0c; lab6_set_priority&#xff0c; sleep&#xff1b;</p>\n<p>文件操作相关有 open&#xff0c; close&#xff0c; read&#xff0c; write&#xff0c; seek&#xff0c; fstat&#xff0c; fsync&#xff0c; getcwd&#xff0c; getdirentry&#xff0c; dup&#xff1b;</p>\n<ol><li>系统信息&#xff1a;putc&#xff0c; pgdir&#xff0c;gettime&#xff1b;</li></ol>", "created": "2016-02-29T11:24:43Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i6ub5at2geM", "children": [], "tag_good_arr": [], "id": "il7wesm1vzs1jf", "updated": "2016-02-29T11:24:43Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "il7a20gc9gwgs", "updated": "2016-02-29T00:58:56Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>题目&#xff1a;<br />5. 3.5中的第2小题&#xff1a;以getpid为例&#xff0c;分析ucore的系统调用中返回结果的传递代码。</p>\n<p></p>\n<p>回答结果写在此贴中对应题目后面。</p>", "created": "2016-02-29T00:59:15Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>2013011720 % 5 == 5 % 5</p>\n<p>系统在检测到中断号为T_SYSCALL时&#xff0c;会跳转到syscall函数&#xff0c;该函数通过一张系统调用表&#xff08;如果可以这么叫的话&#xff09;&#xff0c;首先检查存储于eax寄存器中的系统调用号是否有效&#xff0c;如果无效则立即引发kernel panic。</p>\n<pre>void\nsyscall(void) {\n    struct trapframe *tf = current-&gt;tf;\n    uint32_t arg[5];\n    int num = tf-&gt;tf_regs.reg_eax;\n    if (num &gt;= 0 &amp;&amp; num &lt; NUM_SYSCALLS) {\n        if (syscalls[num] != NULL) {\n\t    //系统调用处理代码。\n            return ;\n        }\n    }\n    print_trapframe(tf);\n    panic(&#34;undefined syscall %d, pid = %d, name = %s.\\n&#34;,\n            num, current-&gt;pid, current-&gt;name);\n}</pre>\n<p>上文中省略的部分就是系统调用处理代码&#xff0c;具体的&#xff0c;trapframe中的edx&#xff0c;ecx&#xff0c;ebx&#xff0c;edi&#xff0c;esi依次作为系统调用的参数&#xff08;对于get_pid来说不需要&#xff09;</p>\n<pre>            arg[0] = tf-&gt;tf_regs.reg_edx;\n            arg[1] = tf-&gt;tf_regs.reg_ecx;\n            arg[2] = tf-&gt;tf_regs.reg_ebx;\n            arg[3] = tf-&gt;tf_regs.reg_edi;\n            arg[4] = tf-&gt;tf_regs.reg_esi;\n            tf-&gt;tf_regs.reg_eax = syscalls[num](arg);</pre>\n<p>对于getpid系统调用来说&#xff0c;syscalls[num]是sys_call指向下面的sys_getpid函数的函数指针</p>\n<pre>static int\nsys_getpid(uint32_t arg[]) {\n    return current-&gt;pid;\n}</pre>\n<p>可以看到返回的值&#xff0c;进程的pid&#xff0c;最终会被存储到trapframe的eax之中。在系统调用处理返回时&#xff0c;该eax会被存储到寄存器中&#xff0c;使得进程可以通过eax寄存器得知系统调用的结果。&#xff08;popal弹出的寄存器中包括eax&#xff09;</p>\n<pre>__trapret:<br /> # restore registers from stack<br /> popal\n# restore %ds, %es, %fs and %gs<br /> popl %gs<br /> popl %fs<br /> popl %es<br /> popl %ds\n# get rid of the trap number and error code<br /> addl $0x8, %esp<br /> iret</pre>\n<p></p>", "created": "2016-02-29T01:30:52Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0nan8i4g0o3s3", "children": [], "tag_good_arr": [], "id": "il7b7366svm6ga", "updated": "2016-02-29T01:30:52Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>在user/libs/syscall.c中有最上级的处于用户态的getpid函数调用</p>\n<p>int<br />sys_getpid(void) {<br />    return syscall(SYS_getpid);<br />}</p>\n<p>之后转到syscall函数中&#xff0c;再跳转到T<span style=\"color:#333333\">_SYSCALL中的syscall()函数。</span></p>\n<p><span style=\"color:#333333\">这里的syscall函数指向了kern/syscall/syscall.c中的</span></p>\n<p><span style=\"color:#333333\">syscall(void) {<br />    struct trapframe *tf = current-&gt;tf;<br />    uint32_t arg[5];<br />    int num = tf-&gt;tf_regs.reg_eax;<br />    if (num &gt;= 0 &amp;&amp; num &lt; NUM_SYSCALLS) {<br />        if (syscalls[num] != NULL) {<br />            arg[0] = tf-&gt;tf_regs.reg_edx;<br />            arg[1] = tf-&gt;tf_regs.reg_ecx;<br />            arg[2] = tf-&gt;tf_regs.reg_ebx;<br />            arg[3] = tf-&gt;tf_regs.reg_edi;<br />            arg[4] = tf-&gt;tf_regs.reg_esi;<br />            tf-&gt;tf_regs.reg_eax = syscalls[num](arg);<br />            return ;<br />        }<br />    }<br />    print_trapframe(tf);<br />    panic(&#34;undefined syscall %d, pid = %d, name = %s.\\n&#34;,<br />            num, current-&gt;pid, current-&gt;name);<br />}</span></p>\n<p><span style=\"color:#333333\">这里面<span style=\"color:#333333\">syscalls[num]是sys_call指向下面的sys_getpid函数的函数指针&#xff0c;对getpid来说&#xff0c;指向的是位于同一文件53行的</span></span></p>\n<p><span style=\"color:#333333\"><span style=\"color:#333333\">static int<br />sys_getpid(uint32_t arg[]) {<br />    return current-&gt;pid;<br />}</span></span></p>\n<p><span style=\"color:#333333\"><span style=\"color:#333333\">到这里&#xff0c;进程号就得出来了</span></span></p>", "created": "2016-02-29T01:37:43Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "ikvcvq38pa7l6", "children": [], "tag_good_arr": [], "id": "il7bfwh2k37fc", "updated": "2016-02-29T01:37:43Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>马志明2013011395 杨明</p>\n<p>sys.c中定义的系统调用getpid函数为</p>\n<p>static int<br />sys_getpid(uint32_t arg[]) {<br />    return current-&gt;pid;<br />}</p>\n<p>current为现行进程。</p>\n<pre>static inline int\nsyscall(int num, ...) {\n    va_list ap;\n    va_start(ap, num);\n    uint32_t a[MAX_ARGS];\n    int i, ret;\n    for (i = 0; i &lt; MAX_ARGS; i &#43;&#43;) {\n        a[i] = va_arg(ap, uint32_t);\n    }\n    va_end(ap);\n\n    asm volatile (\n        &#34;int %1;&#34;\n        : &#34;=a&#34; (ret)\n        : &#34;i&#34; (T_SYSCALL),\n          &#34;a&#34; (num),\n          &#34;d&#34; (a[0]),\n          &#34;c&#34; (a[1]),\n          &#34;b&#34; (a[2]),\n          &#34;D&#34; (a[3]),\n          &#34;S&#34; (a[4])\n        : &#34;cc&#34;, &#34;memory&#34;);\n    return ret;\n}</pre>\n<p>syscall采用内联汇编形式处理系统调用。</p>", "created": "2016-02-29T01:39:08Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0brpl1lbyui6", "children": [], "tag_good_arr": [], "id": "il7bhq13n0s6yq", "updated": "2016-02-29T01:39:08Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p><strong>krajna 2014010527</strong></p>\n<p></p>\n<p>前面和一般clock中断过程一样&#xff0c;通过idt向量表与汇编代码找到kern/trap/trap.c中的trap_dipatch()函数&#xff0c;</p>\n<p>其中跳转到T_SYSCALL中的syscall()函数。</p>\n<p></p>\n<p><strong>syscall()在kern/syscall/syscall.c中188行</strong></p>\n<p><strong>syscall(void){</strong></p>\n<p>  struct trapframe *tf=current-&gt;tf;</p>\n<p>  uint32_t arg[5];</p>\n<p>  int num=tf-&gt;tf_regs.reg_eax;</p>\n<p>  if(num&gt;=0&amp;&amp;num&lt;NUM_SYSCALLS){</p>\n<p>    if(syscalls[num]!=NULL){</p>\n<p>     //....</p>\n<p>     //...参数赋值</p>\n<p>    <strong>tf-&gt;tf_regs.reg_eax=syscall[num](arg);</strong></p>\n<p><strong>    //reg_eax中存储pid号</strong></p>\n<p>    }</p>\n<p>  }</p>\n<p>  <strong>//打印pid号等信息</strong></p>\n<p>}</p>\n<p></p>\n<p>其中syscalls[num]是一个函数指针数组</p>\n<p><strong>定义在kern/syscall/syscall.c 160行</strong></p>\n<p></p>\n<p><strong>static int (*syscalls[])(uint32_t arg[])={</strong></p>\n<p>//...</p>\n<p><strong>[SYS_getpid]     sys_getpid,</strong></p>\n<p></p>\n<p>//...other syscall function address</p>\n<p>}</p>\n<p></p>\n<p><strong>上文在syscall()中根据函数指针跳转到kern/syscall/syscall.c中的54行</strong></p>\n<p><strong>static int</strong></p>\n<p><strong>sys_getpid(uint32_t arg[]){ </strong></p>\n<p><strong>  return current-&gt;pid; //返回pid号</strong></p>\n<p><strong>}</strong></p>", "created": "2016-02-29T02:12:02Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "ikx8y1dzPrM", "children": [], "tag_good_arr": [], "id": "il7co0wov7k425", "updated": "2016-02-29T02:12:02Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>", "created": "2016-02-29T08:41:23Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "ikvcvo2cckb7jb", "children": [], "tag_good_arr": [], "id": "il7qkqlnt321tx", "updated": "2016-02-29T08:41:23Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<p>王智默 2012011355</p>\n<p>高越 2012011379</p>\n<p></p>\n<p>首先处理系统调用的是这段代码</p>\n<p></p>\n<pre>void\nsyscall(void) {\n    struct trapframe *tf = current-&gt;tf;\n    uint32_t arg[5];\n    int num = tf-&gt;tf_regs.reg_eax;\n    if (num &gt;= 0 &amp;&amp; num &lt; NUM_SYSCALLS) {\n        if (syscalls[num] != NULL) {\n            arg[0] = tf-&gt;tf_regs.reg_edx;\n            arg[1] = tf-&gt;tf_regs.reg_ecx;\n            arg[2] = tf-&gt;tf_regs.reg_ebx;\n            arg[3] = tf-&gt;tf_regs.reg_edi;\n            arg[4] = tf-&gt;tf_regs.reg_esi;\n            tf-&gt;tf_regs.reg_eax = syscalls[num](arg);\n            return ;\n        }\n    }\n    print_trapframe(tf);\n    panic(&#34;undefined syscall %d, pid = %d, name = %s.\\n&#34;,\n            num, current-&gt;pid, current-&gt;name);\n}</pre>\n<p>可以看到num是系统调用编号&#xff0c;存在eax寄存器里。先判断这个编号是否是个合法的系统调用&#xff0c;然后取出ebx等5个寄存器里的内容。然后通过syscalls[num](arg)调用相应的系统调用。</p>\n<p></p>\n<p>而syscalls这个函数指针数组在前面声明&#xff1a;</p>\n<p></p>\n<pre>static int (*syscalls[])(uint32_t arg[]) = {<br />    [SYS_exit]              sys_exit,<br />    [SYS_fork]              sys_fork,<br />    [SYS_wait]              sys_wait,<br />    [SYS_exec]              sys_exec,<br />    [SYS_yield]             sys_yield,<br />    [SYS_kill]              sys_kill,<br />    [SYS_getpid]            sys_getpid,<br />    [SYS_putc]              sys_putc,<br />    [SYS_pgdir]             sys_pgdir,<br />    [SYS_gettime]           sys_gettime,<br />    [SYS_lab6_set_priority] sys_lab6_set_priority,<br />    [SYS_sleep]             sys_sleep,<br />    [SYS_open]              sys_open,<br />    [SYS_close]             sys_close,<br />    [SYS_read]              sys_read,<br />    [SYS_write]             sys_write,<br />    [SYS_seek]              sys_seek,<br />    [SYS_fstat]             sys_fstat,<br />    [SYS_fsync]             sys_fsync,<br />    [SYS_getcwd]            sys_getcwd,<br />    [SYS_getdirentry]       sys_getdirentry,<br />    [SYS_dup]               sys_dup,<br />};</pre>\n<p>当系统调用时getpid时&#xff0c;就会去调用sys_getpid函数</p>\n<p></p>\n<pre>static int\nsys_getpid(uint32_t arg[]) {\n    return current-&gt;pid;\n}</pre>\n<p>返回current的pid。在刚才的sys_call函数中可以看到把这个返回值存入了eax寄存器</p>\n<p></p>\n<p></p>", "created": "2016-02-29T09:00:13Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i6uuj5n1v5y2t6", "children": [], "tag_good_arr": [], "id": "il7r8yn08c75dk", "updated": "2016-02-29T09:00:13Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>在user/libs/syscall.c里&#xff1a;</p>\n<pre>int\nsys_getpid(void) {\n    return syscall(SYS_getpid);\n}</pre>\n<p>将getpid对应的标号SYS_getpid&#xff0c;作为参数调用syscall函数&#xff1a;</p>\n<pre>static inline int\nsyscall(int num, ...) {\n    va_list ap;\n    va_start(ap, num);\n    uint32_t a[MAX_ARGS];\n    int i, ret;\n    for (i = 0; i &lt; MAX_ARGS; i &#43;&#43;) {\n        a[i] = va_arg(ap, uint32_t);\n    }\n    va_end(ap);\n\n    asm volatile (\n        &#34;int %1;&#34;\n        : &#34;=a&#34; (ret)\n        : &#34;i&#34; (T_SYSCALL),\n          &#34;a&#34; (num),\n          &#34;d&#34; (a[0]),\n          &#34;c&#34; (a[1]),\n          &#34;b&#34; (a[2]),\n          &#34;D&#34; (a[3]),\n          &#34;S&#34; (a[4])\n        : &#34;cc&#34;, &#34;memory&#34;);\n    return ret;\n}</pre>\n<p>通过内联汇编asm来调用中断汇编指令INT&#xff0c;然后返回eax的值。</p>", "created": "2016-02-29T09:08:35Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "ibz6vywnw6g7nl", "children": [], "tag_good_arr": [], "id": "il7rjpfrzit5o4", "updated": "2016-02-29T09:08:35Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "郭栋 2013011334\nkern/syscall/syscall.c 中 ucore系统调用\n [SYS_exit]              sys_exit,\n    [SYS_fork]              sys_fork,\n    [SYS_wait]              sys_wait,\n    [SYS_exec]              sys_exec,\n    [SYS_yield]             sys_yield,\n    [SYS_kill]              sys_kill,\n    [SYS_getpid]            sys_getpid,\n    [SYS_putc]              sys_putc,\n    [SYS_pgdir]             sys_pgdir,\n    [SYS_gettime]           sys_gettime,\n    [SYS_lab6_set_priority] sys_lab6_set_priority,\n    [SYS_sleep]             sys_sleep,\n    [SYS_open]              sys_open,\n    [SYS_close]             sys_close,\n    [SYS_read]              sys_read,\n    [SYS_write]             sys_write,\n    [SYS_seek]              sys_seek,\n    [SYS_fstat]             sys_fstat,\n    [SYS_fsync]             sys_fsync,\n    [SYS_getcwd]            sys_getcwd,\n    [SYS_getdirentry]       sys_getdirentry,\n    [SYS_dup]               sys_dup,\n\n类别&#xff1a;\n文件操作&#xff0c;进程管理&#xff0c;系统控制", "created": "2016-02-29T10:01:16Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i2om0jwie732m1", "children": [], "tag_good_arr": [], "id": "il7tfh185ub74u", "updated": "2016-02-29T10:01:16Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>getpid函数的定义为</p>\n<pre>static int<br />sys_getpid(uint32_t arg[]) {<br />    return current-&gt;pid;<br />}</pre>\n<p>返回当前进程的id</p>\n<pre>tf-&gt;tf_regs.reg_eax = syscalls[num](arg);</pre>\n<p>存入eax</p>", "created": "2016-02-29T11:54:54Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i17iy2ly5py3ad", "children": [], "tag_good_arr": [], "id": "il7xhluw8i62vv", "updated": "2016-02-29T11:54:54Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "il7a2flawlg3t", "updated": "2016-02-29T00:59:15Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>题目&#xff1a;<br />6. 3.6题&#xff1a;分析函数调用和系统调用的区别</p>\n<p></p>\n<p>回答结果写在此贴中对应题目后面。</p>", "created": "2016-02-29T00:59:28Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>沈哲言2013011371  叶子鹏2013011404</p>\n<p></p>\n<p>系统调用是操作系统给用户程序提供服务的接口&#xff0c;其本质是主动产生一个异常&#xff0c;进入异常处理程序&#xff0c;这个过程涉及到用户态内核态的转换&#xff0c;也涉及到用户栈和内核栈的内存转换。系统调用是操作系统相关的&#xff0c;而函数调用是操作系统无关的。</p>\n<p></p>\n<p>以下是细节&#xff1a;</p>\n<p></p>\n<p>状态&#xff1a;系统调用可能涉及到用户态内核态的转换&#xff0c;而函数调用不涉及。</p>\n<p>内存&#xff1a;由于用户栈和内核栈不同&#xff0c;由于状态切换&#xff0c;从安全性考虑&#xff0c;内核态和用户态的栈是分开的&#xff0c;所以系统调用中会存在内存的切换。包括TLB等缓存的切换。</p>\n<p>功能&#xff1a;函数调用是为了让程序更加模块化&#xff0c;代码复用等而存在的。系统调用是操作系统为用户程序提供服务的接口&#xff0c;库函数也会封装某些系统调用。</p>\n<p>效率&#xff1a;系统调用较函数调用更加消耗资源。因为存在额外的开销。额外开销包括&#xff1a;保存现场&#xff0c;内存栈的转换&#xff0c;内核态用户态转换&#xff0c;TLB的失效等。</p>\n<p>兼容性&#xff1a;系统调用是操作系统相关的&#xff0c;函数调用是操作系统无关的。</p>\n<p>层次&#xff1a;系统调用是最底层的调用&#xff0c;面向硬件和外部设备。函数调用面向应用程序开发&#xff0c;相当于一套高层的API&#xff0c;可能在实现中使用了系统调用。</p>\n<p></p>\n<p></p>\n<p></p>\n<p>这里额外增加说明库函数调用和系统调用的区别&#xff1a;(和原问题略有不同)</p>\n<p>库函数中会封装某些系统调用的功能&#xff0c;而库函数的封装会使这些服务在不同的操作系统上有着相同的接口&#xff0c;是跨操作系统的。使用库函数属于函数调用&#xff0c;但在其执行的过程中涉及系统调用。</p>", "created": "2016-02-29T01:23:52Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0f24oie8102cr", "children": [], "tag_good_arr": [], "id": "il7ay39336l7an", "updated": "2016-02-29T01:23:52Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>姚炫容 2013011379 龚拓宇 2013011376</p>\n<p>系统调用是调用系统提供的服务&#xff0c;有用户态和内核态的切换&#xff0c;还有用户栈和内核栈的切换&#xff0c;其开销较高&#xff0c;不同系统的系统调用不同。</p>\n<p>函数调用是调用用户程序的函数&#xff0c;开销较小.</p>", "created": "2016-02-29T01:29:36Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0c9nvk0xzc2n3", "children": [], "tag_good_arr": [], "id": "il7b5gapua91oy", "updated": "2016-02-29T01:29:36Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>梁泽宇 2014011381</p>\n<p></p>\n<p>函数调用和系统调用的区别主要有&#xff1a;</p>\n<p>&#xff08;1&#xff09;函数调用触发、处理均在用户态&#xff0c;而系统调用在用户态触发而在内核态处理&#xff1b;</p>\n<p>&#xff08;2&#xff09;函数调用需要间接进行系统调用&#xff0c;即一般的函数调用往往需要库函数调用&#xff0c;而库函数调用需要进行系统调用&#xff0c;如C的库函数fprintf()的调用需要进行系统调用&#xff08;假设在UNIX内核&#xff0c;为write()&#xff09;&#xff1b;</p>\n<p>&#xff08;3&#xff09;用户可以直接进行函数调用&#xff08;包括一般函数和库函数&#xff09;&#xff0c;但不能直接进行系统调用&#xff1b;</p>\n<p>&#xff08;4&#xff09;多数函数调用与操作系统&#xff08;平台&#xff09;无关&#xff0c;可以跨平台&#xff0c;而系统调用由于是在操作系统中实现的&#xff0c;所以一般不能跨平台&#xff1b;</p>\n<p>&#xff08;5&#xff09;函数调用开销较小&#xff0c;而系统调用需要在用户态与内核态之间进行多次切换&#xff0c;开销较大。</p>", "created": "2016-02-29T01:32:10Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "ie7xy3iwuug1os", "children": [], "tag_good_arr": [], "id": "il7b8qzz8ur84", "updated": "2016-02-29T01:32:10Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>徐捷 2012011371   赖国堃 2012011372</p>\n<p></p>\n<p>函数调用是为了方便用户编写程序和调试程序而产生的一种代码调用方法&#xff0c;与操作系统无关&#xff0c;在操作系统层面上&#xff0c;对于函数调用&#xff0c;操作系统不需要负责保存现场(保存寄存器的值)&#xff0c;而系统调用是操作系统内核对用户提供的一系列功能接口&#xff0c;用户通过系统调用可以使用操作系统内核提供的功能&#xff0c;在操作系统层面&#xff0c;系统调用时操作系统需要负责保存寄存器的值和其他的进程相关的变量。</p>", "created": "2016-02-29T01:34:51Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i6ub4vwhQXd", "children": [], "tag_good_arr": [], "id": "il7bc7l71l45tk", "updated": "2016-02-29T01:34:51Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "函数调用只涉及到简单的压栈, 包括栈桢, 返回值和参数(可能有寄存器保存), 本质上只是在同一个栈上做跳转, 与操作系统无关, 和应用程序相关, 开销相对较小, 而系统调用是操作系统给应用程序提供的服务接口, 本质上是一种异常, 是异常就会涉及现场保存, 恢复, 以及可能的用户态到内核态切换, 在切换过程当中会涉及到栈的更换, 因此开销较大.", "created": "2016-02-29T01:40:47Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i242q8ug7vw40x", "children": [], "tag_good_arr": [], "id": "il7bjty8xwf106", "updated": "2016-02-29T01:40:47Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>系统调用是用户程序和内核交互的接口&#xff1b;函数调用发生在用户程序执行期间&#xff0c;与用户程序相联系。</p>\n<p>系统调用在内核地址空间执行&#xff0c;运行时间属于系统时间&#xff1b;函数调用在用户地址空间执行&#xff0c;运行时间属于用户时间。</p>\n<p>系统调用开销较大&#xff0c;要在用户和内核间切换&#xff1b;函数调用开销较小&#xff0c;属于过程调用。</p>\n<p>系统调用难以跨操作系统移植&#xff1b;函数调用可以&#xff08;容易&#xff09;跨操作系统移植。</p>\n<p>系统调用数量较少&#xff0c;实现底层的系统功能&#xff1b;函数调用数量庞杂&#xff0c;功能更繁多。</p>\n<p>综上二者之间存在着本质上的区别。</p>", "created": "2016-02-29T01:47:28Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0ccqbaxwdz75c", "children": [], "tag_good_arr": [], "id": "il7bsfwf4qvvq", "updated": "2016-02-29T01:47:28Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<p>系统调用是运行在使用者空间的程序向操作系统内核请求需要更高权限运行的服务&#xff0c;并提供用户程序与操作系统之间的接口。<br />函数调用与系统调用有些相似&#xff0c;只是系统调用由操作系统内核提供&#xff0c;运行于内核核心态&#xff0c;而普通的库函数调用由函数库或用户自己提供&#xff0c;运行于用户态。<br />与函数调用相比&#xff0c;系统调用的开销要大些&#xff0c;因为在执行系统调用时&#xff0c;操作系统必须从运行用户代码切换到执行内核代码&#xff0c;然后再返回用户代码。</p>", "created": "2016-02-29T02:23:22Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i1oqryfapik22", "children": [], "tag_good_arr": [], "id": "il7d2lt6fjw1dk", "updated": "2016-02-29T02:23:22Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "金贤林2012080056\n\n函数调用和系统调用的区别有&#xff1a;\n1&#xff09;函数调用调用函数库中的一段程序&#xff08;或函数&#xff09;&#xff0c;系统调用调用系统内核的服务。\n2&#xff09;函数调用与用户程序相联系&#xff0c;系统调用是操作系统的一个入口点。\n3&#xff09;函数调用在用户地址空间执行&#xff0c;系统调用在内核地址空间执行。\n4&#xff09;函数调用属于过程调用&#xff0c;点用开销比较小&#xff0c;系统调用需要在用户空间和内核上下文环境间切换&#xff0c;开销比较大。", "created": "2016-02-29T06:59:28Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i6uaz437IKR", "children": [], "tag_good_arr": [], "id": "il7mxogesrp6fp", "updated": "2016-02-29T06:59:28Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>", "created": "2016-02-29T07:37:58Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "iem550jbpyn515", "children": [], "tag_good_arr": [], "id": "il7ob6ab1lw2o0", "updated": "2016-02-29T07:37:58Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>trap函数&#xff08;定义在trap.c中&#xff09;是对 中断进行处理的过程&#xff0c;所有的中断在经过中断入口函数__alltraps预处理后 (定义在 trapasm.S中) &#xff0c;都会跳转到这里。在处理过程中&#xff0c;根据不同的中断类型&#xff0c;进行相应的处理。在相应的处理过程结束以后&#xff0c;trap将会返回&#xff0c;被中断的程序会继续运行。具体如 下&#xff1a;</p>\n<p>产生中断后&#xff0c;CPU 跳转到相应的中断处理入口 (vectors)&#xff0c;并在桟中压入相应的 error_code&#xff08;是否存在与异常号相关&#xff09; 以及 trap_no&#xff0c;然后跳转到 alltraps 函数入口。</p>\n<p>在栈中保存当前被打断程序的 trapframe 结构(参见过程trapasm.S)。设置 kernel (内核) 的数据段寄存器&#xff0c;最后压入 esp&#xff0c;作为 trap 函数参数(struct trapframe * tf) 并跳转到中断处理函数 trap 处。</p>\n<p> </p>\n<p>根据中断号对不同的中断进行处理。其中&#xff0c;若中断号是IRQ_OFFSET &#43; IRQ_TIMER 为时钟中断&#xff0c;则把ticks 将增加一&#xff0c;<br />若中断号是IRQ_OFFSET &#43; IRQ_COM1 为串口中断&#xff0c;则显示收到的字符&#xff0c;<br />若中断号是IRQ_OFFSET &#43; IRQ_KBD 为键盘中断&#xff0c;则显示收到的字符&#xff0c;<br />若为其他中断且产生在内核状态&#xff0c;则挂起系统。</p>\n<p>结束 trap 函数的执行后&#xff0c;通过 ret 指令返回到 alltraps 执行过程。 <br />从栈中恢复所有寄存器的值。 <br />调整 esp 的值&#xff1a;跳过栈中的 trap_no 与 error_code&#xff0c;使esp指向中断返回 eip&#xff0c;通过 iret 调用恢复 cs、eflag以及 eip&#xff0c;继续执行。</p>\n<p></p>", "created": "2016-02-29T08:31:22Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "ic226rq2vask0", "children": [], "tag_good_arr": [], "id": "il7q7up89m04is", "updated": "2016-02-29T08:31:22Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<p>系统调用是调用系统给用户程序提供的服务&#xff0c;有用户态和内核态、用户栈和内核栈的切换&#xff0c;其开销较高&#xff0c;各个操作系统的系统调用时不同的。函数调用是为了方便用户编写程序和调试程序而产生的一种代码调用方法&#xff0c;与操作系统无关。</p>\n<p>函数调用即函数库调用是语言或应用程序的一部分&#xff0c;而系统调用是操作系统的一部分。函数库调用通常提供比较复杂的功能 &#xff0c;系统调用通常提供一种最小界面 。</p>", "created": "2016-02-29T08:41:37Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "ikvcvo2cckb7jb", "children": [], "tag_good_arr": [], "id": "il7ql16blvw490", "updated": "2016-02-29T08:41:37Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>2012011321</p>\n<p></p>\n<p>系统调用是操作系统给用户程序提供服务的接口&#xff0c;是操作系统相关的&#xff0c;而函数调用是为了方便用户编写程序和调试程序而产生的一种代码调用方法&#xff0c;与操作系统无关。</p>", "created": "2016-02-29T08:52:58Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i6vir34gLfK", "children": [], "tag_good_arr": [], "id": "il7qzmf5uqo4rz", "updated": "2016-02-29T08:52:58Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>系统调用是调用由os提供的API函数借口&#xff0c;函数调用是调用用户自定义的函数借口。区别如下&#xff1a;</p>\n<p>1. 运行状态不同。系统调用由用户态发起&#xff0c;以API为中转站&#xff0c;最终在内核态完成。函数调用的全过程只在用户态内执行。</p>\n<p>2. 调用方法不同。系统调用需要软中断(INT指令&#xff09;&#xff0c;普通的函数调用直接通过CALL来跳转到被调用函数。</p>\n<p>3. 系统调用在返回时&#xff0c;需要考虑其他因素&#xff08;例如调度分析&#xff09;。而函数调用可直接返回。</p>\n<p>4. 因为以上原因&#xff0c;系统调用的开销较大。</p>", "created": "2016-02-29T09:21:51Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "ibz6vywnw6g7nl", "children": [], "tag_good_arr": [], "id": "il7s0rxsjp96fk", "updated": "2016-02-29T09:21:51Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>郭栋 2013011334 第4题</p>\n<pre>kern/syscall/syscall.c 中 ucore系统调用\n [SYS_exit]              sys_exit,\n    [SYS_fork]              sys_fork,\n    [SYS_wait]              sys_wait,\n    [SYS_exec]              sys_exec,\n    [SYS_yield]             sys_yield,\n    [SYS_kill]              sys_kill,\n    [SYS_getpid]            sys_getpid,\n    [SYS_putc]              sys_putc,\n    [SYS_pgdir]             sys_pgdir,\n    [SYS_gettime]           sys_gettime,\n    [SYS_lab6_set_priority] sys_lab6_set_priority,\n    [SYS_sleep]             sys_sleep,\n    [SYS_open]              sys_open,\n    [SYS_close]             sys_close,\n    [SYS_read]              sys_read,\n    [SYS_write]             sys_write,\n    [SYS_seek]              sys_seek,\n    [SYS_fstat]             sys_fstat,\n    [SYS_fsync]             sys_fsync,\n    [SYS_getcwd]            sys_getcwd,\n    [SYS_getdirentry]       sys_getdirentry,\n    [SYS_dup]               sys_dup,</pre>\n<p>类别&#xff1a;<strong></strong></p>\n<p>文件操作&#xff0c;进程管理&#xff0c;系统控制</p>", "created": "2016-02-29T09:50:54Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i2om0jwie732m1", "children": [], "tag_good_arr": [], "id": "il7t24iwjhw2ya", "updated": "2016-02-29T09:50:54Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>区别如下&#xff1a;</p>\n<p>1. 函数调用是调用用户自定义的函数接口&#xff0c;系统调用是调用由操作系统提供的接口。</p>\n<p>2. 系统调用相对更为底层&#xff0c;更多地面向硬件</p>\n<p>3. 系统调用相对函数调用开销更大</p>\n<p>4. 系统调用使用int、iret指令实现调用和返回&#xff0c;函数调用则使用call、ret实现</p>\n<p>5. 系统调用与操作系统必定相关&#xff0c;函数调用可能与操作系统无关</p>", "created": "2016-02-29T10:40:29Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i2g664y8vve6h4", "children": [], "tag_good_arr": [], "id": "il7utwb8dkx7hf", "updated": "2016-02-29T10:40:29Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<p>王苏 2013011301</p>\n<p>王哲 2013012443</p>\n<p></p>\n<ol><li>函数调用是语言或应用程序的一部分&#xff0c;系统调用是操作系统的一部分。</li><li>系统调用是用户程序和内核交互的接口&#xff0c;而函数调用不是。</li><li>系统调用是为了方便应用使用操作系统的接口&#xff0c;而函数是为了方便人们编写应用程序而引出的。</li><li>不同系统的系统调用不同&#xff0c;函数调用可能相同。</li><li>系统调用与函数调用相比开销较大。</li></ol>", "created": "2016-02-29T11:31:21Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "i0hjdkesg9c5z7", "children": [], "tag_good_arr": [], "id": "il7wnbpotqe69r", "updated": "2016-02-29T11:31:21Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>系统调用涉及到操作系统级别的操作&#xff0c;函数调用只是程序自身的操作。</p>\n<p>系统调用需要触发异常&#xff0c;函数调用不需要。</p>\n<p>系统调用使用操作系统栈&#xff0c;函数调用使用程序自己的栈。</p>\n<p>系统调用有比函数调用更强大的功能&#xff0c;但所消耗空间和时间也更大。</p>", "created": "2016-02-29T12:15:50Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "feedback", "tag_good": [], "uid": "ikvcvr6di5i7ma", "children": [], "tag_good_arr": [], "id": "il7y8j18qi11gz", "updated": "2016-02-29T12:15:50Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "il7a2pox3dg166", "updated": "2016-02-29T00:59:28Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>点错</p>", "created": "2016-02-29T01:29:10Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "followup", "tag_good": [], "uid": "i0c9nvk0xzc2n3", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "il7b4wush013up", "updated": "2016-02-29T01:29:10Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>王奥丞 2014011367 https://github.com/a1exwang/os_course_spoc_exercises/blob/master/all/02-1-spoc-discussion.md</p>", "created": "2016-02-29T01:35:40Z", "bucket_order": 212, "bucket_name": "Week 2/28 - 3/5", "type": "followup", "tag_good": [], "uid": "ie7xy4gmt1p1pp", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "il7bd9eokdv2fj", "updated": "2016-02-29T01:35:40Z", "config": {}}], "tag_good_arr": [], "id": "il79yhxvw5743j", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 69, "num_favorites": 0, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643168199777, "default_anonymity": "no"}, "error": null, "aid": "kyuzx5cxuat6zm"}