{"result": {"history_size": 1, "folders": ["课堂问答", "other"], "nr": 625, "data": {"embed_links": []}, "created": "2016-02-28T09:46:37Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"uid": "i0f24oie8102cr", "anon": "no", "when": "2016-02-28T09:46:37Z", "data": "il6dgrm3y8p3ry", "type": "create"}, {"to": "il6dgrlziwd3rx", "uid": "i0nuu5yhgno5tv", "anon": "no", "when": "2016-02-28T12:07:04Z", "data": "il6ihdupwq52gw", "type": "s_answer"}, {"to": "il6dgrlziwd3rx", "uid": "hdjonbiyfs62ie", "anon": "no", "when": "2016-02-28T14:54:20Z", "data": "il6ogi2glpe32j", "type": "i_answer"}, {"to": "il6dgrlziwd3rx", "uid": "hzx4nrqzey8768", "anon": "no", "when": "2016-02-28T14:58:02Z", "type": "followup"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "i0f24oie8102cr", "subject": "用户程序以及进程相关的问题", "created": "2016-02-28T09:46:37Z", "content": "<p>和室友讨论了一会&#xff0c;有2个问题想不清楚&#xff1a;</p>\n<p>1.用户程序是如何启动的以及用户程序的代码是何时加载的&#xff1f;比如你输入指令./a.out时&#xff0c;操作系统是不是先分配一个进程给这个用户程序&#xff0c;然后这个进程加载代码并从main函数开始执行&#xff1f;</p>\n<p>2.进程和线程是什么&#xff1f;有关系又有什么区别&#xff1f;</p>"}], "type": "question", "tags": ["other", "student", "课堂问答"], "tag_good": [{"role": "", "name": "chengkai", "endorser": {}, "admin": false, "photo": null, "id": "i1569mw0xp954u", "photo_url": null, "published": true, "us": false, "class_sections": ["清华学生_i5j09fnsl7k5x0"], "facebook_id": null}], "unique_views": 123, "children": [{"history_size": 1, "folders": [], "data": {"embed_links": []}, "created": "2016-02-28T12:07:04Z", "bucket_order": 3, "tag_endorse": [], "bucket_name": "Today", "history": [{"anon": "no", "uid": "i0nuu5yhgno5tv", "subject": "", "created": "2016-02-28T12:07:04Z", "content": "<p>第一个问题&#xff0c;我觉得应该是进程分配好后新建一个线程开始从main函数开始&#xff0c;进程至少有一个线程。</p>\n<p>第二个问题&#xff0c;进程比线程大&#xff0c;一个进程可以拥有多个线程。进程之间的切换的开销会比线程之间切换要大。线程之间虽然有不同的栈空间&#xff0c;但是他们共享同一片内存&#xff0c;所以就会有以前看到过的什么锁啊&#xff0c;这种奇怪的东西。进程之间的内存就全部独立开了&#xff0c;一个进程死了其他也没啥事情。</p>"}], "type": "s_answer", "tag_endorse_arr": [], "children": [], "id": "il6ihdukloo2gv", "config": {}, "is_tag_endorse": false}, {"history_size": 1, "folders": [], "data": {"embed_links": []}, "created": "2016-02-28T14:54:20Z", "bucket_order": 3, "tag_endorse": [], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "", "created": "2016-02-28T14:54:20Z", "content": "<p>第二个问题是操作系统课后面内容要讨论的。如果现在想知道&#xff0c;建议先看一下视频或参考书中的相关内容。</p>"}], "type": "i_answer", "tag_endorse_arr": [], "children": [], "id": "il6ogi2frtd32i", "config": {}, "is_tag_endorse": false}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>1. 我认为你这种观点是比较正确的&#xff0c;但是细节上&#xff0c;在 linux 中&#xff0c;“分配一个进程”的操作是由这个进程的父进程干的。这个操作叫“fork()”。作用是&#xff1a;将当前进程的内存复制一份&#xff0c;产生一个一模一样的新进程&#xff0c;并继续运行。而“加载用户程序的代码并运行”是“execve()”&#xff0c;它的作用是&#xff1a;将指定的可执行文件加载到内存中&#xff0c;并清除原有的数据&#xff0c;然后跳转至可执行程序的入口点执行下去。入口点地址在文件头中指定&#xff0c;&#34;execve()&#34;保持 pid、打开的 fd 不变。而一个程序的入口点处&#xff0c;一般都是 C 库的代码&#xff0c;作用就是作初始化工作&#xff0c;载入动态链接库等&#xff0c;然后调用 main()&#xff0c;main() 返回后进行清理&#xff0c;然后调用 “exit()” 结束这个进程。</p>\n<p></p>\n<p>所以&#xff0c;shell 执行一个 a.out 的流程是&#xff1a;先 fork()&#xff0c;然后子进程 execve() 启动要启动的程序&#xff0c;父进程&#xff08;就是原来的进程&#xff09;等待子进程结束。</p>\n<p></p>\n<p>2. linux 里&#xff0c;调度时进程和线程是同等对待的&#xff0c;唯一的区别就是由同一进程启动的几个线程共享内存&#xff0c;而独立的几个进程的内存是互相隔离&#xff0c;不共享的。</p>", "created": "2016-02-28T14:58:02Z", "bucket_order": 303, "bucket_name": "Week 2/28 - 3/5", "type": "followup", "tag_good": [], "uid": "hzx4nrqzey8768", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "il6ol9n870l1t8", "updated": "2016-02-28T14:58:02Z", "config": {}}], "tag_good_arr": ["i1569mw0xp954u"], "no_answer": 0, "id": "il6dgrlziwd3rx", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 6, "num_favorites": 1, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643168184676, "default_anonymity": "no"}, "error": null, "aid": "kyuzwtpgzwn5ke"}