{"result": {"history_size": 3, "folders": ["lecture9", "2019"], "nr": 1297, "data": {"embed_links": []}, "created": "2019-03-31T19:53:18Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "jsilaonbtO8o", "data": "jtxce098nua6r4", "type": "create", "when": "2019-03-31T19:53:18Z"}, {"anon": "no", "uid": "jsilaonbtO8o", "data": "jty1emit8t3m2", "type": "update", "when": "2019-04-01T07:33:37Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "data": "ju14svqb9ou3x2", "type": "update", "when": "2019-04-03T11:32:00Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "恢复计数的LFU算法不会出现Belady现象的证明", "created": "2019-04-03T11:32:00Z", "content": "<p>之前向老师布置了一个思考题&#xff1a;讨论LFU算法的Belady现象。结论是&#xff0c;恢复计数的LFU算法是栈式算法&#xff0c;不会出现Belady现象&#xff1b;不恢复计数的LFU算法则可能存在Belady现象。关于后者&#xff0c;之前已经有学长举了例子&#xff08;<a href=\"/class/i5j09fnsl7k5x0?cid=1031\">https://piazza.com/class/i5j09fnsl7k5x0?cid=1031</a>&#xff09;。对于前者&#xff0c;这里给出讨论和证明&#xff1a;</p>\n<p>首先对恢复计数的LFU算法进行一种感性认识&#xff1a;考虑这样一个大小为$$n$$的栈$$S$$&#xff0c;它能够实时维护当前内存中存在的所有页面&#xff0c;并总能保持从栈顶到栈底存放的页面的访问次数是递减的。那么&#xff0c;需要置换的时候&#xff0c;被换出去的总是当前存在栈底的页面。又&#xff0c;在恢复计数的条件下&#xff0c;各个页面按计数多少排出的顺序总是一致的&#xff0c;且与系统分配的页面个数没有关系。事实上&#xff0c;考虑分配了无穷多个页面的情况&#xff1a;这时&#xff0c;相应的栈$$S_{\\infty}$$总不会有页面被置换出来&#xff0c;那么总有$$S \\subset S_{\\infty}$$&#xff08;这种包含关系是序列的包含&#xff09;。我们认识到&#xff0c;页面的计数与栈的容量无关。</p>\n<p></p>\n<p>下面来进行证明。设$$t$$时刻下大小为$$n$$的栈的内容为有序集$$S(t)$$&#xff0c;大小为$$n&#43;k$$的栈的内容为有序集$$S&#39;(t)$$&#xff0c;其中$$k &gt; 0$$&#xff1b;又&#xff0c;$$B(t)$$为新入栈的元素。</p>\n<p>只需证明&#xff0c;对于任意$$t$$&#xff0c;$$S(t) \\subset S&#39;(t)$$&#xff0c;且任意$$S(t)$$中元素$$a$$&#xff0c;对应到$$S&#39;(t)$$中元素$$a&#39;$$&#xff0c;满足$$a$$的位置小于等于$$a&#39;$$的栈位置&#xff0c;即可证明物理页面数量增加的缺页率不会降低。<br />使用数学归纳法。</p>\n<p>基础&#xff1a;在初始情况下&#xff0c;$$S(0)$$与$$S&#39;(0)$$都为空&#xff0c;满足任意$$S(0)$$中元素$$a$$&#xff0c;对应到$$S&#39;(0)$$中元素$$a&#39;$$。</p>\n<p>归纳&#xff1a;假设在$$t-1$$时刻满足$$S(t-1) \\subset S&#39;(t-1)$$&#xff0c;且任意$$S(t-1)$$中元素$$a$$&#xff0c;对应到$$S&#39;(t-1)$$中元素$$a&#39;$$&#xff0c;满足$$a$$的位置小于等于$$a&#39;$$的栈位置。则在$$t$$时刻&#xff0c;对于$$B(t)$$页的页面访问请求&#xff0c;可能出现以下三种情况&#xff1a;</p>\n<p>1. $$B(t) \\in S(t)$$ 且 $$B(t) \\in S&#39;(t)$$。记$$B(t)$$在$$S(t)$$中的位置是$$b$$&#xff0c;在$$S&#39;(t)$$中的位置是$$b&#39;$$&#xff0c;则$$b \\leq b&#39;$$。经过访问后&#xff0c;要给两个占中的该页面计数各加一。若$$B(t)$$在$$S(t)$$中上移超过了$$\\Delta b$$个页面&#xff0c;则由于这$$\\Delta b$$个页面均有序地存在于$$S&#39;(t-1)$$中&#xff0c;故$$B(t)$$在$$S&#39;(t)$$中至少也上移了$$\\Delta b$$。这样&#xff0c;$$b&#43;\\Delta b \\leq b&#39;&#43;\\Delta b$$&#xff0c;性质仍保持&#xff1b;</p>\n<p>2. $$B(t) \\notin S(t)$$ 且 $$B(t) \\in S&#39;(t)$$。这时将$$B(t)$$页面重新加入到$$S$$中。假设$$B(t)$$最终落在$$S(t)$$的位置$$b$$上&#xff0c;也就是说$$B(t)$$的计数超过了$$S(t-1)$$中的低$$b$$个&#xff1b;由于$$S(t-1) \\subset S&#39;(t-1)$$&#xff0c;那么$$S(t-1)$$中的低$$b$$个也依次存在于$$S&#39;(t-1)$$中。由于页面的计数与栈的容量无关&#xff0c;我们知道$$S&#39;$$中$$B(t)$$下面至少有这低$$b$$个页面&#xff0c;故其落在的位置一定大于等于$$b$$。</p>\n<p>3. $$B(t) \\notin S(t)$$ 且 $$B(t) \\notin S&#39;(t)$$。这时将$$B(t)$$页面重新加入到$$S$$和$$S&#39;$$中。假设$$B(t)$$最终落在$$S(t)$$的位置$$b$$上&#xff0c;也就是说$$B(t)$$的计数超过了$$S(t-1)$$中的低$$b$$个&#xff1b;由于页面的计数与栈的容量无关&#xff0c;且$$S(t-1)$$中的低$$b$$个页面也属于$$S&#39;(t-1)$$中&#xff0c;对应在$$S&#39;$$中的位置至少是低$$b$$个。那么&#xff0c;$$B(t)$$的计数也一定超过了$$S&#39;(t-1)$$中的低$$b$$个&#xff0c;最终落在落在$$S&#39;(t)$$的位置一定大于等于$$b$$。</p>\n<p></p>\n<p>由于假设的存在&#xff0c;$$S(t) \\subset S&#39;(t)$$&#xff0c;即不会出现$$B(t) \\in S(t)$$ 且 $$B(t) \\notin S&#39;(t)$$的情况。<br /> <br />综上所述&#xff0c;由数学归纳法得&#xff0c;对任意时刻$$t$$&#xff0c;$$S(t) \\subset S&#39;(t)$$&#xff0c;且任意$$S(t)$$中元素$$a$$&#xff0c;对应到$$S&#39;(t)$$中元素$$a&#39;$$&#xff0c;满足$$a$$的位置小于等于$$a&#39;$$的栈位置。</p>\n<p>即对任意时刻&#xff0c;对$$S&#39;(t)$$的缺页数量不会大于$$S(t)$$&#xff1b;物理页数量增加&#xff0c;缺页率不会上升。<br /> <br />因此&#xff0c;恢复计数的LFU算法不会出现Belady现象。</p>\n<p></p>\n<p>这份证明的思路主要来自之前对LRU算法不会出现Belady现象的证明。详见&#xff1a;<a href=\"/class/i5j09fnsl7k5x0?cid=205\">https://piazza.com/class/i5j09fnsl7k5x0?cid=205</a></p>"}, {"anon": "no", "uid": "jsilaonbtO8o", "subject": "恢复计数的LFU算法不会出现Belady现象的证明", "created": "2019-04-01T07:33:37Z", "content": "<p>之前向老师布置了一个思考题&#xff1a;讨论LFU算法的Belady现象。结论是&#xff0c;恢复计数的LFU算法是栈式算法&#xff0c;不会出现Belady现象&#xff1b;不恢复计数的LFU算法则可能存在Belady现象。关于后者&#xff0c;之前已经有学长举了例子&#xff08;<a href=\"/class/i5j09fnsl7k5x0?cid=1031\">https://piazza.com/class/i5j09fnsl7k5x0?cid=1031</a>&#xff09;。对于前者&#xff0c;这里给出讨论和证明&#xff1a;</p>\n<p>首先对恢复计数的LFU算法进行一种感性认识&#xff1a;考虑这样一个大小为$$n$$的栈$$S$$&#xff0c;它能够实时维护当前内存中存在的所有页面&#xff0c;并总能保持从栈顶到栈底存放的页面的访问次数是递减的。那么&#xff0c;需要置换的时候&#xff0c;被换出去的总是当前存在栈底的页面。又&#xff0c;在恢复计数的条件下&#xff0c;各个页面按计数多少排出的顺序总是一致的&#xff0c;且与系统分配的页面个数没有关系。事实上&#xff0c;考虑分配了无穷多个页面的情况&#xff1a;这时&#xff0c;相应的栈$$S_{\\infty}$$总不会有页面被置换出来&#xff0c;那么总有$$S \\subset S_{\\infty}$$&#xff08;这种包含关系是序列的包含&#xff09;。我们认识到&#xff0c;页面的计数与栈的容量无关。</p>\n<p></p>\n<p>下面来进行证明。设$$t$$时刻下大小为$$n$$的栈的内容为有序集$$S(t)$$&#xff0c;大小为$$n&#43;k$$的栈的内容为有序集$$S&#39;(t)$$&#xff0c;其中$$k &gt; 0$$&#xff1b;又&#xff0c;$$B(t)$$为新入栈的元素。</p>\n<p>只需证明&#xff0c;对于任意$$t$$&#xff0c;$$S(t) \\subset S&#39;(t)$$&#xff0c;且任意$$S(t)$$中元素$$a$$&#xff0c;对应到$$S&#39;(t)$$中元素$$a&#39;$$&#xff0c;满足$$a$$的位置小于等于$$a&#39;$$的栈位置&#xff0c;即可证明物理页面数量增加的缺页率不会降低。<br />使用数学归纳法。</p>\n<p>基础&#xff1a;在初始情况下&#xff0c;$$S(0)$$与$$S&#39;(0)$$都为空&#xff0c;满足任意$$S(0)$$中元素$$a$$&#xff0c;对应到$$S&#39;(0)$$中元素$$a&#39;$$。</p>\n<p>归纳&#xff1a;假设在$$t-1$$时刻满足$$S(t-1) \\subset S&#39;(t-1)$$&#xff0c;且任意$$S(t-1)$$中元素$$a$$&#xff0c;对应到$$S&#39;(t-1)$$中元素$$a&#39;$$&#xff0c;满足$$a$$的位置小于等于$$a&#39;$$的栈位置。则在$$t$$时刻&#xff0c;对于$$B(t)$$页的页面访问请求&#xff0c;可能出现以下三种情况&#xff1a;</p>\n<p>1. $$B(t) \\in S(t)$$ 且 $$B(t) \\in S&#39;(t)$$。记$$B(t)$$在$$S(t)$$中的位置是$$b$$&#xff0c;在$$S&#39;(t)$$中的位置是$$b&#39;$$&#xff0c;则$$b \\leq b&#39;$$。经过访问后&#xff0c;要给两个占中的该页面计数各加一。若$$B(t)$$在$$S(t)$$中上移超过了$$\\Delta b$$个页面&#xff0c;则由于这$$\\Delta b$$个页面均有序地存在于$$S&#39;(t-1)$$中&#xff0c;故$$B(t)$$在$$S&#39;(t)$$中至少也上移了$$\\Delta b$$。这样&#xff0c;$$b&#43;\\Delta b \\leq b&#39;&#43;\\Delta b$$&#xff0c;性质仍保持&#xff1b;</p>\n<p>2. $$B(t) \\notin S(t)$$ 且 $$B(t) \\in S&#39;(t)$$。这时将$$B(t)$$页面重新加入到$$S$$中。假设$$B(t)$$最终落在$$S(t)$$的位置$$b$$上&#xff0c;也就是说$$B(t)$$的计数超过了$$S(t-1)$$中的低$$b$$个&#xff1b;由于$$S(t-1) \\subset S&#39;(t-1)$$&#xff0c;那么$$S(t-1)$$中的低$$b$$个也依次存在于$$S&#39;(t-1)$$中。由于页面的计数与栈的容量无关&#xff0c;我们知道$$S&#39;$$中$$B(t)$$下面至少有这低$$b$$个页面&#xff0c;故其落在的位置一定大于等于$$b$$。</p>\n<p>3. $$B(t) \\notin S(t)$$ 且 $$B(t) \\notin S&#39;(t)$$。这时将$$B(t)$$页面重新加入到$$S$$和$$S&#39;$$中。假设$$B(t)$$最终落在$$S(t)$$的位置$$b$$上&#xff0c;也就是说$$B(t)$$的计数超过了$$S(t-1)$$中的低$$b$$个&#xff1b;由于页面的计数与栈的容量无关&#xff0c;且$$S(t-1)$$中的低$$b$$个页面也属于$$S&#39;(t-1)$$中&#xff0c;对应在$$S&#39;$$中的位置至少是低$$b$$个。那么&#xff0c;$$B(t)$$的计数也一定超过了$$S&#39;(t-1)$$中的低$$b$$个&#xff0c;最终落在落在$$S&#39;(t)$$的位置一定大于等于$$b$$。</p>\n<p></p>\n<p>由于假设的存在&#xff0c;$$S(t) \\subset S&#39;(t)$$&#xff0c;即不会出现$$B(t) \\in S(t)$$ 且 $$B(t) \\notin S&#39;(t)$$的情况。<br /> <br />综上所述&#xff0c;由数学归纳法得&#xff0c;对任意时刻$$t$$&#xff0c;$$S(t) \\subset S&#39;(t)$$&#xff0c;且任意$$S(t)$$中元素$$a$$&#xff0c;对应到$$S&#39;(t)$$中元素$$a&#39;$$&#xff0c;满足$$a$$的位置小于等于$$a&#39;$$的栈位置。</p>\n<p>即对任意时刻&#xff0c;对$$S&#39;(t)$$的缺页数量不会大于$$S(t)$$&#xff1b;物理页数量增加&#xff0c;缺页率不会上升。<br /> <br />因此&#xff0c;恢复计数的LFU算法不会出现Belady现象。</p>\n<p></p>\n<p>这份证明的思路主要来自之前对LRU算法不会出现Belady现象的证明。详见&#xff1a;<a href=\"/class/i5j09fnsl7k5x0?cid=205\">https://piazza.com/class/i5j09fnsl7k5x0?cid=205</a></p>"}, {"anon": "no", "uid": "jsilaonbtO8o", "subject": "恢复计数的LFU算法不会出现Belady现象的证明", "created": "2019-03-31T19:53:18Z", "content": "<p>之前向老师布置了一个思考题&#xff1a;讨论LFU算法的Belady现象。结论是&#xff0c;恢复计数的LFU算法是栈式算法&#xff0c;不会出现Belady现象&#xff1b;不恢复计数的LFU算法则可能存在Belady现象。关于后者&#xff0c;之前已经有学长举了例子&#xff08;<a href=\"/class/i5j09fnsl7k5x0?cid=1031\">https://piazza.com/class/i5j09fnsl7k5x0?cid=1031</a>&#xff09;。对于前者&#xff0c;这里给出讨论和证明&#xff1a;</p>\n<p>首先对恢复计数的LFU算法进行一种感性认识&#xff1a;考虑这样一个大小为$$n$$的栈$$S$$&#xff0c;它能够实时维护当前内存中存在的所有页面&#xff0c;并总能保持从栈顶到栈底存放的页面的访问次数是递减的。那么&#xff0c;需要置换的时候&#xff0c;被换出去的总是当前存在栈底的页面。又&#xff0c;在恢复计数的条件下&#xff0c;各个页面按计数多少排出的顺序总是一致的&#xff0c;且与系统分配的页面个数没有关系。事实上&#xff0c;考虑分配了无穷多个页面的情况&#xff1a;这时&#xff0c;相应的栈$$S_{\\infty}$$总不会有页面被置换出来&#xff0c;那么总有$$S \\subset S_{\\infty}$$&#xff08;这种包含关系可以视作是有序集的包含&#xff09;。我们认识到&#xff0c;页面的计数与栈的容量无关。</p>\n<p></p>\n<p>下面来进行证明。设$$t$$时刻下大小为$$n$$的栈的内容为有序集$$S(t)$$&#xff0c;大小为$$n&#43;k$$的栈的内容为有序集$$S&#39;(t)$$&#xff0c;其中$$k &gt; 0$$&#xff1b;又&#xff0c;$$B(t)$$为新入栈的元素。</p>\n<p>只需证明&#xff0c;对于任意$$t$$&#xff0c;$$S(t) \\subset S&#39;(t)$$&#xff0c;且任意$$S(t)$$中元素$$a$$&#xff0c;对应到$$S&#39;(t)$$中元素$$a&#39;$$&#xff0c;满足$$a$$的位置小于等于$$a&#39;$$的栈位置&#xff0c;即可证明物理页面数量增加的缺页率不会降低。<br />使用数学归纳法。</p>\n<p>基础&#xff1a;在初始情况下&#xff0c;$$S(0)$$与$$S&#39;(0)$$都为空&#xff0c;满足任意$$S(0)$$中元素$$a$$&#xff0c;对应到$$S&#39;(0)$$中元素$$a&#39;$$。</p>\n<p>归纳&#xff1a;假设在$$t-1$$时刻满足$$S(t-1) \\subset S&#39;(t-1)$$&#xff0c;且任意$$S(t-1)$$中元素$$a$$&#xff0c;对应到$$S&#39;(t-1)$$中元素$$a&#39;$$&#xff0c;满足$$a$$的位置小于等于$$a&#39;$$的栈位置。则在$$t$$时刻&#xff0c;对于$$B(t)$$页的页面访问请求&#xff0c;可能出现以下三种情况&#xff1a;</p>\n<p>1. $$B(t) \\in S(t)$$ 且 $$B(t) \\in S&#39;(t)$$。记$$B(t)$$在$$S(t)$$中的位置是$$b$$&#xff0c;在$$S&#39;(t)$$中的位置是$$b&#39;$$&#xff0c;则$$b \\leq b&#39;$$。经过访问后&#xff0c;要给两个占中的该页面计数各加一。若$$B(t)$$在$$S(t)$$中上移超过了$$\\Delta b$$个页面&#xff0c;则由于这$$\\Delta b$$个页面均有序地存在于$$S&#39;(t-1)$$中&#xff0c;故$$B(t)$$在$$S&#39;(t)$$中至少也上移了$$\\Delta b$$。这样&#xff0c;$$b&#43;\\Delta b \\leq b&#39;&#43;\\Delta b$$&#xff0c;性质仍保持&#xff1b;</p>\n<p>2. $$B(t) \\notin S(t)$$ 且 $$B(t) \\in S&#39;(t)$$。这时将$$B(t)$$页面重新加入到$$S$$中。假设$$B(t)$$最终落在$$S(t)$$的位置$$b$$上&#xff0c;也就是说$$B(t)$$的计数超过了$$S(t-1)$$中的低$$b$$个&#xff1b;由于$$S(t-1) \\subset S&#39;(t-1)$$&#xff0c;那么$$S(t-1)$$中的低$$b$$个也依次存在于$$S&#39;(t-1)$$中。由于页面的计数与栈的容量无关&#xff0c;我们知道$$S&#39;$$中$$B(t)$$下面至少有这低$$b$$个页面&#xff0c;故其落在的位置一定大于等于$$b$$。</p>\n<p>3. $$B(t) \\notin S(t)$$ 且 $$B(t) \\notin S&#39;(t)$$。这时将$$B(t)$$页面重新加入到$$S$$和$$S&#39;$$中。假设$$B(t)$$最终落在$$S(t)$$的位置$$b$$上&#xff0c;也就是说$$B(t)$$的计数超过了$$S(t-1)$$中的低$$b$$个&#xff1b;由于页面的计数与栈的容量无关&#xff0c;且$$S(t-1)$$中的低$$b$$个页面也属于$$S&#39;(t-1)$$中&#xff0c;对应在$$S&#39;$$中的位置至少是低$$b$$个。那么&#xff0c;$$B(t)$$的计数也一定超过了$$S&#39;(t-1)$$中的低$$b$$个&#xff0c;最终落在落在$$S&#39;(t)$$的位置一定大于等于$$b$$。</p>\n<p></p>\n<p>由于假设的存在&#xff0c;$$S(t) \\subset S&#39;(t)$$&#xff0c;即不会出现$$B(t) \\in S(t)$$ 且 $$B(t) \\notin S&#39;(t)$$的情况。<br /> <br />综上所述&#xff0c;由数学归纳法得&#xff0c;对任意时刻$$t$$&#xff0c;$$S(t) \\subset S&#39;(t)$$&#xff0c;且任意$$S(t)$$中元素$$a$$&#xff0c;对应到$$S&#39;(t)$$中元素$$a&#39;$$&#xff0c;满足$$a$$的位置小于等于$$a&#39;$$的栈位置。</p>\n<p>即对任意时刻&#xff0c;对$$S&#39;(t)$$的缺页数量不会大于$$S(t)$$&#xff1b;物理页数量增加&#xff0c;缺页率不会上升。<br /> <br />因此&#xff0c;恢复计数的LFU算法不会出现Belady现象。</p>\n<p></p>\n<p>这份证明的思路主要来自之前对LRU算法不会出现Belady现象的证明。详见&#xff1a;<a href=\"/class/i5j09fnsl7k5x0?cid=205\">https://piazza.com/class/i5j09fnsl7k5x0?cid=205</a></p>"}], "type": "note", "tags": ["2019", "lecture9", "student"], "tag_good": [{"role": "student", "name": "Studymaker", "endorser": {}, "admin": false, "photo": null, "id": "ks1e0jxs40w71", "photo_url": null, "published": true, "us": false, "facebook_id": null}], "unique_views": 205, "children": [], "tag_good_arr": ["ks1e0jxs40w71"], "id": "jtxce0961f06r3", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 3, "num_favorites": 5, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169686138, "default_anonymity": "no"}, "error": null, "aid": "kyv0t08qfu31yd"}