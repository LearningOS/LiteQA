{"result": {"folders": ["lecture5", "2020"], "nr": 1416, "data": {"embed_links": []}, "created": "2020-03-04T16:02:01Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "full", "data": "k7diecx6510v3", "type": "create", "when": "2020-03-04T16:02:01Z", "uid_a": "a_0"}, {"anon": "full", "data": "k7dif989brk1wy", "type": "update", "when": "2020-03-04T16:02:43Z", "uid_a": "a_0"}, {"anon": "full", "data": "k7dikjgqrv26d0", "type": "update", "when": "2020-03-04T16:06:49Z", "uid_a": "a_0"}, {"anon": "full", "data": "k7dimqe8ey016t", "type": "update", "when": "2020-03-04T16:08:32Z", "uid_a": "a_0"}, {"anon": "full", "data": "k7dioqhs7qo34d", "type": "update", "when": "2020-03-04T16:10:05Z", "uid_a": "a_0"}, {"anon": "full", "data": "k7dirjrebh2y7", "type": "update", "when": "2020-03-04T16:12:16Z", "uid_a": "a_0"}, {"anon": "full", "data": "k7disodhzox6dl", "type": "update", "when": "2020-03-04T16:13:09Z", "uid_a": "a_0"}, {"anon": "full", "data": "k7dityvg3ak7ns", "type": "update", "when": "2020-03-04T16:14:09Z", "uid_a": "a_0"}, {"anon": "full", "data": "k7djm0e6y3q4tj", "type": "update", "when": "2020-03-04T16:35:58Z", "uid_a": "a_0"}, {"anon": "full", "data": "k7e0wu18uyt7gx", "type": "update", "when": "2020-03-05T00:40:16Z", "uid_a": "a_0"}, {"anon": "no", "uid": "k6og4u6njzf5y9", "to": "k7diecx3b5tv2", "type": "followup", "when": "2020-03-06T17:48:41Z"}], "bucket_name": "Today", "history": [{"anon": "full", "uid_a": "a_0", "subject": "2020春 lec5 课后习题讨论", "created": "2020-03-05T00:40:16Z", "content": "<p>随机抽取部分同学题解。</p>\n<p><strong>Nature<br /></strong></p>\n<p><strong> <img src=\"/img/1416-8505083dce762b54.png\" alt=\"\" /></strong></p>\n<p><strong>Python</strong></p>\n<md><br />&#96;&#96;&#96;python<br />import sys<br />from memory import *<br /><br /># 判断是否为合法数据<br />def ifvalid(bitstring):<br />    isvalid = bitstring &gt;&gt; 7<br />    return_number = bitstring &amp; 0b01111111<br />    if isvalid == 1:<br />        return True,return_number<br />    else:<br />        return False,return_number<br />    <br /># 读入要求访问的虚拟地址<br />virtual_address = int(sys.argv[1][2:],16) <br />print(&#34;virtual virtual_address is &#34; &#43; hex(virtual_address))<br />page_directory_base_registor = 0x220<br />base_index = 0x220 &gt;&gt; 5<br />pde_index_mask = 0b0111110000000000<br />pte_index_mask = 0b0000001111100000<br />offset_mask = 0b0000000000011111<br />pde_index = (virtual_address &amp; pde_index_mask) &gt;&gt; 10<br />pte_index = (virtual_address &amp; pte_index_mask) &gt;&gt; 5<br />offset = virtual_address &amp; offset_mask<br /># mem[page_index][entry_index] 为已处理好的二维数组<br />first_level_number = mem[base_index][pde_index] <br />flag, pte_base = ifvalid(first_level_number)<br /># 说明不合法<br />if not flag:<br />    print(&#34;   --&gt; pde index : &#34;&#43; str(hex(pde_index))&#43;  &#34; pde contents : (valid = 0 pfn = &#34; &#43; str(hex(pte_base))&#43;&#34;)&#34;)<br />    print(&#34;         --&gt; Fault (page directory entry not valid)&#34;)<br />else:<br />    print(&#34;   --&gt; pde index : &#34;&#43; str(hex(pde_index))&#43;  &#34; pde contents : (valid = 1 pfn = &#34; &#43; str(hex(pte_base))&#43;&#34;)&#34;)<br />    second_level_number = mem[pte_base][pte_index]<br />    flag_2, ppn_base = ifvalid(second_level_number)<br />    if not flag_2:<br />        print(&#34;     --&gt; pte index : &#34;&#43; str(hex(pte_index))&#43;  &#34; pde contents : (valid = 0 pfn = &#34; &#43; str(hex(ppn_base))&#43;&#34;)&#34;)<br />        print(&#34;       --&gt; Fault (page table entry not valid)&#34;)<br />    else:<br />        print(&#34;     --&gt; pte index : &#34;&#43; str(hex(pte_index))&#43;  &#34; pde contents : (valid = 1 pfn = &#34; &#43; str(hex(ppn_base))&#43;&#34;)&#34;)<br />        number = mem[ppn_base][offset]<br />        print(&#34;       --&gt; Translates to physical address : &#34; &#43; str(hex((ppn_base&lt;&lt;5)&#43;offset)) &#43; &#34; --&gt; value : &#34; &#43; str(hex(number))&#43;&#34;)&#34;)<br />&#96;&#96;&#96;<br /></md>\n<p>不是问题的问题&#xff1a;信任了题目数据&#xff0c;注意虚拟地址可能非法&#xff08;有冗余&#xff09;。具体可参考如下函数。</p>\n<md><br />&#96;&#96;&#96;python<br />def read_storage(page,offset):<br />    if page&lt;0 or page&gt;int(&#39;7f&#39;,16):<br />        return -1<br />    if offset&lt;0 or offset&gt;31:<br />        return -1<br />    return storage[page][offset]<br />&#96;&#96;&#96;<br /></md>\n<p><strong>C&#43;&#43;</strong></p>\n<md><br />&#96;&#96;&#96;C&#43;&#43;<br />#include &lt;iostream&gt;<br />#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;<br /><br />uint16_t BASE_ADD = 0x220;<br /><br />void vir_to_phy(uint16_t base_add, int* phy_mem, uint16_t vir_addr){<br />    printf(&#34;Virtual Address %04x :\\n&#34;, vir_addr);<br />    uint8_t pde_shift = vir_addr &gt;&gt; 10;<br />    uint8_t pte_shift = (vir_addr &gt;&gt; 5) % 32;<br />    uint8_t pde_contents = phy_mem[base_add &#43; pde_shift];<br />    printf(&#34;  --&gt; pde index: %02x, pte contents: (valid: %01d, pfn %02x) \\n&#34;, <br />            pde_shift, pde_contents &gt;&gt; 7 ,pde_contents % 128);<br />    if(pde_contents &gt;&gt; 7 == 0){<br />        printf(&#34;    --&gt; Fault (page ditectory entry not valid) \\n&#34;);<br />        return;<br />    }<br />    else {<br />        uint8_t pte_contents = phy_mem[(pde_contents % 128)*32 &#43; pte_shift];<br />        printf(&#34;    --&gt; pte index: %02x, pte contents: (valid: %01d, pfn %02x) \\n&#34;, <br />            pte_shift, pte_contents &gt;&gt; 7 ,pte_contents % 128);<br />        if(pte_contents &gt;&gt; 7 == 0){<br />            printf(&#34;      --&gt; Fault (page table entry not valid) \\n&#34;);<br />            return;<br />        }<br />        else{<br />            uint16_t value_addr = (uint16_t)((pte_contents % 128) &lt;&lt; 5) &#43; vir_addr % 32;<br />            int value = phy_mem[value_addr];<br />            printf(&#34;      --&gt; Translates to physical address %02x --&gt; Value: %02x \\n&#34;, value_addr, value);<br />        }<br />    }<br />}<br /><br />int main(){<br />    int phy_mem[4096];<br />    int i = 0;<br />    FILE *fp;<br />    fp = fopen(&#34;phymem.txt&#34;, &#34;r&#34;);<br />    while(fscanf(fp, &#34;%2x&#34;, &amp;(phy_mem[i])) !=EOF) i&#43;&#43;;<br /><br />    uint16_t vir_addrs[10] = {0x6c74, 0x6b22, 0x03df, 0x69dc, 0x317a, 0x4546, 0x2c03, 0x7fd7, 0x390e, 0x748b};<br />    for(auto va: vir_addrs){<br />        vir_to_phy(BASE_ADD, phy_mem, va);<br />    }<br />    return 0;<br />}<br />&#96;&#96;&#96;<br /></md>\n<p><strong>RUST</strong></p>\n<md><br />&#96;&#96;&#96;rust<br />use std::fs;<br /><br />fn main() {<br />    let mut pde_index : u8;<br />    let mut pte_index : u8;<br />    let mut page_offset : u8;<br /><br />    let mut pde_content : u8;<br />    let mut pde_valid : u8;<br />    let mut pde_addr : u8;<br /><br />    let mut pte_content : u8;<br />    let mut pte_valid : u8;<br />    let mut pte_addr : u8;<br /><br />    let mut paddr : u16;<br />    let mut value : u8;<br /><br />    // load memory information<br />    let contents = fs::read_to_string(&#34;memory.txt&#34;)<br />                .expect(&#34;Something went wrong reading the file&#34;);<br />    let mut mem = Vec::new();<br />    let split = contents.as_str().split(&#34;\\n&#34;);<br />    for s in split {<br />        mem.push(s.split(&#34; &#34;).collect::&lt;Vec&lt;&amp;str&gt;&gt;());<br />    }<br /><br />    let vec : Vec&lt;u16&gt; = vec![0x6c74, 0x6b22, 0x03df, 0x69dc, 0x317a, 0x4546, 0x2c03, 0x7fd7, 0x390e, 0x748b];<br /><br />    for addr in vec.into_iter() {<br />        print!(&#34;\\nthe virtual addr is {:#x} \\n    &#34;, addr);<br /><br />        //parse the virtual addr<br />        pde_index  = (addr &gt;&gt; 10) as u8;<br />        pte_index  = ((addr &lt;&lt; 6) &gt;&gt; 11) as u8;<br />        page_offset  = (addr % 32) as u8;<br /><br />        //get pde<br />        pde_content = parse_str(mem[0x11][2 &#43; pde_index as usize]);<br />        pde_valid = pde_content &gt;&gt; 7;<br />        pde_addr = pde_content - (pde_valid &lt;&lt; 7);<br /><br />        //get pte<br />        pte_content = parse_str(mem[pde_addr as usize][2&#43; pte_index as usize]);<br />        pte_valid = pte_content &gt;&gt; 7;<br />        pte_addr = pte_content - (pte_valid &lt;&lt; 7);<br /><br />        //get physical address and value stored in it<br />        paddr = ((pte_addr as u16) &lt;&lt; 5) &#43; page_offset as u16;<br />        value = parse_str(mem[(paddr &gt;&gt; 5) as usize][2 &#43; (paddr % 32) as usize]);<br /><br />        print!(&#34;the pde index is : {:#x}, pde content is {:#x} (valid {}, pfn {:#x})\\n      &#34;, pde_index, pde_content, pde_valid, pde_addr);<br />        if pde_valid != 0 {<br />            print!(&#34;the pte index is : {:#x}, content is {:#x} (valid {}, pfn {:#x}) \\n         &#34;, pte_index, pte_content, pte_valid, pte_addr);<br />        }else{<br />            println!(&#34;Fault (page directory entry not valid)&#34;);<br />            continue;<br />        }<br />        if pte_valid != 0 {<br />            print!(&#34;the page offset is : {:#x}, the paddr is {:#x}, value is {:#x} \\n       &#34;, page_offset, paddr, value);<br />        }else{<br />            println!(&#34;Fault (page directory entry not valid)&#34;);<br />            continue;<br />        }<br />    }<br />}<br /><br />// convert str to number, such as &#39;1b&#39; =&gt; 27_u8<br />fn parse_str(s : &amp;str) -&gt; u8 {<br />    let mut res : u8 = 0;<br />    for ch in s.bytes() {<br />        res = (res &lt;&lt; 4) &#43; parse_char(ch);<br />    }<br />    res<br />}<br />    <br />// convert char to number<br />fn parse_char(ch : u8) -&gt; u8 {<br />    match ch {<br />        b&#39;0&#39;=&gt; 0,<br />        b&#39;1&#39;=&gt; 1,<br />        b&#39;2&#39;=&gt; 2,<br />        b&#39;3&#39;=&gt; 3,<br />        b&#39;4&#39;=&gt; 4,<br />        b&#39;5&#39;=&gt; 5,<br />        b&#39;6&#39;=&gt; 6,<br />        b&#39;7&#39;=&gt; 7,<br />        b&#39;8&#39;=&gt; 8,<br />        b&#39;9&#39;=&gt; 9,<br />        b&#39;a&#39;=&gt; 10,<br />        b&#39;b&#39;=&gt; 11,<br />        b&#39;c&#39;=&gt; 12,<br />        b&#39;d&#39;=&gt; 13,<br />        b&#39;e&#39;=&gt; 14,<br />        b&#39;f&#39;=&gt; 15,<br />        _ =&gt; 0<br />    }<br />}<br />&#96;&#96;&#96;<br /></md>\n<p></p>\n<p></p>"}, {"anon": "full", "uid_a": "a_0", "subject": "2020春 lec5 课后习题讨论", "created": "2020-03-04T16:35:58Z", "content": "<p>随机抽取部分同学题解。</p>\n<p><strong>Chinese<br /></strong></p>\n<p><strong> <img src=\"/img/1416-8505083dce762b54.png\" alt=\"\" /></strong></p>\n<p><strong>Python</strong></p>\n<md><br />&#96;&#96;&#96;python<br />import sys<br />from memory import *<br /><br /># 判断是否为合法数据<br />def ifvalid(bitstring):<br />    isvalid = bitstring &gt;&gt; 7<br />    return_number = bitstring &amp; 0b01111111<br />    if isvalid == 1:<br />        return True,return_number<br />    else:<br />        return False,return_number<br />    <br /># 读入要求访问的虚拟地址<br />virtual_address = int(sys.argv[1][2:],16) <br />print(&#34;virtual virtual_address is &#34; &#43; hex(virtual_address))<br />page_directory_base_registor = 0x220<br />base_index = 0x220 &gt;&gt; 5<br />pde_index_mask = 0b0111110000000000<br />pte_index_mask = 0b0000001111100000<br />offset_mask = 0b0000000000011111<br />pde_index = (virtual_address &amp; pde_index_mask) &gt;&gt; 10<br />pte_index = (virtual_address &amp; pte_index_mask) &gt;&gt; 5<br />offset = virtual_address &amp; offset_mask<br /># mem[page_index][entry_index] 为已处理好的二维数组<br />first_level_number = mem[base_index][pde_index] <br />flag, pte_base = ifvalid(first_level_number)<br /># 说明不合法<br />if not flag:<br />    print(&#34;   --&gt; pde index : &#34;&#43; str(hex(pde_index))&#43;  &#34; pde contents : (valid = 0 pfn = &#34; &#43; str(hex(pte_base))&#43;&#34;)&#34;)<br />    print(&#34;         --&gt; Fault (page directory entry not valid)&#34;)<br />else:<br />    print(&#34;   --&gt; pde index : &#34;&#43; str(hex(pde_index))&#43;  &#34; pde contents : (valid = 1 pfn = &#34; &#43; str(hex(pte_base))&#43;&#34;)&#34;)<br />    second_level_number = mem[pte_base][pte_index]<br />    flag_2, ppn_base = ifvalid(second_level_number)<br />    if not flag_2:<br />        print(&#34;     --&gt; pte index : &#34;&#43; str(hex(pte_index))&#43;  &#34; pde contents : (valid = 0 pfn = &#34; &#43; str(hex(ppn_base))&#43;&#34;)&#34;)<br />        print(&#34;       --&gt; Fault (page table entry not valid)&#34;)<br />    else:<br />        print(&#34;     --&gt; pte index : &#34;&#43; str(hex(pte_index))&#43;  &#34; pde contents : (valid = 1 pfn = &#34; &#43; str(hex(ppn_base))&#43;&#34;)&#34;)<br />        number = mem[ppn_base][offset]<br />        print(&#34;       --&gt; Translates to physical address : &#34; &#43; str(hex((ppn_base&lt;&lt;5)&#43;offset)) &#43; &#34; --&gt; value : &#34; &#43; str(hex(number))&#43;&#34;)&#34;)<br />&#96;&#96;&#96;<br /></md>\n<p>不是问题的问题&#xff1a;信任了题目数据&#xff0c;注意虚拟地址可能非法&#xff08;有冗余&#xff09;。具体可参考如下函数。</p>\n<md><br />&#96;&#96;&#96;python<br />def read_storage(page,offset):<br />    if page&lt;0 or page&gt;int(&#39;7f&#39;,16):<br />        return -1<br />    if offset&lt;0 or offset&gt;31:<br />        return -1<br />    return storage[page][offset]<br />&#96;&#96;&#96;<br /></md>\n<p><strong>C&#43;&#43;</strong></p>\n<md><br />&#96;&#96;&#96;C&#43;&#43;<br />#include &lt;iostream&gt;<br />#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;<br /><br />uint16_t BASE_ADD = 0x220;<br /><br />void vir_to_phy(uint16_t base_add, int* phy_mem, uint16_t vir_addr){<br />    printf(&#34;Virtual Address %04x :\\n&#34;, vir_addr);<br />    uint8_t pde_shift = vir_addr &gt;&gt; 10;<br />    uint8_t pte_shift = (vir_addr &gt;&gt; 5) % 32;<br />    uint8_t pde_contents = phy_mem[base_add &#43; pde_shift];<br />    printf(&#34;  --&gt; pde index: %02x, pte contents: (valid: %01d, pfn %02x) \\n&#34;, <br />            pde_shift, pde_contents &gt;&gt; 7 ,pde_contents % 128);<br />    if(pde_contents &gt;&gt; 7 == 0){<br />        printf(&#34;    --&gt; Fault (page ditectory entry not valid) \\n&#34;);<br />        return;<br />    }<br />    else {<br />        uint8_t pte_contents = phy_mem[(pde_contents % 128)*32 &#43; pte_shift];<br />        printf(&#34;    --&gt; pte index: %02x, pte contents: (valid: %01d, pfn %02x) \\n&#34;, <br />            pte_shift, pte_contents &gt;&gt; 7 ,pte_contents % 128);<br />        if(pte_contents &gt;&gt; 7 == 0){<br />            printf(&#34;      --&gt; Fault (page table entry not valid) \\n&#34;);<br />            return;<br />        }<br />        else{<br />            uint16_t value_addr = (uint16_t)((pte_contents % 128) &lt;&lt; 5) &#43; vir_addr % 32;<br />            int value = phy_mem[value_addr];<br />            printf(&#34;      --&gt; Translates to physical address %02x --&gt; Value: %02x \\n&#34;, value_addr, value);<br />        }<br />    }<br />}<br /><br />int main(){<br />    int phy_mem[4096];<br />    int i = 0;<br />    FILE *fp;<br />    fp = fopen(&#34;phymem.txt&#34;, &#34;r&#34;);<br />    while(fscanf(fp, &#34;%2x&#34;, &amp;(phy_mem[i])) !=EOF) i&#43;&#43;;<br /><br />    uint16_t vir_addrs[10] = {0x6c74, 0x6b22, 0x03df, 0x69dc, 0x317a, 0x4546, 0x2c03, 0x7fd7, 0x390e, 0x748b};<br />    for(auto va: vir_addrs){<br />        vir_to_phy(BASE_ADD, phy_mem, va);<br />    }<br />    return 0;<br />}<br />&#96;&#96;&#96;<br /></md>\n<p><strong>RUST</strong></p>\n<md><br />&#96;&#96;&#96;rust<br />use std::fs;<br /><br />fn main() {<br />    let mut pde_index : u8;<br />    let mut pte_index : u8;<br />    let mut page_offset : u8;<br /><br />    let mut pde_content : u8;<br />    let mut pde_valid : u8;<br />    let mut pde_addr : u8;<br /><br />    let mut pte_content : u8;<br />    let mut pte_valid : u8;<br />    let mut pte_addr : u8;<br /><br />    let mut paddr : u16;<br />    let mut value : u8;<br /><br />    // load memory information<br />    let contents = fs::read_to_string(&#34;memory.txt&#34;)<br />                .expect(&#34;Something went wrong reading the file&#34;);<br />    let mut mem = Vec::new();<br />    let split = contents.as_str().split(&#34;\\n&#34;);<br />    for s in split {<br />        mem.push(s.split(&#34; &#34;).collect::&lt;Vec&lt;&amp;str&gt;&gt;());<br />    }<br /><br />    let vec : Vec&lt;u16&gt; = vec![0x6c74, 0x6b22, 0x03df, 0x69dc, 0x317a, 0x4546, 0x2c03, 0x7fd7, 0x390e, 0x748b];<br /><br />    for addr in vec.into_iter() {<br />        print!(&#34;\\nthe virtual addr is {:#x} \\n    &#34;, addr);<br /><br />        //parse the virtual addr<br />        pde_index  = (addr &gt;&gt; 10) as u8;<br />        pte_index  = ((addr &lt;&lt; 6) &gt;&gt; 11) as u8;<br />        page_offset  = (addr % 32) as u8;<br /><br />        //get pde<br />        pde_content = parse_str(mem[0x11][2 &#43; pde_index as usize]);<br />        pde_valid = pde_content &gt;&gt; 7;<br />        pde_addr = pde_content - (pde_valid &lt;&lt; 7);<br /><br />        //get pte<br />        pte_content = parse_str(mem[pde_addr as usize][2&#43; pte_index as usize]);<br />        pte_valid = pte_content &gt;&gt; 7;<br />        pte_addr = pte_content - (pte_valid &lt;&lt; 7);<br /><br />        //get physical address and value stored in it<br />        paddr = ((pte_addr as u16) &lt;&lt; 5) &#43; page_offset as u16;<br />        value = parse_str(mem[(paddr &gt;&gt; 5) as usize][2 &#43; (paddr % 32) as usize]);<br /><br />        print!(&#34;the pde index is : {:#x}, pde content is {:#x} (valid {}, pfn {:#x})\\n      &#34;, pde_index, pde_content, pde_valid, pde_addr);<br />        if pde_valid != 0 {<br />            print!(&#34;the pte index is : {:#x}, content is {:#x} (valid {}, pfn {:#x}) \\n         &#34;, pte_index, pte_content, pte_valid, pte_addr);<br />        }else{<br />            println!(&#34;Fault (page directory entry not valid)&#34;);<br />            continue;<br />        }<br />        if pte_valid != 0 {<br />            print!(&#34;the page offset is : {:#x}, the paddr is {:#x}, value is {:#x} \\n       &#34;, page_offset, paddr, value);<br />        }else{<br />            println!(&#34;Fault (page directory entry not valid)&#34;);<br />            continue;<br />        }<br />    }<br />}<br /><br />// convert str to number, such as &#39;1b&#39; =&gt; 27_u8<br />fn parse_str(s : &amp;str) -&gt; u8 {<br />    let mut res : u8 = 0;<br />    for ch in s.bytes() {<br />        res = (res &lt;&lt; 4) &#43; parse_char(ch);<br />    }<br />    res<br />}<br />    <br />// convert char to number<br />fn parse_char(ch : u8) -&gt; u8 {<br />    match ch {<br />        b&#39;0&#39;=&gt; 0,<br />        b&#39;1&#39;=&gt; 1,<br />        b&#39;2&#39;=&gt; 2,<br />        b&#39;3&#39;=&gt; 3,<br />        b&#39;4&#39;=&gt; 4,<br />        b&#39;5&#39;=&gt; 5,<br />        b&#39;6&#39;=&gt; 6,<br />        b&#39;7&#39;=&gt; 7,<br />        b&#39;8&#39;=&gt; 8,<br />        b&#39;9&#39;=&gt; 9,<br />        b&#39;a&#39;=&gt; 10,<br />        b&#39;b&#39;=&gt; 11,<br />        b&#39;c&#39;=&gt; 12,<br />        b&#39;d&#39;=&gt; 13,<br />        b&#39;e&#39;=&gt; 14,<br />        b&#39;f&#39;=&gt; 15,<br />        _ =&gt; 0<br />    }<br />}<br />&#96;&#96;&#96;<br /></md>\n<p></p>\n<p></p>"}, {"anon": "full", "uid_a": "a_0", "subject": "2020春 lec5 课后习题讨论", "created": "2020-03-04T16:14:09Z", "content": "<p>随机抽取部分同学题解。</p>\n<p><strong>Chinese<br /></strong></p>\n<p><strong> <img src=\"/img/1416-8505083dce762b54.png\" alt=\"\" /></strong></p>\n<p><strong>Python</strong></p>\n<md><br />&#96;&#96;&#96;python<br />import sys<br />from memory import *<br /><br /># 判断是否为合法数据<br />def ifvalid(bitstring):<br />    isvalid = bitstring &gt;&gt; 7<br />    return_number = bitstring &amp; 0b01111111<br />    if isvalid == 1:<br />        return True,return_number<br />    else:<br />        return False,return_number<br />    <br /># 读入要求访问的虚拟地址<br />virtual_address = int(sys.argv[1][2:],16) <br />print(&#34;virtual virtual_address is &#34; &#43; hex(virtual_address))<br />page_directory_base_registor = 0x220<br />base_index = 0x220 &gt;&gt; 5<br />pde_index_mask = 0b0111110000000000<br />pte_index_mask = 0b0000001111100000<br />offset_mask = 0b0000000000011111<br />pde_index = (virtual_address &amp; pde_index_mask) &gt;&gt; 10<br />pte_index = (virtual_address &amp; pte_index_mask) &gt;&gt; 5<br />offset = virtual_address &amp; offset_mask<br /># mem[page_index][entry_index] 为已处理好的二维数组<br />first_level_number = mem[base_index][pde_index] <br />flag, pte_base = ifvalid(first_level_number)<br /># 说明不合法<br />if not flag:<br />    print(&#34;   --&gt; pde index : &#34;&#43; str(hex(pde_index))&#43;  &#34; pde contents : (valid = 0 pfn = &#34; &#43; str(hex(pte_base))&#43;&#34;)&#34;)<br />    print(&#34;         --&gt; Fault (page directory entry not valid)&#34;)<br />else:<br />    print(&#34;   --&gt; pde index : &#34;&#43; str(hex(pde_index))&#43;  &#34; pde contents : (valid = 1 pfn = &#34; &#43; str(hex(pte_base))&#43;&#34;)&#34;)<br />    second_level_number = mem[pte_base][pte_index]<br />    flag_2, ppn_base = ifvalid(second_level_number)<br />    if not flag_2:<br />        print(&#34;     --&gt; pte index : &#34;&#43; str(hex(pte_index))&#43;  &#34; pde contents : (valid = 0 pfn = &#34; &#43; str(hex(ppn_base))&#43;&#34;)&#34;)<br />        print(&#34;       --&gt; Fault (page table entry not valid)&#34;)<br />    else:<br />        print(&#34;     --&gt; pte index : &#34;&#43; str(hex(pte_index))&#43;  &#34; pde contents : (valid = 1 pfn = &#34; &#43; str(hex(ppn_base))&#43;&#34;)&#34;)<br />        number = mem[ppn_base][offset]<br />        print(&#34;       --&gt; Translates to physical address : &#34; &#43; str(hex((ppn_base&lt;&lt;5)&#43;offset)) &#43; &#34; --&gt; value : &#34; &#43; str(hex(number))&#43;&#34;)&#34;)<br />&#96;&#96;&#96;<br /></md>\n<p>不是问题的问题&#xff1a;信任了题目数据&#xff0c;注意虚拟地址可能非法&#xff08;有冗余&#xff09;。具体可参考如下函数。</p>\n<md><br />&#96;&#96;&#96;python<br />def read_storage(page,offset):<br />    if page&lt;0 or page&gt;int(&#39;7f&#39;,16):<br />        return -1<br />    if offset&lt;0 or offset&gt;31:<br />        return -1<br />    return storage[page][offset]<br />&#96;&#96;&#96;<br /></md>\n<p><strong>C&#43;&#43;</strong></p>\n<md><br />&#96;&#96;&#96;C&#43;&#43;<br />#include &lt;iostream&gt;<br />#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;<br /><br />uint16_t BASE_ADD = 0x220;<br /><br />void vir_to_phy(uint16_t base_add, int* phy_mem, uint16_t vir_addr){<br />    printf(&#34;Virtual Address %04x :\\n&#34;, vir_addr);<br />    uint8_t pde_shift = vir_addr &gt;&gt; 10;<br />    uint8_t pte_shift = (vir_addr &gt;&gt; 5) % 32;<br />    uint8_t pde_contents = phy_mem[base_add &#43; pde_shift];<br />    printf(&#34;  --&gt; pde index: %02x, pte contents: (valid: %01d, pfn %02x) \\n&#34;, <br />            pde_shift, pde_contents &gt;&gt; 7 ,pde_contents % 128);<br />    if(pde_contents &gt;&gt; 7 == 0){<br />        printf(&#34;    --&gt; Fault (page ditectory entry not valid) \\n&#34;);<br />        return;<br />    }<br />    else {<br />        uint8_t pte_contents = phy_mem[(pde_contents % 128)*32 &#43; pte_shift];<br />        printf(&#34;    --&gt; pte index: %02x, pte contents: (valid: %01d, pfn %02x) \\n&#34;, <br />            pte_shift, pte_contents &gt;&gt; 7 ,pte_contents % 128);<br />        if(pte_contents &gt;&gt; 7 == 0){<br />            printf(&#34;      --&gt; Fault (page table entry not valid) \\n&#34;);<br />            return;<br />        }<br />        else{<br />            uint16_t value_addr = (uint16_t)((pte_contents % 128) &lt;&lt; 5) &#43; vir_addr % 32;<br />            int value = phy_mem[value_addr];<br />            printf(&#34;      --&gt; Translates to physical address %02x --&gt; Value: %02x \\n&#34;, value_addr, value);<br />        }<br />    }<br />}<br /><br />int main(){<br />    int phy_mem[4096];<br />    int i = 0;<br />    FILE *fp;<br />    fp = fopen(&#34;phymem.txt&#34;, &#34;r&#34;);<br />    while(fscanf(fp, &#34;%2x&#34;, &amp;(phy_mem[i])) !=EOF) i&#43;&#43;;<br /><br />    uint16_t vir_addrs[10] = {0x6c74, 0x6b22, 0x03df, 0x69dc, 0x317a, 0x4546, 0x2c03, 0x7fd7, 0x390e, 0x748b};<br />    for(auto va: vir_addrs){<br />        vir_to_phy(BASE_ADD, phy_mem, va);<br />    }<br />    return 0;<br />}<br />&#96;&#96;&#96;<br /></md>\n<p><strong>RUST</strong></p>\n<md><br />&#96;&#96;&#96;rust<br />use std::fs;<br /><br />fn main() {<br />    let mut pde_index : u8;<br />    let mut pte_index : u8;<br />    let mut page_offset : u8;<br /><br />    let mut pde_content : u8;<br />    let mut pde_valid : u8;<br />    let mut pde_addr : u8;<br /><br />    let mut pte_content : u8;<br />    let mut pte_valid : u8;<br />    let mut pte_addr : u8;<br /><br />    let mut paddr : u16;<br />    let mut value : u8;<br /><br />    // load memory information<br />    let contents = fs::read_to_string(&#34;memory.txt&#34;)<br />                .expect(&#34;Something went wrong reading the file&#34;);<br />    let mut mem = Vec::new();<br />    let split = contents.as_str().split(&#34;\\n&#34;);<br />    for s in split {<br />        mem.push(s.split(&#34; &#34;).collect::&lt;Vec&lt;&amp;str&gt;&gt;());<br />    }<br /><br />    let vec : Vec&lt;u16&gt; = vec![0x6c74, 0x6b22, 0x03df, 0x69dc, 0x317a, 0x4546, 0x2c03, 0x7fd7, 0x390e, 0x748b];<br /><br />    for addr in vec.into_iter() {<br />        print!(&#34;\\nthe virtual addr is {:#x} \\n    &#34;, addr);<br /><br />        //parse the virtual addr<br />        pde_index  = (addr &gt;&gt; 10) as u8;<br />        pte_index  = ((addr &lt;&lt; 6) &gt;&gt; 11) as u8;<br />        page_offset  = (addr % 32) as u8;<br /><br />        //get pde<br />        pde_content = parse_str(mem[0x11][2 &#43; pde_index as usize]);<br />        pde_valid = pde_content &gt;&gt; 7;<br />        pde_addr = pde_content - (pde_valid &lt;&lt; 7);<br /><br />        //get pte<br />        pte_content = parse_str(mem[pde_addr as usize][2&#43; pte_index as usize]);<br />        pte_valid = pte_content &gt;&gt; 7;<br />        pte_addr = pte_content - (pte_valid &lt;&lt; 7);<br /><br />        //get physical address and value stored in it<br />        paddr = ((pte_addr as u16) &lt;&lt; 5) &#43; page_offset as u16;<br />        value = parse_str(mem[(paddr &gt;&gt; 5) as usize][2 &#43; (paddr % 32) as usize]);<br /><br />        print!(&#34;the pde index is : {:#x}, pde content is {:#x} (valid {}, pfn {:#x})\\n      &#34;, pde_index, pde_content, pde_valid, pde_addr);<br />        if pde_valid != 0 {<br />            print!(&#34;the pte index is : {:#x}, content is {:#x} (valid {}, pfn {:#x}) \\n         &#34;, pte_index, pte_content, pte_valid, pte_addr);<br />        }else{<br />            println!(&#34;Fault (page directory entry not valid)&#34;);<br />            continue;<br />        }<br />        if pte_valid != 0 {<br />            print!(&#34;the page offset is : {:#x}, the paddr is {:#x}, value is {:#x} \\n       &#34;, page_offset, paddr, value);<br />        }else{<br />            println!(&#34;Fault (page directory entry not valid)&#34;);<br />            continue;<br />        }<br />    }<br />}<br /><br />// convert str to number, such as &#39;1b&#39; =&gt; 27_u8<br />fn parse_str(s : &amp;str) -&gt; u8 {<br />    let mut res : u8 = 0;<br />    for ch in s.bytes() {<br />        res = (res &lt;&lt; 4) &#43; parse_char(ch);<br />    }<br />    res<br />}<br />    <br />// convert char to number<br />fn parse_char(ch : u8) -&gt; u8 {<br />    match ch {<br />        b&#39;0&#39;=&gt; 0,<br />        b&#39;1&#39;=&gt; 1,<br />        b&#39;2&#39;=&gt; 2,<br />        b&#39;3&#39;=&gt; 3,<br />        b&#39;4&#39;=&gt; 4,<br />        b&#39;5&#39;=&gt; 5,<br />        b&#39;6&#39;=&gt; 6,<br />        b&#39;7&#39;=&gt; 7,<br />        b&#39;8&#39;=&gt; 8,<br />        b&#39;9&#39;=&gt; 9,<br />        b&#39;a&#39;=&gt; 10,<br />        b&#39;b&#39;=&gt; 11,<br />        b&#39;c&#39;=&gt; 12,<br />        b&#39;d&#39;=&gt; 13,<br />        b&#39;e&#39;=&gt; 14,<br />        b&#39;f&#39;=&gt; 15,<br />        _ =&gt; 0<br />    }<br />}<br />&#96;&#96;&#96;<br /></md>\n<p></p>\n<p></p>"}, {"anon": "full", "uid_a": "a_0", "subject": "2020春 lec5 课后习题讨论", "created": "2020-03-04T16:13:09Z", "content": "<p>随机抽取部分同学题解。</p>\n<p><strong>Chinese<br /></strong></p>\n<p><strong> <img src=\"/img/1416-8505083dce762b54.png\" alt=\"\" /></strong></p>\n<p><strong>Python</strong></p>\n<md><br />&#96;&#96;&#96;python<br />import sys<br />from memory import *<br /><br /># 判断是否为合法数据<br />def ifvalid(bitstring):<br />    isvalid = bitstring &gt;&gt; 7<br />    return_number = bitstring &amp; 0b01111111<br />    if isvalid == 1:<br />        return True,return_number<br />    else:<br />        return False,return_number<br />    <br /># 读入要求访问的虚拟地址<br />virtual_address = int(sys.argv[1][2:],16) <br />print(&#34;virtual virtual_address is &#34; &#43; hex(virtual_address))<br />page_directory_base_registor = 0x220<br />base_index = 0x220 &gt;&gt; 5<br />pde_index_mask = 0b0111110000000000<br />pte_index_mask = 0b0000001111100000<br />offset_mask = 0b0000000000011111<br />pde_index = (virtual_address &amp; pde_index_mask) &gt;&gt; 10<br />pte_index = (virtual_address &amp; pte_index_mask) &gt;&gt; 5<br />offset = virtual_address &amp; offset_mask<br /># mem[page_index][entry_index] 为已处理好的二维数组<br />first_level_number = mem[base_index][pde_index] <br />flag, pte_base = ifvalid(first_level_number)<br /># 说明不合法<br />if not flag:<br />    print(&#34;   --&gt; pde index : &#34;&#43; str(hex(pde_index))&#43;  &#34; pde contents : (valid = 0 pfn = &#34; &#43; str(hex(pte_base))&#43;&#34;)&#34;)<br />    print(&#34;         --&gt; Fault (page directory entry not valid)&#34;)<br />else:<br />    print(&#34;   --&gt; pde index : &#34;&#43; str(hex(pde_index))&#43;  &#34; pde contents : (valid = 1 pfn = &#34; &#43; str(hex(pte_base))&#43;&#34;)&#34;)<br />    second_level_number = mem[pte_base][pte_index]<br />    flag_2, ppn_base = ifvalid(second_level_number)<br />    if not flag_2:<br />        print(&#34;     --&gt; pte index : &#34;&#43; str(hex(pte_index))&#43;  &#34; pde contents : (valid = 0 pfn = &#34; &#43; str(hex(ppn_base))&#43;&#34;)&#34;)<br />        print(&#34;       --&gt; Fault (page table entry not valid)&#34;)<br />    else:<br />        print(&#34;     --&gt; pte index : &#34;&#43; str(hex(pte_index))&#43;  &#34; pde contents : (valid = 1 pfn = &#34; &#43; str(hex(ppn_base))&#43;&#34;)&#34;)<br />        number = mem[ppn_base][offset]<br />        print(&#34;       --&gt; Translates to physical address : &#34; &#43; str(hex((ppn_base&lt;&lt;5)&#43;offset)) &#43; &#34; --&gt; value : &#34; &#43; str(hex(number))&#43;&#34;)&#34;)<br />&#96;&#96;&#96;<br /></md>\n<p>不是问题的问题&#xff1a;信任了题目数据&#xff0c;注意虚拟地址可能非法&#xff08;有冗余&#xff09;。具体可参考如下函数。</p>\n<md><br />&#96;&#96;&#96;python<br />def read_storage(page,offset): if page&lt;0 or page&gt;int(&#39;7f&#39;,16): return -1 if offset&lt;0 or offset&gt;31: return -1 return storage[page][offset]<br />&#96;&#96;&#96;<br /></md>\n<p><strong>C&#43;&#43;</strong></p>\n<md><br />&#96;&#96;&#96;c&#43;&#43;<br />#include &lt;iostream&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; uint16_t BASE_ADD = 0x220; void vir_to_phy(uint16_t base_add, int* phy_mem, uint16_t vir_addr){ printf(&#34;Virtual Address %04x :\\n&#34;, vir_addr); uint8_t pde_shift = vir_addr &gt;&gt; 10; uint8_t pte_shift = (vir_addr &gt;&gt; 5) % 32; uint8_t pde_contents = phy_mem[base_add &#43; pde_shift]; printf(&#34; --&gt; pde index: %02x, pte contents: (valid: %01d, pfn %02x) \\n&#34;, pde_shift, pde_contents &gt;&gt; 7 ,pde_contents % 128); if(pde_contents &gt;&gt; 7 == 0){ printf(&#34; --&gt; Fault (page ditectory entry not valid) \\n&#34;); return; } else { uint8_t pte_contents = phy_mem[(pde_contents % 128)*32 &#43; pte_shift]; printf(&#34; --&gt; pte index: %02x, pte contents: (valid: %01d, pfn %02x) \\n&#34;, pte_shift, pte_contents &gt;&gt; 7 ,pte_contents % 128); if(pte_contents &gt;&gt; 7 == 0){ printf(&#34; --&gt; Fault (page table entry not valid) \\n&#34;); return; } else{ uint16_t value_addr = (uint16_t)((pte_contents % 128) &lt;&lt; 5) &#43; vir_addr % 32; int value = phy_mem[value_addr]; printf(&#34; --&gt; Translates to physical address %02x --&gt; Value: %02x \\n&#34;, value_addr, value); } } } int main(){ int phy_mem[4096]; int i = 0; FILE *fp; fp = fopen(&#34;phymem.txt&#34;, &#34;r&#34;); while(fscanf(fp, &#34;%2x&#34;, &amp;(phy_mem[i])) !=EOF) i&#43;&#43;; uint16_t vir_addrs[10] = {0x6c74, 0x6b22, 0x03df, 0x69dc, 0x317a, 0x4546, 0x2c03, 0x7fd7, 0x390e, 0x748b}; for(auto va: vir_addrs){ vir_to_phy(BASE_ADD, phy_mem, va); } return 0; }<br />&#96;&#96;&#96;<br /></md>\n<p><strong>RUST</strong></p>\n<md><br />&#96;&#96;&#96;rust<br />use std::fs; fn main() {     let mut pde_index : u8;     let mut pte_index : u8;     let mut page_offset : u8;     let mut pde_content : u8;     let mut pde_valid : u8;     let mut pde_addr : u8;     let mut pte_content : u8;     let mut pte_valid : u8;     let mut pte_addr : u8;     let mut paddr : u16;     let mut value : u8;     // load memory information     let contents = fs::read_to_string(&#34;memory.txt&#34;)                 .expect(&#34;Something went wrong reading the file&#34;);     let mut mem = Vec::new();     let split = contents.as_str().split(&#34;\\n&#34;);     for s in split {         mem.push(s.split(&#34; &#34;).collect::&lt;Vec&lt;&amp;str&gt;&gt;());     }     let vec : Vec&lt;u16&gt; = vec![0x6c74, 0x6b22, 0x03df, 0x69dc, 0x317a, 0x4546, 0x2c03, 0x7fd7, 0x390e, 0x748b];     for addr in vec.into_iter() {         print!(&#34;\\nthe virtual addr is {:#x} \\n    &#34;, addr);         //parse the virtual addr         pde_index  = (addr &gt;&gt; 10) as u8;         pte_index  = ((addr &lt;&lt; 6) &gt;&gt; 11) as u8;         page_offset  = (addr % 32) as u8;         //get pde         pde_content = parse_str(mem[0x11][2 &#43; pde_index as usize]);         pde_valid = pde_content &gt;&gt; 7;         pde_addr = pde_content - (pde_valid &lt;&lt; 7);         //get pte         pte_content = parse_str(mem[pde_addr as usize][2&#43; pte_index as usize]);         pte_valid = pte_content &gt;&gt; 7;         pte_addr = pte_content - (pte_valid &lt;&lt; 7);         //get physical address and value stored in it         paddr = ((pte_addr as u16) &lt;&lt; 5) &#43; page_offset as u16;         value = parse_str(mem[(paddr &gt;&gt; 5) as usize][2 &#43; (paddr % 32) as usize]);         print!(&#34;the pde index is : {:#x}, pde content is {:#x} (valid {}, pfn {:#x})\\n      &#34;, pde_index, pde_content, pde_valid, pde_addr);         if pde_valid != 0 {             print!(&#34;the pte index is : {:#x}, content is {:#x} (valid {}, pfn {:#x}) \\n         &#34;, pte_index, pte_content, pte_valid, pte_addr);         }else{             println!(&#34;Fault (page directory entry not valid)&#34;);             continue;         }         if pte_valid != 0 {             print!(&#34;the page offset is : {:#x}, the paddr is {:#x}, value is {:#x} \\n       &#34;, page_offset, paddr, value);         }else{             println!(&#34;Fault (page directory entry not valid)&#34;);             continue;         }     } } // convert str to number, such as &#39;1b&#39; =&gt; 27_u8 fn parse_str(s : &amp;str) -&gt; u8 {     let mut res : u8 = 0;     for ch in s.bytes() {         res = (res &lt;&lt; 4) &#43; parse_char(ch);     }     res }      // convert char to number fn parse_char(ch : u8) -&gt; u8 {     match ch {         b&#39;0&#39;=&gt; 0,         b&#39;1&#39;=&gt; 1,         b&#39;2&#39;=&gt; 2,         b&#39;3&#39;=&gt; 3,         b&#39;4&#39;=&gt; 4,         b&#39;5&#39;=&gt; 5,         b&#39;6&#39;=&gt; 6,         b&#39;7&#39;=&gt; 7,         b&#39;8&#39;=&gt; 8,         b&#39;9&#39;=&gt; 9,         b&#39;a&#39;=&gt; 10,         b&#39;b&#39;=&gt; 11,         b&#39;c&#39;=&gt; 12,         b&#39;d&#39;=&gt; 13,         b&#39;e&#39;=&gt; 14,         b&#39;f&#39;=&gt; 15,         _ =&gt; 0     } }<br />&#96;&#96;&#96;<br /></md>\n<p></p>\n<p></p>"}, {"anon": "full", "uid_a": "a_0", "subject": "2020春 lec5 课后习题讨论", "created": "2020-03-04T16:12:16Z", "content": "<p>随机抽取部分同学题解。</p>\n<p><strong>Chinese<br /></strong></p>\n<p><strong> <img src=\"/img/1416-8505083dce762b54.png\" alt=\"\" /></strong></p>\n<p><strong>Python</strong></p>\n<md>&#96;&#96;&#96;python<br />import sys from memory import * # 判断是否为合法数据 def ifvalid(bitstring): isvalid = bitstring &gt;&gt; 7 return_number = bitstring &amp; 0b01111111 if isvalid == 1: return True,return_number else: return False,return_number # 读入要求访问的虚拟地址 virtual_address = int(sys.argv[1][2:],16) print(&#34;virtual virtual_address is &#34; &#43; hex(virtual_address)) page_directory_base_registor = 0x220 base_index = 0x220 &gt;&gt; 5 pde_index_mask = 0b0111110000000000 pte_index_mask = 0b0000001111100000 offset_mask = 0b0000000000011111 pde_index = (virtual_address &amp; pde_index_mask) &gt;&gt; 10 pte_index = (virtual_address &amp; pte_index_mask) &gt;&gt; 5 offset = virtual_address &amp; offset_mask # mem[page_index][entry_index] 为已处理好的二维数组 first_level_number = mem[base_index][pde_index] flag, pte_base = ifvalid(first_level_number) # 说明不合法 if not flag: print(&#34; --&gt; pde index : &#34;&#43; str(hex(pde_index))&#43; &#34; pde contents : (valid = 0 pfn = &#34; &#43; str(hex(pte_base))&#43;&#34;)&#34;) print(&#34; --&gt; Fault (page directory entry not valid)&#34;) else: print(&#34; --&gt; pde index : &#34;&#43; str(hex(pde_index))&#43; &#34; pde contents : (valid = 1 pfn = &#34; &#43; str(hex(pte_base))&#43;&#34;)&#34;) second_level_number = mem[pte_base][pte_index] flag_2, ppn_base = ifvalid(second_level_number) if not flag_2: print(&#34; --&gt; pte index : &#34;&#43; str(hex(pte_index))&#43; &#34; pde contents : (valid = 0 pfn = &#34; &#43; str(hex(ppn_base))&#43;&#34;)&#34;) print(&#34; --&gt; Fault (page table entry not valid)&#34;) else: print(&#34; --&gt; pte index : &#34;&#43; str(hex(pte_index))&#43; &#34; pde contents : (valid = 1 pfn = &#34; &#43; str(hex(ppn_base))&#43;&#34;)&#34;) number = mem[ppn_base][offset] print(&#34; --&gt; Translates to physical address : &#34; &#43; str(hex((ppn_base&lt;&lt;5)&#43;offset)) &#43; &#34; --&gt; value : &#34; &#43; str(hex(number))&#43;&#34;)&#34;)<br />&#96;&#96;&#96;</md>\n<p>不是问题的问题&#xff1a;信任了题目数据&#xff0c;注意虚拟地址可能非法&#xff08;有冗余&#xff09;。具体可参考如下函数。</p>\n<md>&#96;&#96;&#96;python<br />def read_storage(page,offset): if page&lt;0 or page&gt;int(&#39;7f&#39;,16): return -1 if offset&lt;0 or offset&gt;31: return -1 return storage[page][offset]<br />&#96;&#96;&#96;</md>\n<p><strong>C&#43;&#43;</strong></p>\n<md>&#96;&#96;&#96;c&#43;&#43;<br />#include &lt;iostream&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; uint16_t BASE_ADD = 0x220; void vir_to_phy(uint16_t base_add, int* phy_mem, uint16_t vir_addr){ printf(&#34;Virtual Address %04x :\\n&#34;, vir_addr); uint8_t pde_shift = vir_addr &gt;&gt; 10; uint8_t pte_shift = (vir_addr &gt;&gt; 5) % 32; uint8_t pde_contents = phy_mem[base_add &#43; pde_shift]; printf(&#34; --&gt; pde index: %02x, pte contents: (valid: %01d, pfn %02x) \\n&#34;, pde_shift, pde_contents &gt;&gt; 7 ,pde_contents % 128); if(pde_contents &gt;&gt; 7 == 0){ printf(&#34; --&gt; Fault (page ditectory entry not valid) \\n&#34;); return; } else { uint8_t pte_contents = phy_mem[(pde_contents % 128)*32 &#43; pte_shift]; printf(&#34; --&gt; pte index: %02x, pte contents: (valid: %01d, pfn %02x) \\n&#34;, pte_shift, pte_contents &gt;&gt; 7 ,pte_contents % 128); if(pte_contents &gt;&gt; 7 == 0){ printf(&#34; --&gt; Fault (page table entry not valid) \\n&#34;); return; } else{ uint16_t value_addr = (uint16_t)((pte_contents % 128) &lt;&lt; 5) &#43; vir_addr % 32; int value = phy_mem[value_addr]; printf(&#34; --&gt; Translates to physical address %02x --&gt; Value: %02x \\n&#34;, value_addr, value); } } } int main(){ int phy_mem[4096]; int i = 0; FILE *fp; fp = fopen(&#34;phymem.txt&#34;, &#34;r&#34;); while(fscanf(fp, &#34;%2x&#34;, &amp;(phy_mem[i])) !=EOF) i&#43;&#43;; uint16_t vir_addrs[10] = {0x6c74, 0x6b22, 0x03df, 0x69dc, 0x317a, 0x4546, 0x2c03, 0x7fd7, 0x390e, 0x748b}; for(auto va: vir_addrs){ vir_to_phy(BASE_ADD, phy_mem, va); } return 0; }<br />&#96;&#96;&#96;</md>\n<p><strong>RUST</strong></p>\n<md>&#96;&#96;&#96;rust<br />use std::fs; fn main() {     let mut pde_index : u8;     let mut pte_index : u8;     let mut page_offset : u8;     let mut pde_content : u8;     let mut pde_valid : u8;     let mut pde_addr : u8;     let mut pte_content : u8;     let mut pte_valid : u8;     let mut pte_addr : u8;     let mut paddr : u16;     let mut value : u8;     // load memory information     let contents = fs::read_to_string(&#34;memory.txt&#34;)                 .expect(&#34;Something went wrong reading the file&#34;);     let mut mem = Vec::new();     let split = contents.as_str().split(&#34;\\n&#34;);     for s in split {         mem.push(s.split(&#34; &#34;).collect::&lt;Vec&lt;&amp;str&gt;&gt;());     }     let vec : Vec&lt;u16&gt; = vec![0x6c74, 0x6b22, 0x03df, 0x69dc, 0x317a, 0x4546, 0x2c03, 0x7fd7, 0x390e, 0x748b];     for addr in vec.into_iter() {         print!(&#34;\\nthe virtual addr is {:#x} \\n    &#34;, addr);         //parse the virtual addr         pde_index  = (addr &gt;&gt; 10) as u8;         pte_index  = ((addr &lt;&lt; 6) &gt;&gt; 11) as u8;         page_offset  = (addr % 32) as u8;         //get pde         pde_content = parse_str(mem[0x11][2 &#43; pde_index as usize]);         pde_valid = pde_content &gt;&gt; 7;         pde_addr = pde_content - (pde_valid &lt;&lt; 7);         //get pte         pte_content = parse_str(mem[pde_addr as usize][2&#43; pte_index as usize]);         pte_valid = pte_content &gt;&gt; 7;         pte_addr = pte_content - (pte_valid &lt;&lt; 7);         //get physical address and value stored in it         paddr = ((pte_addr as u16) &lt;&lt; 5) &#43; page_offset as u16;         value = parse_str(mem[(paddr &gt;&gt; 5) as usize][2 &#43; (paddr % 32) as usize]);         print!(&#34;the pde index is : {:#x}, pde content is {:#x} (valid {}, pfn {:#x})\\n      &#34;, pde_index, pde_content, pde_valid, pde_addr);         if pde_valid != 0 {             print!(&#34;the pte index is : {:#x}, content is {:#x} (valid {}, pfn {:#x}) \\n         &#34;, pte_index, pte_content, pte_valid, pte_addr);         }else{             println!(&#34;Fault (page directory entry not valid)&#34;);             continue;         }         if pte_valid != 0 {             print!(&#34;the page offset is : {:#x}, the paddr is {:#x}, value is {:#x} \\n       &#34;, page_offset, paddr, value);         }else{             println!(&#34;Fault (page directory entry not valid)&#34;);             continue;         }     } } // convert str to number, such as &#39;1b&#39; =&gt; 27_u8 fn parse_str(s : &amp;str) -&gt; u8 {     let mut res : u8 = 0;     for ch in s.bytes() {         res = (res &lt;&lt; 4) &#43; parse_char(ch);     }     res }      // convert char to number fn parse_char(ch : u8) -&gt; u8 {     match ch {         b&#39;0&#39;=&gt; 0,         b&#39;1&#39;=&gt; 1,         b&#39;2&#39;=&gt; 2,         b&#39;3&#39;=&gt; 3,         b&#39;4&#39;=&gt; 4,         b&#39;5&#39;=&gt; 5,         b&#39;6&#39;=&gt; 6,         b&#39;7&#39;=&gt; 7,         b&#39;8&#39;=&gt; 8,         b&#39;9&#39;=&gt; 9,         b&#39;a&#39;=&gt; 10,         b&#39;b&#39;=&gt; 11,         b&#39;c&#39;=&gt; 12,         b&#39;d&#39;=&gt; 13,         b&#39;e&#39;=&gt; 14,         b&#39;f&#39;=&gt; 15,         _ =&gt; 0     } }<br />&#96;&#96;&#96;</md>\n<p></p>\n<p></p>"}, {"anon": "full", "uid_a": "a_0", "subject": "2020春 lec5 课后习题讨论", "created": "2020-03-04T16:10:05Z", "content": "<p>随机抽取部分同学题解。</p>\n<p><strong>Chinese<br /></strong></p>\n<p><strong> <img src=\"/img/1416-8505083dce762b54.png\" alt=\"\" /></strong></p>\n<p><strong>Python</strong></p>\n<pre>import sys\nfrom memory import *\n\n# 判断是否为合法数据\ndef ifvalid(bitstring):\n isvalid = bitstring &gt;&gt; 7\n return_number = bitstring &amp; 0b01111111\n if isvalid == 1:\n return True,return_number\n else:\n return False,return_number\n \n# 读入要求访问的虚拟地址\nvirtual_address = int(sys.argv[1][2:],16) \nprint(&#34;virtual virtual_address is &#34; &#43; hex(virtual_address))\npage_directory_base_registor = 0x220\nbase_index = 0x220 &gt;&gt; 5\npde_index_mask = 0b0111110000000000\npte_index_mask = 0b0000001111100000\noffset_mask = 0b0000000000011111\npde_index = (virtual_address &amp; pde_index_mask) &gt;&gt; 10\npte_index = (virtual_address &amp; pte_index_mask) &gt;&gt; 5\noffset = virtual_address &amp; offset_mask\n# mem[page_index][entry_index] 为已处理好的二维数组\nfirst_level_number = mem[base_index][pde_index] \nflag, pte_base = ifvalid(first_level_number)\n# 说明不合法\nif not flag:\n print(&#34; --&gt; pde index : &#34;&#43; str(hex(pde_index))&#43; &#34; pde contents : (valid = 0 pfn = &#34; &#43; str(hex(pte_base))&#43;&#34;)&#34;)\n print(&#34; --&gt; Fault (page directory entry not valid)&#34;)\nelse:\n print(&#34; --&gt; pde index : &#34;&#43; str(hex(pde_index))&#43; &#34; pde contents : (valid = 1 pfn = &#34; &#43; str(hex(pte_base))&#43;&#34;)&#34;)\n second_level_number = mem[pte_base][pte_index]\n flag_2, ppn_base = ifvalid(second_level_number)\n if not flag_2:\n print(&#34; --&gt; pte index : &#34;&#43; str(hex(pte_index))&#43; &#34; pde contents : (valid = 0 pfn = &#34; &#43; str(hex(ppn_base))&#43;&#34;)&#34;)\n print(&#34; --&gt; Fault (page table entry not valid)&#34;)\n else:\n print(&#34; --&gt; pte index : &#34;&#43; str(hex(pte_index))&#43; &#34; pde contents : (valid = 1 pfn = &#34; &#43; str(hex(ppn_base))&#43;&#34;)&#34;)\n number = mem[ppn_base][offset]\n print(&#34; --&gt; Translates to physical address : &#34; &#43; str(hex((ppn_base&lt;&lt;5)&#43;offset)) &#43; &#34; --&gt; value : &#34; &#43; str(hex(number))&#43;&#34;)&#34;)</pre>\n<p>不是问题的问题&#xff1a;信任了题目数据&#xff0c;注意虚拟地址可能非法&#xff08;有冗余&#xff09;。具体可参考如下函数。</p>\n<pre>def read_storage(page,offset):\n    if page&lt;0 or page&gt;int(&#39;7f&#39;,16):\n        return -1\n    if offset&lt;0 or offset&gt;31:\n        return -1\n    return storage[page][offset]</pre>\n<p><strong>C&#43;&#43;</strong></p>\n<pre>#include &lt;iostream&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nuint16_t BASE_ADD = 0x220;\n\nvoid vir_to_phy(uint16_t base_add, int* phy_mem, uint16_t vir_addr){\n    printf(&#34;Virtual Address %04x :\\n&#34;, vir_addr);\n    uint8_t pde_shift = vir_addr &gt;&gt; 10;\n    uint8_t pte_shift = (vir_addr &gt;&gt; 5) % 32;\n    uint8_t pde_contents = phy_mem[base_add &#43; pde_shift];\n    printf(&#34;  --&gt; pde index: %02x, pte contents: (valid: %01d, pfn %02x) \\n&#34;, \n            pde_shift, pde_contents &gt;&gt; 7 ,pde_contents % 128);\n    if(pde_contents &gt;&gt; 7 == 0){\n        printf(&#34;    --&gt; Fault (page ditectory entry not valid) \\n&#34;);\n        return;\n    }\n    else {\n        uint8_t pte_contents = phy_mem[(pde_contents % 128)*32 &#43; pte_shift];\n        printf(&#34;    --&gt; pte index: %02x, pte contents: (valid: %01d, pfn %02x) \\n&#34;, \n            pte_shift, pte_contents &gt;&gt; 7 ,pte_contents % 128);\n        if(pte_contents &gt;&gt; 7 == 0){\n            printf(&#34;      --&gt; Fault (page table entry not valid) \\n&#34;);\n            return;\n        }\n        else{\n            uint16_t value_addr = (uint16_t)((pte_contents % 128) &lt;&lt; 5) &#43; vir_addr % 32;\n            int value = phy_mem[value_addr];\n            printf(&#34;      --&gt; Translates to physical address %02x --&gt; Value: %02x \\n&#34;, value_addr, value);\n        }\n    }\n}\n\nint main(){\n    int phy_mem[4096];\n    int i = 0;\n    FILE *fp;\n    fp = fopen(&#34;phymem.txt&#34;, &#34;r&#34;);\n    while(fscanf(fp, &#34;%2x&#34;, &amp;(phy_mem[i])) !=EOF) i&#43;&#43;;\n\n    uint16_t vir_addrs[10] = {0x6c74, 0x6b22, 0x03df, 0x69dc, 0x317a, 0x4546, 0x2c03, 0x7fd7, 0x390e, 0x748b};\n    for(auto va: vir_addrs){\n        vir_to_phy(BASE_ADD, phy_mem, va);\n    }\n    return 0;\n}</pre>\n<p><strong>RUST</strong></p>\n<pre>use std::fs;\n\nfn main() {\n    let mut pde_index : u8;\n    let mut pte_index : u8;\n    let mut page_offset : u8;\n\n    let mut pde_content : u8;\n    let mut pde_valid : u8;\n    let mut pde_addr : u8;\n\n    let mut pte_content : u8;\n    let mut pte_valid : u8;\n    let mut pte_addr : u8;\n\n    let mut paddr : u16;\n    let mut value : u8;\n\n    // load memory information\n    let contents = fs::read_to_string(&#34;memory.txt&#34;)\n                .expect(&#34;Something went wrong reading the file&#34;);\n    let mut mem = Vec::new();\n    let split = contents.as_str().split(&#34;\\n&#34;);\n    for s in split {\n        mem.push(s.split(&#34; &#34;).collect::&lt;Vec&lt;&amp;str&gt;&gt;());\n    }\n\n    let vec : Vec&lt;u16&gt; = vec![0x6c74, 0x6b22, 0x03df, 0x69dc, 0x317a, 0x4546, 0x2c03, 0x7fd7, 0x390e, 0x748b];\n\n    for addr in vec.into_iter() {\n        print!(&#34;\\nthe virtual addr is {:#x} \\n    &#34;, addr);\n\n        //parse the virtual addr\n        pde_index  = (addr &gt;&gt; 10) as u8;\n        pte_index  = ((addr &lt;&lt; 6) &gt;&gt; 11) as u8;\n        page_offset  = (addr % 32) as u8;\n\n        //get pde\n        pde_content = parse_str(mem[0x11][2 &#43; pde_index as usize]);\n        pde_valid = pde_content &gt;&gt; 7;\n        pde_addr = pde_content - (pde_valid &lt;&lt; 7);\n\n        //get pte\n        pte_content = parse_str(mem[pde_addr as usize][2&#43; pte_index as usize]);\n        pte_valid = pte_content &gt;&gt; 7;\n        pte_addr = pte_content - (pte_valid &lt;&lt; 7);\n\n        //get physical address and value stored in it\n        paddr = ((pte_addr as u16) &lt;&lt; 5) &#43; page_offset as u16;\n        value = parse_str(mem[(paddr &gt;&gt; 5) as usize][2 &#43; (paddr % 32) as usize]);\n\n        print!(&#34;the pde index is : {:#x}, pde content is {:#x} (valid {}, pfn {:#x})\\n      &#34;, pde_index, pde_content, pde_valid, pde_addr);\n        if pde_valid != 0 {\n            print!(&#34;the pte index is : {:#x}, content is {:#x} (valid {}, pfn {:#x}) \\n         &#34;, pte_index, pte_content, pte_valid, pte_addr);\n        }else{\n            println!(&#34;Fault (page directory entry not valid)&#34;);\n            continue;\n        }\n        if pte_valid != 0 {\n            print!(&#34;the page offset is : {:#x}, the paddr is {:#x}, value is {:#x} \\n       &#34;, page_offset, paddr, value);\n        }else{\n            println!(&#34;Fault (page directory entry not valid)&#34;);\n            continue;\n        }\n    }\n}\n\n// convert str to number, such as &#39;1b&#39; =&gt; 27_u8\nfn parse_str(s : &amp;str) -&gt; u8 {\n    let mut res : u8 = 0;\n    for ch in s.bytes() {\n        res = (res &lt;&lt; 4) &#43; parse_char(ch);\n    }\n    res\n}\n    \n// convert char to number\nfn parse_char(ch : u8) -&gt; u8 {\n    match ch {\n        b&#39;0&#39;=&gt; 0,\n        b&#39;1&#39;=&gt; 1,\n        b&#39;2&#39;=&gt; 2,\n        b&#39;3&#39;=&gt; 3,\n        b&#39;4&#39;=&gt; 4,\n        b&#39;5&#39;=&gt; 5,\n        b&#39;6&#39;=&gt; 6,\n        b&#39;7&#39;=&gt; 7,\n        b&#39;8&#39;=&gt; 8,\n        b&#39;9&#39;=&gt; 9,\n        b&#39;a&#39;=&gt; 10,\n        b&#39;b&#39;=&gt; 11,\n        b&#39;c&#39;=&gt; 12,\n        b&#39;d&#39;=&gt; 13,\n        b&#39;e&#39;=&gt; 14,\n        b&#39;f&#39;=&gt; 15,\n        _ =&gt; 0\n    }\n}</pre>\n<p></p>\n<p></p>"}, {"anon": "full", "uid_a": "a_0", "subject": "2020春 lec5 课后习题讨论", "created": "2020-03-04T16:08:32Z", "content": "<p>随机抽取部分同学题解。</p>\n<p><strong>Chinese<br /></strong></p>\n<p><strong> <img src=\"/img/1416-122e11433c5bbb11.png\" alt=\"\" /></strong></p>\n<p><strong>Python</strong></p>\n<pre>import sys<br />from memory import *<br /><br /># 判断是否为合法数据<br />def ifvalid(bitstring):<br /> isvalid = bitstring &gt;&gt; 7<br /> return_number = bitstring &amp; 0b01111111<br /> if isvalid == 1:<br /> return True,return_number<br /> else:<br /> return False,return_number<br /> <br /># 读入要求访问的虚拟地址<br />virtual_address = int(sys.argv[1][2:],16) <br />print(&#34;virtual virtual_address is &#34; &#43; hex(virtual_address))<br />page_directory_base_registor = 0x220<br />base_index = 0x220 &gt;&gt; 5<br />pde_index_mask = 0b0111110000000000<br />pte_index_mask = 0b0000001111100000<br />offset_mask = 0b0000000000011111<br />pde_index = (virtual_address &amp; pde_index_mask) &gt;&gt; 10<br />pte_index = (virtual_address &amp; pte_index_mask) &gt;&gt; 5<br />offset = virtual_address &amp; offset_mask<br /># mem[page_index][entry_index] 为已处理好的二维数组<br />first_level_number = mem[base_index][pde_index] <br />flag, pte_base = ifvalid(first_level_number)<br /># 说明不合法<br />if not flag:<br /> print(&#34; --&gt; pde index : &#34;&#43; str(hex(pde_index))&#43; &#34; pde contents : (valid = 0 pfn = &#34; &#43; str(hex(pte_base))&#43;&#34;)&#34;)<br /> print(&#34; --&gt; Fault (page directory entry not valid)&#34;)<br />else:<br /> print(&#34; --&gt; pde index : &#34;&#43; str(hex(pde_index))&#43; &#34; pde contents : (valid = 1 pfn = &#34; &#43; str(hex(pte_base))&#43;&#34;)&#34;)<br /> second_level_number = mem[pte_base][pte_index]<br /> flag_2, ppn_base = ifvalid(second_level_number)<br /> if not flag_2:<br /> print(&#34; --&gt; pte index : &#34;&#43; str(hex(pte_index))&#43; &#34; pde contents : (valid = 0 pfn = &#34; &#43; str(hex(ppn_base))&#43;&#34;)&#34;)<br /> print(&#34; --&gt; Fault (page table entry not valid)&#34;)<br /> else:<br /> print(&#34; --&gt; pte index : &#34;&#43; str(hex(pte_index))&#43; &#34; pde contents : (valid = 1 pfn = &#34; &#43; str(hex(ppn_base))&#43;&#34;)&#34;)<br /> number = mem[ppn_base][offset]<br /> print(&#34; --&gt; Translates to physical address : &#34; &#43; str(hex((ppn_base&lt;&lt;5)&#43;offset)) &#43; &#34; --&gt; value : &#34; &#43; str(hex(number))&#43;&#34;)&#34;)</pre>\n<p>不是问题的问题&#xff1a;信任了题目数据&#xff0c;注意虚拟地址可能非法&#xff08;有冗余&#xff09;。具体可参考如下函数。</p>\n<pre>def read_storage(page,offset):<br />    if page&lt;0 or page&gt;int(&#39;7f&#39;,16):<br />        return -1<br />    if offset&lt;0 or offset&gt;31:<br />        return -1<br />    return storage[page][offset]</pre>\n<p><strong>C&#43;&#43;</strong></p>\n<pre>#include &lt;iostream&gt;<br />#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;<br /><br />uint16_t BASE_ADD = 0x220;<br /><br />void vir_to_phy(uint16_t base_add, int* phy_mem, uint16_t vir_addr){<br />    printf(&#34;Virtual Address %04x :\\n&#34;, vir_addr);<br />    uint8_t pde_shift = vir_addr &gt;&gt; 10;<br />    uint8_t pte_shift = (vir_addr &gt;&gt; 5) % 32;<br />    uint8_t pde_contents = phy_mem[base_add &#43; pde_shift];<br />    printf(&#34;  --&gt; pde index: %02x, pte contents: (valid: %01d, pfn %02x) \\n&#34;, <br />            pde_shift, pde_contents &gt;&gt; 7 ,pde_contents % 128);<br />    if(pde_contents &gt;&gt; 7 == 0){<br />        printf(&#34;    --&gt; Fault (page ditectory entry not valid) \\n&#34;);<br />        return;<br />    }<br />    else {<br />        uint8_t pte_contents = phy_mem[(pde_contents % 128)*32 &#43; pte_shift];<br />        printf(&#34;    --&gt; pte index: %02x, pte contents: (valid: %01d, pfn %02x) \\n&#34;, <br />            pte_shift, pte_contents &gt;&gt; 7 ,pte_contents % 128);<br />        if(pte_contents &gt;&gt; 7 == 0){<br />            printf(&#34;      --&gt; Fault (page table entry not valid) \\n&#34;);<br />            return;<br />        }<br />        else{<br />            uint16_t value_addr = (uint16_t)((pte_contents % 128) &lt;&lt; 5) &#43; vir_addr % 32;<br />            int value = phy_mem[value_addr];<br />            printf(&#34;      --&gt; Translates to physical address %02x --&gt; Value: %02x \\n&#34;, value_addr, value);<br />        }<br />    }<br />}<br /><br />int main(){<br />    int phy_mem[4096];<br />    int i = 0;<br />    FILE *fp;<br />    fp = fopen(&#34;phymem.txt&#34;, &#34;r&#34;);<br />    while(fscanf(fp, &#34;%2x&#34;, &amp;(phy_mem[i])) !=EOF) i&#43;&#43;;<br /><br />    uint16_t vir_addrs[10] = {0x6c74, 0x6b22, 0x03df, 0x69dc, 0x317a, 0x4546, 0x2c03, 0x7fd7, 0x390e, 0x748b};<br />    for(auto va: vir_addrs){<br />        vir_to_phy(BASE_ADD, phy_mem, va);<br />    }<br />    return 0;<br />}</pre>\n<p><strong>RUST</strong></p>\n<pre>use std::fs;<br /><br />fn main() {<br />    let mut pde_index : u8;<br />    let mut pte_index : u8;<br />    let mut page_offset : u8;<br /><br />    let mut pde_content : u8;<br />    let mut pde_valid : u8;<br />    let mut pde_addr : u8;<br /><br />    let mut pte_content : u8;<br />    let mut pte_valid : u8;<br />    let mut pte_addr : u8;<br /><br />    let mut paddr : u16;<br />    let mut value : u8;<br /><br />    // load memory information<br />    let contents = fs::read_to_string(&#34;memory.txt&#34;)<br />                .expect(&#34;Something went wrong reading the file&#34;);<br />    let mut mem = Vec::new();<br />    let split = contents.as_str().split(&#34;\\n&#34;);<br />    for s in split {<br />        mem.push(s.split(&#34; &#34;).collect::&lt;Vec&lt;&amp;str&gt;&gt;());<br />    }<br /><br />    let vec : Vec&lt;u16&gt; = vec![0x6c74, 0x6b22, 0x03df, 0x69dc, 0x317a, 0x4546, 0x2c03, 0x7fd7, 0x390e, 0x748b];<br /><br />    for addr in vec.into_iter() {<br />        print!(&#34;\\nthe virtual addr is {:#x} \\n    &#34;, addr);<br /><br />        //parse the virtual addr<br />        pde_index  = (addr &gt;&gt; 10) as u8;<br />        pte_index  = ((addr &lt;&lt; 6) &gt;&gt; 11) as u8;<br />        page_offset  = (addr % 32) as u8;<br /><br />        //get pde<br />        pde_content = parse_str(mem[0x11][2 &#43; pde_index as usize]);<br />        pde_valid = pde_content &gt;&gt; 7;<br />        pde_addr = pde_content - (pde_valid &lt;&lt; 7);<br /><br />        //get pte<br />        pte_content = parse_str(mem[pde_addr as usize][2&#43; pte_index as usize]);<br />        pte_valid = pte_content &gt;&gt; 7;<br />        pte_addr = pte_content - (pte_valid &lt;&lt; 7);<br /><br />        //get physical address and value stored in it<br />        paddr = ((pte_addr as u16) &lt;&lt; 5) &#43; page_offset as u16;<br />        value = parse_str(mem[(paddr &gt;&gt; 5) as usize][2 &#43; (paddr % 32) as usize]);<br /><br />        print!(&#34;the pde index is : {:#x}, pde content is {:#x} (valid {}, pfn {:#x})\\n      &#34;, pde_index, pde_content, pde_valid, pde_addr);<br />        if pde_valid != 0 {<br />            print!(&#34;the pte index is : {:#x}, content is {:#x} (valid {}, pfn {:#x}) \\n         &#34;, pte_index, pte_content, pte_valid, pte_addr);<br />        }else{<br />            println!(&#34;Fault (page directory entry not valid)&#34;);<br />            continue;<br />        }<br />        if pte_valid != 0 {<br />            print!(&#34;the page offset is : {:#x}, the paddr is {:#x}, value is {:#x} \\n       &#34;, page_offset, paddr, value);<br />        }else{<br />            println!(&#34;Fault (page directory entry not valid)&#34;);<br />            continue;<br />        }<br />    }<br />}<br /><br />// convert str to number, such as &#39;1b&#39; =&gt; 27_u8<br />fn parse_str(s : &amp;str) -&gt; u8 {<br />    let mut res : u8 = 0;<br />    for ch in s.bytes() {<br />        res = (res &lt;&lt; 4) &#43; parse_char(ch);<br />    }<br />    res<br />}<br />    <br />// convert char to number<br />fn parse_char(ch : u8) -&gt; u8 {<br />    match ch {<br />        b&#39;0&#39;=&gt; 0,<br />        b&#39;1&#39;=&gt; 1,<br />        b&#39;2&#39;=&gt; 2,<br />        b&#39;3&#39;=&gt; 3,<br />        b&#39;4&#39;=&gt; 4,<br />        b&#39;5&#39;=&gt; 5,<br />        b&#39;6&#39;=&gt; 6,<br />        b&#39;7&#39;=&gt; 7,<br />        b&#39;8&#39;=&gt; 8,<br />        b&#39;9&#39;=&gt; 9,<br />        b&#39;a&#39;=&gt; 10,<br />        b&#39;b&#39;=&gt; 11,<br />        b&#39;c&#39;=&gt; 12,<br />        b&#39;d&#39;=&gt; 13,<br />        b&#39;e&#39;=&gt; 14,<br />        b&#39;f&#39;=&gt; 15,<br />        _ =&gt; 0<br />    }<br />}</pre>\n<p></p>\n<p></p>"}, {"anon": "full", "uid_a": "a_0", "subject": "2020春 lec5 课后习题讨论", "created": "2020-03-04T16:06:49Z", "content": "<p>随机抽取部分同学题解。</p>\n<p><strong>汉语</strong></p>\n<p><strong> </strong></p>\n<p><strong>Python</strong></p>\n<md><br />&#96;&#96;&#96;python<br />import sys<br />from memory import *<br /><br /># 判断是否为合法数据<br />def ifvalid(bitstring):<br /> isvalid = bitstring &gt;&gt; 7<br /> return_number = bitstring &amp; 0b01111111<br /> if isvalid == 1:<br /> return True,return_number<br /> else:<br /> return False,return_number<br /> <br /># 读入要求访问的虚拟地址<br />virtual_address = int(sys.argv[1][2:],16) <br />print(&#34;virtual virtual_address is &#34; &#43; hex(virtual_address))<br />page_directory_base_registor = 0x220<br />base_index = 0x220 &gt;&gt; 5<br />pde_index_mask = 0b0111110000000000<br />pte_index_mask = 0b0000001111100000<br />offset_mask = 0b0000000000011111<br />pde_index = (virtual_address &amp; pde_index_mask) &gt;&gt; 10<br />pte_index = (virtual_address &amp; pte_index_mask) &gt;&gt; 5<br />offset = virtual_address &amp; offset_mask<br /># mem[page_index][entry_index] 为已处理好的二维数组<br />first_level_number = mem[base_index][pde_index] <br />flag, pte_base = ifvalid(first_level_number)<br /># 说明不合法<br />if not flag:<br /> print(&#34; --&gt; pde index : &#34;&#43; str(hex(pde_index))&#43; &#34; pde contents : (valid = 0 pfn = &#34; &#43; str(hex(pte_base))&#43;&#34;)&#34;)<br /> print(&#34; --&gt; Fault (page directory entry not valid)&#34;)<br />else:<br /> print(&#34; --&gt; pde index : &#34;&#43; str(hex(pde_index))&#43; &#34; pde contents : (valid = 1 pfn = &#34; &#43; str(hex(pte_base))&#43;&#34;)&#34;)<br /> second_level_number = mem[pte_base][pte_index]<br /> flag_2, ppn_base = ifvalid(second_level_number)<br /> if not flag_2:<br /> print(&#34; --&gt; pte index : &#34;&#43; str(hex(pte_index))&#43; &#34; pde contents : (valid = 0 pfn = &#34; &#43; str(hex(ppn_base))&#43;&#34;)&#34;)<br /> print(&#34; --&gt; Fault (page table entry not valid)&#34;)<br /> else:<br /> print(&#34; --&gt; pte index : &#34;&#43; str(hex(pte_index))&#43; &#34; pde contents : (valid = 1 pfn = &#34; &#43; str(hex(ppn_base))&#43;&#34;)&#34;)<br /> number = mem[ppn_base][offset]<br /> print(&#34; --&gt; Translates to physical address : &#34; &#43; str(hex((ppn_base&lt;&lt;5)&#43;offset)) &#43; &#34; --&gt; value : &#34; &#43; str(hex(number))&#43;&#34;)&#34;)<br />&#96;&#96;&#96;<br /></md>\n<p>不是问题的问题&#xff1a;信任了题目数据&#xff0c;注意虚拟地址可能非法&#xff08;有冗余&#xff09;。具体可参考如下函数。</p>\n<pre><strong></strong></pre>\n<p><strong>C&#43;&#43;</strong></p>\n<pre>def read_storage(page,offset):<br />    if page&lt;0 or page&gt;int(&#39;7f&#39;,16):<br />        return -1<br />    if offset&lt;0 or offset&gt;31:<br />        return -1<br />    return storage[page][offset]</pre>\n<p></p>\n<p></p>"}, {"anon": "full", "uid_a": "a_0", "subject": "2020春 lec5 课后习题讨论", "created": "2020-03-04T16:02:43Z", "content": "<p><md><br />随机抽取部分同学课后习题题解。<br /><br />## Chinese<br /><img alt=\"\" /><br /><br />## Python<br /><br />&#96;&#96;&#96;python<br />import sys<br />from memory import *<br /><br /># 判断是否为合法数据<br />def ifvalid(bitstring):<br />    isvalid = bitstring &gt;&gt; 7<br />    return_number = bitstring &amp; 0b01111111<br />    if isvalid == 1:<br />        return True,return_number<br />    else:<br />        return False,return_number<br />    <br /># 读入要求访问的虚拟地址<br />virtual_address = int(sys.argv[1][2:],16) <br />print(&#34;virtual virtual_address is &#34; &#43; hex(virtual_address))<br />page_directory_base_registor = 0x220<br />base_index = 0x220 &gt;&gt; 5<br />pde_index_mask = 0b0111110000000000<br />pte_index_mask = 0b0000001111100000<br />offset_mask = 0b0000000000011111<br />pde_index = (virtual_address &amp; pde_index_mask) &gt;&gt; 10<br />pte_index = (virtual_address &amp; pte_index_mask) &gt;&gt; 5<br />offset = virtual_address &amp; offset_mask<br /># mem[page_index][entry_index] 为已处理好的二维数组<br />first_level_number = mem[base_index][pde_index] <br />flag, pte_base = ifvalid(first_level_number)<br /># 说明不合法<br />if not flag:<br />    print(&#34;   --&gt; pde index : &#34;&#43; str(hex(pde_index))&#43;  &#34; pde contents : (valid = 0 pfn = &#34; &#43; str(hex(pte_base))&#43;&#34;)&#34;)<br />    print(&#34;         --&gt; Fault (page directory entry not valid)&#34;)<br />else:<br />    print(&#34;   --&gt; pde index : &#34;&#43; str(hex(pde_index))&#43;  &#34; pde contents : (valid = 1 pfn = &#34; &#43; str(hex(pte_base))&#43;&#34;)&#34;)<br />    second_level_number = mem[pte_base][pte_index]<br />    flag_2, ppn_base = ifvalid(second_level_number)<br />    if not flag_2:<br />        print(&#34;     --&gt; pte index : &#34;&#43; str(hex(pte_index))&#43;  &#34; pde contents : (valid = 0 pfn = &#34; &#43; str(hex(ppn_base))&#43;&#34;)&#34;)<br />        print(&#34;       --&gt; Fault (page table entry not valid)&#34;)<br />    else:<br />        print(&#34;     --&gt; pte index : &#34;&#43; str(hex(pte_index))&#43;  &#34; pde contents : (valid = 1 pfn = &#34; &#43; str(hex(ppn_base))&#43;&#34;)&#34;)<br />        number = mem[ppn_base][offset]<br />        print(&#34;       --&gt; Translates to physical address : &#34; &#43; str(hex((ppn_base&lt;&lt;5)&#43;offset)) &#43; &#34; --&gt; value : &#34; &#43; str(hex(number))&#43;&#34;)&#34;)<br />&#96;&#96;&#96;<br /><br />不是问题的问题&#xff1a;信任了题目数据&#xff0c;注意虚拟地址可能非法&#xff08;有冗余&#xff09;。具体可参考如下函数。<br /><br />&#96;&#96;&#96;python<br />def read_storage(page,offset):<br />    if page&lt;0 or page&gt;int(&#39;7f&#39;,16):<br />        return -1<br />    if offset&lt;0 or offset&gt;31:<br />        return -1<br />    return storage[page][offset]<br />&#96;&#96;&#96;<br /><br />## C&#43;&#43;<br /><br />&#96;&#96;&#96;C&#43;&#43;<br />#include &lt;iostream&gt;<br />#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;<br /><br />uint16_t BASE_ADD = 0x220;<br /><br />void vir_to_phy(uint16_t base_add, int* phy_mem, uint16_t vir_addr){<br />    printf(&#34;Virtual Address %04x :\\n&#34;, vir_addr);<br />    uint8_t pde_shift = vir_addr &gt;&gt; 10;<br />    uint8_t pte_shift = (vir_addr &gt;&gt; 5) % 32;<br />    uint8_t pde_contents = phy_mem[base_add &#43; pde_shift];<br />    printf(&#34;  --&gt; pde index: %02x, pte contents: (valid: %01d, pfn %02x) \\n&#34;, <br />            pde_shift, pde_contents &gt;&gt; 7 ,pde_contents % 128);<br />    if(pde_contents &gt;&gt; 7 == 0){<br />        printf(&#34;    --&gt; Fault (page ditectory entry not valid) \\n&#34;);<br />        return;<br />    }<br />    else {<br />        uint8_t pte_contents = phy_mem[(pde_contents % 128)*32 &#43; pte_shift];<br />        printf(&#34;    --&gt; pte index: %02x, pte contents: (valid: %01d, pfn %02x) \\n&#34;, <br />            pte_shift, pte_contents &gt;&gt; 7 ,pte_contents % 128);<br />        if(pte_contents &gt;&gt; 7 == 0){<br />            printf(&#34;      --&gt; Fault (page table entry not valid) \\n&#34;);<br />            return;<br />        }<br />        else{<br />            uint16_t value_addr = (uint16_t)((pte_contents % 128) &lt;&lt; 5) &#43; vir_addr % 32;<br />            int value = phy_mem[value_addr];<br />            printf(&#34;      --&gt; Translates to physical address %02x --&gt; Value: %02x \\n&#34;, value_addr, value);<br />        }<br />    }<br />}<br /><br />int main(){<br />    int phy_mem[4096];<br />    int i = 0;<br />    FILE *fp;<br />    fp = fopen(&#34;phymem.txt&#34;, &#34;r&#34;);<br />    while(fscanf(fp, &#34;%2x&#34;, &amp;(phy_mem[i])) !=EOF) i&#43;&#43;;<br /><br />    uint16_t vir_addrs[10] = {0x6c74, 0x6b22, 0x03df, 0x69dc, 0x317a, 0x4546, 0x2c03, 0x7fd7, 0x390e, 0x748b};<br />    for(auto va: vir_addrs){<br />        vir_to_phy(BASE_ADD, phy_mem, va);<br />    }<br />    return 0;<br />}<br />&#96;&#96;&#96;<br /><br />## RUST<br /><br />&#96;&#96;&#96;rust<br />use std::fs;<br /><br />fn main() {<br />    let mut pde_index : u8;<br />    let mut pte_index : u8;<br />    let mut page_offset : u8;<br /><br />    let mut pde_content : u8;<br />    let mut pde_valid : u8;<br />    let mut pde_addr : u8;<br /><br />    let mut pte_content : u8;<br />    let mut pte_valid : u8;<br />    let mut pte_addr : u8;<br /><br />    let mut paddr : u16;<br />    let mut value : u8;<br /><br />    // load memory information<br />    let contents = fs::read_to_string(&#34;memory.txt&#34;)<br />                .expect(&#34;Something went wrong reading the file&#34;);<br />    let mut mem = Vec::new();<br />    let split = contents.as_str().split(&#34;\\n&#34;);<br />    for s in split {<br />        mem.push(s.split(&#34; &#34;).collect::&lt;Vec&lt;&amp;str&gt;&gt;());<br />    }<br /><br />    let vec : Vec&lt;u16&gt; = vec![0x6c74, 0x6b22, 0x03df, 0x69dc, 0x317a, 0x4546, 0x2c03, 0x7fd7, 0x390e, 0x748b];<br /><br />    for addr in vec.into_iter() {<br />        print!(&#34;\\nthe virtual addr is {:#x} \\n    &#34;, addr);<br /><br />        //parse the virtual addr<br />        pde_index  = (addr &gt;&gt; 10) as u8;<br />        pte_index  = ((addr &lt;&lt; 6) &gt;&gt; 11) as u8;<br />        page_offset  = (addr % 32) as u8;<br /><br />        //get pde<br />        pde_content = parse_str(mem[0x11][2 &#43; pde_index as usize]);<br />        pde_valid = pde_content &gt;&gt; 7;<br />        pde_addr = pde_content - (pde_valid &lt;&lt; 7);<br /><br />        //get pte<br />        pte_content = parse_str(mem[pde_addr as usize][2&#43; pte_index as usize]);<br />        pte_valid = pte_content &gt;&gt; 7;<br />        pte_addr = pte_content - (pte_valid &lt;&lt; 7);<br /><br />        //get physical address and value stored in it<br />        paddr = ((pte_addr as u16) &lt;&lt; 5) &#43; page_offset as u16;<br />        value = parse_str(mem[(paddr &gt;&gt; 5) as usize][2 &#43; (paddr % 32) as usize]);<br /><br />        print!(&#34;the pde index is : {:#x}, pde content is {:#x} (valid {}, pfn {:#x})\\n      &#34;, pde_index, pde_content, pde_valid, pde_addr);<br />        if pde_valid != 0 {<br />            print!(&#34;the pte index is : {:#x}, content is {:#x} (valid {}, pfn {:#x}) \\n         &#34;, pte_index, pte_content, pte_valid, pte_addr);<br />        }else{<br />            println!(&#34;Fault (page directory entry not valid)&#34;);<br />            continue;<br />        }<br />        if pte_valid != 0 {<br />            print!(&#34;the page offset is : {:#x}, the paddr is {:#x}, value is {:#x} \\n       &#34;, page_offset, paddr, value);<br />        }else{<br />            println!(&#34;Fault (page directory entry not valid)&#34;);<br />            continue;<br />        }<br />    }<br />}<br /><br />// convert str to number, such as &#39;1b&#39; =&gt; 27_u8<br />fn parse_str(s : &amp;str) -&gt; u8 {<br />    let mut res : u8 = 0;<br />    for ch in s.bytes() {<br />        res = (res &lt;&lt; 4) &#43; parse_char(ch);<br />    }<br />    res<br />}<br />    <br />// convert char to number<br />fn parse_char(ch : u8) -&gt; u8 {<br />    match ch {<br />        b&#39;0&#39;=&gt; 0,<br />        b&#39;1&#39;=&gt; 1,<br />        b&#39;2&#39;=&gt; 2,<br />        b&#39;3&#39;=&gt; 3,<br />        b&#39;4&#39;=&gt; 4,<br />        b&#39;5&#39;=&gt; 5,<br />        b&#39;6&#39;=&gt; 6,<br />        b&#39;7&#39;=&gt; 7,<br />        b&#39;8&#39;=&gt; 8,<br />        b&#39;9&#39;=&gt; 9,<br />        b&#39;a&#39;=&gt; 10,<br />        b&#39;b&#39;=&gt; 11,<br />        b&#39;c&#39;=&gt; 12,<br />        b&#39;d&#39;=&gt; 13,<br />        b&#39;e&#39;=&gt; 14,<br />        b&#39;f&#39;=&gt; 15,<br />        _ =&gt; 0<br />    }<br />}<br />&#96;&#96;&#96;<br /></md></p>\n<p></p>\n<p></p>"}, {"anon": "full", "uid_a": "a_0", "subject": "2020春 lec5 课后习题讨论", "created": "2020-03-04T16:02:01Z", "content": "<p><md><br />随机抽取部分同学课后习题题解。<br /><br />## Chinese<br /><img alt=\"\" /><br /><br />## Python<br /><br />&#96;&#96;&#96;python<br />import sys<br />from memory import *<br /><br /># 判断是否为合法数据<br />def ifvalid(bitstring):<br />    isvalid = bitstring &gt;&gt; 7<br />    return_number = bitstring &amp; 0b01111111<br />    if isvalid == 1:<br />        return True,return_number<br />    else:<br />        return False,return_number<br />    <br /># 读入要求访问的虚拟地址<br />virtual_address = int(sys.argv[1][2:],16) <br />print(&#34;virtual virtual_address is &#34; &#43; hex(virtual_address))<br />page_directory_base_registor = 0x220<br />base_index = 0x220 &gt;&gt; 5<br />pde_index_mask = 0b0111110000000000<br />pte_index_mask = 0b0000001111100000<br />offset_mask = 0b0000000000011111<br />pde_index = (virtual_address &amp; pde_index_mask) &gt;&gt; 10<br />pte_index = (virtual_address &amp; pte_index_mask) &gt;&gt; 5<br />offset = virtual_address &amp; offset_mask<br /># mem[page_index][entry_index] 为已处理好的二维数组<br />first_level_number = mem[base_index][pde_index] <br />flag, pte_base = ifvalid(first_level_number)<br /># 说明不合法<br />if not flag:<br />    print(&#34;   --&gt; pde index : &#34;&#43; str(hex(pde_index))&#43;  &#34; pde contents : (valid = 0 pfn = &#34; &#43; str(hex(pte_base))&#43;&#34;)&#34;)<br />    print(&#34;         --&gt; Fault (page directory entry not valid)&#34;)<br />else:<br />    print(&#34;   --&gt; pde index : &#34;&#43; str(hex(pde_index))&#43;  &#34; pde contents : (valid = 1 pfn = &#34; &#43; str(hex(pte_base))&#43;&#34;)&#34;)<br />    second_level_number = mem[pte_base][pte_index]<br />    flag_2, ppn_base = ifvalid(second_level_number)<br />    if not flag_2:<br />        print(&#34;     --&gt; pte index : &#34;&#43; str(hex(pte_index))&#43;  &#34; pde contents : (valid = 0 pfn = &#34; &#43; str(hex(ppn_base))&#43;&#34;)&#34;)<br />        print(&#34;       --&gt; Fault (page table entry not valid)&#34;)<br />    else:<br />        print(&#34;     --&gt; pte index : &#34;&#43; str(hex(pte_index))&#43;  &#34; pde contents : (valid = 1 pfn = &#34; &#43; str(hex(ppn_base))&#43;&#34;)&#34;)<br />        number = mem[ppn_base][offset]<br />        print(&#34;       --&gt; Translates to physical address : &#34; &#43; str(hex((ppn_base&lt;&lt;5)&#43;offset)) &#43; &#34; --&gt; value : &#34; &#43; str(hex(number))&#43;&#34;)&#34;)<br />&#96;&#96;&#96;<br /><br />不是问题的问题&#xff1a;信任了题目数据&#xff0c;注意虚拟地址可能非法&#xff08;有冗余&#xff09;。具体可参考如下函数。<br /><br />&#96;&#96;&#96;python<br />def read_storage(page,offset):<br />    if page&lt;0 or page&gt;int(&#39;7f&#39;,16):<br />        return -1<br />    if offset&lt;0 or offset&gt;31:<br />        return -1<br />    return storage[page][offset]<br />&#96;&#96;&#96;<br /><br />## C&#43;&#43;<br /><br />&#96;&#96;&#96;C&#43;&#43;<br />#include &lt;iostream&gt;<br />#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;<br /><br />uint16_t BASE_ADD = 0x220;<br /><br />void vir_to_phy(uint16_t base_add, int* phy_mem, uint16_t vir_addr){<br />    printf(&#34;Virtual Address %04x :\\n&#34;, vir_addr);<br />    uint8_t pde_shift = vir_addr &gt;&gt; 10;<br />    uint8_t pte_shift = (vir_addr &gt;&gt; 5) % 32;<br />    uint8_t pde_contents = phy_mem[base_add &#43; pde_shift];<br />    printf(&#34;  --&gt; pde index: %02x, pte contents: (valid: %01d, pfn %02x) \\n&#34;, <br />            pde_shift, pde_contents &gt;&gt; 7 ,pde_contents % 128);<br />    if(pde_contents &gt;&gt; 7 == 0){<br />        printf(&#34;    --&gt; Fault (page ditectory entry not valid) \\n&#34;);<br />        return;<br />    }<br />    else {<br />        uint8_t pte_contents = phy_mem[(pde_contents % 128)*32 &#43; pte_shift];<br />        printf(&#34;    --&gt; pte index: %02x, pte contents: (valid: %01d, pfn %02x) \\n&#34;, <br />            pte_shift, pte_contents &gt;&gt; 7 ,pte_contents % 128);<br />        if(pte_contents &gt;&gt; 7 == 0){<br />            printf(&#34;      --&gt; Fault (page table entry not valid) \\n&#34;);<br />            return;<br />        }<br />        else{<br />            uint16_t value_addr = (uint16_t)((pte_contents % 128) &lt;&lt; 5) &#43; vir_addr % 32;<br />            int value = phy_mem[value_addr];<br />            printf(&#34;      --&gt; Translates to physical address %02x --&gt; Value: %02x \\n&#34;, value_addr, value);<br />        }<br />    }<br />}<br /><br />int main(){<br />    int phy_mem[4096];<br />    int i = 0;<br />    FILE *fp;<br />    fp = fopen(&#34;phymem.txt&#34;, &#34;r&#34;);<br />    while(fscanf(fp, &#34;%2x&#34;, &amp;(phy_mem[i])) !=EOF) i&#43;&#43;;<br /><br />    uint16_t vir_addrs[10] = {0x6c74, 0x6b22, 0x03df, 0x69dc, 0x317a, 0x4546, 0x2c03, 0x7fd7, 0x390e, 0x748b};<br />    for(auto va: vir_addrs){<br />        vir_to_phy(BASE_ADD, phy_mem, va);<br />    }<br />    return 0;<br />}<br />&#96;&#96;&#96;<br /><br />## RUST<br /><br />&#96;&#96;&#96;rust<br />use std::fs;<br /><br />fn main() {<br />    let mut pde_index : u8;<br />    let mut pte_index : u8;<br />    let mut page_offset : u8;<br /><br />    let mut pde_content : u8;<br />    let mut pde_valid : u8;<br />    let mut pde_addr : u8;<br /><br />    let mut pte_content : u8;<br />    let mut pte_valid : u8;<br />    let mut pte_addr : u8;<br /><br />    let mut paddr : u16;<br />    let mut value : u8;<br /><br />    // load memory information<br />    let contents = fs::read_to_string(&#34;memory.txt&#34;)<br />                .expect(&#34;Something went wrong reading the file&#34;);<br />    let mut mem = Vec::new();<br />    let split = contents.as_str().split(&#34;\\n&#34;);<br />    for s in split {<br />        mem.push(s.split(&#34; &#34;).collect::&lt;Vec&lt;&amp;str&gt;&gt;());<br />    }<br /><br />    let vec : Vec&lt;u16&gt; = vec![0x6c74, 0x6b22, 0x03df, 0x69dc, 0x317a, 0x4546, 0x2c03, 0x7fd7, 0x390e, 0x748b];<br /><br />    for addr in vec.into_iter() {<br />        print!(&#34;\\nthe virtual addr is {:#x} \\n    &#34;, addr);<br /><br />        //parse the virtual addr<br />        pde_index  = (addr &gt;&gt; 10) as u8;<br />        pte_index  = ((addr &lt;&lt; 6) &gt;&gt; 11) as u8;<br />        page_offset  = (addr % 32) as u8;<br /><br />        //get pde<br />        pde_content = parse_str(mem[0x11][2 &#43; pde_index as usize]);<br />        pde_valid = pde_content &gt;&gt; 7;<br />        pde_addr = pde_content - (pde_valid &lt;&lt; 7);<br /><br />        //get pte<br />        pte_content = parse_str(mem[pde_addr as usize][2&#43; pte_index as usize]);<br />        pte_valid = pte_content &gt;&gt; 7;<br />        pte_addr = pte_content - (pte_valid &lt;&lt; 7);<br /><br />        //get physical address and value stored in it<br />        paddr = ((pte_addr as u16) &lt;&lt; 5) &#43; page_offset as u16;<br />        value = parse_str(mem[(paddr &gt;&gt; 5) as usize][2 &#43; (paddr % 32) as usize]);<br /><br />        print!(&#34;the pde index is : {:#x}, pde content is {:#x} (valid {}, pfn {:#x})\\n      &#34;, pde_index, pde_content, pde_valid, pde_addr);<br />        if pde_valid != 0 {<br />            print!(&#34;the pte index is : {:#x}, content is {:#x} (valid {}, pfn {:#x}) \\n         &#34;, pte_index, pte_content, pte_valid, pte_addr);<br />        }else{<br />            println!(&#34;Fault (page directory entry not valid)&#34;);<br />            continue;<br />        }<br />        if pte_valid != 0 {<br />            print!(&#34;the page offset is : {:#x}, the paddr is {:#x}, value is {:#x} \\n       &#34;, page_offset, paddr, value);<br />        }else{<br />            println!(&#34;Fault (page directory entry not valid)&#34;);<br />            continue;<br />        }<br />    }<br />}<br /><br />// convert str to number, such as &#39;1b&#39; =&gt; 27_u8<br />fn parse_str(s : &amp;str) -&gt; u8 {<br />    let mut res : u8 = 0;<br />    for ch in s.bytes() {<br />        res = (res &lt;&lt; 4) &#43; parse_char(ch);<br />    }<br />    res<br />}<br />    <br />// convert char to number<br />fn parse_char(ch : u8) -&gt; u8 {<br />    match ch {<br />        b&#39;0&#39;=&gt; 0,<br />        b&#39;1&#39;=&gt; 1,<br />        b&#39;2&#39;=&gt; 2,<br />        b&#39;3&#39;=&gt; 3,<br />        b&#39;4&#39;=&gt; 4,<br />        b&#39;5&#39;=&gt; 5,<br />        b&#39;6&#39;=&gt; 6,<br />        b&#39;7&#39;=&gt; 7,<br />        b&#39;8&#39;=&gt; 8,<br />        b&#39;9&#39;=&gt; 9,<br />        b&#39;a&#39;=&gt; 10,<br />        b&#39;b&#39;=&gt; 11,<br />        b&#39;c&#39;=&gt; 12,<br />        b&#39;d&#39;=&gt; 13,<br />        b&#39;e&#39;=&gt; 14,<br />        b&#39;f&#39;=&gt; 15,<br />        _ =&gt; 0<br />    }<br />}<br />&#96;&#96;&#96;<br /></md>\n</p><p></p><p></p>"}], "type": "note", "tags": ["lecture5", "student"], "tag_good": [], "unique_views": 172, "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>谢兴宇同学提出的问题: 硬盘上存在第0x7f个页, 为什么0x7f在页表项中表示这个页不在内存也不在硬盘?</p>\n<p>一个可能的解释:</p>\n<p>感觉是&#xff0c;因为内存128个页&#xff0c;磁盘128个页&#xff0c;一共256个页&#xff0c;而8位页表项只有256种数字&#xff0c;但是还想表达“这个虚拟内存页不对应任何物理地址”这么一种情况&#xff0c;所以只能占用原先一个页的编码&#xff1f;</p>\n<p>然后对于这个4k内存&#xff0c;4k硬盘的系统&#xff0c;增加页表项大小的开销又太大&#xff0c;浪费一个硬盘页倒可以接受&#xff1f;</p>", "created": "2020-03-06T17:48:41Z", "bucket_order": 3, "bucket_name": "Today", "type": "followup", "tag_good": [], "uid": "k6og4u6njzf5y9", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "k7gh385ahf74qw", "updated": "2020-03-06T17:48:41Z", "config": {}}], "tag_good_arr": [], "id": "k7diecx3b5tv2", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 2, "num_favorites": 0, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169981603, "default_anonymity": "no"}, "error": null, "aid": "kyv0zc83bgd5ar"}