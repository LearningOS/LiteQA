{"result": {"history_size": 3, "folders": ["lab1"], "nr": 1378, "data": {"embed_links": []}, "created": "2020-02-15T11:16:56Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "k0keglbgnqt59c", "data": "k6niaec2cev568", "type": "create", "when": "2020-02-15T11:16:56Z"}, {"anon": "no", "uid": "k0keglbgnqt59c", "data": "k6nqppqpou5h4", "type": "update", "when": "2020-02-15T15:12:47Z"}, {"anon": "no", "uid": "jsjp32n2zAHb", "data": "k6ovstjn5yno2", "to": "k6niaebzksl567", "type": "s_answer", "when": "2020-02-16T10:22:56Z"}, {"anon": "no", "uid": "jsjp32n2zAHb", "data": "k6ovwoqi6691td", "type": "s_answer_update", "when": "2020-02-16T10:25:57Z"}, {"anon": "no", "uid": "k0keglbgnqt59c", "data": "k6ox7agayqt5c2", "type": "update", "when": "2020-02-16T11:02:11Z"}, {"anon": "no", "uid": "k0keglbgnqt59c", "to": "k6niaebzksl567", "type": "followup", "when": "2020-02-16T11:08:18Z"}, {"anon": "no", "uid": "jsjp32n2zAHb", "to": "k6niaebzksl567", "type": "feedback", "when": "2020-02-16T12:12:59Z"}, {"anon": "no", "uid": "k0keglbgnqt59c", "to": "k6niaebzksl567", "type": "feedback", "when": "2020-02-16T12:16:28Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "k0keglbgnqt59c", "subject": "对lab1中的bootmain.c中若干细节的疑惑", "created": "2020-02-16T11:02:11Z", "content": "<md># 1  在readseg函数中va向下取整的疑惑  \n\n&#96;&#96;&#96;\n/* *\n * readseg - read &#64;count bytes at &#64;offset from kernel into virtual address &#64;va,\n * might copy more than asked.\n * */\nstatic void\nreadseg(uintptr_t va, uint32_t count, uint32_t offset) {\n    uintptr_t end_va = va &#43; count;\n    // round down to sector boundary\n    va -= offset % SECTSIZE;\n    // translate from bytes to sectors; kernel starts at sector 1\n    uint32_t secno = (offset / SECTSIZE) &#43; 1;\n    // If this is too slow, we could read lots of sectors at a time.\n    // We&#39;d write more to memory than asked, but it doesn&#39;t matter --\n    // we load in increasing order.\n    for (; va &lt; end_va; va &#43;= SECTSIZE, secno &#43;&#43;) {\n        readsect((void *)va, secno);\n }\n}\n&#96;&#96;&#96;\n\n这里为什么va要向下取整&#xff1f;这样做难道不会不小心把新写的数据写到前面已经写好了的数据上而导致错误么&#xff1f;  \n\n# 2  readseg函数中读取扇区的方式  \n\n在代码注释中写说一次仅读取一个扇区速度较慢&#xff0c;可以一次读取多个扇区。那么这里提到的一次读取多个扇区的技术是如何实现的&#xff1f;DMA&#xff1f;还是简单在去除多次调用函数改为调用一次函数多次读取扇区&#xff1f;  \n\n# 3 bootmain函数最后bad的含义  \n\n&#96;&#96;&#96;\nbad:\n    outw(0x8A00, 0x8A00);\n    outw(0x8A00, 0x8E00);\n&#96;&#96;&#96;\n\nbad的代码&#xff0c;是在加载bootloader后面扇区的kernel不满足elf文件的格式或者从kern_init函数返回后才会运行&#xff0c;但是对于这两行代码的具体含义我不太明白&#xff0c;向0x8A00端口传送0x8A00和0x8E00是什么意思&#xff0c;端口0x8A00又是什么&#xff1f;我查阅了互联网上的资料&#xff0c;只看到有说是端口0x8A00连接到模拟器&#xff0c;并会向模拟器转交控制&#xff0c;然后就没有了。我想了解得更具体一些&#xff0c;恳请老师同学们给我一点查阅的方向或者可以告诉我更详细的信息那就更好啦。谢谢&#xff01;  \n</md>"}, {"anon": "no", "uid": "k0keglbgnqt59c", "subject": "对lab1中的bootmain.c中若干细节的疑惑", "created": "2020-02-15T15:12:47Z", "content": "<p># 1  在readseg函数中va向下取整的疑惑  </p>\n<p></p>\n<p>&#96;&#96;&#96;</p>\n<p>/* *<br /> * readseg - read &#64;count bytes at &#64;offset from kernel into virtual address &#64;va,<br /> * might copy more than asked.<br /> * */<br />static void<br />readseg(uintptr_t va, uint32_t count, uint32_t offset) {<br />    uintptr_t end_va = va &#43; count;</p>\n<p>    // round down to sector boundary<br />    va -= offset % SECTSIZE;</p>\n<p>    // translate from bytes to sectors; kernel starts at sector 1<br />    uint32_t secno = (offset / SECTSIZE) &#43; 1;</p>\n<p>    // If this is too slow, we could read lots of sectors at a time.<br />    // We&#39;d write more to memory than asked, but it doesn&#39;t matter --<br />    // we load in increasing order.<br />    for (; va &lt; end_va; va &#43;= SECTSIZE, secno &#43;&#43;) {<br />        readsect((void *)va, secno);<br /> }<br />}</p>\n<p>&#96;&#96;&#96;</p>\n<p></p>\n<p>这里为什么va要向下取整&#xff1f;这样做难道不会不小心把新写的数据写到前面已经写好了的数据上而导致错误么&#xff1f;  </p>\n<p></p>\n<p># 2  readseg函数中读取扇区的方式  </p>\n<p></p>\n<p>在代码注释中写说一次仅读取一个扇区速度较慢&#xff0c;可以一次读取多个扇区。那么这里提到的一次读取多个扇区的技术是如何实现的&#xff1f;DMA&#xff1f;还是简单在去除多次调用函数改为调用一次函数多次读取扇区&#xff1f;  </p>\n<p></p>\n<p># 3 bootmain函数最后bad的含义  </p>\n<p></p>\n<p>&#96;&#96;&#96;</p>\n<p>bad:<br />    outw(0x8A00, 0x8A00);<br />    outw(0x8A00, 0x8E00);</p>\n<p>&#96;&#96;&#96;</p>\n<p></p>\n<p>bad的代码&#xff0c;是在加载bootloader后面扇区的kernel不满足elf文件的格式或者从kern_init函数返回后才会运行&#xff0c;但是对于这两行代码的具体含义我不太明白&#xff0c;向0x8A00端口传送0x8A00和0x8E00是什么意思&#xff0c;端口0x8A00又是什么&#xff1f;我查阅了互联网上的资料&#xff0c;只看到有说是端口0x8A00连接到模拟器&#xff0c;并会向模拟器转交控制&#xff0c;然后就没有了。我想了解得更具体一些&#xff0c;恳请老师同学们给我一点查阅的方向或者可以告诉我更详细的信息那就更好啦。谢谢&#xff01;  </p>\n<p></p>"}, {"anon": "no", "uid": "k0keglbgnqt59c", "subject": "对lab1中的bootmain.c中的第109-111行bad的作用的含义的疑惑", "created": "2020-02-15T11:16:56Z", "content": "<p>bootmain.c中最后有bad的代码&#xff0c;是在加载bootloader后面扇区的kernel不满足elf文件的格式或者从kern_init函数返回后才会运行&#xff0c;但是对于这两行代码的具体含义我不太明白&#xff0c;向0x8A00端口传送0x8A00和0x8E00是什么意思&#xff0c;端口0x8A00又是什么&#xff1f;我查阅了互联网上的资料&#xff0c;只看到有说是端口0x8A00连接到模拟器&#xff0c;并会向模拟器转交控制&#xff0c;然后就没有了。我想了解得更具体一些&#xff0c;恳请老师同学们给我一点查阅的方向或者可以告诉我更详细的信息那就更好啦。谢谢&#xff01;</p>"}], "type": "question", "tags": ["lab1", "student"], "tag_good": [{"role": "student", "name": "Yves Wong", "endorser": {}, "admin": false, "photo": null, "id": "kjurfb1fxq2rq", "photo_url": null, "published": true, "us": false, "facebook_id": null}], "unique_views": 250, "children": [{"history_size": 2, "folders": [], "data": {"embed_links": []}, "created": "2020-02-16T10:22:56Z", "bucket_order": 3, "tag_endorse": [{"role": "student", "name": "Esoom", "endorser": {}, "admin": false, "photo": null, "id": "k0keglbgnqt59c", "photo_url": null, "us": false, "facebook_id": null}, {"role": "student", "name": "Yves Wong", "endorser": {}, "admin": false, "photo": null, "id": "kjurfb1fxq2rq", "photo_url": null, "published": true, "us": false, "facebook_id": null}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "jsjp32n2zAHb", "subject": "", "created": "2020-02-16T10:25:57Z", "content": "<md>## 1\n\n首先来看看 *readseg* 函数到底在什么情况下被调用。\n\n在 *bootmain* 函数中读入了内核镜像 kernel 的 elf header :\n\n&#96;&#96;&#96;c\nreadseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);\n&#96;&#96;&#96;\n\n可见&#xff0c;从文件偏移量 &#96;&#96;[0x0,0x1000)&#96;&#96; 读取到虚拟内存地址 &#96;&#96;[0x10000,0x11000)&#96;&#96; 上。\n\n其次&#xff0c;读入了各个 program header :\n\n&#96;&#96;&#96;c\nph = (struct proghdr *)((uintptr_t)ELFHDR &#43; ELFHDR-&gt;e_phoff);\neph = ph &#43; ELFHDR-&gt;e_phnum;\nfor (; ph &lt; eph; ph &#43;&#43;) {\n    readseg(ph-&gt;p_va &amp; 0xFFFFFF, ph-&gt;p_memsz, ph-&gt;p_offset);\n}\n&#96;&#96;&#96;\n\n我们可以在内核启动起来之后用和上面相同的方式输出传入 *readseg* 的参数&#xff1a;\n\n在 &#96;&#96;kernel/init/init.c&#96;&#96; 中增加\n\n&#96;&#96;&#96;c\nvoid disk_test() {\n    cprintf(&#34;hello world!, 0x%x\\n&#34;, ELFHDR-&gt;e_magic);\n    cprintf(&#34;phnum = %u\\n&#34;, ELFHDR-&gt;e_phnum);\n    struct proghdr *ph, *eph;\n    ph = (struct proghdr *)((uintptr_t)ELFHDR &#43; ELFHDR-&gt;e_phoff);\n    eph = ph &#43; ELFHDR-&gt;e_phnum;\n    for (; ph &lt; eph; ph&#43;&#43;) {\n        cprintf(&#34;va = 0x%x memsz = 0x%x offset=0x%x\\n&#34;,ph-&gt;p_va, ph-&gt;p_memsz, ph-&gt;p_offset);\n    }\n}\n&#96;&#96;&#96;\n\n并在 *kern_init* 的开头就调用它。\n\n运行后可以看到结果是&#xff1a;\n\n&#96;&#96;&#96;c\nhello world!, 0x464c457f\nphnum = 3\nva = 0x100000 memsz = 0xe310 offset=0x1000\nva = 0x10f000 memsz = 0x1d20 offset=0x10000\nva = 0x0 memsz = 0x0 offset=0x0\n&#96;&#96;&#96;\n\n也就是一共有三个段&#xff0c;略去大小为 $$0$$ 的第三个不看&#xff0c;前两个分别&#xff1a;\n\n1. 从文件偏移量 &#96;&#96;[0x1000,0xf310)&#96;&#96; 读取到虚拟内存区间 &#96;&#96;[0x100000,0x10e310)&#96;&#96; &#xff1b;\n2. 从文件偏移量 &#96;&#96;[0x10000,0x11d20)&#96;&#96; 读取到虚拟内存区间 &#96;&#96;[0x10f000,0x110d20)&#96;&#96; 。\n\n不必运行模拟器的情况下&#xff0c;我们还可以借助 *objdump* 来看看 kernel 中这些段更具体的信息&#xff1a;\n\n&#96;&#96;&#96;c\n$ objdump target/kernel -x\n\nbin/kernel:     file format elf32-i386\nbin/kernel\narchitecture: i386, flags 0x00000112:\nEXEC_P, HAS_SYMS, D_PAGED\nstart address 0x001001f0\n\nProgram Header:\n    LOAD off    0x00001000 vaddr 0x00100000 paddr 0x00100000 align 2**12\n         filesz 0x0000e310 memsz 0x0000e310 flags r-x\n    LOAD off    0x00010000 vaddr 0x0010f000 paddr 0x0010f000 align 2**12\n         filesz 0x00000a16 memsz 0x00001d20 flags rw-\n   STACK off    0x00000000 vaddr 0x00000000 paddr 0x00000000 align 2**4\n         filesz 0x00000000 memsz 0x00000000 flags rwx\n\nSections:\nIdx Name          Size      VMA       LMA       File off  Algn\n  0 .text         00003599  00100000  00100000  00001000  2**0\n                  CONTENTS, ALLOC, LOAD, READONLY, CODE\n  1 .rodata       0000096c  001035a0  001035a0  000045a0  2**5\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  2 .stab         0000801d  00103f0c  00103f0c  00004f0c  2**2\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  3 .stabstr      000023e7  0010bf29  0010bf29  0000cf29  2**0\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  4 .data         00000a16  0010f000  0010f000  00010000  2**5\n                  CONTENTS, ALLOC, LOAD, DATA\n  5 .bss          00001300  0010fa20  0010fa20  00010a16  2**5\n                  ALLOC\n  6 .comment      0000002b  00000000  00000000  00010a16  2**0\n                  CONTENTS, READONLY\n&#96;&#96;&#96;\n\n仔细观察数据&#xff0c;发现\n\n* 第一个段是与 *.text, .rodata, .stab, .stabstr* 几个 Sections 对应的&#xff1b;\n* 第二个段是与 *.data, .bss* 对应的。\n\n于是 *readseg* 的三次调用&#xff0c;其 *va* 分别为 &#96;&#96;0x10000, 0x100000, 0x10f000&#96;&#96; &#xff0c;都是 *SECTSIZE* 的倍数&#xff0c;实际上向下取整的语句并未发挥作用。也更不必担心覆盖数据的问题了。\n\n事实上&#xff0c;只要保证这些段的开头位置与将要放在的起始虚拟地址均对齐于扇区大小 *SECTSIZE* &#xff0c;那就几乎不会有问题。\n\n## 2\n\n&#96;&#96;&#96;c\nstatic void\nreadsect(void *dst, uint32_t secno) {\n    ...\n\n    outb(0x1F2, 2);\n    \n    ...\n        \n    insl(0x1F0, dst, SECTSIZE / 2);\n}\nstatic void\nreadseg(uintptr_t va, uint32_t count, uint32_t offset) {\n    ...\n    for (; va &lt; end_va; va &#43;= 1024, secno &#43;= 2) {\n        readsect((void *)va, secno);\n    }\n}\n&#96;&#96;&#96;\n\n也许可以通过将端口 &#96;&#96;0x1F2&#96;&#96; 对应的设备寄存器设为 $$2$$ 来每次读入两个扇区。然而&#xff0c;在 &#96;&#96;bootmain.c&#96;&#96; 中做上述修改&#xff0c;发现 bootloader 的大小超过了 $$510$$ 字节&#xff0c;违反了 BIOS 的限制。\n\n话说回来&#xff0c;一次操作读写 $$1$$ 个块还是 $$2$$ 个块并不能影响磁盘的运行速度。在 &#96;&#96;bootmain.c&#96;&#96; 中这种通过 *polling* 循环等待磁盘操作结束再继续下面的流程的实现中&#xff0c;程序的总运行时间是一样的。\n\n然而&#xff0c;如果 CPU 发出了I/O 请求后不是通过 *polling* 等待操作结束&#xff0c;而是去做别的事情(切换到别的进程)&#xff0c;并使用中断机制及时回到工作现场。那么越频繁的发起 I/O 请求会增加上下文切换的次数&#xff0c;降低 CPU 的使用效率。于是&#xff0c;一次操作多读写一些会比较好。\n\n*DMA* 方面&#xff0c;需要模拟器提供的支持&#xff0c;暂时没有进行调研&#xff0c;可以留待后续补充。\n\n## 3\n\n个人觉得对于模拟器而言&#xff0c;这种致命情况直接 panic 或者直接死循环即可&#xff0c;并不清楚“把控制移交给模拟器”有何意义。\n\n尝试了一下将那两行代码删掉&#xff0c;感觉删掉前后并没有什么变化&#xff0c;可能只有 while(1) 在起作用吧。</md>"}, {"anon": "no", "uid": "jsjp32n2zAHb", "subject": "", "created": "2020-02-16T10:22:56Z", "content": "<md>## 1\n\n首先来看看 *readseg* 函数到底在什么情况下被调用。\n\n在 *bootmain* 函数中读入了内核镜像 kernel 的 elf header :\n\n&#96;&#96;&#96;c\nreadseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);\n&#96;&#96;&#96;\n\n可见&#xff0c;从文件偏移量 &#96;&#96;[0x0,0x1000)&#96;&#96; 读取到虚拟内存地址 &#96;&#96;[0x10000,0x10100)&#96;&#96; 上。\n\n其次&#xff0c;读入了各个 program header :\n\n&#96;&#96;&#96;c\nph = (struct proghdr *)((uintptr_t)ELFHDR &#43; ELFHDR-&gt;e_phoff);\neph = ph &#43; ELFHDR-&gt;e_phnum;\nfor (; ph &lt; eph; ph &#43;&#43;) {\n    readseg(ph-&gt;p_va &amp; 0xFFFFFF, ph-&gt;p_memsz, ph-&gt;p_offset);\n}\n&#96;&#96;&#96;\n\n我们可以在内核启动起来之后用和上面相同的方式输出传入 *readseg* 的参数&#xff1a;\n\n在 &#96;&#96;kernel/init/init.c&#96;&#96; 中增加\n\n&#96;&#96;&#96;c\nvoid disk_test() {\n    cprintf(&#34;hello world!, 0x%x\\n&#34;, ELFHDR-&gt;e_magic);\n    cprintf(&#34;phnum = %u\\n&#34;, ELFHDR-&gt;e_phnum);\n    struct proghdr *ph, *eph;\n    ph = (struct proghdr *)((uintptr_t)ELFHDR &#43; ELFHDR-&gt;e_phoff);\n    eph = ph &#43; ELFHDR-&gt;e_phnum;\n    for (; ph &lt; eph; ph&#43;&#43;) {\n        cprintf(&#34;va = 0x%x memsz = 0x%x offset=0x%x\\n&#34;,ph-&gt;p_va, ph-&gt;p_memsz, ph-&gt;p_offset);\n    }\n}\n&#96;&#96;&#96;\n\n并在 *kern_init* 的开头就调用它。\n\n运行后可以看到结果是&#xff1a;\n\n&#96;&#96;&#96;c\nhello world!, 0x464c457f\nphnum = 3\nva = 0x100000 memsz = 0xe310 offset=0x1000\nva = 0x10f000 memsz = 0x1d20 offset=0x10000\nva = 0x0 memsz = 0x0 offset=0x0\n&#96;&#96;&#96;\n\n也就是一共有三个段&#xff0c;略去大小为 $$0$$ 的第三个不看&#xff0c;前两个分别&#xff1a;\n\n1. 从文件偏移量 &#96;&#96;[0x1000,0xf310)&#96;&#96; 读取到虚拟内存区间 &#96;&#96;[0x100000,0x10e310)&#96;&#96; &#xff1b;\n2. 从文件偏移量 &#96;&#96;[0x10000,0x11d20)&#96;&#96; 读取到虚拟内存区间 &#96;&#96;[0x10f000,0x110d20)&#96;&#96; 。\n\n不必运行模拟器的情况下&#xff0c;我们还可以借助 *objdump* 来看看 kernel 中这些段更具体的信息&#xff1a;\n\n&#96;&#96;&#96;c\n$ objdump target/kernel -x\n\nbin/kernel:     file format elf32-i386\nbin/kernel\narchitecture: i386, flags 0x00000112:\nEXEC_P, HAS_SYMS, D_PAGED\nstart address 0x001001f0\n\nProgram Header:\n    LOAD off    0x00001000 vaddr 0x00100000 paddr 0x00100000 align 2**12\n         filesz 0x0000e310 memsz 0x0000e310 flags r-x\n    LOAD off    0x00010000 vaddr 0x0010f000 paddr 0x0010f000 align 2**12\n         filesz 0x00000a16 memsz 0x00001d20 flags rw-\n   STACK off    0x00000000 vaddr 0x00000000 paddr 0x00000000 align 2**4\n         filesz 0x00000000 memsz 0x00000000 flags rwx\n\nSections:\nIdx Name          Size      VMA       LMA       File off  Algn\n  0 .text         00003599  00100000  00100000  00001000  2**0\n                  CONTENTS, ALLOC, LOAD, READONLY, CODE\n  1 .rodata       0000096c  001035a0  001035a0  000045a0  2**5\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  2 .stab         0000801d  00103f0c  00103f0c  00004f0c  2**2\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  3 .stabstr      000023e7  0010bf29  0010bf29  0000cf29  2**0\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  4 .data         00000a16  0010f000  0010f000  00010000  2**5\n                  CONTENTS, ALLOC, LOAD, DATA\n  5 .bss          00001300  0010fa20  0010fa20  00010a16  2**5\n                  ALLOC\n  6 .comment      0000002b  00000000  00000000  00010a16  2**0\n                  CONTENTS, READONLY\n&#96;&#96;&#96;\n\n仔细观察数据&#xff0c;发现\n\n* 第一个段是与 *.text, .rodata, .stab, .stabstr* 几个 Sections 对应的&#xff1b;\n* 第二个段是与 *.data, .bss* 对应的。\n\n于是 *readseg* 的三次调用&#xff0c;其 *va* 分别为 &#96;&#96;0x10000, 0x100000, 0x10f000&#96;&#96; &#xff0c;都是 *SECTSIZE* 的倍数&#xff0c;实际上向下取整的语句并未发挥作用。也更不必担心覆盖数据的问题了。\n\n事实上&#xff0c;只要保证这些段的开头位置与将要放在的起始虚拟地址均对齐于扇区大小 *SECTSIZE* &#xff0c;那就几乎不会有问题。\n\n## 2\n\n&#96;&#96;&#96;c\nstatic void\nreadsect(void *dst, uint32_t secno) {\n    ...\n\n    outb(0x1F2, 2);\n    \n    ...\n        \n    insl(0x1F0, dst, SECTSIZE / 2);\n}\nstatic void\nreadseg(uintptr_t va, uint32_t count, uint32_t offset) {\n    ...\n    for (; va &lt; end_va; va &#43;= 1024, secno &#43;= 2) {\n        readsect((void *)va, secno);\n    }\n}\n&#96;&#96;&#96;\n\n也许可以通过将端口 &#96;&#96;0x1F2&#96;&#96; 对应的设备寄存器设为 $$2$$ 来每次读入两个扇区。然而&#xff0c;在 &#96;&#96;bootmain.c&#96;&#96; 中做上述修改&#xff0c;发现 bootloader 的大小超过了 $$510$$ 字节&#xff0c;违反了 BIOS 的限制。\n\n话说回来&#xff0c;一次操作读写 $$1$$ 个块还是 $$2$$ 个块并不能影响磁盘的运行速度。在 &#96;&#96;bootmain.c&#96;&#96; 中这种通过 *polling* 循环等待磁盘操作结束再继续下面的流程的实现中&#xff0c;程序的总运行时间是一样的。\n\n然而&#xff0c;如果 CPU 发出了I/O 请求后不是通过 *polling* 等待操作结束&#xff0c;而是去做别的事情(切换到别的进程)&#xff0c;并使用中断机制及时回到工作现场。那么越频繁的发起 I/O 请求会增加上下文切换的次数&#xff0c;降低 CPU 的使用效率。于是&#xff0c;一次操作多读写一些会比较好。\n\n*DMA* 方面&#xff0c;需要模拟器提供的支持&#xff0c;暂时没有进行调研&#xff0c;可以留待后续补充。\n\n## 3\n\n个人觉得对于模拟器而言&#xff0c;这种致命情况直接 panic 或者直接死循环即可&#xff0c;并不清楚“把控制移交给模拟器”有何意义。\n\n尝试了一下将那两行代码删掉&#xff0c;感觉删掉前后并没有什么变化&#xff0c;可能只有 while(1) 在起作用吧。</md>"}], "type": "s_answer", "tag_endorse_arr": ["k0keglbgnqt59c", "kjurfb1fxq2rq"], "children": [], "id": "k6ovstjj910o1", "config": {}, "is_tag_endorse": false}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<md>谢谢你的回答&#xff0c;非常详尽。下面我在说一些我的想法。  \n对于&#xff08;1&#xff09;来说&#xff0c;按照你的意思va的向下取整是作为一种冗余的保护措施存在&#xff0c;但是我觉得这种冗余的保护措施可能会导致数据覆盖的错误&#xff0c;甚至会导致进入ELFHDR-&gt;e_entry错误&#xff0c;这样的话直接删除不是更合适么&#xff1f;  \n对于&#xff08;3&#xff09;来说&#xff0c;我知道到bad的情况比较致命&#xff0c;但是我还是想搞清楚这个0x8a00端口的具体信息&#xff0c;可能我有点钻牛角尖了。</md>", "created": "2020-02-16T11:08:18Z", "bucket_order": 59, "bucket_name": "Week 2/9 - 2/15", "type": "followup", "tag_good": [{"role": "student", "name": "Guoqiang Zhong", "endorser": {}, "admin": false, "photo": null, "id": "k8mkxrs7jjp35j", "photo_url": null, "published": true, "us": false, "facebook_id": null}], "uid": "k0keglbgnqt59c", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<md>## 1\n\n从实际应用的角度看&#xff0c;出于各种因素&#xff0c;通常会通过设置链接脚本保证各段满足对齐要求&#xff0c;通常是以一页为单位 ($$4096$$ 字节)&#xff0c;则向下取整就完全没有必要了。\n\n但是&#xff0c;也可以强行设置不满足对齐要求。在这种情况下&#xff0c;如果对于所有的段&#xff0c;其在文件中的位置和加载到虚拟内存之后的位置之间差值是一个定值&#xff0c;等于是整个文件整体平移到虚拟内存中。此时&#xff0c;向下取整不会产生问题。\n\n但是如果既不满足对齐要求&#xff0c;上述的定值条件也不满足&#xff0c;向下取整确实会出现覆盖之前读入的数据的情况。此时我们只能开一块缓冲区存储从 IDE 中读到的数据&#xff0c;然后再将其中合适的部分写入到内存&#xff0c;而不是直接整块覆盖到内存。\n\n## 3\n\n这种写法应该来源于 MIT 的 xv6 &#xff0c;在[这里](https://github.com/mit-pdos/xv6-public/blob/master/bootasm.S#L70)可以看到&#xff0c;解析 ELF 失败后使用汇编代码进行了一样的操作。在注释中提到了它是针对于 Bochs 模拟器起作用的&#xff0c;作用大概是进行调试。\n\n[Bochs](http://bochs.sourceforge.net/)模拟器是一个 i386 模拟器&#xff0c;在[手册](http://bochs.sourceforge.net/doc/docbook/development/debugger-advanced.html)中找到了有关 &#96;&#96;0x8A00&#96;&#96; 端口的相关使用方法&#xff0c;也介绍了写入 &#96;&#96;0x8A00,0x8AE0&#96;&#96; 各是什么含义&#xff0c;有兴趣的话可以通过 Bochs 模拟器运行 uCore 看看会如何。\n\n因此结论是&#xff0c;这两行代码对于 Qemu 来说并没有用(从 Qemu 源代码中也未找到对应的 PIO 映射)&#xff0c;它是在 Bochs 中调试用的。</md>", "created": "2020-02-16T12:12:59Z", "bucket_order": 58, "bucket_name": "Week 2/16 - 2/22", "type": "feedback", "tag_good": [{"role": "student", "name": "Esoom", "endorser": {}, "admin": false, "photo": null, "id": "k0keglbgnqt59c", "photo_url": null, "us": false, "facebook_id": null}], "uid": "jsjp32n2zAHb", "children": [], "tag_good_arr": ["k0keglbgnqt59c"], "id": "k6ozqbzti6z4ap", "updated": "2020-02-16T12:12:59Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<md>完全明白了&#xff0c;非常感谢&#xff01;</md>", "created": "2020-02-16T12:16:28Z", "bucket_order": 58, "bucket_name": "Week 2/16 - 2/22", "type": "feedback", "tag_good": [], "uid": "k0keglbgnqt59c", "children": [], "tag_good_arr": [], "id": "k6ozutcti964l7", "updated": "2020-02-16T12:16:28Z", "config": {}}], "tag_good_arr": ["k8mkxrs7jjp35j"], "no_answer": 0, "id": "k6oxf5shl9zq9", "updated": "2020-02-16T11:08:18Z", "config": {}}], "tag_good_arr": ["kjurfb1fxq2rq"], "no_answer": 0, "id": "k6niaebzksl567", "config": {"seen": {"550": 7, "89": 3, "444": 9, "631": 6, "676": 1, "6": 2, "1222": 5, "1122": 0, "1351": 4, "837": 8}}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 4, "num_favorites": 4, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169904858, "default_anonymity": "no"}, "error": null, "aid": "kyv0xp0as5r6cc"}