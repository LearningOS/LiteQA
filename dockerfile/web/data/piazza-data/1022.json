{"result": {"folders": ["2017", "lecture11", "课堂问答"], "nr": 1022, "data": {"embed_links": []}, "created": "2017-03-26T09:22:08Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "hdjonbiyfs62ie", "data": "j0qh780a1s858b", "type": "create", "when": "2017-03-26T09:22:08Z"}, {"anon": "no", "uid": "ie7xy5sipx51qz", "to": "j0qh78087iw58a", "type": "followup", "when": "2017-03-28T01:37:45Z"}, {"anon": "no", "uid": "ie7xy8gtpwk1t5", "to": "j0qh78087iw58a", "type": "followup", "when": "2017-03-28T01:41:19Z"}, {"anon": "no", "uid": "ie7xy0l5qrq1lq", "to": "j0qh78087iw58a", "type": "followup", "when": "2017-03-28T01:44:22Z"}, {"anon": "no", "uid": "i5g31e12hcr27s", "to": "j0qh78087iw58a", "type": "followup", "when": "2017-03-28T02:36:37Z"}, {"anon": "no", "uid": "izb0ce5rlex6xc", "to": "j0qh78087iw58a", "type": "followup", "when": "2017-03-28T03:22:57Z"}, {"anon": "no", "uid": "izb0cbxq1a76wi", "to": "j0qh78087iw58a", "type": "followup", "when": "2017-03-28T07:04:22Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "2017春季-第十一讲课堂实践练习", "created": "2017-03-26T09:22:08Z", "content": "<p>请两人一组完成“第十一讲 进程和线程”中指定小题的回答在此贴中回复。</p>\n<p></p>\n<p>题目&#xff1a;<br /><a href=\"https://chyyuu.gitbooks.io/os_course_exercises/content/all/05-1-spoc-discussion.html\">https://chyyuu.gitbooks.io/os_course_exercises/content/all/05-1-spoc-discussion.html</a></p>\n<p></p>\n<p><br />小组思考题目 -&gt; 第2题&#xff1a;设计一个简化的进程管理子系统</p>\n<p></p>\n<p>建议&#xff1a;先看第1题中的进程管理子系统实现&#xff0c;然后再做第2题。</p>"}], "type": "note", "tags": ["2017", "instructor-note", "lecture11", "课堂问答"], "tag_good": [], "unique_views": 159, "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p></p><pre>class scheduler:<br />\n    #change to READY STATE, the current proc&#39;s state should be expected\n    #if pid==-1, then pid=self.curr_proc\n    def move_to_ready(self, expected, pid=-1):\n        if pid == -1:\n            pid = self.curr_proc\n\n        if self.proc_info[pid][PROC_STATE] == expected:\n            self.proc_info[pid][PROC_STATE] = STATE_READY\n\n        return\n\n    #change to RUNNING STATE, the current proc&#39;s state should be expected\n    def move_to_running(self, expected):\n        if self.proc_info[self.curr_proc][PROC_STATE] == expected:\n            self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING\n        return\n\n    #change to DONE STATE, the current proc&#39;s state should be expected\n    def move_to_done(self, expected):\n        if self.proc_info[self.curr_proc][PROC_STATE] == expected:\n            self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE\n        return\n\n    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc\n    def next_proc(self, pid=-1):\n        if pid == -1:\n            pid = self.curr_proc\n\n        for i in range(pid&#43;1, len(self.proc_info)):\n            if self.proc_info[i][PROC_STATE] == STATE_READY:\n                self.proc_info[i][PROC_STATE] = STATE_RUNNING\n                self.curr_proc = i\n                return\n\n        for i in range(0, pid&#43;1):\n            if self.proc_info[i][PROC_STATE] == STATE_READY:\n                self.proc_info[i][PROC_STATE] = STATE_RUNNING\n                self.curr_proc = i\n                return\n\n        return\n\n    def run(self):\n        clock_tick = 0\n\n        if len(self.proc_info) == 0:\n            return\n\n        # make first one active\n        self.curr_proc = 0\n        self.move_to_running(STATE_READY)\n\n        # OUTPUT: heade&#96;[rs for each column\n        print &#39;%s&#39; % &#39;Time&#39;,\n        for pid in range(len(self.proc_info)):\n            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),\n\n        print &#39;&#39;\n\n        # init statistics\n        cpu_busy = 0\n\n        while self.get_num_active() &gt; 0:\n            clock_tick &#43;= 1\n\n            # if current proc is RUNNING and has an instruction, execute it\n            # statistics clock_tick\n            instruction_to_execute = &#39;&#39;\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n                   len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)\n                cpu_busy &#43;= 1\n\n            # OUTPUT: print what everyone is up to\n            print &#39;%3d &#39; % clock_tick,\n            for pid in range(len(self.proc_info)):\n                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n                    print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),\n                else:\n                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),\n\n            print &#39;&#39;\n\n            # if this is an YIELD instruction, switch to ready state\n            # and add an io completion in the future\n            if instruction_to_execute == DO_YIELD:\n                self.move_to_ready(STATE_RUNNING)\n                self.next_proc()\n\n            # ENDCASE: check if currently running thing is out of instructions\n            self.check_if_done()\n        return (clock_tick)</pre>", "created": "2017-03-28T01:37:45Z", "bucket_order": 157, "bucket_name": "Week 3/26 - 4/1", "type": "followup", "tag_good": [], "uid": "ie7xy5sipx51qz", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "j0svhph3mu87pr", "updated": "2017-03-28T01:37:45Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p><a href=\"https://github.com/zqwerty/os_course/blob/master/process/process_hw.py\" target=\"_blank\">https://github.com/zqwerty/os_course/blob/master/process/process_hw.py</a></p>", "created": "2017-03-28T01:41:19Z", "bucket_order": 157, "bucket_name": "Week 3/26 - 4/1", "type": "followup", "tag_good": [], "uid": "ie7xy8gtpwk1t5", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "j0svmb257743gg", "updated": "2017-03-28T01:41:19Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p></p>\n<pre># Chen Yazheng  2014011423\n\nclass scheduler:\n    def __init__(self):\n        # keep set of instructions for each of the processes\n        self.proc_info = {}\n        return\n\n    def new_process(self):\n        proc_id = len(self.proc_info)\n        self.proc_info[proc_id] = {}\n        self.proc_info[proc_id][PROC_PC] = 0\n        self.proc_info[proc_id][PROC_ID] = proc_id\n        self.proc_info[proc_id][PROC_CODE] = []\n        self.proc_info[proc_id][PROC_STATE] = STATE_READY\n        return proc_id\n\n    def load(self, program_description):\n        proc_id = self.new_process()\n        tmp = program_description.split(&#39;:&#39;)\n        if len(tmp) != 2:\n            print &#39;Bad description (%s): Must be number &lt;x:y&gt;&#39;\n            print &#39;  where X is the number of instructions&#39;\n            print &#39;  and Y is the percent change that an instruction is CPU not YIELD&#39;\n            exit(1)\n\n        num_instructions, chance_cpu = int(tmp[0]), float(tmp[1])/100.0\n        for i in range(num_instructions):\n            if random.random() &lt; chance_cpu:\n                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)\n            else:\n                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)\n        return\n\n    #change to READY STATE, the current proc&#39;s state should be expected\n    #if pid==-1, then pid=self.curr_proc\n    def move_to_ready(self, expected, pid=-1):\n        #YOUR CODE\n        if pid == -1:\n            pid = self.curr_proc\n        assert(self.proc_info[pid][PROC_STATE] == expected)\n        self.proc_info[pid][PROC_STATE] = STATE_READY\n        return\n\n    #change to RUNNING STATE, the current proc&#39;s state should be expected\n    def move_to_running(self, expected):\n        #YOUR CODE\n        assert(self.proc_info[self.curr_proc][PROC_STATE] == expected)\n        self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING\n        return\n\n    #change to DONE STATE, the current proc&#39;s state should be expected\n    def move_to_done(self, expected):\n        #YOUR CODE\n        assert(self.proc_info[self.curr_proc][PROC_STATE] == expected)\n        self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE\n        return\n\n    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc\n    def next_proc(self, pid=-1):\n        #YOUR CODE\n        if pid != -1:\n            pid = self.curr_proc\n            self.move_to_running(STATE_READY)\n        \n        for pid in range(self.curr_proc &#43; 1, len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] == STATE_READY:\n                self.curr_proc = pid\n                self.move_to_running(STATE_READY)\n                return\n        for pid in range(0, self.curr_proc &#43; 1):\n            if self.proc_info[pid][PROC_STATE] == STATE_READY:\n                self.curr_proc = pid\n                self.move_to_running(STATE_READY)\n                return\n        return\n\n    def get_num_processes(self):\n        return len(self.proc_info)\n\n    def get_num_instructions(self, pid):\n        return len(self.proc_info[pid][PROC_CODE])\n\n    def get_instruction(self, pid, index):\n        return self.proc_info[pid][PROC_CODE][index]\n\n    def get_num_active(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] != STATE_DONE:\n                num_active &#43;= 1\n        return num_active\n\n    def get_num_runnable(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\\n                   self.proc_info[pid][PROC_STATE] == STATE_RUNNING:\n                num_active &#43;= 1\n        return num_active\n\n    def space(self, num_columns):\n        for i in range(num_columns):\n            print &#39;%10s&#39; % &#39; &#39;,\n\n    def check_if_done(self):\n        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n                self.move_to_done(STATE_RUNNING)\n                self.next_proc()\n        return\n\n    def run(self):\n        clock_tick = 0\n\n        if len(self.proc_info) == 0:\n            return\n\n        # make first one active\n        self.curr_proc = 0\n        self.move_to_running(STATE_READY)\n\n        # OUTPUT: heade&#96;[rs for each column\n        print &#39;%s&#39; % &#39;Time&#39;, \n        for pid in range(len(self.proc_info)):\n            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),\n\n        print &#39;&#39;\n\n        # init statistics\n        cpu_busy = 0\n\n        while self.get_num_active() &gt; 0:\n            clock_tick &#43;= 1\n            \n            # if current proc is RUNNING and has an instruction, execute it\n            # statistics clock_tick\n            instruction_to_execute = &#39;&#39;\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n                   len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                #YOUR CODE\n                instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)\n                cpu_busy &#43;= 1\n\n            # OUTPUT: print what everyone is up to\n            print &#39;%3d &#39; % clock_tick,\n            for pid in range(len(self.proc_info)):\n                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n                    print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),\n                else:\n                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),\n\n            print &#39;&#39;\n\n            # if this is an YIELD instruction, switch to ready state\n            # and add an io completion in the future\n            if instruction_to_execute == DO_YIELD:\n                #YOUR CODE\n                self.move_to_ready(STATE_RUNNING)\n                self.next_proc()\n\n            # ENDCASE: check if currently running thing is out of instructions\n            self.check_if_done()\n        return (clock_tick)\n        \n</pre>", "created": "2017-03-28T01:44:22Z", "bucket_order": 157, "bucket_name": "Week 3/26 - 4/1", "type": "followup", "tag_good": [], "uid": "ie7xy0l5qrq1lq", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "j0svq80nvou5sm", "updated": "2017-03-28T01:44:22Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p><a href=\"https://github.com/mengcz13/ucore_lab/blob/master/related_info/lab4/process-concept-homework.py\" target=\"_blank\">https://github.com/mengcz13/ucore_lab/blob/master/related_info/lab4/process-concept-homework.py</a></p>", "created": "2017-03-28T02:36:37Z", "bucket_order": 157, "bucket_name": "Week 3/26 - 4/1", "type": "followup", "tag_good": [], "uid": "i5g31e12hcr27s", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "j0sxlf0d9kk4ov", "updated": "2017-03-28T02:36:37Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p><a href=\"https://gist.github.com/liwt31/6d65efa4d0b4a34939d487ee14634edd\">https://gist.github.com/liwt31/6d65efa4d0b4a34939d487ee14634edd</a></p>", "created": "2017-03-28T03:22:57Z", "bucket_order": 157, "bucket_name": "Week 3/26 - 4/1", "type": "followup", "tag_good": [], "uid": "izb0ce5rlex6xc", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "j0sz90dvuoa67x", "updated": "2017-03-28T03:22:57Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p><a href=\"https://gist.github.com/sunskyhsh/827c6fa035fbb5a758bacf732c5f14a9\" target=\"_blank\">https://gist.github.com/sunskyhsh/827c6fa035fbb5a758bacf732c5f14a9</a></p>", "created": "2017-03-28T07:04:22Z", "bucket_order": 157, "bucket_name": "Week 3/26 - 4/1", "type": "followup", "tag_good": [], "uid": "izb0cbxq1a76wi", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "j0t75raae9g14i", "updated": "2017-03-28T07:04:22Z", "config": {}}], "tag_good_arr": [], "id": "j0qh78087iw58a", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 10, "num_favorites": 0, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643168990595, "default_anonymity": "no"}, "error": null, "aid": "kyv0e3k3fi9156"}