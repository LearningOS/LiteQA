{"result": {"folders": ["lab1"], "nr": 997, "data": {"embed_links": []}, "created": "2017-03-03T08:49:09Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "ie7xy9yltfs1uq", "data": "iztkw7c1x8w77g", "type": "create", "when": "2017-03-03T08:49:09Z"}, {"anon": "no", "uid": "ie7xy9yltfs1uq", "data": "iztlnjrs19l6f9", "to": "iztkw7by6pe77f", "type": "s_answer", "when": "2017-03-03T09:10:25Z"}, {"anon": "no", "uid": "ie7xy8iscsw1t7", "to": "iztkw7by6pe77f", "type": "followup", "when": "2017-03-03T14:23:49Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "ie7xy9yltfs1uq", "subject": "gdb的寄存器信息不同于monitor显示的信息", "created": "2017-03-03T08:49:09Z", "content": "<p>想做的是停在BIOS第一条指令处并查看一些寄存器的信息&#xff0c;为此进行了以下操作&#xff1a;</p>\n<p></p>\n<p>在Makefile中加入以下代码&#xff1a;</p>\n<pre>lab1-mon: $(UCOREIMG)\n\t$(V)$(TERMINAL) -e &#34;$(QEMU) -S -s -d in_asm -D $(BINDIR)/q.log -monitor stdio -hda $&lt; -serial null&#34;\n\t$(V)sleep 2\n\t$(V)$(TERMINAL) -e &#34;gdb -q -x tools/lab1init&#34;</pre>\n<p>其中的-monitor stdio -hda参数会启动qemu的monitor&#xff0c;可以在其中显示一些信息&#xff1b;</p>\n<p>在tools/lab1init文件中加入以下初始化gdb的代码&#xff1a;</p>\n<pre>file bin/kernel<br />set architecture i386<br />target remote :1234</pre>\n<p>这时运行</p>\n<pre>make lab1-mon</pre>\n<p>应当会启动一个qemu、一个qemu的monitor、一个gdb的命令行&#xff0c;并且停在执行第一条指令之前。</p>\n<p>这时如果查看当前pc及之后的汇编代码&#xff0c;在gdb命令行和monitor中分别运行</p>\n<pre>x /10i $pc</pre>\n<p>会发现结果不一样&#xff0c;理论上这时$pc应是0xfffffff0&#xff0c;gdb显示的却是0x0000fff0&#xff1a;</p>\n<pre>(gdb) x /10i $pc\n=&gt; 0xfff0:\tadd    %al,(%eax)\n   0xfff2:\tadd    %al,(%eax)\n   0xfff4:\tadd    %al,(%eax)\n   0xfff6:\tadd    %al,(%eax)\n   0xfff8:\tadd    %al,(%eax)\n   0xfffa:\tadd    %al,(%eax)\n   0xfffc:\tadd    %al,(%eax)\n   0xfffe:\tadd    %al,(%eax)\n   0x10000:\tadd    %al,(%eax)\n   0x10002:\tadd    %al,(%eax)</pre>\n<p>monitor显示是正确的预期结果&#xff1a;</p>\n<pre>(qemu) x /10i $pc\n0xfffffff0:  ljmp   $0xf000,$0xe05b\n0xfffffff5:  xor    %dh,0x322f\n0xfffffff9:  xor    (%bx),%bp\n0xfffffffb:  cmp    %di,(%bx,%di)\n0xfffffffd:  add    %bh,%ah\n0xffffffff:  add    %al,(%bx,%si)\n0x00000001:  add    %al,(%bx,%si)\n0x00000003:  add    %al,(%bx,%si)\n0x00000005:  add    %al,(%bx,%si)\n0x00000007:  add    %al,(%bx,%si)</pre>\n<p></p>\n<p>实际测试中还发现如果在gdb中设置断点为32位的地址处&#xff0c;比如0xfe05b&#xff0c;gdb会显示停到了低16位的地址处0xe05b&#xff0c;并且继续用si单步执行的话也执行不下去。所以猜测gdb对于32位的内存地址设置断点还有显示会有一些问题&#xff1f;这样的话对于之后在gdb中调试可能会产生一些影响&#xff0c;是否可能需要在gdb中进行某些设置或者是其他什么原因&#xff1f;</p>"}], "type": "question", "tags": ["lab1", "student"], "tag_good": [], "unique_views": 174, "children": [{"folders": [], "data": {"embed_links": []}, "children": [], "created": "2017-03-03T09:10:25Z", "bucket_order": 3, "tag_endorse": [], "bucket_name": "Today", "id": "iztlnjrpp9i6f8", "history": [{"anon": "no", "uid": "ie7xy9yltfs1uq", "subject": "", "created": "2017-03-03T09:10:25Z", "content": "<p>目前感觉是gdb只加载了kernel&#xff0c;还在实模式类似的问题&#xff0c;但具体的还不太清楚</p>"}], "type": "s_answer", "tag_endorse_arr": [], "config": {}, "is_tag_endorse": false}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>我感觉在gdb中打印的$PC的值是$EIP的值&#xff0c;但是实际执行的指令地址是base&#43;EIP&#xff0c;就出现了$pc值“不正确”的现象。停在执行第一条指令之前的时候&#xff0c;虽然gdb显示的$pc=0x0000fff0&#xff0c;但是运行si命令之后会发现执行的命令其实是0xfffffff0处的跳转指令。</p>", "created": "2017-03-03T14:23:49Z", "bucket_order": 163, "bucket_name": "Week 2/26 - 3/4", "type": "followup", "tag_good": [], "uid": "ie7xy8iscsw1t7", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "iztwul797fe5hs", "updated": "2017-03-03T14:23:49Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "iztkw7by6pe77f", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 5, "num_favorites": 1, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643168953126, "default_anonymity": "no"}, "error": null, "aid": "kyv0dana3x65bl"}