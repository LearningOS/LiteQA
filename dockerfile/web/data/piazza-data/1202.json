{"result": {"folders": ["lecture13", "2018"], "nr": 1202, "data": {"embed_links": []}, "created": "2018-04-17T01:38:24Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "ie7xy2fekwm1np", "data": "jg301irrz9h68e", "type": "create", "when": "2018-04-17T01:38:24Z"}, {"anon": "no", "uid": "ie7xy2fekwm1np", "data": "jg33tasecdxeg", "type": "update", "when": "2018-04-17T03:23:59Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "data": "jt9gs59ewop4au", "type": "update", "when": "2019-03-15T02:49:48Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "python多线程的实现方式", "created": "2019-03-15T02:49:48Z", "content": "<p>这篇文章讲的很清楚&#xff1a;<a href=\"https://www.cnblogs.com/ybjourney/p/6429715.html\">https://www.cnblogs.com/ybjourney/p/6429715.html</a></p>\n<p></p>\n<p>结论</p>\n<ul><li>python的多线程确实调用了操作系统提供的线程库&#xff0c;用来创建线程和调度线程。</li><li>python在每次解释命令时&#xff0c;都会统计次数&#xff0c;&#xff08;用软件模拟了时钟中断&#xff0c;&#xff09;用于定时控制全局解释锁的权限。</li><li>&#xff08;其实如果解释性语言愿意写&#xff0c;是可以自行实现线程块的&#xff0c;反正这里锁都是要控制。我认为这里的线程&#xff0c;调度机制对用户透明&#xff0c;同时不被内核所知&#xff0c;所以是可行的、能随时打断线程的一种用户线程调度方式。&#xff09;</li></ul>\n<p>细节</p>\n<ul><li>python的解释器有一个全局解释锁GIL&#xff0c;导致任意两个线程无法同时解释命令&#xff0c;也就是无法同时执行。</li><li>所有线程除了一个有锁权限的在运行&#xff08;或者该Python程序在运行&#xff0c;那么这个线程是就绪状态&#xff09;&#xff0c;其他的全部在等待锁&#xff0c;即wait状态&#xff0c;也不会被系统调度。</li><li>当一个线程执行次数到达一定数量&#xff08;在解释命令时有计数&#xff09;&#xff0c;python解释器会释放该线程全局解释锁的权限&#xff0c;等待操作系统调度下一个线程。</li><li>上一个操作&#xff0c;我们可以认为是python用软件模拟的一个中断&#xff0c;即可作为我们实现切换用户态线程的一个入口点。</li></ul>\n<p></p>\n<p>重要部分节选</p>\n<p></p>\n<p></p>\n<p><span style=\"font-size:14pt\"><strong>关于线程调度</strong></span></p>\n<p><span style=\"font-size:18px\">和操作系统的进程调度一样&#xff0c;Python线程调度机制主要解决两个问题&#xff1a;</span></p>\n<p><span style=\"font-size:18px\">1. 在何时挂起当前线程&#xff0c;选择处于等待状态的下一个线程&#xff1f;</span></p>\n<p><span style=\"font-size:18px\">2. 在众多处于等待状态的线程中&#xff0c;应该选择激活哪个线程&#xff1f;</span></p>\n<p><span style=\"font-size:18px\">对于何时进行线程调度的问题&#xff0c;是由Python自身决定的。我们可以联想操作系统进行进程切换的问题&#xff0c;当一个进程执行了一段时间之后&#xff0c;发生了时钟中断&#xff0c;于是操作系统响应时钟中断&#xff0c;并在这时开始进程的调度。</span></p>\n<p><span style=\"font-size:18px\">与此类似&#xff0c;Python中通过软件模拟了这样的中断&#xff0c;来激活线程的调度。Python的字节码解释器是按照指令的顺序一条一条的顺序执行从而工作的&#xff0c;Python内部维护着这样一个数值&#xff0c;作为Python内部的时钟&#xff0c;假设这个值为N&#xff0c;那么Python将在执行了N条指令之后立刻启动线程调度机制。</span></p>\n<p><span style=\"font-size:18px\">也就是说&#xff0c;当一个线程获得GIL后&#xff0c;Python内部的监测机制就开始启动&#xff0c;当这个线程执行了N条指令后&#xff0c;Python解释器将强制挂起当前线程&#xff0c;开始切换到下一个处于等待状态的线程。</span></p>\n<p></p>"}, {"anon": "no", "uid": "ie7xy2fekwm1np", "subject": "python多线程的实现方式", "created": "2018-04-17T03:23:59Z", "content": "<p>这篇文章讲的很清楚&#xff1a;<a href=\"https://www.cnblogs.com/ybjourney/p/6429715.html\">https://www.cnblogs.com/ybjourney/p/6429715.html</a></p>\n<p></p>\n<p>结论</p>\n<ul><li>python的多线程确实调用了操作系统提供的线程库&#xff0c;用来创建线程和调度线程。</li><li>python在每次解释命令时&#xff0c;都会统计次数&#xff0c;&#xff08;用软件模拟了时钟中断&#xff0c;&#xff09;用于定时控制全局解释锁的权限。</li><li>&#xff08;其实如果解释性语言愿意写&#xff0c;是可以自行实现线程块的&#xff0c;反正这里锁都是要控制。我认为这里的线程&#xff0c;调度机制对用户透明&#xff0c;同时不被内核所知&#xff0c;所以是可行的、能随时打断线程的一种用户线程调度方式。&#xff09;</li></ul>\n<p>细节</p>\n<ul><li>python的解释器有一个全局解释锁GIL&#xff0c;导致任意两个线程无法同时解释命令&#xff0c;也就是无法同时执行。</li><li>所有线程除了一个有锁权限的在运行&#xff08;或者该Python程序在运行&#xff0c;那么这个线程是就绪状态&#xff09;&#xff0c;其他的全部在等待锁&#xff0c;即wait状态&#xff0c;也不会被系统调度。</li><li>当一个线程执行次数到达一定数量&#xff08;在解释命令时有计数&#xff09;&#xff0c;python解释器会释放该线程全局解释锁的权限&#xff0c;等待操作系统调度下一个线程。</li><li>上一个操作&#xff0c;我们可以认为是python用软件模拟的一个中断&#xff0c;即可作为我们实现切换用户态线程的一个入口点。</li></ul>\n<p></p>\n<p>重要部分节选</p>\n<p></p>\n<p></p>\n<p><span style=\"font-size:14pt\"><strong>关于线程调度</strong></span></p>\n<p><span style=\"font-size:18px\">和操作系统的进程调度一样&#xff0c;Python线程调度机制主要解决两个问题&#xff1a;</span></p>\n<p><span style=\"font-size:18px\">1. 在何时挂起当前线程&#xff0c;选择处于等待状态的下一个线程&#xff1f;</span></p>\n<p><span style=\"font-size:18px\">2. 在众多处于等待状态的线程中&#xff0c;应该选择激活哪个线程&#xff1f;</span></p>\n<p><span style=\"font-size:18px\">对于何时进行线程调度的问题&#xff0c;是由Python自身决定的。我们可以联想操作系统进行进程切换的问题&#xff0c;当一个进程执行了一段时间之后&#xff0c;发生了时钟中断&#xff0c;于是操作系统响应时钟中断&#xff0c;并在这时开始进程的调度。</span></p>\n<p><span style=\"font-size:18px\">与此类似&#xff0c;Python中通过软件模拟了这样的中断&#xff0c;来激活线程的调度。Python的字节码解释器是按照指令的顺序一条一条的顺序执行从而工作的&#xff0c;Python内部维护着这样一个数值&#xff0c;作为Python内部的时钟&#xff0c;假设这个值为N&#xff0c;那么Python将在执行了N条指令之后立刻启动线程调度机制。</span></p>\n<p><span style=\"font-size:18px\">也就是说&#xff0c;当一个线程获得GIL后&#xff0c;Python内部的监测机制就开始启动&#xff0c;当这个线程执行了N条指令后&#xff0c;Python解释器将强制挂起当前线程&#xff0c;开始切换到下一个处于等待状态的线程。</span></p>\n\n<p></p>"}, {"anon": "no", "uid": "ie7xy2fekwm1np", "subject": "python多线程的实现方式", "created": "2018-04-17T01:38:24Z", "content": "<p>之后补上</p>"}], "type": "note", "tags": ["2018", "lecture13", "student"], "tag_good": [], "unique_views": 113, "children": [], "tag_good_arr": [], "id": "jg301iroy5r68d", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 2, "num_favorites": 0, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169380304, "default_anonymity": "no"}, "error": null, "aid": "kyv0mg9cyco5mv"}