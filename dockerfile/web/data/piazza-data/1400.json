{"result": {"folders": ["lab4"], "nr": 1400, "data": {"embed_links": []}, "created": "2020-02-26T10:48:30Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "stud", "data": "k73747ralac2a2", "type": "create", "when": "2020-02-26T10:48:30Z", "uid_a": "a_0"}, {"anon": "stud", "to": "k73747r8jz92a1", "type": "followup", "when": "2020-02-26T10:50:19Z", "uid_a": "a_0"}, {"anon": "no", "uid": "k6ofjvmpddj11c", "to": "k73747r8jz92a1", "type": "feedback", "when": "2020-03-06T14:13:03Z"}], "bucket_name": "Today", "history": [{"anon": "stud", "uid_a": "a_0", "subject": "物理内存探测和分配的一个alternative版本", "created": "2020-02-26T10:48:30Z", "content": "<p>原文实在是太NOI-istic。小生在此抛砖引玉给出一个人类可读版本的&#xff1a;</p>\n<pre>// root at one as routine\n// inline helper funtion, they can be better to be written in marco or association function\nimpl SegmentTreeAllocator {\n    #[inline]\n    fn left_child(&amp;self, idx : usize) -&gt; usize {idx &lt;&lt; 1}\n    #[inline]\n    fn right_child(&amp;self, idx : usize) -&gt; usize {(idx &lt;&lt; 1) | 1}\n    #[inline]\n    fn update(&amp;mut self, idx : usize) {\n        let mut temp = idx &gt;&gt; 1;\n        while temp &gt; 0 {\n            // if left child and right child is full, then nodes[p] is full\n            self.nodes[temp] = self.nodes[self.left_child(temp)] &amp; self.nodes[self.right_child(temp)];\n            temp &gt;&gt;= 1;\n        }\n    }\n}\n\n// consturct a complete binary tree and put all real node into leaves.\n// so [l,r) length assignment needs pow(2, log(2,r-l)&#43;1) leaves to store, from lfet most child to right\nimpl SegmentTreeAllocator {\n    // init [l,r) interval \n    pub fn init(&amp;mut self, l : usize, r : usize) {\n        self.offset = l;\n        self.total = r - l;  // total may be not a power of 2\n        // compute the first key index\n        self.leaf_begin = 1;\n        // why add 2? \n        // one for root start from one instead of zero\n        // another one for total number is contained, say we have 10 number,\n        // naturally, the condition shall be less than 11, you need to take 10 into account\n        while self.leaf_begin &lt; self.total &#43; 2 {\n            self.leaf_begin &lt;&lt;= 1;\n        }\n        // since [l,r) may not be aligned, we need to let extra element marked as invalid\n        // on level of leaf, you have pow(2,leaf_begin)&#39;s leaves.\n        // so total elements of this complete binary tree should be\n        //  1 &#43; 2 &#43; 4 &#43;  ... &#43; pow(2,leaf_begin)\n        // pow(2,leaf_begin&#43;1) - 1, namely range from [1,pow(2,leaf_begin&#43;1)\n        for i in (1..(self.leaf_begin &lt;&lt; 1)) {self.nodes[i] = 1;}\n        // avaiable part, please notice it shall start from left child, which is even\n        // different from origin version,  \n        // so you can see above self.offset is l, not l-1\n        for i in (0..self.total) {self.nodes[self.leaf_begin &#43; i] = 0;}\n        // update parents who are available\n        for i in (1..self.leaf_begin).rev() {\n            self.nodes[i] = self.nodes[self.left_child(i)] &amp; self.nodes[self.right_child(i)];\n        }\n    }\n\n    // allocate a physical page, return a physical page number\n    pub fn alloc(&amp;mut self) -&gt; usize {\n        // assume that we never run out of physical memory\n        if self.nodes[1] == 1 {\n            panic!(&#34;physical memory depleted!&#34;);\n        }\n        // from top, find first available page\n        let mut p = 1;\n        while p &lt; self.leaf_begin {\n            if self.nodes[self.left_child(p)] == 0 {\n                p = self.left_child(p);\n            } else{\n                p = self.right_child(p);\n            }\n        }\n        // since it has offset, we need to compute\n        let result = (p - self.leaf_begin) &#43; self.offset;\n        // it has been allocated, we need to mark it as used\n        self.nodes[p] = 1;\n        // update its ancestor\n        self.update(p);\n        result\n    }\n\n    // recycle the target page\n    pub fn dealloc(&amp;mut self, idx : usize) {\n        // notice there is a difference between alloc and de-alloc\n        // the operation order is inversed.\n        let pos_in_tree = (idx - self.offset) &#43; self.leaf_begin;\n        // we recycle a used one\n        assert!(self.nodes[pos_in_tree] == 1);\n        self.nodes[pos_in_tree] = 0;\n        self.update(pos_in_tree);\n    }\n}\n\n// singleton\npub static SEGMENT_TREE_ALLOCATOR: Mutex&lt;SegmentTreeAllocator&gt; = Mutex::new(SegmentTreeAllocator {\n    nodes: [0; MAX_PHYSICAL_PAGES &lt;&lt; 1],\n    leaf_begin: 0,\n    total: 0,\n    offset: 0\n});</pre>\n<p></p>"}], "type": "note", "tags": ["lab4", "student"], "tag_good": [], "unique_views": 84, "children": [{"anon": "stud", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>忘了线段树定义了</p>\n<pre>pub struct SegmentTreeAllocator {\n    nodes : [u8; MAX_PHYSICAL_PAGES &lt;&lt; 1],  // allocate double max nodes\n    leaf_begin : usize,  // our real pages are at leaf node, which is not indexed at 0\n    total : usize,       // how many pages we have in total\n    offset : usize       // since physical page could start at non-zero\n}</pre>\n<p></p>", "created": "2020-02-26T10:50:19Z", "bucket_order": 6, "bucket_name": "Last week", "type": "followup", "tag_good": [{"role": "student", "name": "XianyuGu", "endorser": {}, "admin": false, "photo": null, "id": "k6ofjvmpddj11c", "photo_url": null, "published": true, "us": false, "facebook_id": null}], "uid_a": "a_0", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<md>楼主代码对人类非常友好&#xff01;那个注释可能有一丢丢问题\n&gt; // so total elements of this complete binary tree should be 1 &#43; 2 &#43; 4 &#43;  ... &#43; pow(2,leaf_begin)\n\n应该是 1 &#43; 2 &#43; 4 &#43; .. leaf_begin&#xff0c;最后一层应该有leaf_begin个node吧</md>", "created": "2020-03-06T14:13:03Z", "bucket_order": 3, "bucket_name": "Today", "type": "feedback", "tag_good": [], "uid": "k6ofjvmpddj11c", "children": [], "tag_good_arr": [], "id": "k7g9dx5jivn1zj", "updated": "2020-03-06T14:13:03Z", "config": {}}], "tag_good_arr": ["k6ofjvmpddj11c"], "no_answer": 0, "id": "k7376jtgsxt6o1", "updated": "2020-02-26T10:50:19Z", "config": {}}], "tag_good_arr": [], "id": "k73747r8jz92a1", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 2, "num_favorites": 2, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169956399, "default_anonymity": "no"}, "error": null, "aid": "kyv0ysrzi22321"}