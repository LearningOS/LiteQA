{"result": {"folders": ["lecture14"], "nr": 1314, "data": {"embed_links": []}, "created": "2019-04-24T15:07:51Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "jshne0ytr8i4nb", "data": "juvcrdfx2ey1c4", "type": "create", "when": "2019-04-24T15:07:51Z"}, {"anon": "no", "uid": "jshne0ytr8i4nb", "data": "juvd80b1oik3od", "type": "update", "when": "2019-04-24T15:20:48Z"}, {"anon": "no", "uid": "jshne0ytr8i4nb", "data": "juvdkz0ho997ja", "type": "update", "when": "2019-04-24T15:30:52Z"}, {"anon": "no", "uid": "jshne0ytr8i4nb", "data": "juvduyf5ifbkz", "type": "update", "when": "2019-04-24T15:38:38Z"}, {"anon": "no", "uid": "jshne0ytr8i4nb", "data": "juve3usynohql", "type": "update", "when": "2019-04-24T15:45:33Z"}, {"anon": "no", "uid": "jshne0ytr8i4nb", "data": "juvfg057ngj6jj", "type": "update", "when": "2019-04-24T16:23:00Z"}, {"anon": "no", "uid": "jshne0ytr8i4nb", "data": "juvy28ujmed1fb", "type": "update", "when": "2019-04-25T01:04:11Z"}, {"anon": "no", "uid": "jshne0ytr8i4nb", "data": "juvzscwnuy82tu", "type": "update", "when": "2019-04-25T01:52:29Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "jshne0ytr8i4nb", "subject": "按要求实现了lab5前两个练习之后&#xff0c;还是有些相关疑问待解", "created": "2019-04-25T01:52:29Z", "content": "<md>\n* 1.在更新lab5之前代码的部分&#xff0c;do_fork()中&#xff0c;如果不把nr_process简单加一变成 set_links(proc); 在init_main中&#xff0c;报错显示nr_process是3不是2。\n关于这个问题&#xff0c;我先说我看到的部分\n&gt;cptr:表示孩子进程指针\n&gt;yptr:表示最年轻的兄弟进程指针\n&gt;optr:表示最大的兄弟进程指针\n在do_wait()中&#xff0c;涉及到了这三个指针\n&#96;&#96;&#96;c&#43;&#43;\n    if (pid != 0)\n    {\n        proc = find_proc(pid);\n        if (proc != NULL &amp;&amp; proc-&gt;parent == current)\n        {\n            haskid = 1;\n            if (proc-&gt;state == PROC_ZOMBIE)\n            {\n                goto found;\n            }\n        }\n    }\n    else\n    {\n        proc = current-&gt;cptr;\n        for (; proc != NULL; proc = proc-&gt;optr)\n        {\n            haskid = 1;\n            if (proc-&gt;state == PROC_ZOMBIE)\n            {\n                goto found;\n            }\n        }\n    }\n&#96;&#96;&#96;\n我的理解&#xff0c;作用是去清楚僵尸进程&#xff0c;因为在found中的实现逻辑如下\n&#96;&#96;&#96;c&#43;&#43;\n    if (proc == idleproc || proc == initproc)\n    {\n        panic(&#34;wait idleproc or initproc.\\n&#34;);\n    }\n    if (code_store != NULL)\n    {\n        *code_store = proc-&gt;exit_code;\n    }\n    local_intr_save(intr_flag);\n    {\n        unhash_proc(proc);\n        remove_links(proc);\n    }\n    local_intr_restore(intr_flag);\n    put_kstack(proc);\n    kfree(proc);\n    return 0;\n&#96;&#96;&#96;\n但为什么这里不会报错&#xff0c;反而在init_main中说是3不是2&#xff0c;而又为什么按照原来的写法是3&#xff0c;更新之后才是2了&#xff1f;\n* 2.还是在更新以前的部分&#xff0c;trao.c中&#xff0c;时钟中断要更新为如下代码\n&#96;&#96;&#96;c&#43;&#43;\n    ticks &#43;&#43;;\n        if (ticks % TICK_NUM == 0) {\n            assert(current !=NULL);   //一定是空的吗&#xff1f;因为在内核态吧&#xff1f;\n            current-&gt;need_resched=1;\n        }\n        break;\n&#96;&#96;&#96;\n这里为什么要让它变成可调度的&#xff0c;而原来的不行的原因是什么&#xff1f;\n问题已解决&#xff0c;为了解决用户态程序while(1)死锁\n我实验中把它删去依然是可以跑出来的\n</md>"}, {"anon": "no", "uid": "jshne0ytr8i4nb", "subject": "按要求实现了lab5前两个练习之后&#xff0c;还是有些相关疑问待解", "created": "2019-04-25T01:04:11Z", "content": "<md>\n* 1.在更新lab5之前代码的部分&#xff0c;do_fork()中&#xff0c;如果不把nr_process简单加一变成 set_links(proc); 在init_main中&#xff0c;报错显示nr_process是3不是2。\n关于这个问题&#xff0c;我先说我看到的部分\n&gt;cptr:表示孩子进程指针\n&gt;yptr:表示最年轻的兄弟进程指针\n&gt;optr:表示最大的兄弟进程指针\n在do_wait()中&#xff0c;涉及到了这三个指针\n&#96;&#96;&#96;c&#43;&#43;\n    if (pid != 0)\n    {\n        proc = find_proc(pid);\n        if (proc != NULL &amp;&amp; proc-&gt;parent == current)\n        {\n            haskid = 1;\n            if (proc-&gt;state == PROC_ZOMBIE)\n            {\n                goto found;\n            }\n        }\n    }\n    else\n    {\n        proc = current-&gt;cptr;\n        for (; proc != NULL; proc = proc-&gt;optr)\n        {\n            haskid = 1;\n            if (proc-&gt;state == PROC_ZOMBIE)\n            {\n                goto found;\n            }\n        }\n    }\n&#96;&#96;&#96;\n我的理解&#xff0c;作用是去清楚僵尸进程&#xff0c;因为在found中的实现逻辑如下\n&#96;&#96;&#96;c&#43;&#43;\n    if (proc == idleproc || proc == initproc)\n    {\n        panic(&#34;wait idleproc or initproc.\\n&#34;);\n    }\n    if (code_store != NULL)\n    {\n        *code_store = proc-&gt;exit_code;\n    }\n    local_intr_save(intr_flag);\n    {\n        unhash_proc(proc);\n        remove_links(proc);\n    }\n    local_intr_restore(intr_flag);\n    put_kstack(proc);\n    kfree(proc);\n    return 0;\n&#96;&#96;&#96;\n但为什么这里不会报错&#xff0c;反而在init_main中说是3不是2&#xff0c;而又为什么按照原来的写法是3&#xff0c;更新之后才是2了&#xff1f;\n* 2.还是在更新以前的部分&#xff0c;trao.c中&#xff0c;时钟中断要更新为如下代码\n&#96;&#96;&#96;c&#43;&#43;\n    ticks &#43;&#43;;\n        if (ticks % TICK_NUM == 0) {\n            assert(current !=NULL);   //一定是空的吗&#xff1f;因为在内核态吧&#xff1f;\n            current-&gt;need_resched=1;\n        }\n        break;\n&#96;&#96;&#96;\n这里为什么要让它变成可调度的&#xff0c;而原来的不行的原因是什么&#xff1f;\n问题已解决&#xff0c;为了解决用户态程序while(1)死锁\n我实验中把它删去依然是可以跑出来的\n3.练习1中的tf&#xff0c;不是局部变量吗&#xff0c;在return之后不应该就销毁了吗。\n&#96;&#96;&#96;c&#43;&#43;\n    tf-&gt;tf_cs=USER_CS;\n    tf-&gt;tf_ds=tf-&gt;tf_es=tf-&gt;tf_ss=USER_DS;\n    tf-&gt;tf_esp=USTACKTOP;\n    tf-&gt;tf_eip=elf-&gt;e_entry;\n    tf-&gt;tf_eflags=FL_IF;\n    ret = 0;\n&#96;&#96;&#96;\n紧接着就return返回了。\n为什么这样的设置操作可以保留下来呢&#xff1f;\n* 3.用户程序通过ld加载&#xff0c;感觉不符合操作系统的操作&#xff0c;这是我们在编译操作系统的时候可以做的&#xff0c;而操作系统自己却做不了。实验指导书说&#xff0c;lab8将通过文件系统加入&#xff0c;所以这也是真实操作系统做的事吗\n* 4. init内核进程创建子进程&#xff0c;进入user_main&#xff0c;通过宏&#xff0c;传入子名称exit&#xff0c;通过ld加载二进制程序&#xff0c;并在do_execve()中执行&#xff0c;在icode中加载初始化虚拟内存。由于堆栈和虚拟内存都已经建立好了而后返回就进入用户态进程。是这样的吗&#xff1f;我感觉最后一步好像还差点什么&#xff0c;从代码上我还是无从知悉de_execve()函数返回之后去了哪里&#xff0c;用户进程结束之后又如何了&#xff0c;这部分应该看哪些代码呢&#xff1f;\n* 5.在练习2的最后一步\npage_insert(to, npage, start,  perm);\n这个表示建立了虚拟地址和物理地址的映射关系&#xff0c;不太理解为什么是这样的\n* 6.copy on write 的设计合理性考量&#xff0c;没有详细实现&#xff0c;分成以下三个部分\n - 在执行do_fork时&#xff0c;子进程的页目录表直接拷贝父进程的页目录表&#xff0c;而不是拷贝内核页目录表&#xff1b;在dup_mmap&#xff0c;只需保留拷贝vma链表的部分&#xff0c;取消调用copy_range来为子进程分配物理内存。\n - 将父进程的内存空间对应的所有Page结构的ref均加1&#xff0c;表示子进程也在使用这些内存\n - 将父子进程的页目录表的写权限取消&#xff0c;这样一旦父子进程执行写操作时&#xff0c;就会发生页面访问异常&#xff0c;进入页面访问异常处理函数中&#xff0c;再进行内存拷贝操作&#xff0c;并恢复页目录表的写权限。\n这样是否就已经足够了\n</md>"}, {"anon": "no", "uid": "jshne0ytr8i4nb", "subject": "按要求实现了lab5前两个练习之后&#xff0c;还是有些相关疑问待解", "created": "2019-04-24T16:23:00Z", "content": "<md>\n* 1.在更新lab5之前代码的部分&#xff0c;do_fork()中&#xff0c;如果不把nr_process简单加一变成 set_links(proc); 在init_main中&#xff0c;报错显示nr_process是3不是2。\n关于这个问题&#xff0c;我先说我看到的部分\n&gt;cptr:表示孩子进程指针\n&gt;yptr:表示最年轻的兄弟进程指针\n&gt;optr:表示最大的兄弟进程指针\n在do_wait()中&#xff0c;涉及到了这三个指针\n&#96;&#96;&#96;c&#43;&#43;\n    if (pid != 0)\n    {\n        proc = find_proc(pid);\n        if (proc != NULL &amp;&amp; proc-&gt;parent == current)\n        {\n            haskid = 1;\n            if (proc-&gt;state == PROC_ZOMBIE)\n            {\n                goto found;\n            }\n        }\n    }\n    else\n    {\n        proc = current-&gt;cptr;\n        for (; proc != NULL; proc = proc-&gt;optr)\n        {\n            haskid = 1;\n            if (proc-&gt;state == PROC_ZOMBIE)\n            {\n                goto found;\n            }\n        }\n    }\n&#96;&#96;&#96;\n我的理解&#xff0c;作用是去清楚僵尸进程&#xff0c;因为在found中的实现逻辑如下\n&#96;&#96;&#96;c&#43;&#43;\n    if (proc == idleproc || proc == initproc)\n    {\n        panic(&#34;wait idleproc or initproc.\\n&#34;);\n    }\n    if (code_store != NULL)\n    {\n        *code_store = proc-&gt;exit_code;\n    }\n    local_intr_save(intr_flag);\n    {\n        unhash_proc(proc);\n        remove_links(proc);\n    }\n    local_intr_restore(intr_flag);\n    put_kstack(proc);\n    kfree(proc);\n    return 0;\n&#96;&#96;&#96;\n但为什么这里不会报错&#xff0c;反而在init_main中说是3不是2&#xff0c;而又为什么按照原来的写法是3&#xff0c;更新之后才是2了&#xff1f;\n* 2.还是在更新以前的部分&#xff0c;trao.c中&#xff0c;时钟中断要更新为如下代码\n&#96;&#96;&#96;c&#43;&#43;\n    ticks &#43;&#43;;\n        if (ticks % TICK_NUM == 0) {\n            assert(current !=NULL);   //一定是空的吗&#xff1f;因为在内核态吧&#xff1f;\n            current-&gt;need_resched=1;\n        }\n        break;\n&#96;&#96;&#96;\n这里为什么要让它变成可调度的&#xff0c;而原来的不行的原因是什么&#xff1f;\n我实验中把它删去依然是可以跑出来的\n3.练习1中的tf&#xff0c;不是局部变量吗&#xff0c;在return之后不应该就销毁了吗。\n&#96;&#96;&#96;c&#43;&#43;\n    tf-&gt;tf_cs=USER_CS;\n    tf-&gt;tf_ds=tf-&gt;tf_es=tf-&gt;tf_ss=USER_DS;\n    tf-&gt;tf_esp=USTACKTOP;\n    tf-&gt;tf_eip=elf-&gt;e_entry;\n    tf-&gt;tf_eflags=FL_IF;\n    ret = 0;\n&#96;&#96;&#96;\n紧接着就return返回了。\n为什么这样的设置操作可以保留下来呢&#xff1f;\n* 3.用户程序通过ld加载&#xff0c;感觉不符合操作系统的操作&#xff0c;这是我们在编译操作系统的时候可以做的&#xff0c;而操作系统自己却做不了。实验指导书说&#xff0c;lab8将通过文件系统加入&#xff0c;所以这也是真实操作系统做的事吗\n* 4. init内核进程创建子进程&#xff0c;进入user_main&#xff0c;通过宏&#xff0c;传入子名称exit&#xff0c;通过ld加载二进制程序&#xff0c;并在do_execve()中执行&#xff0c;在icode中加载初始化虚拟内存。由于堆栈和虚拟内存都已经建立好了而后返回就进入用户态进程。是这样的吗&#xff1f;我感觉最后一步好像还差点什么&#xff0c;从代码上我还是无从知悉de_execve()函数返回之后去了哪里&#xff0c;用户进程结束之后又如何了&#xff0c;这部分应该看哪些代码呢&#xff1f;\n* 5.在练习2的最后一步\npage_insert(to, npage, start,  perm);\n这个表示建立了虚拟地址和物理地址的映射关系&#xff0c;不太理解为什么是这样的\n* 6.copy on write 的设计合理性考量&#xff0c;没有详细实现&#xff0c;分成以下三个部分\n - 在执行do_fork时&#xff0c;子进程的页目录表直接拷贝父进程的页目录表&#xff0c;而不是拷贝内核页目录表&#xff1b;在dup_mmap&#xff0c;只需保留拷贝vma链表的部分&#xff0c;取消调用copy_range来为子进程分配物理内存。\n - 将父进程的内存空间对应的所有Page结构的ref均加1&#xff0c;表示子进程也在使用这些内存\n - 将父子进程的页目录表的写权限取消&#xff0c;这样一旦父子进程执行写操作时&#xff0c;就会发生页面访问异常&#xff0c;进入页面访问异常处理函数中&#xff0c;再进行内存拷贝操作&#xff0c;并恢复页目录表的写权限。\n这样是否就已经足够了\n</md>"}, {"anon": "no", "uid": "jshne0ytr8i4nb", "subject": "按要求实现了lab5前两个练习之后&#xff0c;还是有些相关疑问待解", "created": "2019-04-24T15:45:33Z", "content": "<md>\n* 1.在更新lab5之前代码的部分&#xff0c;do_fork()中&#xff0c;如果不把nr_process简单加一变成 set_links(proc); 在init_main中&#xff0c;报错显示nr_process是3不是2。\n关于这个问题&#xff0c;我先说我看到的部分\n&gt;cptr:表示孩子进程指针\n&gt;yptr:表示最年轻的兄弟进程指针\n&gt;optr:表示最大的兄弟进程指针\n在do_wait()中&#xff0c;涉及到了这三个指针\n&#96;&#96;&#96;c&#43;&#43;\n    if (pid != 0)\n    {\n        proc = find_proc(pid);\n        if (proc != NULL &amp;&amp; proc-&gt;parent == current)\n        {\n            haskid = 1;\n            if (proc-&gt;state == PROC_ZOMBIE)\n            {\n                goto found;\n            }\n        }\n    }\n    else\n    {\n        proc = current-&gt;cptr;\n        for (; proc != NULL; proc = proc-&gt;optr)\n        {\n            haskid = 1;\n            if (proc-&gt;state == PROC_ZOMBIE)\n            {\n                goto found;\n            }\n        }\n    }\n&#96;&#96;&#96;\n我的理解&#xff0c;作用是去清楚僵尸进程&#xff0c;因为在found中的实现逻辑如下\n&#96;&#96;&#96;c&#43;&#43;\n    if (proc == idleproc || proc == initproc)\n    {\n        panic(&#34;wait idleproc or initproc.\\n&#34;);\n    }\n    if (code_store != NULL)\n    {\n        *code_store = proc-&gt;exit_code;\n    }\n    local_intr_save(intr_flag);\n    {\n        unhash_proc(proc);\n        remove_links(proc);\n    }\n    local_intr_restore(intr_flag);\n    put_kstack(proc);\n    kfree(proc);\n    return 0;\n&#96;&#96;&#96;\n但为什么这里不会报错&#xff0c;反而在init_main中说是3不是2&#xff0c;而又为什么按照原来的写法是3&#xff0c;更新之后才是2了&#xff1f;\n* 2.还是在更新以前的部分&#xff0c;trao.c中&#xff0c;时钟中断要更新为如下代码\n&#96;&#96;&#96;c&#43;&#43;\n    ticks &#43;&#43;;\n        if (ticks % TICK_NUM == 0) {\n            assert(current !=NULL);   //一定是空的吗&#xff1f;因为在内核态吧&#xff1f;\n            current-&gt;need_resched=1;\n        }\n        break;\n&#96;&#96;&#96;\n这里为什么要让它变成可调度的&#xff0c;而原来的不行的原因是什么&#xff1f;\n我实验中把它删去依然是可以跑出来的\n3.练习1中的tf&#xff0c;不是局部变量吗&#xff0c;在return之后不应该就销毁了吗。\n&#96;&#96;&#96;c&#43;&#43;\n    tf-&gt;tf_cs=USER_CS;\n    tf-&gt;tf_ds=tf-&gt;tf_es=tf-&gt;tf_ss=USER_DS;\n    tf-&gt;tf_esp=USTACKTOP;\n    tf-&gt;tf_eip=elf-&gt;e_entry;\n    tf-&gt;tf_eflags=FL_IF;\n    ret = 0;\n&#96;&#96;&#96;\n紧接着就return返回了。\n为什么这样的设置操作可以保留下来呢&#xff1f;\n* 3.用户程序通过ld加载&#xff0c;感觉不符合操作系统的操作&#xff0c;这是我们在编译操作系统的时候可以做的&#xff0c;而操作系统自己却做不了。实验指导书说&#xff0c;lab8将通过文件系统加入&#xff0c;所以这也是真实操作系统做的事吗\n* 4. init内核进程创建子进程&#xff0c;进入user_main&#xff0c;通过宏&#xff0c;传入子名称exit&#xff0c;通过ld加载二进制程序&#xff0c;并在do_execve()中执行&#xff0c;在icode中加载初始化虚拟内存。由于堆栈和虚拟内存都已经建立好了而后返回就进入用户态进程。是这样的吗&#xff1f;我感觉最后一步好像还差点什么&#xff0c;从代码上我还是无从知悉de_execve()函数返回之后去了哪里&#xff0c;用户进程结束之后又如何了&#xff0c;这部分应该看哪些代码呢&#xff1f;\n* 5.在练习2的最后一步\npage_insert(to, npage, start,  perm);\n这个表示建立了虚拟地址和物理地址的映射关系&#xff0c;不太理解为什么是这样的\n</md>"}, {"anon": "no", "uid": "jshne0ytr8i4nb", "subject": "按要求实现了lab5前两个练习之后&#xff0c;还是有些相关疑问待解", "created": "2019-04-24T15:38:38Z", "content": "<md>\n* 1.在更新lab5之前代码的部分&#xff0c;do_fork()中&#xff0c;如果不把nr_process简单加一变成 set_links(proc); 在init_main中&#xff0c;报错显示nr_process是3不是2。\n关于这个问题&#xff0c;我先说我看到的部分\n&gt;cptr:表示孩子进程指针\n&gt;yptr:表示最年轻的兄弟进程指针\n&gt;optr:表示最大的兄弟进程指针\n在do_wait()中&#xff0c;涉及到了这三个指针\n&#96;&#96;&#96;c&#43;&#43;\n    if (pid != 0)\n    {\n        proc = find_proc(pid);\n        if (proc != NULL &amp;&amp; proc-&gt;parent == current)\n        {\n            haskid = 1;\n            if (proc-&gt;state == PROC_ZOMBIE)\n            {\n                goto found;\n            }\n        }\n    }\n    else\n    {\n        proc = current-&gt;cptr;\n        for (; proc != NULL; proc = proc-&gt;optr)\n        {\n            haskid = 1;\n            if (proc-&gt;state == PROC_ZOMBIE)\n            {\n                goto found;\n            }\n        }\n    }\n&#96;&#96;&#96;\n我的理解&#xff0c;作用是去清楚僵尸进程&#xff0c;因为在found中的实现逻辑如下\n&#96;&#96;&#96;c&#43;&#43;\n    if (proc == idleproc || proc == initproc)\n    {\n        panic(&#34;wait idleproc or initproc.\\n&#34;);\n    }\n    if (code_store != NULL)\n    {\n        *code_store = proc-&gt;exit_code;\n    }\n    local_intr_save(intr_flag);\n    {\n        unhash_proc(proc);\n        remove_links(proc);\n    }\n    local_intr_restore(intr_flag);\n    put_kstack(proc);\n    kfree(proc);\n    return 0;\n&#96;&#96;&#96;\n但为什么这里不会报错&#xff0c;反而在init_main中说是3不是2&#xff0c;而又为什么按照原来的写法是3&#xff0c;更新之后才是2了&#xff1f;\n* 2.还是在更新以前的部分&#xff0c;trao.c中&#xff0c;时钟中断要更新为如下代码\n&#96;&#96;&#96;c&#43;&#43;\n    ticks &#43;&#43;;\n        if (ticks % TICK_NUM == 0) {\n            assert(current !=NULL);   //一定是空的吗&#xff1f;因为在内核态吧&#xff1f;\n            current-&gt;need_resched=1;\n        }\n        break;\n&#96;&#96;&#96;\n这里为什么要让它变成可调度的&#xff0c;而原来的不行的原因是什么&#xff1f;\n我实验中把它删去依然是可以跑出来的\n3.练习1中的tf&#xff0c;不是局部变量吗&#xff0c;在return之后不应该就销毁了吗。\n&#96;&#96;&#96;c&#43;&#43;\n    tf-&gt;tf_cs=USER_CS;\n    tf-&gt;tf_ds=tf-&gt;tf_es=tf-&gt;tf_ss=USER_DS;\n    tf-&gt;tf_esp=USTACKTOP;\n    tf-&gt;tf_eip=elf-&gt;e_entry;\n    tf-&gt;tf_eflags=FL_IF;\n    ret = 0;\n&#96;&#96;&#96;\n紧接着就return返回了。\n为什么这样的设置操作可以保留下来呢&#xff1f;\n* 3.用户程序通过ld加载&#xff0c;感觉不符合操作系统的操作&#xff0c;这是我们在编译操作系统的时候可以做的&#xff0c;而操作系统自己却做不了。实验指导书说&#xff0c;lab8将通过文件系统加入&#xff0c;所以这也是真实操作系统做的事吗\n* 4. init内核进程创建子进程&#xff0c;进入user_main&#xff0c;通过宏&#xff0c;传入子名称exit&#xff0c;通过ld加载二进制程序&#xff0c;并在do_execve()中执行&#xff0c;在icode中加载初始化虚拟内存。由于堆栈和虚拟内存都已经建立好了而后返回就进入用户态进程。是这样的吗&#xff1f;我感觉最后一步好像还差点什么&#xff0c;从代码上我还是无从知悉de_execve()函数返回之后去了哪里&#xff0c;用户进程结束之后又如何了&#xff0c;这部分应该看哪些代码呢&#xff1f;\n</md>"}, {"anon": "no", "uid": "jshne0ytr8i4nb", "subject": "按要求实现了lab5前两个练习之后&#xff0c;还是有些相关疑问待解", "created": "2019-04-24T15:30:52Z", "content": "<md>\n* 1.在更新lab5之前代码的部分&#xff0c;do_fork()中&#xff0c;如果不把nr_process简单加一变成 set_links(proc); 在init_main中&#xff0c;报错显示nr_process是3不是2。\n关于这个问题&#xff0c;我先说我看到的部分\n&gt;cptr:表示孩子进程指针\n&gt;yptr:表示最年轻的兄弟进程指针\n&gt;optr:表示最大的兄弟进程指针\n在do_wait()中&#xff0c;涉及到了这三个指针\n&#96;&#96;&#96;c&#43;&#43;\n    if (pid != 0)\n    {\n        proc = find_proc(pid);\n        if (proc != NULL &amp;&amp; proc-&gt;parent == current)\n        {\n            haskid = 1;\n            if (proc-&gt;state == PROC_ZOMBIE)\n            {\n                goto found;\n            }\n        }\n    }\n    else\n    {\n        proc = current-&gt;cptr;\n        for (; proc != NULL; proc = proc-&gt;optr)\n        {\n            haskid = 1;\n            if (proc-&gt;state == PROC_ZOMBIE)\n            {\n                goto found;\n            }\n        }\n    }\n&#96;&#96;&#96;\n我的理解&#xff0c;作用是去清楚僵尸进程&#xff0c;因为在found中的实现逻辑如下\n&#96;&#96;&#96;c&#43;&#43;\n    if (proc == idleproc || proc == initproc)\n    {\n        panic(&#34;wait idleproc or initproc.\\n&#34;);\n    }\n    if (code_store != NULL)\n    {\n        *code_store = proc-&gt;exit_code;\n    }\n    local_intr_save(intr_flag);\n    {\n        unhash_proc(proc);\n        remove_links(proc);\n    }\n    local_intr_restore(intr_flag);\n    put_kstack(proc);\n    kfree(proc);\n    return 0;\n&#96;&#96;&#96;\n但为什么这里不会报错&#xff0c;反而在init_main中说是3不是2&#xff0c;而又为什么按照原来的写法是3&#xff0c;更新之后才是2了&#xff1f;\n* 2.还是在更新以前的部分&#xff0c;trao.c中&#xff0c;时钟中断要更新为如下代码\n&#96;&#96;&#96;c&#43;&#43;\n    ticks &#43;&#43;;\n        if (ticks % TICK_NUM == 0) {\n            assert(current !=NULL);   //一定是空的吗&#xff1f;因为在内核态吧&#xff1f;\n            current-&gt;need_resched=1;\n        }\n        break;\n&#96;&#96;&#96;\n这里为什么要让它变成可调度的&#xff0c;而原来的不行的原因是什么&#xff1f;\n我实验中把它删去依然是可以跑出来的\n3.练习1中的tf&#xff0c;不是局部变量吗&#xff0c;在return之后不应该就销毁了吗。\n&#96;&#96;&#96;c&#43;&#43;\n    tf-&gt;tf_cs=USER_CS;\n    tf-&gt;tf_ds=tf-&gt;tf_es=tf-&gt;tf_ss=USER_DS;\n    tf-&gt;tf_esp=USTACKTOP;\n    tf-&gt;tf_eip=elf-&gt;e_entry;\n    tf-&gt;tf_eflags=FL_IF;\n    ret = 0;\n&#96;&#96;&#96;\n紧接着就return返回了。\n为什么这样的设置操作可以保留下来呢&#xff1f;\n* 3.用户程序通过ld加载&#xff0c;感觉不符合操作系统的操作&#xff0c;这是我们在编译操作系统的时候可以做的&#xff0c;而操作系统自己却做不了。实验指导书说&#xff0c;lab8将通过文件系统加入&#xff0c;所以这也是真实操作系统做的事吗\n</md>"}, {"anon": "no", "uid": "jshne0ytr8i4nb", "subject": "按要求实现了lab5前两个练习之后&#xff0c;还是有些相关疑问待解", "created": "2019-04-24T15:20:48Z", "content": "<md>\n* 1.在更新lab5之前代码的部分&#xff0c;do_fork()中&#xff0c;如果不把nr_process简单加一变成 set_links(proc); 在init_main中&#xff0c;报错显示nr_process是3不是2。\n关于这个问题&#xff0c;我先说我看到的部分\n&gt;cptr:表示孩子进程指针\n&gt;yptr:表示最年轻的兄弟进程指针\n&gt;optr:表示最大的兄弟进程指针\n在do_wait()中&#xff0c;涉及到了这三个指针\n&#96;&#96;&#96;c&#43;&#43;\n    if (pid != 0)\n    {\n        proc = find_proc(pid);\n        if (proc != NULL &amp;&amp; proc-&gt;parent == current)\n        {\n            haskid = 1;\n            if (proc-&gt;state == PROC_ZOMBIE)\n            {\n                goto found;\n            }\n        }\n    }\n    else\n    {\n        proc = current-&gt;cptr;\n        for (; proc != NULL; proc = proc-&gt;optr)\n        {\n            haskid = 1;\n            if (proc-&gt;state == PROC_ZOMBIE)\n            {\n                goto found;\n            }\n        }\n    }\n&#96;&#96;&#96;\n我的理解&#xff0c;作用是去清楚僵尸进程&#xff0c;因为在found中的实现逻辑如下\n&#96;&#96;&#96;c&#43;&#43;\n    if (proc == idleproc || proc == initproc)\n    {\n        panic(&#34;wait idleproc or initproc.\\n&#34;);\n    }\n    if (code_store != NULL)\n    {\n        *code_store = proc-&gt;exit_code;\n    }\n    local_intr_save(intr_flag);\n    {\n        unhash_proc(proc);\n        remove_links(proc);\n    }\n    local_intr_restore(intr_flag);\n    put_kstack(proc);\n    kfree(proc);\n    return 0;\n&#96;&#96;&#96;\n但为什么这里不会报错&#xff0c;反而在init_main中说是3不是2&#xff0c;而又为什么按照原来的写法是3&#xff0c;更新之后才是2了&#xff1f;\n* 2.还是在更新以前的部分&#xff0c;trao.c中&#xff0c;时钟中断要更新为如下代码\n&#96;&#96;&#96;c&#43;&#43;\n    ticks &#43;&#43;;\n        if (ticks % TICK_NUM == 0) {\n            assert(current !=NULL);   //一定是空的吗&#xff1f;因为在内核态吧&#xff1f;\n            current-&gt;need_resched=1;\n        }\n        break;\n&#96;&#96;&#96;\n这里为什么要让它变成可调度的&#xff0c;而原来的不行的原因是什么&#xff1f;\n我实验中把它删去依然是可以跑出来的\n3.练习1中的tf&#xff0c;不是局部变量吗&#xff0c;在return之后不应该就销毁了吗。\n&#96;&#96;&#96;c&#43;&#43;\n    tf-&gt;tf_cs=USER_CS;\n    tf-&gt;tf_ds=tf-&gt;tf_es=tf-&gt;tf_ss=USER_DS;\n    tf-&gt;tf_esp=USTACKTOP;\n    tf-&gt;tf_eip=elf-&gt;e_entry;\n    tf-&gt;tf_eflags=FL_IF;\n    ret = 0;\n&#96;&#96;&#96;\n紧接着就return返回了。\n为什么这样的设置操作可以保留下来呢&#xff1f;\n</md>"}, {"anon": "no", "uid": "jshne0ytr8i4nb", "subject": "按要求实现了lab5前两个练习之后&#xff0c;还是有些相关疑问待解", "created": "2019-04-24T15:07:51Z", "content": "<md>\n* 1.在更新lab5之前代码的部分&#xff0c;do_fork()中&#xff0c;如果不把nr_process简单加一变成 set_links(proc); 在init_main中&#xff0c;报错显示nr_process是3不是2。\n关于这个问题&#xff0c;我先说我看到的部分\n&gt;cptr:表示孩子进程指针\n&gt;yptr:表示最年轻的兄弟进程指针\n&gt;optr:表示最大的兄弟进程指针\n在do_wait()中&#xff0c;涉及到了这三个指针\n&#96;&#96;&#96;c&#43;&#43;\n    if (pid != 0)\n    {\n        proc = find_proc(pid);\n        if (proc != NULL &amp;&amp; proc-&gt;parent == current)\n        {\n            haskid = 1;\n            if (proc-&gt;state == PROC_ZOMBIE)\n            {\n                goto found;\n            }\n        }\n    }\n    else\n    {\n        proc = current-&gt;cptr;\n        for (; proc != NULL; proc = proc-&gt;optr)\n        {\n            haskid = 1;\n            if (proc-&gt;state == PROC_ZOMBIE)\n            {\n                goto found;\n            }\n        }\n    }\n&#96;&#96;&#96;\n我的理解&#xff0c;作用是去清楚僵尸进程&#xff0c;因为在found中的实现逻辑如下\n&#96;&#96;&#96;c&#43;&#43;\n    if (proc == idleproc || proc == initproc)\n    {\n        panic(&#34;wait idleproc or initproc.\\n&#34;);\n    }\n    if (code_store != NULL)\n    {\n        *code_store = proc-&gt;exit_code;\n    }\n    local_intr_save(intr_flag);\n    {\n        unhash_proc(proc);\n        remove_links(proc);\n    }\n    local_intr_restore(intr_flag);\n    put_kstack(proc);\n    kfree(proc);\n    return 0;\n&#96;&#96;&#96;\n但为什么这里不会报错&#xff0c;反而在init_main中说是3不是2&#xff0c;而又为什么按照原来的写法是3&#xff0c;更新之后才是2了&#xff1f;\n* 2.还是在更新以前的部分&#xff0c;trao.c中&#xff0c;时钟中断要更新为如下代码\n&#96;&#96;&#96;c&#43;&#43;\n    ticks &#43;&#43;;\n        if (ticks % TICK_NUM == 0) {\n            assert(current !=NULL);   //一定是空的吗&#xff1f;因为在内核态吧&#xff1f;\n            current-&gt;need_resched=1;\n        }\n        break;\n&#96;&#96;&#96;\n这里为什么要让它变成可调度的&#xff0c;而原来的不行的原因是什么&#xff1f;\n我实验中把它删去依然是可以跑出来的\n</md>"}], "type": "question", "tags": ["lecture14", "student", "unanswered"], "tag_good": [], "unique_views": 124, "children": [], "tag_good_arr": [], "no_answer": 1, "id": "juvcrdftbp41c3", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 1, "num_favorites": 0, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169729776, "default_anonymity": "no"}, "error": null, "aid": "kyv0txwwam05xz"}