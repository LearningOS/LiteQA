{"result": {"folders": ["lecture12"], "nr": 1438, "data": {"embed_links": []}, "created": "2020-03-29T07:28:36Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "k6pwue0ugaw6jo", "data": "k8cq2e1rgk8fu", "type": "create", "when": "2020-03-29T07:28:36Z"}, {"anon": "no", "uid": "k6pwue0ugaw6jo", "data": "k8cq45ys5zy1bd", "type": "update", "when": "2020-03-29T07:29:59Z"}, {"anon": "no", "uid": "k6pwue0ugaw6jo", "data": "k8dwwb4wuln7ds", "type": "update", "when": "2020-03-30T03:27:36Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "k6pwue0ugaw6jo", "subject": "Linux O(1) 调度梳理", "created": "2020-03-30T03:27:36Z", "content": "<md>### 2.4 scheduler 的问题\n\nLinux 2.4 scheduler 支持 SMP&#xff08;Symmetric Multi-Processing&#xff09;&#xff0c;然而&#xff0c;由于只用一个 global runqueue&#xff0c;各个 core 需要竞争同一个 runqueue 里面的任务&#xff0c;所以可伸缩性&#xff08;scalability&#xff09;不好。这个问题 2.6 O(1) scheduler 用 per core runqueue 解决这个问题。\n\nglobal runqueue 带来的性能问题其实还可以忍受&#xff0c;毕竟只是在 dequeue 的过程需要加锁&#xff1b;接下来这个问题&#xff0c;就很要命 —— 2.4 scheduler 的时间复杂度是 O(N)。我们知道&#xff0c;现代操作系统都能运行成千上万个进程&#xff0c;O(N) 的算法意味着每次调度时&#xff0c;对于当前执行完的 process&#xff0c;需要把所有在 expired queue 中的 process 过一遍&#xff0c;找到合适的位置插入。这不仅仅会带来性能上的巨大损失&#xff0c;还使得系统的调度时间非常不确定 —— 根据系统的负载&#xff0c;可能有数倍甚至数百倍的差异。我们知道&#xff0c;不确定性是软件系统的大敌&#xff0c;尤其是实时系统。\n\n&#xff08;2.4 scheduler 维护两个 queue&#xff1a;runqueue 和 expired queue。两个 queue 都永远保持有序&#xff0c;一个 process 用完时间片&#xff0c;就会被插入 expired queue&#xff1b;当 runqueue 为空时&#xff0c;只需要把 runqueue 和 expired queue 交换一下即可。&#xff09;\n\n注意&#xff0c;所有调度系统的难点不在于寻找下一个可执行的 process&#xff0c;这个操作一般都是 O(1)&#xff0c;因为我们只要妥善对 runqueue 排序&#xff0c;使其第一个 process 永远是下次需要调度的 process 即可。难点在于执行完的 process —— 怎样插入到合适的位置使得 runqueue 是有序的&#xff1f;\n\n### 满足 O(1) 的数据结构\n\n根据我们在数据结构课程里学到的知识可以知道&#xff0c;大多数算法的时间复杂度&#xff0c;O(log N) 基本上就是最好的结果&#xff0c;那么&#xff0c;2.6 的 O(1) scheduler 是怎么做到的&#xff1f;\n\n在回答这个问题之前&#xff0c;我们先回顾一下数据结构的四种基本操作以及其时间复杂度&#xff1a;\n\naccess&#xff1a;随机访问。array 是唯一能够达到&#xff0c;且平均情况和最坏情况均能达到 O(1) 随机访问的数据结构。其它的结构&#xff0c;linked list 是 O(N)&#xff0c;tree 一般是 O(log N)。\n\nsearch&#xff1a;搜索。谈到搜索&#xff0c;大家第一反应是 hash table 是 O(1) 时间复杂度的。然而&#xff0c;它在最坏情况下是 O(N) 的。除此之外&#xff0c;没有任何算法能在最坏情况下 search 也是 O(1)。大部分 tree&#xff08;b-tree / red-black tree&#xff09;平均和最坏情况都是 O(log N)&#xff0c;其实很不错了。\n\ninsert/deletion&#xff1a;插入和删除。插入删除是对等的操作&#xff0c;这里放在一起讲。linked list&#xff0c;stack&#xff0c;queue 在平均和最坏情况下都是 O(1)&#xff0c;而大家脑海里的 hash table&#xff0c;同样的&#xff0c;虽然平均是 O(1)&#xff0c;但最坏情况是 O(N)。大部分 tree&#xff08;b-tree / red-black tree&#xff09;平均和最坏情况都是 O(log N)&#xff0c;也还不错。\n\n所以我们看到&#xff0c;如果想要达成 O(1) scheduler 的目标&#xff0c;操作只能包含纯粹的 access&#xff0c;insert 和 deletion。一定不能有 search。2.4 scheduler 在将执行完的 process insert 回 expired queue 时使用 search&#xff0c;大大拉低整个算法的时间复杂度。这是其一。\n\n此外&#xff0c;对于 scheduler&#xff0c;我们选择算法&#xff0c;尽量要选择平均情况和最坏情况表现一致的算法。如果平均情况是 O(1)&#xff0c;最坏情况是 O(n)&#xff0c;那么这个 scheduler 会给系统带来很大的不确定性&#xff0c;这很伤脑筋 —— 毕竟谁也不愿意面对一个大部分时候表现乖巧&#xff0c;极端情况抽风到不可理喻的系统。这是其二。\n\n在这两个先决条件下&#xff0c;我们可选择的范围就很窄 —— access 只能用 array&#xff0c;insert / deletion 只能用 linked list / queue / stack。\n\n接下来&#xff0c;我们把调度的场景简化一下&#xff1a;假设系统中有六个 process&#xff0c;三种优先级&#xff1a;high&#xff0c;medium&#xff0c;low。没有 preemption&#xff0c;严格按照优先级的顺序执行 process。那么&#xff0c;我们怎么组合上述的数据结构&#xff0c;让 scheduling 是 O(1) 的&#xff1f;\n\n### 2.6 O(1) scheduler\n\n2.6 kernel 里有 140 种优先级&#xff0c;所以我们就用长度为 140 的 array 去记录优先级。每个优先级下面用一个 FIFO queue 管理这个优先级下的 process。新来的插到队尾&#xff0c;先进先出。在这种情况下&#xff0c;insert / deletion 都是 O(1)。\n\n那么&#xff0c;我们怎么找到当前最高优先级下面的可执行的 process 呢&#xff1f;如果从 0 开始一直遍历下去&#xff0c;算法虽然不是 O(N)&#xff0c;但是是跟优先级多寡相关的 O(M)&#xff0c;也不能算作 O(1)。在 2.6 scheduler 里&#xff0c;聪明的先贤们采用 bitarray。它为每种优先级分配一个 bit&#xff0c;如果这个优先级队列下面有 process&#xff0c;那么就对相应的 bit 染色&#xff0c;置为 1&#xff0c;否则置为 0。这样&#xff0c;问题就简化成寻找一个 bitarray 里面最高位是 1 的 bit&#xff08;left-most bit&#xff09;&#xff0c;这基本上是一条 CPU 指令的事&#xff08;fls&#xff09;。\n\n好&#xff0c;大致的思路齐备&#xff0c;我们来捋一捋完整的步骤&#xff1a;\n1. 在 active bitarray 里&#xff0c;寻找 left-most bit 的位置 x。\n2. 在 active priority array&#xff08;APA&#xff09;中&#xff0c;找到对应队列 APA[x]。\n3. 从 APA[x] 中 dequeue 一个 process&#xff0c;dequeue 后&#xff0c;如果 APA[x] 的 queue 为空&#xff0c;那么将 active bitarray 里第 x bit置为 0。\n4. 对于当前执行完的 process&#xff0c;重新计算其 priority&#xff0c;然后 enqueue 到 expired priority array&#xff08;EPA&#xff09;相应的队里 EPA[priority]。\n5. 如果 priority 在 expired bitarray 里对应的 bit 为 0&#xff0c;将其置 1。\n6. 如果 active bitarray 全为零&#xff0c;将 active bitarray 和 expired bitarray 交换一下。\n\n当然&#xff0c;这里面还有一些细节&#xff0c;比如如果是 process 被抢占&#xff0c;其时间片没用完&#xff0c;那么第 4 步&#xff0c;enqueue 回 active priority queue 中。\n\n### 补充\n我们说&#xff0c;kernel 里有 140 种优先级&#xff0c;所以我们就用长度为 140 的 array 去记录优先级。每个优先级下面用一个 FIFO queue 管理这个优先级下的 process。新来的插到队尾&#xff0c;先进先出。在这种情况下&#xff0c;insert / deletion 都是 O(1)。这是不太准确的&#xff0c;其不是数学上严格意义的O(1)&#xff0c;因为此时优先级数量&#xff0c;计算机字长都是固定的&#xff0c;如果我们设定优先级为N种&#xff0c;计算机字长为M&#xff0c;那么准确地来说&#xff0c;nsert / deletion 的时间复杂度为O(N/M)。\n\n\n### 题外话\n\n2.6 O(1) scheduler 目前已经被性能略输一筹&#xff0c;同时更加强调公平性的 CFS&#xff08;Completely Fair Scheduler&#xff09;取代&#xff0c;但其以独特的设计&#xff0c;简单的算法&#xff0c;影响很多系统。\n在其刚问世时&#xff0c;很多 linux 发行版就迫不及待将其移植回 2.4 kernel&#xff0c;另外&#xff0c;在许多操作系统的调度器中&#xff0c;都能见到 bitarray &#43; priority queue 的身影。\n它让我感慨算法之美&#xff0c;同时也告诉我&#xff1a;你手中即便拿着一副并不那么出众的牌&#xff0c;历经辗转腾挪&#xff0c;也能打出精彩。\n\n\n</md>"}, {"anon": "no", "uid": "k6pwue0ugaw6jo", "subject": "Linux O(1) 调度梳理", "created": "2020-03-29T07:29:59Z", "content": "<md>### 2.4 scheduler 的问题\n\nLinux 2.4 scheduler 支持 SMP&#xff08;Symmetric Multi-Processing&#xff09;&#xff0c;然而&#xff0c;由于只用一个 global runqueue&#xff0c;各个 core 需要竞争同一个 runqueue 里面的任务&#xff0c;所以可伸缩性&#xff08;scalability&#xff09;不好。这个问题 2.6 O(1) scheduler 用 per core runqueue 解决这个问题。\n\nglobal runqueue 带来的性能问题其实还可以忍受&#xff0c;毕竟只是在 dequeue 的过程需要加锁&#xff1b;接下来这个问题&#xff0c;就很要命 —— 2.4 scheduler 的时间复杂度是 O(N)。我们知道&#xff0c;现代操作系统都能运行成千上万个进程&#xff0c;O(N) 的算法意味着每次调度时&#xff0c;对于当前执行完的 process&#xff0c;需要把所有在 expired queue 中的 process 过一遍&#xff0c;找到合适的位置插入。这不仅仅会带来性能上的巨大损失&#xff0c;还使得系统的调度时间非常不确定 —— 根据系统的负载&#xff0c;可能有数倍甚至数百倍的差异。我们知道&#xff0c;不确定性是软件系统的大敌&#xff0c;尤其是实时系统。\n\n&#xff08;2.4 scheduler 维护两个 queue&#xff1a;runqueue 和 expired queue。两个 queue 都永远保持有序&#xff0c;一个 process 用完时间片&#xff0c;就会被插入 expired queue&#xff1b;当 runqueue 为空时&#xff0c;只需要把 runqueue 和 expired queue 交换一下即可。&#xff09;\n\n注意&#xff0c;所有调度系统的难点不在于寻找下一个可执行的 process&#xff0c;这个操作一般都是 O(1)&#xff0c;因为我们只要妥善对 runqueue 排序&#xff0c;使其第一个 process 永远是下次需要调度的 process 即可。难点在于执行完的 process —— 怎样插入到合适的位置使得 runqueue 是有序的&#xff1f;\n\n### 满足 O(1) 的数据结构\n\n根据我们在数据结构课程里学到的知识可以知道&#xff0c;大多数算法的时间复杂度&#xff0c;O(log N) 基本上就是最好的结果&#xff0c;那么&#xff0c;2.6 的 O(1) scheduler 是怎么做到的&#xff1f;\n\n在回答这个问题之前&#xff0c;我们先回顾一下数据结构的四种基本操作以及其时间复杂度&#xff1a;\n\naccess&#xff1a;随机访问。array 是唯一能够达到&#xff0c;且平均情况和最坏情况均能达到 O(1) 随机访问的数据结构。其它的结构&#xff0c;linked list 是 O(N)&#xff0c;tree 一般是 O(log N)。\n\nsearch&#xff1a;搜索。谈到搜索&#xff0c;大家第一反应是 hash table 是 O(1) 时间复杂度的。然而&#xff0c;它在最坏情况下是 O(N) 的。除此之外&#xff0c;没有任何算法能在最坏情况下 search 也是 O(1)。大部分 tree&#xff08;b-tree / red-black tree&#xff09;平均和最坏情况都是 O(log N)&#xff0c;其实很不错了。\n\ninsert/deletion&#xff1a;插入和删除。插入删除是对等的操作&#xff0c;这里放在一起讲。linked list&#xff0c;stack&#xff0c;queue 在平均和最坏情况下都是 O(1)&#xff0c;而大家脑海里的 hash table&#xff0c;同样的&#xff0c;虽然平均是 O(1)&#xff0c;但最坏情况是 O(N)。大部分 tree&#xff08;b-tree / red-black tree&#xff09;平均和最坏情况都是 O(log N)&#xff0c;也还不错。\n\n所以我们看到&#xff0c;如果想要达成 O(1) scheduler 的目标&#xff0c;操作只能包含纯粹的 access&#xff0c;insert 和 deletion。一定不能有 search。2.4 scheduler 在将执行完的 process insert 回 expired queue 时使用 search&#xff0c;大大拉低整个算法的时间复杂度。这是其一。\n\n此外&#xff0c;对于 scheduler&#xff0c;我们选择算法&#xff0c;尽量要选择平均情况和最坏情况表现一致的算法。如果平均情况是 O(1)&#xff0c;最坏情况是 O(n)&#xff0c;那么这个 scheduler 会给系统带来很大的不确定性&#xff0c;这很伤脑筋 —— 毕竟谁也不愿意面对一个大部分时候表现乖巧&#xff0c;极端情况抽风到不可理喻的系统。这是其二。\n\n在这两个先决条件下&#xff0c;我们可选择的范围就很窄 —— access 只能用 array&#xff0c;insert / deletion 只能用 linked list / queue / stack。\n\n接下来&#xff0c;我们把调度的场景简化一下&#xff1a;假设系统中有六个 process&#xff0c;三种优先级&#xff1a;high&#xff0c;medium&#xff0c;low。没有 preemption&#xff0c;严格按照优先级的顺序执行 process。那么&#xff0c;我们怎么组合上述的数据结构&#xff0c;让 scheduling 是 O(1) 的&#xff1f;\n\n### 2.6 O(1) scheduler\n\n2.6 kernel 里有 140 种优先级&#xff0c;所以我们就用长度为 140 的 array 去记录优先级。每个优先级下面用一个 FIFO queue 管理这个优先级下的 process。新来的插到队尾&#xff0c;先进先出。在这种情况下&#xff0c;insert / deletion 都是 O(1)。\n\n那么&#xff0c;我们怎么找到当前最高优先级下面的可执行的 process 呢&#xff1f;如果从 0 开始一直遍历下去&#xff0c;算法虽然不是 O(N)&#xff0c;但是是跟优先级多寡相关的 O(M)&#xff0c;也不能算作 O(1)。在 2.6 scheduler 里&#xff0c;聪明的先贤们采用 bitarray。它为每种优先级分配一个 bit&#xff0c;如果这个优先级队列下面有 process&#xff0c;那么就对相应的 bit 染色&#xff0c;置为 1&#xff0c;否则置为 0。这样&#xff0c;问题就简化成寻找一个 bitarray 里面最高位是 1 的 bit&#xff08;left-most bit&#xff09;&#xff0c;这基本上是一条 CPU 指令的事&#xff08;fls&#xff09;。\n\n好&#xff0c;大致的思路齐备&#xff0c;我们来捋一捋完整的步骤&#xff1a;\n1. 在 active bitarray 里&#xff0c;寻找 left-most bit 的位置 x。\n2. 在 active priority array&#xff08;APA&#xff09;中&#xff0c;找到对应队列 APA[x]。\n3. 从 APA[x] 中 dequeue 一个 process&#xff0c;dequeue 后&#xff0c;如果 APA[x] 的 queue 为空&#xff0c;那么将 active bitarray 里第 x bit置为 0。\n4. 对于当前执行完的 process&#xff0c;重新计算其 priority&#xff0c;然后 enqueue 到 expired priority array&#xff08;EPA&#xff09;相应的队里 EPA[priority]。\n5. 如果 priority 在 expired bitarray 里对应的 bit 为 0&#xff0c;将其置 1。\n6. 如果 active bitarray 全为零&#xff0c;将 active bitarray 和 expired bitarray 交换一下。\n\n当然&#xff0c;这里面还有一些细节&#xff0c;比如如果是 process 被抢占&#xff0c;其时间片没用完&#xff0c;那么第 4 步&#xff0c;enqueue 回 active priority queue 中。\n\n### 题外话\n\n2.6 O(1) scheduler 目前已经被性能略输一筹&#xff0c;同时更加强调公平性的 CFS&#xff08;Completely Fair Scheduler&#xff09;取代&#xff0c;但其以独特的设计&#xff0c;简单的算法&#xff0c;影响很多系统。\n在其刚问世时&#xff0c;很多 linux 发行版就迫不及待将其移植回 2.4 kernel&#xff0c;另外&#xff0c;在许多操作系统的调度器中&#xff0c;都能见到 bitarray &#43; priority queue 的身影。\n它让我感慨算法之美&#xff0c;同时也告诉我&#xff1a;你手中即便拿着一副并不那么出众的牌&#xff0c;历经辗转腾挪&#xff0c;也能打出精彩。\n\n\n</md>"}, {"anon": "no", "uid": "k6pwue0ugaw6jo", "subject": "Linux O(1) 调度梳理", "created": "2020-03-29T07:28:36Z", "content": "<md>### 2.4 scheduler 的问题\n\nLinux 2.4 scheduler 支持 SMP&#xff08;Symmetric Multi-Processing&#xff09;&#xff0c;然而&#xff0c;由于只用一个 global runqueue&#xff0c;各个 core 需要竞争同一个 runqueue 里面的任务&#xff0c;所以可伸缩性&#xff08;scalability&#xff09;不好。这个问题 2.6 O(1) scheduler 用 per core runqueue 解决这个问题。\n\nglobal runqueue 带来的性能问题其实还可以忍受&#xff0c;毕竟只是在 dequeue 的过程需要加锁&#xff1b;接下来这个问题&#xff0c;就很要命 —— 2.4 scheduler 的时间复杂度是 O(N)。我们知道&#xff0c;现代操作系统都能运行成千上万个进程&#xff0c;O(N) 的算法意味着每次调度时&#xff0c;对于当前执行完的 process&#xff0c;需要把所有在 expired queue 中的 process 过一遍&#xff0c;找到合适的位置插入。这不仅仅会带来性能上的巨大损失&#xff0c;还使得系统的调度时间非常不确定 —— 根据系统的负载&#xff0c;可能有数倍甚至数百倍的差异。我们知道&#xff0c;不确定性是软件系统的大敌&#xff0c;尤其是实时系统。\n\n&#xff08;2.4 scheduler 维护两个 queue&#xff1a;runqueue 和 expired queue。两个 queue 都永远保持有序&#xff0c;一个 process 用完时间片&#xff0c;就会被插入 expired queue&#xff1b;当 runqueue 为空时&#xff0c;只需要把 runqueue 和 expired queue 交换一下即可。&#xff09;\n\n注意&#xff0c;所有调度系统的难点不在于寻找下一个可执行的 process&#xff0c;这个操作一般都是 O(1)&#xff0c;因为我们只要妥善对 runqueue 排序&#xff0c;使其第一个 process 永远是下次需要调度的 process 即可。难点在于执行完的 process —— 怎样插入到合适的位置使得 runqueue 是有序的&#xff1f;\n\n### 满足 O(1) 的数据结构&#xff1f;\n\n根据我们在数据结构课程里学到的知识可以知道&#xff0c;大多数算法的时间复杂度&#xff0c;O(log N) 基本上就是最好的结果&#xff0c;那么&#xff0c;2.6 的 O(1) scheduler 是怎么做到的&#xff1f;\n\n在回答这个问题之前&#xff0c;我们先回顾一下数据结构的四种基本操作以及其时间复杂度&#xff1a;\n\naccess&#xff1a;随机访问。array 是唯一能够达到&#xff0c;且平均情况和最坏情况均能达到 O(1) 随机访问的数据结构。其它的结构&#xff0c;linked list 是 O(N)&#xff0c;tree 一般是 O(log N)。\n\nsearch&#xff1a;搜索。谈到搜索&#xff0c;大家第一反应是 hash table 是 O(1) 时间复杂度的。然而&#xff0c;它在最坏情况下是 O(N) 的。除此之外&#xff0c;没有任何算法能在最坏情况下 search 也是 O(1)。大部分 tree&#xff08;b-tree / red-black tree&#xff09;平均和最坏情况都是 O(log N)&#xff0c;其实很不错了。\n\ninsert/deletion&#xff1a;插入和删除。插入删除是对等的操作&#xff0c;这里放在一起讲。linked list&#xff0c;stack&#xff0c;queue 在平均和最坏情况下都是 O(1)&#xff0c;而大家脑海里的 hash table&#xff0c;同样的&#xff0c;虽然平均是 O(1)&#xff0c;但最坏情况是 O(N)。大部分 tree&#xff08;b-tree / red-black tree&#xff09;平均和最坏情况都是 O(log N)&#xff0c;也还不错。\n\n所以我们看到&#xff0c;如果想要达成 O(1) scheduler 的目标&#xff0c;操作只能包含纯粹的 access&#xff0c;insert 和 deletion。一定不能有 search。2.4 scheduler 在将执行完的 process insert 回 expired queue 时使用 search&#xff0c;大大拉低整个算法的时间复杂度。这是其一。\n\n此外&#xff0c;对于 scheduler&#xff0c;我们选择算法&#xff0c;尽量要选择平均情况和最坏情况表现一致的算法。如果平均情况是 O(1)&#xff0c;最坏情况是 O(n)&#xff0c;那么这个 scheduler 会给系统带来很大的不确定性&#xff0c;这很伤脑筋 —— 毕竟谁也不愿意面对一个大部分时候表现乖巧&#xff0c;极端情况抽风到不可理喻的系统。这是其二。\n\n在这两个先决条件下&#xff0c;我们可选择的范围就很窄 —— access 只能用 array&#xff0c;insert / deletion 只能用 linked list / queue / stack。\n\n接下来&#xff0c;我们把调度的场景简化一下&#xff1a;假设系统中有六个 process&#xff0c;三种优先级&#xff1a;high&#xff0c;medium&#xff0c;low。没有 preemption&#xff0c;严格按照优先级的顺序执行 process。那么&#xff0c;我们怎么组合上述的数据结构&#xff0c;让 scheduling 是 O(1) 的&#xff1f;\n\n### 2.6 O(1) scheduler\n\n2.6 kernel 里有 140 种优先级&#xff0c;所以我们就用长度为 140 的 array 去记录优先级。每个优先级下面用一个 FIFO queue 管理这个优先级下的 process。新来的插到队尾&#xff0c;先进先出。在这种情况下&#xff0c;insert / deletion 都是 O(1)。\n\n那么&#xff0c;我们怎么找到当前最高优先级下面的可执行的 process 呢&#xff1f;如果从 0 开始一直遍历下去&#xff0c;算法虽然不是 O(N)&#xff0c;但是是跟优先级多寡相关的 O(M)&#xff0c;也不能算作 O(1)。在 2.6 scheduler 里&#xff0c;聪明的先贤们采用 bitarray。它为每种优先级分配一个 bit&#xff0c;如果这个优先级队列下面有 process&#xff0c;那么就对相应的 bit 染色&#xff0c;置为 1&#xff0c;否则置为 0。这样&#xff0c;问题就简化成寻找一个 bitarray 里面最高位是 1 的 bit&#xff08;left-most bit&#xff09;&#xff0c;这基本上是一条 CPU 指令的事&#xff08;fls&#xff09;。\n\n好&#xff0c;大致的思路齐备&#xff0c;我们来捋一捋完整的步骤&#xff1a;\n\n1. 在 active bitarray 里&#xff0c;寻找 left-most bit 的位置 x。\n2. 在 active priority array&#xff08;APA&#xff09;中&#xff0c;找到对应队列 APA[x]。\n3. 从 APA[x] 中 dequeue 一个 process&#xff0c;dequeue 后&#xff0c;如果 APA[x] 的 queue 为空&#xff0c;那么将 active bitarray 里第 x bit置为 0。\n4. 对于当前执行完的 process&#xff0c;重新计算其 priority&#xff0c;然后 enqueue 到 expired priority array&#xff08;EPA&#xff09;相应的队里 EPA[priority]。\n5. 如果 priority 在 expired bitarray 里对应的 bit 为 0&#xff0c;将其置 1。\n6. 如果 active bitarray 全为零&#xff0c;将 active bitarray 和 expired bitarray 交换一下。\n\n当然&#xff0c;这里面还有一些细节&#xff0c;比如如果是 process 被抢占&#xff0c;其时间片没用完&#xff0c;那么第 4 步&#xff0c;enqueue 回 active priority queue 中。\n\n### 题外话\n\n2.6 O(1) scheduler 目前已经被性能略输一筹&#xff0c;同时更加强调公平性的 CFS&#xff08;Completely Fair Scheduler&#xff09;取代&#xff0c;但其以独特的设计&#xff0c;简单的算法&#xff0c;影响很多系统。\n\n在其刚问世时&#xff0c;很多 linux 发行版就迫不及待将其移植回 2.4 kernel&#xff0c;另外&#xff0c;在许多操作系统的调度器中&#xff0c;都能见到 bitarray &#43; priority queue 的身影。\n\n它让我感慨算法之美&#xff0c;同时也告诉我&#xff1a;你手中即便拿着一副并不那么出众的牌&#xff0c;历经辗转腾挪&#xff0c;也能打出精彩。\n\n\n</md>"}], "type": "note", "tags": ["lecture12", "student"], "tag_good": [], "unique_views": 96, "children": [], "tag_good_arr": [], "id": "k8cq2e1phzjft", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 1, "num_favorites": 1, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643170048300, "default_anonymity": "no"}, "error": null, "aid": "kyv10ros3bp3ht"}