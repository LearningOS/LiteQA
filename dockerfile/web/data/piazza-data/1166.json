{"result": {"folders": ["lecture3", "2018"], "nr": 1166, "data": {"embed_links": []}, "created": "2018-03-19T12:33:38Z", "bucket_order": 3, "no_answer_followup": 1, "change_log": [{"anon": "no", "uid": "itef43kvaqj4ok", "data": "jey7oga4du54cw", "type": "create", "when": "2018-03-19T12:33:38Z"}, {"anon": "no", "uid": "isvte2o93ju2dt", "to": "jey7og9z4mh4cv", "type": "followup", "when": "2018-03-19T14:55:53Z"}, {"anon": "no", "uid": "hcrrjuyequh4bt", "data": "jezdy4jg5tn35r", "to": "jey7og9z4mh4cv", "type": "i_answer", "when": "2018-03-20T08:16:53Z"}, {"anon": "no", "uid": "itef43kvaqj4ok", "to": "jey7og9z4mh4cv", "type": "followup", "when": "2018-03-20T09:26:23Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "data": "jt9dfsk7ipl1hc", "type": "update", "when": "2019-03-15T01:16:13Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "思考题&#xff1a;最差匹配的外碎片会比最优适配算法少吗&#xff1f;请说明理由&#xff08;可来源于猜想或具体的实验&#xff09;。", "created": "2019-03-15T01:16:13Z", "content": "<p>我的答案如下&#xff1a;<br />内存在分配时不会增多碎片&#xff0c;碎片是在内存释放时增加的。假设分配内存时永远不会消去碎片&#xff08;实际不可能&#xff0c;内存总是按照单元分配&#xff0c;且最优匹配会更容易消去碎片&#xff09;&#xff0c;改变碎片数的唯二途径就是&#xff1a;一、在释放内存时无法与其他碎片合并&#xff0c;增加一个碎片&#xff1b;二、归还内存时把两个相邻碎片连接到一起&#xff0c;减少一个碎片。基于假设情况一必然是某个碎片先被分配一部分&#xff0c;之后相邻的内存又被分配且未归还&#xff0c;现在先被分配的内存归还了无法与其他碎片合并。因为最佳匹配总是会选最小的碎片分配&#xff0c;只会剩下更小的更难分配的碎片&#xff0c;所以我认为情况一更容易在最差匹配中出现。而在无法得到进程信息的情况下&#xff0c;碎片的归还理应看作与算法不相关的随机因素&#xff0c;所以我认为情况二对两种算法的碎片数的影响是同等的。现在去掉假设&#xff0c;即认为分配内存可能减少碎片&#xff0c;这个被减少的碎片在回来时也可能增加碎片&#xff0c;这只对最优匹配更加有利&#xff0c;不会影响结论。所以结论是最差匹配的外碎片不会比最优适配算法少&#xff0c;相反最优适配算法的外碎片应该会较少。</p>\n<p>请问老师这个逻辑有没有问题&#xff1f;</p>"}, {"anon": "no", "uid": "itef43kvaqj4ok", "subject": "思考题&#xff1a;最差匹配的外碎片会比最优适配算法少吗&#xff1f;请说明理由&#xff08;可来源于猜想或具体的实验&#xff09;。", "created": "2018-03-19T12:33:38Z", "content": "<p>我的答案如下&#xff1a;<br />内存在分配时不会增多碎片&#xff0c;碎片是在内存释放时增加的。假设分配内存时永远不会消去碎片&#xff08;实际不可能&#xff0c;内存总是按照单元分配&#xff0c;且最优匹配会更容易消去碎片&#xff09;&#xff0c;改变碎片数的唯二途径就是&#xff1a;一、在释放内存时无法与其他碎片合并&#xff0c;增加一个碎片&#xff1b;二、归还内存时把两个相邻碎片连接到一起&#xff0c;减少一个碎片。基于假设情况一必然是某个碎片先被分配一部分&#xff0c;之后相邻的内存又被分配且未归还&#xff0c;现在先被分配的内存归还了无法与其他碎片合并。因为最佳匹配总是会选最小的碎片分配&#xff0c;只会剩下更小的更难分配的碎片&#xff0c;所以我认为情况一更容易在最差匹配中出现。而在无法得到进程信息的情况下&#xff0c;碎片的归还理应看作与算法不相关的随机因素&#xff0c;所以我认为情况二对两种算法的碎片数的影响是同等的。现在去掉假设&#xff0c;即认为分配内存可能减少碎片&#xff0c;这个被减少的碎片在回来时也可能增加碎片&#xff0c;这只对最优匹配更加有利&#xff0c;不会影响结论。所以结论是最差匹配的外碎片不会比最优适配算法少&#xff0c;相反最优适配算法的外碎片应该会较少。</p>\n<p>请问老师这个逻辑有没有问题&#xff1f;</p>"}], "type": "question", "tags": ["2018", "lecture3", "student"], "tag_good": [], "unique_views": 116, "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>我觉得算法的最终表现还是要看工作集的性质吧。</p>\n<p></p>\n<p>另外这条链接 <a href=\"https://opendsa-server.cs.vt.edu/ODSA/Books/CS3/html/WorstFit.html\" target=\"_blank\">CHAPTER 11 MEMORY MANAGEMENT</a> 称 &#34;A strategy contrary to best fit might make sense because it tends to minimize the effects of external fragmentation. This is called worst fit...<em>&#34;</em></p>", "created": "2018-03-19T14:55:53Z", "bucket_order": 108, "bucket_name": "Week 3/18 - 3/24", "type": "followup", "tag_good": [], "uid": "isvte2o93ju2dt", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "jeycrdro1b1541", "updated": "2018-03-19T14:55:53Z", "config": {}}, {"folders": [], "data": {"embed_links": []}, "children": [], "created": "2018-03-20T08:16:53Z", "bucket_order": 3, "tag_endorse": [{"role": "student", "name": "THU15", "endorser": {}, "admin": false, "photo": null, "id": "itef43kvaqj4ok", "photo_url": null, "published": true, "us": false, "class_sections": ["os2018spring_i5j09fnsl7k5x0"], "facebook_id": null}], "bucket_name": "Today", "id": "jezdy4jbuye35q", "history": [{"anon": "no", "uid": "hcrrjuyequh4bt", "subject": "", "created": "2018-03-20T08:16:53Z", "content": "<p>“最差匹配的外碎片会比最优适配算法少吗&#xff1f;”这里的“少”可以有多种含义&#xff1a;“在相同碎片容量情况下&#xff0c;外碎片数量少”&#xff0c;“在相同碎片数量情况下&#xff0c;外碎片的总容量少”&#xff0c;“外碎片数量少”&#xff0c;“外碎片的总容量少”&#xff0c;等等。其实&#xff0c;这个题目可能想表达的是“采用两种内存管理算法&#xff1a;最差匹配和最优适配&#xff0c;在同一个随机的内存请求/释放序列中&#xff0c;对于一个初始化为空的大内存块&#xff0c;在多次内存请求/释放后&#xff0c;接下来的内存申请成功的概率大的是哪个算法&#xff1f;” </p>\n<p></p>\n<p>对于你的解释&#xff0c;我觉得缺少严格的证明&#xff0c;只是一种表述。就我个人理解而言&#xff0c;同意下面的解释“算法的最终表现还是要看内存请求/释放序列的性质&#xff0c;即申请/释放的顺序和每次申请的大小等”。应该可以构造出某个访问序列&#xff0c;采用最优适配算法或最差适配算法&#xff0c;在多次内存请求/释放后&#xff0c;接下来的内存申请成功的概率都比对方大。</p>\n<p></p>\n<p>我现在没有这个序列&#xff0c;也许你能帮助构造出来&#xff1f;或给出反对意见&#xff1f;</p>"}], "type": "i_answer", "tag_endorse_arr": ["itef43kvaqj4ok"], "config": {}, "is_tag_endorse": false}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>   这里的表述的确缺少严格证明。但从直观上来看&#xff0c;我认为最差匹配有利于减少分配的决策时间&#xff0c;最优匹配则是我觉得它会找到非常合适的碎片。但另一方面最差匹配所留下的碎片仍然可以利用的概率更大&#xff0c;最优匹配会更容易留下无法再分配的过小的碎片。</p>\n<p>   课上也提到过内存的管理还有其它的手段&#xff0c;如页式存储管理能够把大的请求化整为零&#xff0c;而操作系统也可以对分配除去的内存进行紧凑&#xff0c;所以对这两个算法的表现深入研究的意义恐怕也不大吧&#xff1f;其实我是希望知道对于纯随机生成的序列请求&#xff0c;两种算法的平均表现如何。我会在近期做个模拟实验看看&#xff0c;但是并不知道结果会有多大意义。</p>\n<p></p>\n<p>   希望有人能给出更好的研究手段。</p>", "created": "2018-03-20T09:26:23Z", "bucket_order": 108, "bucket_name": "Week 3/18 - 3/24", "type": "followup", "tag_good": [], "uid": "itef43kvaqj4ok", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "jezgfi0i3d25s9", "updated": "2018-03-20T09:26:23Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "jey7og9z4mh4cv", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 4, "num_favorites": 1, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169297559, "default_anonymity": "no"}, "error": null, "aid": "kyv0koevist6bg"}