{"result": {"folders": ["2017", "lecture15", "课堂问答"], "nr": 1052, "data": {"embed_links": []}, "created": "2017-04-17T09:10:09Z", "bucket_order": 3, "no_answer_followup": 7, "change_log": [{"anon": "no", "uid": "hdjonbiyfs62ie", "data": "j1lwgjszttw37f", "type": "create", "when": "2017-04-17T09:10:09Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j1lwgjsw1nn37e", "type": "followup", "when": "2017-04-17T09:11:51Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j1lwgjsw1nn37e", "type": "followup", "when": "2017-04-17T09:12:04Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j1lwgjsw1nn37e", "type": "followup", "when": "2017-04-17T09:12:24Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j1lwgjsw1nn37e", "type": "followup", "when": "2017-04-17T09:12:42Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j1lwgjsw1nn37e", "type": "followup", "when": "2017-04-17T09:13:05Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j1lwgjsw1nn37e", "type": "followup", "when": "2017-04-17T09:13:31Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j1lwgjsw1nn37e", "type": "followup", "when": "2017-04-17T09:13:43Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j1lwgjsw1nn37e", "type": "followup", "when": "2017-04-17T09:14:06Z"}, {"anon": "no", "uid": "i176lqynyf85fu", "to": "j1lwgjsw1nn37e", "type": "feedback", "when": "2017-04-24T06:18:57Z"}, {"anon": "no", "uid": "isvxeq6bspf1vn", "to": "j1lwgjsw1nn37e", "type": "feedback", "when": "2018-04-24T01:20:08Z"}, {"anon": "no", "uid": "isvxeq6bspf1vn", "to": "j1lwgjsw1nn37e", "type": "feedback", "when": "2018-04-25T16:41:50Z"}, {"anon": "no", "uid": "isvxeq6bspf1vn", "to": "j1lwgjsw1nn37e", "type": "feedback", "when": "2018-04-25T16:43:30Z"}, {"anon": "no", "uid": "isvxeq6bspf1vn", "to": "j1lwgjsw1nn37e", "type": "feedback", "when": "2018-04-25T16:45:03Z"}, {"anon": "no", "uid": "isvxeq6bspf1vn", "to": "j1lwgjsw1nn37e", "type": "feedback", "when": "2018-04-25T16:46:43Z"}, {"anon": "no", "uid": "isvxeq6bspf1vn", "to": "j1lwgjsw1nn37e", "type": "feedback", "when": "2018-04-25T16:57:40Z"}, {"anon": "no", "uid": "iswj8urcumf2o2", "to": "j1lwgjsw1nn37e", "type": "feedback", "when": "2018-04-27T04:06:27Z"}, {"anon": "no", "uid": "iswj8urcumf2o2", "to": "j1lwgjsw1nn37e", "type": "feedback", "when": "2018-04-27T04:12:30Z"}, {"anon": "no", "uid": "jsiyf76cGzf9", "to": "j1lwgjsw1nn37e", "type": "feedback", "when": "2019-04-19T10:21:17Z"}, {"anon": "no", "uid": "jsiyf76cGzf9", "to": "j1lwgjsw1nn37e", "type": "feedback", "when": "2019-04-19T15:09:20Z"}, {"anon": "no", "uid": "jsiyf76cGzf9", "to": "j1lwgjsw1nn37e", "type": "feedback", "when": "2019-04-19T15:10:37Z"}, {"anon": "no", "uid": "jsjp7j7mu8BB", "to": "j1lwgjsw1nn37e", "type": "feedback", "when": "2019-04-21T11:59:13Z"}, {"anon": "no", "uid": "jsjp7j7mu8BB", "to": "j1lwgjsw1nn37e", "type": "feedback", "when": "2019-04-21T15:31:21Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "2017春季-第十五讲课堂实践练习", "created": "2017-04-17T09:10:09Z", "content": "<p>请两人一组完成“第十五讲 处理机调度”中指定小题的回答在此贴中回复&#xff0c;每组同学选做一个题目。</p>\n<p></p>\n<p>题目&#xff1a;<br /><a href=\"https://chyyuu.gitbooks.io/os_course_exercises/content/all/06-1-spoc-discussion.html\">https://chyyuu.gitbooks.io/os_course_exercises/content/all/06-1-spoc-discussion.html</a> -&gt; 小组练习与思考题</p>\n<p></p>\n<p>(1)理解并实现FIFO调度算法<br />(2)理解并实现SJF调度算法<br />(3)理解并实现RR调度算法<br />(4)理解并实现MLFQ调度算法<br />(5)理解并实现stride调度算法<br />(6)理解并实现EDF实时调度算法<br />(7)理解并实现RM实时调度算法<br />(8)理解并实现优先级反置方法</p>"}], "type": "note", "tags": ["2017", "instructor-note", "lecture15", "课堂问答"], "tag_good": [], "unique_views": 157, "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>(1)理解并实现FIFO调度算法</p>\n<p></p>\n<p>选择“(1)”的同学的回答结果写在此贴后面。</p>", "created": "2017-04-17T09:11:51Z", "bucket_order": 153, "bucket_name": "Week 4/16 - 4/22", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>魏钧宇 2015011263</p>", "created": "2018-04-25T16:41:49Z", "bucket_order": 100, "bucket_name": "Week 4/22 - 4/28", "type": "feedback", "tag_good": [], "uid": "isvxeq6bspf1vn", "children": [], "tag_good_arr": [], "id": "jgfbu566cbp12o", "updated": "2018-04-25T16:41:49Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>在下面的MLFQ处将给出使用java实现的整个调度框架&#xff0c;这里给出其中的涉及到fifo的调度代码&#xff1a;</p>\n<pre>public class FifoScheduler implements Scheduler{\n\tDeque &lt;Process&gt; pro_que = new LinkedList&lt;Process&gt;();\n\tboolean proc_finish = false;\n\tpublic FifoScheduler(ArrayList&lt;Process&gt; pro_array){\n\t\tfor (int i = 0; i &lt; pro_array.size(); i&#43;&#43;) {\n\t\t\tenque(pro_array.get(i));\n\t\t}\n\t}\n\t\n\t&#64;Override\n\tpublic Process get_next() {\n\t\treturn pro_que.peek();\n\t}\n\t&#64;Override\n\tpublic Process deque() {\n\t\t// TODO Auto-generated method stub\n\t\treturn pro_que.poll();\n\t}\n\n\t&#64;Override\n\tpublic void enque(Process temp) {\n\t\t// TODO Auto-generated method stub\n\t\tpro_que.add(temp);\n\t}\n\t\n\t&#64;Override\n\tpublic double start_run(double total_time) {\n\t\tproc_finish = false;\n\t\tdouble run_time = 0;\n\t\twhile(!pro_que.isEmpty() &amp;&amp; total_time &gt; 0) {\n\t\t\tProcess now_pro = get_next();\n\t\t\tdouble remain_time = now_pro.get_remain();\n\t\t\tdouble real_time = remain_time;\n\t\t\tif (remain_time &lt;= total_time) {\n\t\t\t\tnow_pro.Run(remain_time);\n\t\t\t\tproc_finish = true;\n\t\t\t\tdeque();\n\t\t\t}else {\n\t\t\t\treal_time = total_time;\n\t\t\t\tnow_pro.Run(real_time);\n\t\t\t}\n\t\t\trun_time &#43;= real_time;\n\t\t\ttotal_time -= real_time;\n\t\t}\n\t\treturn run_time;\n\t}\n\n\t&#64;Override\n\tpublic boolean finish() {\n\t\treturn pro_que.isEmpty();\n\t}\n\n}</pre>\n<p>测试如下&#xff08;随机生成了6个新进程&#xff09;&#xff1a;</p>\n<pre>请输入进程总数: \n6\nProcess: 0: \nTotal time: 1.5711262548344966 Remain time: 1.5711262548344966\n\nProcess: 1: \nTotal time: 2.7415343775833794 Remain time: 2.7415343775833794\n\nProcess: 2: \nTotal time: 2.7386348359894392 Remain time: 2.7386348359894392\n\nProcess: 3: \nTotal time: 2.326677068766938 Remain time: 2.326677068766938\n\nProcess: 4: \nTotal time: 2.1609509881155278 Remain time: 2.1609509881155278\n\nProcess: 5: \nTotal time: 2.495165875813373 Remain time: 2.495165875813373\n\n请输入调度策略: \n0\nProcess: 0 Run for 1.5711262548344966\nProcess: 0 Finish!\nProcess: 1 Run for 2.7415343775833794\nProcess: 1 Finish!\nProcess: 2 Run for 2.7386348359894392\nProcess: 2 Finish!\nProcess: 3 Run for 2.326677068766938\nProcess: 3 Finish!\nProcess: 4 Run for 2.1609509881155278\nProcess: 4 Finish!\nProcess: 5 Run for 2.495165875813373\nProcess: 5 Finish!</pre>\n<p></p>", "created": "2018-04-25T16:43:30Z", "bucket_order": 100, "bucket_name": "Week 4/22 - 4/28", "type": "feedback", "tag_good": [], "uid": "isvxeq6bspf1vn", "children": [], "tag_good_arr": [], "id": "jgfbwap9qmo2c0", "updated": "2018-04-25T16:43:30Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>在原有的python代码上补充实现的&#xff1a;</p>\n<pre>    if options.policy == &#39;FIFO&#39;:\n        thetime = 0\n        print &#39;Execution trace:&#39;<br />\n        t = 0.0\n        for job in joblist:\n            jobnum = job[0]\n            runtime = job[1]\n            print &#39;  [ time %3.0f] Run job %d for %.2f secs ( DONE at %.2f )&#39; % (t, jobnum, runtime, runtime &#43; t)\n            t &#43;= runtime<br />\n        print &#39;\\nFinal statistics:&#39;\n        t     = 0.0\n        count = 0\n        turnaroundSum = 0.0\n        waitSum       = 0.0\n        responseSum   = 0.0\n        for job in joblist:\n            jobnum  = job[0]\n            runtime = job[1]\n            \n            response   = t\n            turnaround = t &#43; runtime\n            wait       = t\n            print &#39;  Job %3d -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f&#39; % (jobnum, response, turnaround, wait)\n            responseSum   &#43;= response\n            turnaroundSum &#43;= turnaround\n            waitSum       &#43;= wait\n            t &#43;= runtime\n            count = count &#43; 1\n        print &#39;\\n  Average -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f\\n&#39; % (responseSum/count, turnaroundSum/count, waitSum/count)</pre>\n<p>运行结果如下&#xff1a;</p>\n<pre>ARG policy FIFO\nARG jobs 3\nARG maxlen 10\nARG seed 0\n\nHere is the job list, with the run time of each job:\n  Job 0 ( length = 9 )\n  Job 1 ( length = 8 )\n  Job 2 ( length = 5 )\n\n\n** Solutions **\n\nExecution trace:\n  [ time   0] Run job 0 for 9.00 secs ( DONE at 9.00 )\n  [ time   9] Run job 1 for 8.00 secs ( DONE at 17.00 )\n  [ time  17] Run job 2 for 5.00 secs ( DONE at 22.00 )\n\nFinal statistics:\n  Job   0 -- Response: 0.00  Turnaround 9.00  Wait 0.00\n  Job   1 -- Response: 9.00  Turnaround 17.00  Wait 9.00\n  Job   2 -- Response: 17.00  Turnaround 22.00  Wait 17.00\n\n  Average -- Response: 8.67  Turnaround 16.00  Wait 8.67</pre>\n<p></p>", "created": "2018-04-27T04:06:27Z", "bucket_order": 100, "bucket_name": "Week 4/22 - 4/28", "type": "feedback", "tag_good": [], "uid": "iswj8urcumf2o2", "children": [], "tag_good_arr": [], "id": "jghfqfkwffu1nf", "updated": "2018-04-27T04:06:27Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "j1lwiq4rrkh5oj", "updated": "2017-04-17T09:11:51Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>(2)理解并实现SJF调度算法</p>\n<p></p>\n<p>选择“(2)”的同学的回答结果写在此贴后面。</p>", "created": "2017-04-17T09:12:04Z", "bucket_order": 153, "bucket_name": "Week 4/16 - 4/22", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>魏钧宇 2015011263</p>\n<p>同上&#xff0c;这里给出涉及到SPN的调度代码&#xff1a;</p>\n<pre>public class SpnScheduler implements Scheduler {\n\tQueue&lt;Process&gt; pro_que = new PriorityQueue&lt;&gt;(cmp);\n\t\n\tpublic SpnScheduler(ArrayList&lt;Process&gt; pro_array){\n\t\tfor (int i = 0; i &lt; pro_array.size(); i&#43;&#43;) {\n\t\t\tenque(pro_array.get(i));\n\t\t}\n\t}\n\t\n\t&#64;Override\n\tpublic String toString() {\n\t\t\n\t\tString temp  = &#34;&#34;;\n\t\tint tot = pro_que.size();\n\t\twhile(tot != 0) {\n\t\t\tProcess tp = pro_que.poll();\n\t\t\ttemp &#43;= tp.toString();\n\t\t\ttot -= 1;\n\t\t}\n\t\treturn temp;\n\t}\n\tpublic static Comparator&lt;Process&gt; cmp = new Comparator&lt;Process&gt;() {\n\t\t&#64;Override\n\t\tpublic int compare(Process p1, Process p2) {\n\t\t\tif (p1.get_remain() - p2.get_remain() &lt; 0) {\n\t\t\t\treturn -1;\n\t\t\t}else {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t};\n\t\n\t&#64;Override\n\tpublic Process get_next() {\n\t\treturn pro_que.peek();\n\t}\n\n\t&#64;Override\n\tpublic Process deque() {\n\t\t// TODO Auto-generated method stub\n\t\treturn pro_que.poll();\n\t}\n\n\t&#64;Override\n\tpublic void enque(Process temp) {\n\t\tpro_que.add(temp);\n\n\t}\n\n\t&#64;Override\n\tpublic double start_run(double total_time) {\n\t\tdouble run_time = 0;\n\t\t\n\t\twhile(!pro_que.isEmpty() &amp;&amp; total_time &gt; 0) {\n\t\t\tProcess now_pro = get_next();\n\t\t\tdouble remain_time = now_pro.get_remain();\n\t\t\tdouble real_time = remain_time;\n\t\t\tif (remain_time &lt;= total_time) {\n\t\t\t\tnow_pro.Run(remain_time);\n\t\t\t\tdeque();\n\t\t\t}else {\n\t\t\t\treal_time = total_time;\n\t\t\t\tnow_pro.Run(total_time);\n\t\t\t\tdeque();\n\t\t\t\tenque(now_pro);\n\t\t\t}\n\t\t\trun_time &#43;= real_time;\n\t\t\ttotal_time -= real_time;\n\t\t}\n\t\t\n\t\treturn run_time;\n\t}\n\n\t&#64;Override\n\tpublic boolean finish() {\n\t\treturn pro_que.isEmpty();\n\t}\n\n}</pre>\n<p>进行测试得到如下结果&#xff08;随机生成了6个进程&#xff09;</p>\n<pre>请输入进程总数: \n6\nProcess: 0: \nTotal time: 2.1314379393711023 Remain time: 2.1314379393711023\n\nProcess: 1: \nTotal time: 18.49084709005667 Remain time: 18.49084709005667\n\nProcess: 2: \nTotal time: 1.899732481136875 Remain time: 1.899732481136875\n\nProcess: 3: \nTotal time: 1.411844732663955 Remain time: 1.411844732663955\n\nProcess: 4: \nTotal time: 2.3354464305666096 Remain time: 2.3354464305666096\n\nProcess: 5: \nTotal time: 1.427480706617846 Remain time: 1.427480706617846\n\n请输入调度策略: \n1\nProcess: 3 Run for 1.411844732663955\nProcess: 3 Finish!\nProcess: 5 Run for 1.427480706617846\nProcess: 5 Finish!\nProcess: 2 Run for 1.899732481136875\nProcess: 2 Finish!\nProcess: 0 Run for 2.1314379393711023\nProcess: 0 Finish!\nProcess: 4 Run for 2.3354464305666096\nProcess: 4 Finish!\nProcess: 1 Run for 18.49084709005667\nProcess: 1 Finish!</pre>\n<p></p>", "created": "2018-04-25T16:45:03Z", "bucket_order": 100, "bucket_name": "Week 4/22 - 4/28", "type": "feedback", "tag_good": [], "uid": "isvxeq6bspf1vn", "children": [], "tag_good_arr": [], "id": "jgfbyasix6v3mk", "updated": "2018-04-25T16:45:03Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>实现代码如下&#xff1a;</p>\n<pre>    if options.policy == &#39;SJF&#39;:<br />        jobsorted = sorted(joblist, key=lambda x:x[1])<br />        thetime = 0<br />        print &#39;Execution trace:&#39;<br /><br />        t = 0.0<br />        for job in jobsorted:<br />            jobnum = job[0]<br />            runtime = job[1]<br />            print &#39;  [ time %3.0f] Run job %d for %.2f secs ( DONE at %.2f )&#39; % (t, jobnum, runtime, runtime &#43; t)<br />            t &#43;= runtime<br />        print &#39;\\nFinal statistics:&#39;<br />        t     = 0.0<br />        count = 0<br />        turnaroundSum = 0.0<br />        waitSum       = 0.0<br />        responseSum   = 0.0<br />        for job in jobsorted:<br />            jobnum  = job[0]<br />            runtime = job[1]<br />            <br />            response   = t<br />            turnaround = t &#43; runtime<br />            wait       = t<br />            print &#39;  Job %3d -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f&#39; % (jobnum, response, turnaround, wait)<br />            responseSum   &#43;= response<br />            turnaroundSum &#43;= turnaround<br />            waitSum       &#43;= wait<br />            t &#43;= runtime<br />            count = count &#43; 1<br />        print &#39;\\n  Average -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f\\n&#39; % (responseSum/count, turnaroundSum/count, waitSum/count)</pre>\n<p>运行结果如下&#xff1a;</p>\n<pre>ARG policy SJF\nARG jobs 3\nARG maxlen 10\nARG seed 0\n\nHere is the job list, with the run time of each job:\n  Job 0 ( length = 9 )\n  Job 1 ( length = 8 )\n  Job 2 ( length = 5 )\n\n\n** Solutions **\n\nExecution trace:\n  [ time   0] Run job 2 for 5.00 secs ( DONE at 5.00 )\n  [ time   5] Run job 1 for 8.00 secs ( DONE at 13.00 )\n  [ time  13] Run job 0 for 9.00 secs ( DONE at 22.00 )\n\nFinal statistics:\n  Job   2 -- Response: 0.00  Turnaround 5.00  Wait 0.00\n  Job   1 -- Response: 5.00  Turnaround 13.00  Wait 5.00\n  Job   0 -- Response: 13.00  Turnaround 22.00  Wait 13.00\n\n  Average -- Response: 6.00  Turnaround 13.33  Wait 6.00</pre>\n<p></p>", "created": "2018-04-27T04:12:30Z", "bucket_order": 100, "bucket_name": "Week 4/22 - 4/28", "type": "feedback", "tag_good": [], "uid": "iswj8urcumf2o2", "children": [], "tag_good_arr": [], "id": "jghfy7kqwjj37v", "updated": "2018-04-27T04:12:30Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "j1lwj0ivy0l1ip", "updated": "2017-04-17T09:12:04Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>(3)理解并实现RR调度算法</p>\n<p></p>\n<p>选择“(3)”的同学的回答结果写在此贴后面。</p>", "created": "2017-04-17T09:12:24Z", "bucket_order": 153, "bucket_name": "Week 4/16 - 4/22", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p><pre>    if options.policy == &#39;RR&#39;:\n        print &#39;Execution trace:&#39;\n        turnaround = {}\n        response = {}\n        lastran = {}\n        wait = {}\n        quantum  = float(options.quantum)\n        jobcount = len(joblist)\n        for i in range(0,jobcount):\n            lastran[i] = 0.0\n            wait[i] = 0.0\n            turnaround[i] = 0.0\n            response[i] = -1\n\n        runlist = []\n        for e in joblist:\n            runlist.append(e)\n\n        thetime  = 0.0\n        while jobcount &gt; 0:\n            print &#39;%d jobs remaining&#39; % jobcount\n            job = runlist.pop(0)\n            jobnum  = job[0]\n            runtime = float(job[1])\n            if response[jobnum] == -1:\n                response[jobnum] = thetime\n            currwait = thetime - lastran[jobnum]\n            wait[jobnum] &#43;= currwait\n            ranfor = 0\n            if runtime &gt; quantum:\n                runtime -= quantum\n                ranfor = quantum\n                print &#39;  [ time %3d ] Run job %3d for %.2f secs&#39; % (thetime, jobnum, ranfor)\n                runlist.append([jobnum, runtime])\n            else:\n                ranfor = runtime\n                print &#39;  [ time %3d ] Run job %3d for %.2f secs ( DONE at %.2f )&#39; % (thetime, jobnum, ranfor, thetime &#43; ranfor)\n                turnaround[jobnum] = thetime &#43; ranfor\n                jobcount -= 1\n            thetime &#43;= ranfor\n            lastran[jobnum] = thetime\n\n        print &#39;\\nFinal statistics:&#39;\n        turnaroundSum = 0.0\n        waitSum       = 0.0\n        responseSum   = 0.0\n        for i in range(0,len(joblist)):\n            turnaroundSum &#43;= turnaround[i]\n            responseSum &#43;= response[i]\n            waitSum &#43;= wait[i]\n            print &#39;  Job %3d -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f&#39; % (i, response[i], turnaround[i], wait[i])\n        count = len(joblist)\n        \n        print &#39;\\n  Average -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f\\n&#39; % (responseSum/count, turnaroundSum/count, waitSum/count)</pre>\n<p>Round-Robin调度简洁&#xff0c;实现开销比较小&#xff0c;但是没有考虑到进程自身的特点。当时间片足够大时退化为FIFO算法。</p>", "created": "2017-04-24T06:18:57Z", "bucket_order": 152, "bucket_name": "Week 4/23 - 4/29", "type": "feedback", "tag_good": [], "uid": "i176lqynyf85fu", "children": [], "tag_good_arr": [], "id": "j1vqfbzjgby3l", "updated": "2017-04-24T06:18:57Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>魏钧宇 2015011263</p>\n<p>这里给出RR的实现代码</p>\n<pre>public class RRScheduler implements Scheduler{\n\tDeque&lt;Process&gt; pro_que = new ArrayDeque&lt;Process&gt;();\n\tdouble slice = 2.0;\n\tpublic boolean proc_finish = true;\n\tpublic RRScheduler() {\n\t\t\n\t}\n\tpublic RRScheduler(ArrayList&lt;Process&gt; pro_array, double s){\n\t\tfor (int i = 0; i &lt; pro_array.size(); i&#43;&#43;) {\n\t\t\tenque(pro_array.get(i));\n\t\t}\n\t\tslice = s;\n\t}\n\t&#64;Override\n\tpublic Process get_next() {\n\t\t// TODO Auto-generated method stub\n\t\treturn pro_que.peek();\n\t}\n\n\t&#64;Override\n\tpublic Process deque() {\n\t\t// TODO Auto-generated method stub\n\t\treturn pro_que.poll();\n\t}\n\n\t&#64;Override\n\tpublic void enque(Process temp) {\n\t\t// TODO Auto-generated method stub\n\t\tpro_que.add(temp);\n\t}\n\t\n\t\n\t&#64;Override\n\tpublic double start_run(double total_time) {\n\t\tproc_finish = true;\n\t\tdouble run_time = 0;\n\t\twhile(total_time &gt; 0 &amp;&amp; !pro_que.isEmpty()) {\n\t\t\tProcess now_pro = pro_que.peek();\n\t\t\tSystem.out.print(&#34;RR Scheduler pick out Process &#34; &#43; now_pro.id &#43; &#34; to Run&#34;);\n\t\t\tdouble remain_time = now_pro.get_remain();\n\t\t\tdouble real_time = remain_time;\n\t\t\tif (total_time &lt; remain_time) {\n\t\t\t\tif (total_time &lt; slice) {\n\t\t\t\t\tnow_pro.Run(total_time);\n\t\t\t\t\treal_time = total_time;\n\t\t\t\t}else {\n\t\t\t\t\tnow_pro.Run(slice);\n\t\t\t\t\treal_time = slice;\n\t\t\t\t\tdeque();\n\t\t\t\t\tenque(now_pro);\n\t\t\t\t}\n\t\t\t}else {\n\t\t\t\tif (remain_time &lt; slice) {\n\t\t\t\t\tnow_pro.Run(remain_time);\n\t\t\t\t\tdeque();\n\t\t\t\t\treal_time = remain_time;\n\t\t\t\t}else {\n\t\t\t\t\tnow_pro.Run(slice);\n\t\t\t\t\tdeque();\n\t\t\t\t\tenque(now_pro);\n\t\t\t\t\treal_time = slice;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttotal_time -= real_time;\n\t\t\trun_time &#43;= real_time;\n\t\t}\n\t\treturn run_time;\n\t}\n\t&#64;Override\n\tpublic boolean finish() {\n\t\treturn pro_que.isEmpty();\n\t}\n\t\n\t\n}</pre>\n<p>进行测试&#xff08;随机生成了6个进程&#xff09;</p>\n<pre>请输入进程总数: \n6\nProcess: 0: \nTotal time: 2.163400647526702 Remain time: 2.163400647526702\n\nProcess: 1: \nTotal time: 2.1337751300814483 Remain time: 2.1337751300814483\n\nProcess: 2: \nTotal time: 2.1618899204913156 Remain time: 2.1618899204913156\n\nProcess: 3: \nTotal time: 2.944857834021936 Remain time: 2.944857834021936\n\nProcess: 4: \nTotal time: 1.4795684489217589 Remain time: 1.4795684489217589\n\nProcess: 5: \nTotal time: 1.0556344314632922 Remain time: 1.0556344314632922\n\n请输入调度策略: \n2\nRR Scheduler pick out Process 0 to RunProcess: 0 Run for 2.0\nRR Scheduler pick out Process 1 to RunProcess: 1 Run for 2.0\nRR Scheduler pick out Process 2 to RunProcess: 2 Run for 2.0\nRR Scheduler pick out Process 3 to RunProcess: 3 Run for 2.0\nRR Scheduler pick out Process 4 to RunProcess: 4 Run for 1.4795684489217589\nProcess: 4 Finish!\nRR Scheduler pick out Process 5 to RunProcess: 5 Run for 1.0556344314632922\nProcess: 5 Finish!\nRR Scheduler pick out Process 0 to RunProcess: 0 Run for 0.1634006475267018\nProcess: 0 Finish!\nRR Scheduler pick out Process 1 to RunProcess: 1 Run for 0.13377513008144826\nProcess: 1 Finish!\nRR Scheduler pick out Process 2 to RunProcess: 2 Run for 0.16188992049131556\nProcess: 2 Finish!\nRR Scheduler pick out Process 3 to RunProcess: 3 Run for 0.9448578340219358\nProcess: 3 Finish!</pre>\n<p></p>", "created": "2018-04-25T16:46:43Z", "bucket_order": 100, "bucket_name": "Week 4/22 - 4/28", "type": "feedback", "tag_good": [], "uid": "isvxeq6bspf1vn", "children": [], "tag_good_arr": [], "id": "jgfc0fdripe6pm", "updated": "2018-04-25T16:46:43Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "j1lwjg4hcgm1mp", "updated": "2017-04-17T09:12:24Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>(4)理解并实现MLFQ调度算法</p>\n<p></p>\n<p>选择“(4)”的同学的回答结果写在此贴后面。</p>", "created": "2017-04-17T09:12:42Z", "bucket_order": 153, "bucket_name": "Week 4/16 - 4/22", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>2015011263 魏钧宇</p>", "created": "2018-04-24T01:20:08Z", "bucket_order": 100, "bucket_name": "Week 4/22 - 4/28", "type": "feedback", "tag_good": [], "uid": "isvxeq6bspf1vn", "children": [], "tag_good_arr": [], "id": "jgczgzed3pe2zn", "updated": "2018-04-24T01:20:08Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>整个调度框架参见 <a href=\"https://github.com/Program-Bear/Scheduler\">https://github.com/Program-Bear/Scheduler</a></p>\n<p>设计实现MLFQ算法&#xff0c;共有三个队列&#xff0c;前两个使用FIFO&#xff0c;最后一个使用RR&#xff0c;有可能在执行过程中插入新的进程&#xff0c;先随机生成6个进程&#xff0c;最大进程上限设置为20&#xff0c;得到如下测试结果</p>\n<pre>请输入进程总数: \n6\nProcess: 0: \nTotal time: 1.2162415598190228 Remain time: 1.2162415598190228\n\nProcess: 1: \nTotal time: 1.3624498601917996 Remain time: 1.3624498601917996\n\nProcess: 2: \nTotal time: 2.3134545249890754 Remain time: 2.3134545249890754\n\nProcess: 3: \nTotal time: 6.981158973618699 Remain time: 6.981158973618699\n\nProcess: 4: \nTotal time: 19.45743242358399 Remain time: 19.45743242358399\n\nProcess: 5: \nTotal time: 17.873091215253343 Remain time: 17.873091215253343\n\n请输入调度策略: \n3\nCreate new proc: Process: 6: \nTotal time: 1.451645529022572 Remain time: 1.451645529022572\n\nCreate new proc: Process: 7: \nTotal time: 0.8043191559106311 Remain time: 0.8043191559106311\n\nCreate new proc: Process: 8: \nTotal time: 0.23436459692416678 Remain time: 0.23436459692416678\n\nCreate new proc: Process: 9: \nTotal time: 1.7625912153090295 Remain time: 1.7625912153090295\n\nCreate new proc: Process: 10: \nTotal time: 0.4183682988614932 Remain time: 0.4183682988614932\n\nCreate new proc: Process: 11: \nTotal time: 19.77361677262309 Remain time: 19.77361677262309\n\nCreate new proc: Process: 12: \nTotal time: 1.3904700849338403 Remain time: 1.3904700849338403\n\nCreate new proc: Process: 13: \nTotal time: 0.11350464134523297 Remain time: 0.11350464134523297\n\nCreate new proc: Process: 14: \nTotal time: 8.777594637968969 Remain time: 8.777594637968969\n\nCreate new proc: Process: 15: \nTotal time: 0.3646341990519679 Remain time: 0.3646341990519679\n\nCreate new proc: Process: 16: \nTotal time: 5.851522178125612 Remain time: 5.851522178125612\n\nCreate num: 11 new_procs size: 11\nProcess: 0 Run for 1.2162415598190228\nProcess: 0 Finish!\nProcess: 1 Run for 0.7837584401809772\nProcess: 1 Run for 0.5786914200108224\nProcess: 1 Finish!\nProcess: 2 Run for 1.4213085799891776\nProcess: 2 Run for 0.8921459449998979\nProcess: 2 Finish!\nProcess: 3 Run for 1.1078540550001021\nProcess: 3 Run for 2.0\nMove Process: 3 from Level 1 to Level 2\nProcess: 3 Run for 3.8733049186185973\nProcess: 3 Finish!\nProcess: 4 Run for 2.0\nMove Process: 4 from Level 1 to Level 2\nProcess: 4 Run for 5.0\nMove Process: 4 from Level 2 to Level 3\nRR Scheduler pick out Process 4 to Run\nProcess: 4 Run for 2.0\nRR Scheduler pick out Process 4 to Run\nProcess: 4 Run for 2.0\nRR Scheduler pick out Process 4 to Run\nProcess: 4 Run for 2.0\nRR Scheduler pick out Process 4 to Run\nProcess: 4 Run for 2.0\nRR Scheduler pick out Process 4 to Run\nProcess: 4 Run for 2.0\nProcess: 5 Run for 2.0\nMove Process: 5 from Level 1 to Level 2\nProcess: 5 Run for 5.0\nMove Process: 5 from Level 2 to Level 3\nRR Scheduler pick out Process 4 to Run\nProcess: 4 Run for 2.0\nRR Scheduler pick out Process 5 to Run\nProcess: 5 Run for 2.0\nRR Scheduler pick out Process 4 to Run\nProcess: 4 Run for 0.4574324235839917\nProcess: 4 Finish!\nRR Scheduler pick out Process 5 to Run\nProcess: 5 Run for 2.0\nRR Scheduler pick out Process 5 to Run\nProcess: 5 Run for 2.0\nRR Scheduler pick out Process 5 to Run\nProcess: 5 Run for 1.5425675764160083\nProcess: 6 Run for 1.451645529022572\nProcess: 6 Finish!\nProcess: 7 Run for 0.548354470977428\nRR Scheduler pick out Process 5 to Run\nProcess: 5 Run for 2.0\nRR Scheduler pick out Process 5 to Run\nProcess: 5 Run for 1.3305236388373345\nProcess: 5 Finish!\nProcess: 7 Run for 0.2559646849332031\nProcess: 7 Finish!\nProcess: 8 Run for 0.23436459692416678\nProcess: 8 Finish!\nProcess: 9 Run for 1.50967071814263\nProcess: 9 Run for 0.2529204971663994\nProcess: 9 Finish!\nProcess: 10 Run for 0.4183682988614932\nProcess: 10 Finish!\nProcess: 11 Run for 1.3287112039721074\nProcess: 11 Run for 2.0\nMove Process: 11 from Level 1 to Level 2\nProcess: 11 Run for 5.0\nMove Process: 11 from Level 2 to Level 3\nRR Scheduler pick out Process 11 to Run\nProcess: 11 Run for 2.0\nRR Scheduler pick out Process 11 to Run\nProcess: 11 Run for 2.0\nRR Scheduler pick out Process 11 to Run\nProcess: 11 Run for 2.0\nRR Scheduler pick out Process 11 to Run\nProcess: 11 Run for 2.0\nRR Scheduler pick out Process 11 to Run\nProcess: 11 Run for 2.0\nProcess: 12 Run for 1.3904700849338403\nProcess: 12 Finish!\nProcess: 13 Run for 0.11350464134523297\nProcess: 13 Finish!\nProcess: 14 Run for 0.49602527372092675\nProcess: 14 Run for 2.0\nMove Process: 14 from Level 1 to Level 2\nProcess: 14 Run for 5.0\nMove Process: 14 from Level 2 to Level 3\nRR Scheduler pick out Process 11 to Run\nProcess: 11 Run for 1.4449055686509809\nProcess: 11 Finish!\nRR Scheduler pick out Process 14 to Run\nProcess: 14 Run for 1.2815693642480426\nProcess: 14 Finish!\nProcess: 15 Run for 0.3646341990519679\nProcess: 15 Finish!\nProcess: 16 Run for 1.635365800948032\nProcess: 16 Run for 2.0\nMove Process: 16 from Level 1 to Level 2\nProcess: 16 Run for 2.2161563771775796\nProcess: 16 Finish!\nCreate new proc: Process: 17: \nTotal time: 19.960929775867065 Remain time: 19.960929775867065\n\nCreate num: 1 new_procs size: 1\nProcess: 17 Run for 2.0\nMove Process: 17 from Level 1 to Level 2\nProcess: 17 Run for 5.0\nMove Process: 17 from Level 2 to Level 3\nRR Scheduler pick out Process 17 to Run\nProcess: 17 Run for 2.0\nRR Scheduler pick out Process 17 to Run\nProcess: 17 Run for 2.0\nRR Scheduler pick out Process 17 to Run\nProcess: 17 Run for 2.0\nRR Scheduler pick out Process 17 to Run\nProcess: 17 Run for 2.0\nRR Scheduler pick out Process 17 to Run\nProcess: 17 Run for 2.0\nRR Scheduler pick out Process 17 to Run\nProcess: 17 Run for 2.0\nRR Scheduler pick out Process 17 to Run\nProcess: 17 Run for 0.960929775867065\nProcess: 17 Finish!\nCreate new proc: Process: 18: \nTotal time: 0.14328326251414714 Remain time: 0.14328326251414714\n\nCreate new proc: Process: 19: \nTotal time: 12.003891334546022 Remain time: 12.003891334546022\n\nCreate num: 2 new_procs size: 2\nProcess: 18 Run for 0.14328326251414714\nProcess: 18 Finish!\nProcess: 19 Run for 1.8567167374858529\nProcess: 19 Run for 2.0\nMove Process: 19 from Level 1 to Level 2\nProcess: 19 Run for 5.0\nMove Process: 19 from Level 2 to Level 3\nRR Scheduler pick out Process 19 to Run\nProcess: 19 Run for 2.0\nRR Scheduler pick out Process 19 to Run\nProcess: 19 Run for 1.1471745970601699\nProcess: 19 Finish!</pre>\n<p></p>", "created": "2018-04-25T16:57:40Z", "bucket_order": 100, "bucket_name": "Week 4/22 - 4/28", "type": "feedback", "tag_good": [], "uid": "isvxeq6bspf1vn", "children": [], "tag_good_arr": [], "id": "jgfceitrz7y42f", "updated": "2018-04-25T16:57:40Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "j1lwjtxaw947bk", "updated": "2017-04-17T09:12:42Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>(5)理解并实现stride调度算法</p>\n<p></p>\n<p>选择“(5)”的同学的回答结果写在此贴后面。</p>", "created": "2017-04-17T09:13:05Z", "bucket_order": 153, "bucket_name": "Week 4/16 - 4/22", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>2016011277 孙桢波</p>\n<p>具体可见 https://github.com/Bran-Sun/StrideScheduler</p>", "created": "2019-04-19T10:21:17Z", "bucket_order": 49, "bucket_name": "Week 4/14 - 4/20", "type": "feedback", "tag_good": [], "uid": "jsiyf76cGzf9", "children": [], "tag_good_arr": [], "id": "junxbl2rt2k4sg", "updated": "2019-04-19T10:21:17Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p><pre>import java.awt.*;<br />import java.util.*;<br />import java.util.List;<br /><br />public class StrideScheduler {<br />    public TreeSet&lt;Proc&gt; processes; //pass, process<br />    public Queue&lt;Proc&gt; init_process; //begin_time, process<br /><br />    public int global_pass, last_update, global_tickets, stride_whole, global_stride;<br />    public int quantum, time, unfinished;<br />    Proc current_proc;<br /><br />    public StrideScheduler(int stride_whole, int quantum, List&lt;Proc&gt; procs) {<br />        global_tickets = 0;<br />        time = 0;<br />        global_pass = 0;<br />        global_stride = 0;<br />        this.stride_whole = stride_whole;<br />        last_update = 0;<br />        this.quantum = quantum;<br /><br />        init_process = new LinkedList&lt;Proc&gt;();<br />        for (Proc p: procs) {<br />            init_process.offer(p);<br />        }<br /><br />        processes = new TreeSet&lt;Proc&gt;(new ProcComparator());<br />        unfinished = procs.size();<br />    }<br /><br />    public void update_global_pass() {<br />        int elapse = time - last_update;<br />        global_pass =  elapse / quantum * global_stride;<br />        last_update = time;<br />    }<br /><br />    public void update_global_tickets(int tickets) {<br />        global_tickets &#43;= tickets;<br />        if (global_tickets == 0) global_stride = 0;<br />        else global_stride = stride_whole / global_tickets;<br />    }<br /><br />    public void load_new_process() {<br />        while (true) {<br />            Proc proc = init_process.peek();<br />            if (proc != null &amp;&amp; proc.begin_time == time) {<br />                init_process.remove();<br /><br />                update_global_pass();<br />                proc.ready_init(global_pass);<br />                processes.add(proc);<br /><br />                update_global_tickets(proc.tickets);<br />            } else {<br />                break;<br />            }<br />        }<br />    }<br /><br />    public void stop_cur_proc() {<br />        Proc proc = processes.pollFirst();<br />        update_global_pass();<br />        update_global_tickets(-current_proc.tickets);<br />        current_proc.finish(time);<br />        current_proc = null;<br />        unfinished--;<br />    }<br /><br />    public void switch_out() {<br />        Proc out_proc= processes.pollFirst();<br />        //System.out.printf(&#34;switch out: %d\\n&#34;, processes.size());<br />        out_proc.switch_out(time);<br />        processes.add(out_proc);<br />        //System.out.printf(&#34;switch out add: %d\\n&#34;, processes.size());<br />        current_proc = null;<br />    }<br /><br />    public  void switch_in() {<br />        if (processes.isEmpty()) return;<br />        current_proc = processes.first();<br />        current_proc.switch_in(time);<br />    }<br /><br />    public void start_run() {<br />        time = -1;<br />        while (unfinished &gt; 0) {<br />            &#43;&#43;time;<br />            print();<br /><br />            load_new_process();<br /><br />            if (current_proc != null) {<br />                if (current_proc.is_over(time)) {<br />                    stop_cur_proc();<br />                } else if (current_proc.is_slice_out(time)) {<br />                    switch_out();<br />                }<br />            }<br /><br />            if (current_proc == null) {<br />                switch_in();<br />            }<br />        }<br />    }<br /><br />    public void print() {<br />        System.out.printf(&#34;-----time: %d, size: %d\\n&#34;, time, processes.size());<br />        if (current_proc != null) current_proc.printIntern();<br />    }<br /><br />}</pre>", "created": "2019-04-19T15:09:20Z", "bucket_order": 49, "bucket_name": "Week 4/14 - 4/20", "type": "feedback", "tag_good": [], "uid": "jsiyf76cGzf9", "children": [], "tag_good_arr": [], "id": "juo7m0eh66b2ca", "updated": "2019-04-19T15:09:20Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p><pre>public class Main {\n    static  int quantum = 2;\n    static  int stride_whole = 6;\n    public static void main(String[] args) {\n        ArrayList&lt;Proc&gt; procs = new ArrayList&lt;Proc&gt;();\n        procs.add(new Proc(&#34;A&#34;, 1, stride_whole, 0, 8, quantum));\n        procs.add(new Proc(&#34;B&#34;, 2, stride_whole, 0, 8, quantum));\n        procs.add(new Proc(&#34;C&#34;, 3, stride_whole, 0, 8, quantum));\n\n        StrideScheduler scheduler = new StrideScheduler(stride_whole, quantum, procs);\n        scheduler.start_run();\n\n        for (Proc p: procs) {\n            p.printResult();\n        }\n\n    }\n}</pre>\n<p>结果如下&#xff1a;</p>\n<p>-----time: 0, size: 0<br />-----time: 1, size: 3<br />name: C, last time: 0, pass: 2<br />-----time: 2, size: 3<br />name: C, last time: 0, pass: 2<br />-----time: 3, size: 3<br />name: B, last time: 2, pass: 3<br />-----time: 4, size: 3<br />name: B, last time: 2, pass: 3<br />-----time: 5, size: 3<br />name: C, last time: 4, pass: 4<br />-----time: 6, size: 3<br />name: C, last time: 4, pass: 4<br />-----time: 7, size: 3<br />name: A, last time: 6, pass: 6<br />-----time: 8, size: 3<br />name: A, last time: 6, pass: 6<br />-----time: 9, size: 3<br />name: B, last time: 8, pass: 6<br />-----time: 10, size: 3<br />name: B, last time: 8, pass: 6<br />-----time: 11, size: 3<br />name: C, last time: 10, pass: 6<br />-----time: 12, size: 3<br />name: C, last time: 10, pass: 6<br />-----time: 13, size: 3<br />name: C, last time: 12, pass: 8<br />-----time: 14, size: 3<br />name: C, last time: 12, pass: 8<br />-----time: 15, size: 2<br />name: B, last time: 14, pass: 9<br />-----time: 16, size: 2<br />name: B, last time: 14, pass: 9<br />-----time: 17, size: 2<br />name: A, last time: 16, pass: 12<br />-----time: 18, size: 2<br />name: A, last time: 16, pass: 12<br />-----time: 19, size: 2<br />name: B, last time: 18, pass: 12<br />-----time: 20, size: 2<br />name: B, last time: 18, pass: 12<br />-----time: 21, size: 1<br />name: A, last time: 20, pass: 18<br />-----time: 22, size: 1<br />name: A, last time: 20, pass: 18<br />-----time: 23, size: 1<br />name: A, last time: 22, pass: 24<br />-----time: 24, size: 1<br />name: A, last time: 22, pass: 24<br />------print proc: A<br />response time: 6<br />wait time: 16<br />turnaround time: 24<br />------print proc: B<br />response time: 2<br />wait time: 12<br />turnaround time: 20<br />------print proc: C<br />response time: 0<br />wait time: 6<br />turnaround time: 14</p>", "created": "2019-04-19T15:10:37Z", "bucket_order": 49, "bucket_name": "Week 4/14 - 4/20", "type": "feedback", "tag_good": [], "uid": "jsiyf76cGzf9", "children": [], "tag_good_arr": [], "id": "juo7nnq4jvj477", "updated": "2019-04-19T15:10:37Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "j1lwkb1s4ay1wg", "updated": "2017-04-17T09:13:05Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>(6)理解并实现EDF实时调度算法</p>\n<p></p>\n<p>选择“(6)”的同学的回答结果写在此贴后面。</p>", "created": "2017-04-17T09:13:31Z", "bucket_order": 153, "bucket_name": "Week 4/16 - 4/22", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "j1lwkv5q9zp6a0", "updated": "2017-04-17T09:13:31Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>(7)理解并实现RM实时调度算法</p>\n<p></p>\n<p>选择“(7)”的同学的回答结果写在此贴后面。</p>", "created": "2017-04-17T09:13:43Z", "bucket_order": 153, "bucket_name": "Week 4/16 - 4/22", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>更新于4.23&#xff0c;增加了U上界计算过程&#xff0c;判断任务是否可全部被调度&#xff0c;修正了之前变量命名的一些问题&#xff0c;并且可以随机生成任意数量的模拟&#xff08;简陋的&#xff09;进程</p>\n<pre>#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n#include &lt;ctime&gt;\nusing namespace std;\n#define TIME_LIMIT 10\n#define IDLE -1\n#define PROC_NUM 5\n#define D_LO 4\n#define D_HI 8\n#define C_LO 1\n#define C_HI 4\n#define T_LO 10\n#define T_HI 20\n\nclass process {\npublic:\n\tint Di = 1;\t//Deadline\n\tint Ci = 1, Ci_left; //执行时间\n\tint Ti = 1, Ti_left;\t//执行周期\n\tvoid set(int D, int C, int T) {\n\t\tthis-&gt;Di = D;\n\t\tthis-&gt;Ci = this-&gt;Ci_left = C;\n\t\tthis-&gt;Ti = this-&gt;Ti_left = T;\n\t}\n\t\n};\n\nvoid swap_proc(process* proc_list, int proc_num1, int proc_num2) {\n\tprocess tmp = proc_list[proc_num1];\n\tproc_list[proc_num1] = proc_list[proc_num2];\n\tproc_list[proc_num2] = tmp;\n}\n\nvoid init_schedule(process* proc_list, int proc_num) {\t//RM是个静态的调度方法\n\tif(proc_num &lt; 2)\n\t\treturn;\n\tfor(int i = proc_num - 1; i &gt;= 0; i--) {\n\t\tfor(int j = i; j &lt; proc_num; j&#43;&#43;) {\n\t\t\tif (proc_list[j - 1].Ti &gt; proc_list[j].Ti) {\n\t\t\t\tswap_proc(proc_list, j - 1, j);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint scheduler(process* proc_list, int proc_num) {\t//选择优先级高的\n\tint picked_index;\n\tfor (picked_index = 0; picked_index &lt; proc_num; picked_index&#43;&#43;) {\n\t\tif(proc_list[picked_index].Ci_left &gt; 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(picked_index == proc_num) {\n\t\tpicked_index = IDLE;\n\t}\n\treturn picked_index;\n}\n\ndouble U_count(process* proc_list, int proc_num) {\t//根据RM理论计算可调度比例\n\tdouble U = 0.0;\n\tfor(int i = 0; i &lt; proc_num; i&#43;&#43;) {\n\t\tU &#43;= proc_list[i].Ci / (double)proc_list[i].Ti;\n\t}\n\treturn U;\n}\n\ndouble Umax_count(int proc_num) {\t//计算U上界\n\treturn proc_num * (pow(2, 1 / double(proc_num)) - 1);//Umax=n*(2^(1/n)-1)\n}\n\nvoid tik(process* proc_list, int proc_num, int current_proc_index) {\t//走一步时钟\n\tfor(int i = 0; i &lt; proc_num; i&#43;&#43;) {\n\t\tif(i == current_proc_index) {\n\t\t\tproc_list[i].Ci_left--;\n\t\t\tproc_list[i].Ti_left--;\n\t\t\tif(proc_list[i].Ti_left == 0) {\n\t\t\t\tproc_list[i].Ci_left = proc_list[i].Ci;\n\t\t\t\tproc_list[i].Ti_left = proc_list[i].Ti;\n\t\t\t}\n\t\t} else {\n\t\t\tproc_list[i].Ti_left--;\n\t\t\tif(proc_list[i].Ti_left == 0) {\n\t\t\t\tproc_list[i].Ci_left = proc_list[i].Ci;\n\t\t\t\tproc_list[i].Ti_left = proc_list[i].Ti;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint random(double lo, double hi){\n\treturn lo &#43; int((hi - lo) * (rand() / (RAND_MAX &#43; 1.0)));\n}\n\nint main() {\n\tint current_proc_index = -1;\n\tsrand(unsigned(time(0)));\n\tprocess *proc_list = new process[PROC_NUM];\n\tfor(int i = 0; i &lt; PROC_NUM; i&#43;&#43;) {\n\t\tproc_list[i].set(random(D_LO, D_HI), random(C_LO, C_HI), random(T_LO, T_HI));\n\t}\n\tinit_schedule(proc_list, PROC_NUM);\n\tcout &lt;&lt; &#34;U is : &#34; &lt;&lt; U_count(proc_list, PROC_NUM) &lt;&lt; endl;\n\tcout &lt;&lt; &#34;U max is : &#34; &lt;&lt; Umax_count(PROC_NUM) &lt;&lt; endl;\n\tif(U_count(proc_list, PROC_NUM) &lt; Umax_count(PROC_NUM)) {\t//判断是否全部任务都能被调度\n\t\tcout &lt;&lt; &#34;Task schedulable!&#34; &lt;&lt; endl;\n\t} else {\n\t\tcout &lt;&lt; &#34;Task unschedulable!&#34; &lt;&lt; endl;\n\t}\n\tcout &lt;&lt; &#34;Process priority&#34; &lt;&lt; endl;\n\tfor(int i = 0; i &lt; PROC_NUM; i&#43;&#43;) {\n\t\tcout &lt;&lt; &#34;Ti:&#34; &lt;&lt; proc_list[i].Ti &lt;&lt; &#34;, Ci:&#34; &lt;&lt; proc_list[i].Ci &lt;&lt; &#34;, Di:&#34; &lt;&lt; proc_list[i].Di &lt;&lt; endl;\n\t}\n\tcout &lt;&lt; &#34;----------------&#34; &lt;&lt; endl;\n\tfor(int i = 0; i &lt; TIME_LIMIT; i&#43;&#43;) {\n\t\tcout &lt;&lt; &#34;Time &#34; &lt;&lt; i &lt;&lt; &#34;, running process &#34; &lt;&lt; current_proc_index &lt;&lt; endl;\n\t\tfor(int i = 0; i &lt; PROC_NUM; i&#43;&#43;) {\n\t\t\tcout &lt;&lt; &#34;Ti left:&#34; &lt;&lt; proc_list[i].Ti_left &lt;&lt; &#34;, Di left:&#34; &lt;&lt; proc_list[i].Ci_left &lt;&lt; endl;\n\t\t}\n\t\tcurrent_proc_index = scheduler(proc_list, PROC_NUM);\n\t\ttik(proc_list, PROC_NUM, current_proc_index);\n\t}\n\treturn 0;\n}</pre>\n<p></p>", "created": "2019-04-21T11:59:13Z", "bucket_order": 48, "bucket_name": "Week 4/21 - 4/27", "type": "feedback", "tag_good": [], "uid": "jsjp7j7mu8BB", "children": [], "tag_good_arr": [], "id": "juqvp87rz0p6re", "updated": "2019-04-21T11:59:13Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>采用5个进程&#xff0c;10个时间单位之后的输出</p>\n<pre>U is : 0.672926<br />U max is : 0.743492<br />Task schedulable!<br />Process priority<br />Ti:12, Ci:2, Di:6<br />Ti:12, Ci:1, Di:7<br />Ti:13, Ci:3, Di:4<br />Ti:15, Ci:2, Di:4<br />Ti:17, Ci:1, Di:6<br />----------------<br />Time 0, running process -1<br />Ti left:12, Di left:2<br />Ti left:12, Di left:1<br />Ti left:13, Di left:3<br />Ti left:15, Di left:2<br />Ti left:17, Di left:1<br />Time 1, running process 0<br />Ti left:11, Di left:1<br />Ti left:11, Di left:1<br />Ti left:12, Di left:3<br />Ti left:14, Di left:2<br />Ti left:16, Di left:1<br />Time 2, running process 0<br />Ti left:10, Di left:0<br />Ti left:10, Di left:1<br />Ti left:11, Di left:3<br />Ti left:13, Di left:2<br />Ti left:15, Di left:1<br />Time 3, running process 1<br />Ti left:9, Di left:0<br />Ti left:9, Di left:0<br />Ti left:10, Di left:3<br />Ti left:12, Di left:2<br />Ti left:14, Di left:1<br />Time 4, running process 2<br />Ti left:8, Di left:0<br />Ti left:8, Di left:0<br />Ti left:9, Di left:2<br />Ti left:11, Di left:2<br />Ti left:13, Di left:1<br />Time 5, running process 2<br />Ti left:7, Di left:0<br />Ti left:7, Di left:0<br />Ti left:8, Di left:1<br />Ti left:10, Di left:2<br />Ti left:12, Di left:1<br />Time 6, running process 2<br />Ti left:6, Di left:0<br />Ti left:6, Di left:0<br />Ti left:7, Di left:0<br />Ti left:9, Di left:2<br />Ti left:11, Di left:1<br />Time 7, running process 3<br />Ti left:5, Di left:0<br />Ti left:5, Di left:0<br />Ti left:6, Di left:0<br />Ti left:8, Di left:1<br />Ti left:10, Di left:1<br />Time 8, running process 3<br />Ti left:4, Di left:0<br />Ti left:4, Di left:0<br />Ti left:5, Di left:0<br />Ti left:7, Di left:0<br />Ti left:9, Di left:1<br />Time 9, running process 4<br />Ti left:3, Di left:0<br />Ti left:3, Di left:0<br />Ti left:4, Di left:0<br />Ti left:6, Di left:0<br />Ti left:8, Di left:0<br />Program ended with exit code: 0</pre>\n<p></p>", "created": "2019-04-21T15:31:21Z", "bucket_order": 48, "bucket_name": "Week 4/21 - 4/27", "type": "feedback", "tag_good": [], "uid": "jsjp7j7mu8BB", "children": [], "tag_good_arr": [], "id": "jur3a0qtmev3x9", "updated": "2019-04-21T15:31:21Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "j1lwl53ooyj24i", "updated": "2017-04-17T09:13:43Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>(8)理解并实现优先级反置方法</p>\n<p></p>\n<p>选择“(8)”的同学的回答结果写在此贴后面。</p>", "created": "2017-04-17T09:14:06Z", "bucket_order": 153, "bucket_name": "Week 4/16 - 4/22", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "j1lwlmg1uex29k", "updated": "2017-04-17T09:14:06Z", "config": {}}], "tag_good_arr": [], "id": "j1lwgjsw1nn37e", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 6, "num_favorites": 0, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169038470, "default_anonymity": "no"}, "error": null, "aid": "kyv0f4hywql5rr"}