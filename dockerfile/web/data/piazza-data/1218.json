{"result": {"history_size": 3, "folders": ["lecture16", "2018"], "nr": 1218, "data": {"embed_links": []}, "created": "2018-05-07T19:59:32Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "je2ib5nk89v6ca", "data": "jgwo6m1fueq2fa", "type": "create", "when": "2018-05-07T19:59:32Z"}, {"anon": "no", "uid": "je2ib5nk89v6ca", "data": "jgwo7bhvtoq2zq", "type": "update", "when": "2018-05-07T20:00:05Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "data": "jgx2wvelynn3f0", "type": "update", "when": "2018-05-08T02:51:51Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "data": "jgx33vr4ve2g8", "to": "jgwo6m1dkwq2f9", "type": "i_answer", "when": "2018-05-08T02:57:18Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "父进程不进行do_wait也不退出时的问题", "created": "2018-05-08T02:51:51Z", "content": "<p>上次课上向老师让我看一看父进程不进行do_wait也不退出时会发生什么问题&#xff0c;当时课上讨论给出的思路是让父进程不断fork&#xff0c;而不退出&#xff0c;不wait()&#xff0c;子进程创建之后直接退出。</p>\n<p></p>\n<p>请老师同学指正。</p>\n<p></p>\n<p>下面首先在Ubuntu16.04上给出了实现&#xff1a;</p>\n<pre>#include &lt;unistd.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n#define DATASIZE 10240000 // around 1GB per process\n\nint main(int argc, char** argv) {\n    int number = -1;\n    if (argc &gt; 1) {\n        number = atoi(argv[1]);\n    }\n    \n    double *data = (double *)malloc(sizeof(double) * DATASIZE);\n    for (int i = 0; i &lt; number || number &lt; 0; &#43;&#43;i) {\n\tpid_t pid = fork();\n\tif (pid == 0) {\n\t    exit(0);\n\t}\n\tif (pid &gt; 0) {\n\t    printf(&#34;Child pid %d is created.\\n&#34;, pid);\n\t}\n\telse {\n\t    printf(&#34;Fork error, returned pid is %d.\\n&#34;, pid);\n\t}\n    }\n    while(1);\n    return 0;\n}</pre>\n<p>其中设置number为最大的子进程数&#xff0c;可以通过命令行参数输入&#xff0c;负值时没有最大子进程数限制&#xff0c;</p>\n<p>当父进程pid返回值为负值时&#xff0c;进程槽已满&#xff0c;fork失败&#xff0c;但这里没有退出&#xff0c;而是继续尝试fork。</p>\n<p>开辟堆空间是想看子进程退出后是否会仍然占用这些空间的。</p>\n<p></p>\n<p>首先是一个简单的测试&#xff0c;程序名为fork_without_wait&#xff0c;则./fork_without_wait 10</p>\n<p><img src=\"/img/1218-61363113ff684d30.png\" alt=\"\" /></p>\n<p>然后可以使用ps命令来查看这些进程的情况&#xff08;ps aux | grep fork_without&#xff09;&#xff1a;</p>\n<p>USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</p>\n<p>------------------------------------------------------------------------------------------------------------------</p>\n<p><img src=\"/img/1218-d2164245f0d4ee30.png\" alt=\"\" /></p>\n<p>由此可见&#xff0c;子进程退出时已经清理了用户堆栈数据&#xff0c;所以内存和虚存的占用量均为0&#xff0c;进程状态均为ZOMBIE&#xff08;Z&#43;&#xff09;&#xff0c;所以其主要占用的实际上是进程槽、进程列表、内核栈等在do_wait()中清理掉的部分。</p>\n<p></p>\n<p>在进程数比较多&#xff0c;特别是在使用number为负值即子进程数没有上限时&#xff0c;就会出现无法创建新进程&#xff0c;一有其他进程退出就立刻被fork出的新进程占用空间&#xff0c;导致系统卡顿无响应&#xff0c;但如果没有使用&amp;后台运行的话&#xff0c;还可以通过Ctrl&#43;C终止所有的父子进程&#xff0c;如果是后台运行&#xff0c;基本上除了重启系统就没啥解决方法了。</p>\n<p></p>\n<p>以下是./fork_without_wait -1</p>\n<p><img src=\"/img/1218-22e8bd59b6cde794.png\" alt=\"\" /></p>\n<p>两次Ctrl&#43;C&#xff0c;第一次出现fork failed&#xff0c;第二次才终止该程序</p>\n<p></p>\n<p>而在ucore中&#xff0c;去掉了动态分配&#xff0c;使用lab8的载入程序的方式显示情况与上面相同&#xff0c;终止可以直接关闭qemu。</p>\n<p>由于不太清楚需要用gdb追踪什么&#xff0c;所以没有使用make gdb&#xff08;同时也的确是时间有点紧了&#xff0c;因为周一上午坐飞机赶到成都出差&#xff0c;干活一直到晚上才回到宾馆&#xff0c;而且周二上午还有工作安排&#xff09;。</p>\n<p></p>\n<p>通过查看do_wait()的代码&#xff0c;也可以看到&#xff0c;在找到需要清理的子进程后&#xff0c;做的处理如下&#xff1a;</p>\n<pre>found:\n    if (proc == idleproc || proc == initproc) {\n        panic(&#34;wait idleproc or initproc.\\n&#34;);\n    }\n    if (code_store != NULL) {\n        *code_store = proc-&gt;exit_code; // 设置返回值\n    }\n    local_intr_save(intr_flag);\n    {\n        unhash_proc(proc);  // 将该进程从hash链表中移除\n        remove_links(proc); // 将该进程从进程链接中移除\n    }\n    local_intr_restore(intr_flag);\n    put_kstack(proc);  // 释放内核栈\n    kfree(proc);       // 释放该进程的struct_proc\n    return 0;</pre>\n<p>没有do_wait()实际上就是这些没有清理&#xff0c;其他的都在do_exit()中清理了</p>\n<pre>// do_exit - called by sys_exit\n//   1. call exit_mmap &amp; put_pgdir &amp; mm_destroy to free the almost all memory space of process\n//   2. set process&#39; state as PROC_ZOMBIE, then call wakeup_proc(parent) to ask parent reclaim itself.\n//   3. call scheduler to switch to other process\nint\ndo_exit(int error_code) {\n    if (current == idleproc) {\n        panic(&#34;idleproc exit.\\n&#34;);\n    }\n    if (current == initproc) {\n        panic(&#34;initproc exit.\\n&#34;);\n    }\n    // 清理内存管理数据结构mm\n    struct mm_struct *mm = current-&gt;mm;\n    if (mm != NULL) {\n        lcr3(boot_cr3);\n        if (mm_count_dec(mm) == 0) {\n            exit_mmap(mm);\n            put_pgdir(mm);\n            mm_destroy(mm);\n        }\n        current-&gt;mm = NULL;\n    }\n    put_files(current); //for LAB8\n    current-&gt;state = PROC_ZOMBIE;   // 修改进程状态\n    current-&gt;exit_code = error_code;  // 设置返回值\n    \n    bool intr_flag;\n    struct proc_struct *proc;\n    local_intr_save(intr_flag);\n    {\n        proc = current-&gt;parent; \n        if (proc-&gt;wait_state == WT_CHILD) {\n            wakeup_proc(proc);          // 唤醒父进程\n        }\n        while (current-&gt;cptr != NULL) {   // 该进程有子进程&#xff0c;就将子进程过继给initproc\n            proc = current-&gt;cptr;\n            current-&gt;cptr = proc-&gt;optr;\n    \n            proc-&gt;yptr = NULL;\n            if ((proc-&gt;optr = initproc-&gt;cptr) != NULL) {\n                initproc-&gt;cptr-&gt;yptr = proc;\n            }\n            proc-&gt;parent = initproc;\n            initproc-&gt;cptr = proc;\n            if (proc-&gt;state == PROC_ZOMBIE) {  // 如果过继的子进程已经处于ZOMBIE状态&#xff0c;则唤醒initproc进行清理\n                if (initproc-&gt;wait_state == WT_CHILD) {\n                    wakeup_proc(initproc);\n                }\n            }\n        }\n    }\n    local_intr_restore(intr_flag);\n    \n    schedule();\n    panic(&#34;do_exit will not return!! %d.\\n&#34;, current-&gt;pid); // 正常的do_exit不会运行该指令</pre>\n<p>由此可见&#xff0c;do_exit()清理用户进程的页表等内存管理数据结构&#xff0c;修改进程状态&#xff0c;唤醒父进程&#xff08;或过继到的initproc&#xff09;进行清理&#xff0c;最后让出CPU使用权&#xff0c;而do_wait()则是在找到退出的子进程后将其内核栈释放&#xff0c;移出hash链表和进程链表&#xff0c;设置返回值和释放进程控制块。</p>"}, {"anon": "no", "uid": "je2ib5nk89v6ca", "subject": "父进程不进行do_wait也不退出时的问题", "created": "2018-05-07T20:00:05Z", "content": "<p>上次课上向老师让我看一看父进程不进行do_wait也不退出时会发生什么问题&#xff0c;当时课上讨论给出的思路是让父进程不断fork&#xff0c;而不退出&#xff0c;不wait()&#xff0c;子进程创建之后直接退出。</p>\n<p></p>\n<p>请老师同学指正。</p>\n<p></p>\n<p>下面首先在Ubuntu16.04上给出了实现&#xff1a;</p>\n<pre>#include &lt;unistd.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n#define DATASIZE 10240000 // around 1GB per process\n\nint main(int argc, char** argv) {\n    int number = -1;\n    if (argc &gt; 1) {\n        number = atoi(argv[1]);\n    }\n    \n    double *data = (double *)malloc(sizeof(double) * DATASIZE);\n    for (int i = 0; i &lt; number || number &lt; 0; &#43;&#43;i) {\n\tpid_t pid = fork();\n\tif (pid == 0) {\n\t    exit(0);\n\t}\n\tif (pid &gt; 0) {\n\t    printf(&#34;Child pid %d is created.\\n&#34;, pid);\n\t}\n\telse {\n\t    printf(&#34;Fork error, returned pid is %d.\\n&#34;, pid);\n\t}\n    }\n    while(1);\n    return 0;\n}</pre>\n<p>其中设置number为最大的子进程数&#xff0c;可以通过命令行参数输入&#xff0c;负值时没有最大子进程数限制&#xff0c;</p>\n<p>当父进程pid返回值为负值时&#xff0c;进程槽已满&#xff0c;fork失败&#xff0c;但这里没有退出&#xff0c;而是继续尝试fork。</p>\n<p>开辟堆空间是想看子进程退出后是否会仍然占用这些空间的。</p>\n<p></p>\n<p>首先是一个简单的测试&#xff0c;程序名为fork_without_wait&#xff0c;则./fork_without_wait 10</p>\n<p><img src=\"/img/1218-61363113ff684d30.png\" alt=\"\" /></p>\n<p>然后可以使用ps命令来查看这些进程的情况&#xff08;ps aux | grep fork_without&#xff09;&#xff1a;</p>\n<p>USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</p>\n<p>------------------------------------------------------------------------------------------------------------------</p>\n<p><img src=\"/img/1218-d2164245f0d4ee30.png\" alt=\"\" /></p>\n<p>由此可见&#xff0c;子进程退出时已经清理了用户堆栈数据&#xff0c;所以内存和虚存的占用量均为0&#xff0c;进程状态均为ZOMBIE&#xff08;Z&#43;&#xff09;&#xff0c;所以其主要占用的实际上是进程槽、进程列表、内核栈等在do_wait()中清理掉的部分。</p>\n<p></p>\n<p>在进程数比较多&#xff0c;特别是在使用number为负值即子进程数没有上限时&#xff0c;就会出现无法创建新进程&#xff0c;一有其他进程退出就立刻被fork出的新进程占用空间&#xff0c;导致系统卡顿无响应&#xff0c;但如果没有使用&amp;后台运行的话&#xff0c;还可以通过Ctrl&#43;C终止所有的父子进程&#xff0c;如果是后台运行&#xff0c;基本上除了重启系统就没啥解决方法了。</p>\n<p></p>\n<p>以下是./fork_without_wait -1</p>\n<p><img src=\"/img/1218-22e8bd59b6cde794.png\" alt=\"\" /></p>\n<p>两次Ctrl&#43;C&#xff0c;第一次出现fork failed&#xff0c;第二次才终止该程序</p>\n<p></p>\n<p>而在ucore中&#xff0c;去掉了动态分配&#xff0c;使用lab8的载入程序的方式显示情况与上面相同&#xff0c;终止可以直接关闭qemu。</p>\n<p>由于不太清楚需要用gdb追踪什么&#xff0c;所以没有使用make gdb&#xff08;同时也的确是时间有点紧了&#xff0c;因为周一上午坐飞机赶到成都出差&#xff0c;干活一直到晚上才回到宾馆&#xff0c;而且周二上午还有工作安排&#xff09;。</p>\n<p></p>\n<p>通过查看do_wait()的代码&#xff0c;也可以看到&#xff0c;在找到需要清理的子进程后&#xff0c;做的处理如下&#xff1a;</p>\n<pre>found:\n    if (proc == idleproc || proc == initproc) {\n        panic(&#34;wait idleproc or initproc.\\n&#34;);\n    }\n    if (code_store != NULL) {\n        *code_store = proc-&gt;exit_code; // 设置返回值\n    }\n    local_intr_save(intr_flag);\n    {\n        unhash_proc(proc);  // 将该进程从hash链表中移除\n        remove_links(proc); // 将该进程从进程链接中移除\n    }\n    local_intr_restore(intr_flag);\n    put_kstack(proc);  // 释放内核栈\n    kfree(proc);       // 释放该进程的struct_proc\n    return 0;</pre>\n<p>没有do_wait()实际上就是这些没有清理&#xff0c;其他的都在do_exit()中清理了</p>\n<pre>// do_exit - called by sys_exit\n//   1. call exit_mmap &amp; put_pgdir &amp; mm_destroy to free the almost all memory space of process\n//   2. set process&#39; state as PROC_ZOMBIE, then call wakeup_proc(parent) to ask parent reclaim itself.\n//   3. call scheduler to switch to other process\nint\ndo_exit(int error_code) {\n    if (current == idleproc) {\n        panic(&#34;idleproc exit.\\n&#34;);\n    }\n    if (current == initproc) {\n        panic(&#34;initproc exit.\\n&#34;);\n    }\n    // 清理内存管理数据结构mm\n    struct mm_struct *mm = current-&gt;mm;\n    if (mm != NULL) {\n        lcr3(boot_cr3);\n        if (mm_count_dec(mm) == 0) {\n            exit_mmap(mm);\n            put_pgdir(mm);\n            mm_destroy(mm);\n        }\n        current-&gt;mm = NULL;\n    }\n    put_files(current); //for LAB8\n    current-&gt;state = PROC_ZOMBIE;   // 修改进程状态\n    current-&gt;exit_code = error_code;  // 设置返回值\n    \n    bool intr_flag;\n    struct proc_struct *proc;\n    local_intr_save(intr_flag);\n    {\n        proc = current-&gt;parent; \n        if (proc-&gt;wait_state == WT_CHILD) {\n            wakeup_proc(proc);          // 唤醒父进程\n        }\n        while (current-&gt;cptr != NULL) {   // 该进程有子进程&#xff0c;就将子进程过继给initproc\n            proc = current-&gt;cptr;\n            current-&gt;cptr = proc-&gt;optr;\n    \n            proc-&gt;yptr = NULL;\n            if ((proc-&gt;optr = initproc-&gt;cptr) != NULL) {\n                initproc-&gt;cptr-&gt;yptr = proc;\n            }\n            proc-&gt;parent = initproc;\n            initproc-&gt;cptr = proc;\n            if (proc-&gt;state == PROC_ZOMBIE) {  // 如果过继的子进程已经处于ZOMBIE状态&#xff0c;则唤醒initproc进行清理\n                if (initproc-&gt;wait_state == WT_CHILD) {\n                    wakeup_proc(initproc);\n                }\n            }\n        }\n    }\n    local_intr_restore(intr_flag);\n    \n    schedule();\n    panic(&#34;do_exit will not return!! %d.\\n&#34;, current-&gt;pid); // 正常的do_exit不会运行该指令</pre>\n<p>由此可见&#xff0c;do_exit()清理用户进程的页表等内存管理数据结构&#xff0c;修改进程状态&#xff0c;唤醒父进程&#xff08;或过继到的initproc&#xff09;进行清理&#xff0c;最后让出CPU使用权&#xff0c;而do_wait()则是在找到退出的子进程后将其内核栈释放&#xff0c;移出hash链表和进程链表&#xff0c;设置返回值和释放进程控制块。</p>"}, {"anon": "no", "uid": "je2ib5nk89v6ca", "subject": "父进程不进行do_wait也不退出时的问题", "created": "2018-05-07T19:59:32Z", "content": "<p>上次课上向老师让我看一看父进程不进行do_wait也不退出时会发生什么问题&#xff0c;当时课上讨论给出的思路是让父进程不断fork&#xff0c;而不退出&#xff0c;不wait()&#xff0c;子进程创建之后直接退出。</p>\n<p></p>\n<p>请老师同学指正。</p>\n<p></p>\n<p>下面首先在Ubuntu16.04上给出了实现&#xff1a;</p>\n<pre>#include &lt;unistd.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n#define DATASIZE 10240000 // around 1GB per process\n\nint main(int argc, char** argv) {\n    int number = -1;\n    if (argc &gt; 1) {\n        number = atoi(argv[1]);\n    }\n    \n    double *data = (double *)malloc(sizeof(double) * DATASIZE);\n    for (int i = 0; i &lt; number || number &lt; 0; &#43;&#43;i) {\n\tpid_t pid = fork();\n\tif (pid == 0) {\n\t    exit(0);\n\t}\n\tif (pid &gt; 0) {\n\t    printf(&#34;Child pid %d is created.\\n&#34;, pid);\n\t}\n\telse {\n\t    printf(&#34;Fork error, returned pid is %d.\\n&#34;, pid);\n\t}\n    }\n    while(1);\n    return 0;\n}</pre>\n<p>其中设置number为最大的子进程数&#xff0c;可以通过命令行参数输入&#xff0c;负值时没有最大子进程数限制&#xff0c;</p>\n<p>当父进程pid返回值为负值时&#xff0c;进程槽已满&#xff0c;fork失败&#xff0c;但这里没有退出&#xff0c;而是继续尝试fork。</p>\n<p>开辟堆空间是想看子进程退出后是否会仍然占用这些空间的。</p>\n<p></p>\n<p>首先是一个简单的测试&#xff0c;程序名为fork_without_wait&#xff0c;则./fork_without_wait 10</p>\n<p><img src=\"/img/1218-61363113ff684d30.png\" alt=\"\" /></p>\n<p>然后可以使用ps命令来查看这些进程的情况&#xff08;ps aux | grep fork_without&#xff09;&#xff1a;</p>\n<p>USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</p>\n<p>------------------------------------------------------------------------------------------------------------------</p>\n<p><img src=\"/img/1218-d2164245f0d4ee30.png\" alt=\"\" /></p>\n<p>由此可见&#xff0c;子进程退出时已经清理了用户堆栈数据&#xff0c;所以内存和虚存的占用量均为0&#xff0c;进程状态均为ZOMBIE&#xff08;Z&#43;&#xff09;&#xff0c;所以其主要占用的实际上是进程槽、进程列表、内核栈等在do_wait()中清理掉的部分。</p>\n<p></p>\n<p>在进程数比较多&#xff0c;特别是在使用number为负值即子进程数没有上限时&#xff0c;就会出现无法创建新进程&#xff0c;一有其他进程退出就立刻被fork出的新进程占用空间&#xff0c;导致系统卡顿无响应&#xff0c;但如果没有使用&amp;后台运行的话&#xff0c;还可以通过Ctrl&#43;C终止所有的父子进程&#xff0c;如果是后台运行&#xff0c;基本上除了重启系统就没啥解决方法了。</p>\n<p></p>\n<p>以下是./fork_without_wait -1</p>\n<p><img src=\"/img/1218-22e8bd59b6cde794.png\" alt=\"\" /></p>\n<p>两次Ctrl&#43;C&#xff0c;第一次出现fork failed&#xff0c;第二次才终止该程序</p>\n<p></p>\n<p>而在ucore中&#xff0c;去掉了动态分配&#xff0c;使用lab8的载入程序的方式显示情况与上面相同&#xff0c;终止可以直接关闭qemu。</p>\n<p>由于不太清楚需要用gdb追踪什么&#xff0c;所以没有使用make gdb&#xff08;同时也的确是时间有点紧了&#xff0c;因为周一上午坐飞机赶到成都出差&#xff0c;干活一直到晚上才回到宾馆&#xff0c;而且周二上午还有工作安排&#xff09;。</p>\n<p></p>\n<p>通过查看do_wait()的代码&#xff0c;也可以看到&#xff0c;在找到需要清理的子进程后&#xff0c;做的处理如下&#xff1a;</p>\n<pre>found:\n    if (proc == idleproc || proc == initproc) {\n        panic(&#34;wait idleproc or initproc.\\n&#34;);\n    }\n    if (code_store != NULL) {\n        *code_store = proc-&gt;exit_code; // 设置返回值\n    }\n    local_intr_save(intr_flag);\n    {\n        unhash_proc(proc);  // 将该进程从hash链表中移除\n        remove_links(proc); // 将该进程从进程链接中移除\n    }\n    local_intr_restore(intr_flag);\n    put_kstack(proc);  // 释放内核栈\n    kfree(proc);       // 释放该进程的struct_proc\n    return 0;</pre>\n<p>没有do_wait()实际上就是这些没有清理&#xff0c;其他的都在do_exit()中清理了</p>\n<pre>// do_exit - called by sys_exit\n//   1. call exit_mmap &amp; put_pgdir &amp; mm_destroy to free the almost all memory space of process\n//   2. set process&#39; state as PROC_ZOMBIE, then call wakeup_proc(parent) to ask parent reclaim itself.\n//   3. call scheduler to switch to other process\nint\ndo_exit(int error_code) {\n    if (current == idleproc) {\n        panic(&#34;idleproc exit.\\n&#34;);\n    }\n    if (current == initproc) {\n        panic(&#34;initproc exit.\\n&#34;);\n    }\n    // 清理内存管理数据结构mm\n    struct mm_struct *mm = current-&gt;mm;\n    if (mm != NULL) {\n        lcr3(boot_cr3);\n        if (mm_count_dec(mm) == 0) {\n            exit_mmap(mm);\n            put_pgdir(mm);\n            mm_destroy(mm);\n        }\n        current-&gt;mm = NULL;\n    }\n    put_files(current); //for LAB8\n    current-&gt;state = PROC_ZOMBIE;   // 修改进程状态\n    current-&gt;exit_code = error_code;  // 设置返回值\n    \n    bool intr_flag;\n    struct proc_struct *proc;\n    local_intr_save(intr_flag);\n    {\n        proc = current-&gt;parent; \n        if (proc-&gt;wait_state == WT_CHILD) {\n            wakeup_proc(proc);          // 唤醒父进程\n        }\n        while (current-&gt;cptr != NULL) {   // 该进程有子进程&#xff0c;就将子进程过继给initproc\n            proc = current-&gt;cptr;\n            current-&gt;cptr = proc-&gt;optr;\n    \n            proc-&gt;yptr = NULL;\n            if ((proc-&gt;optr = initproc-&gt;cptr) != NULL) {\n                initproc-&gt;cptr-&gt;yptr = proc;\n            }\n            proc-&gt;parent = initproc;\n            initproc-&gt;cptr = proc;\n            if (proc-&gt;state == PROC_ZOMBIE) {  // 如果过继的子进程已经处于ZOMBIE状态&#xff0c;则唤醒initproc进行清理\n                if (initproc-&gt;wait_state == WT_CHILD) {\n                    wakeup_proc(initproc);\n                }\n            }\n        }\n    }\n    local_intr_restore(intr_flag);\n    \n    schedule();\n    panic(&#34;do_exit will not return!! %d.\\n&#34;, current-&gt;pid); // 正常的do_exit不会运行该指令</pre>\n<p>由此可见&#xff0c;do_exit()清理用户进程的页表等内存管理数据结构&#xff0c;修改进程状态&#xff0c;唤醒父进程&#xff08;或过继到的initproc&#xff09;进行清理&#xff0c;最后让出CPU使用权&#xff0c;而do_wait()则是在找到退出的子进程后将其内核栈释放&#xff0c;移出hash链表和进程链表&#xff0c;设置返回值和释放进程控制块。</p>"}], "type": "question", "tags": ["2018", "lecture16", "student"], "tag_good": [{"role": "instructor", "name": "Yong XIANG", "endorser": {}, "admin": true, "photo": null, "id": "hdjonbiyfs62ie", "photo_url": null, "us": false, "class_sections": ["课程设计_i5j09fnsl7k5x0", "清华学生_i5j09fnsl7k5x0", "所有老师和助教_i5j09fnsl7k5x0", "os2018spring_i5j09fnsl7k5x0"], "facebook_id": null}, {"role": "student", "name": "Yiwei Zhang", "endorser": {}, "admin": false, "photo": null, "id": "jshne38wsp64q9", "photo_url": null, "published": true, "us": false, "facebook_id": null}], "unique_views": 158, "children": [{"history_size": 1, "folders": [], "data": {"embed_links": []}, "created": "2018-05-08T02:57:18Z", "bucket_order": 3, "tag_endorse": [{"role": "student", "name": "Jesauca@163.com", "endorser": {}, "admin": false, "photo": null, "id": "kg6kg6bsabl5hv", "photo_url": null, "published": true, "us": false, "facebook_id": null}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "", "created": "2018-05-08T02:57:18Z", "content": "<p>通过分析do_wait()函数和do_exit()函数的执行流程&#xff0c;可以很好地说明进程正常退出、孤儿进程和僵尸进程的关系。李凯文同学的分析和测试程序很好地展现这一点。</p>"}], "type": "i_answer", "tag_endorse_arr": ["kg6kg6bsabl5hv"], "children": [], "id": "jgx33vr05a82g7", "config": {}, "is_tag_endorse": false}], "tag_good_arr": ["hdjonbiyfs62ie", "jshne38wsp64q9"], "no_answer": 0, "id": "jgwo6m1dkwq2f9", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 3, "num_favorites": 1, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169434078, "default_anonymity": "no"}, "error": null, "aid": "kyv0nlr2rje2dr"}