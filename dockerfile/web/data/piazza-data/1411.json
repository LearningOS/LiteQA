{"result": {"folders": ["lab2", "lab4", "lecture4"], "nr": 1411, "data": {"embed_links": []}, "created": "2020-03-03T06:09:47Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "k6ojtppjd4xxr", "data": "k7bhswclgs71rb", "type": "create", "when": "2020-03-03T06:09:47Z"}, {"anon": "no", "uid": "k6ojtppjd4xxr", "data": "k7crc1dw8xa64t", "type": "update", "when": "2020-03-04T03:24:23Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "k6ojtppjd4xxr", "subject": "关于rcore中的SegmentTreeAllocator实现的疑问和想法", "created": "2020-03-04T03:24:23Z", "content": "<md>首先感谢助教组精心编写的文档。rcore 实验物理内存页式管理一节中给出的 &#96;SegmentTreeAllocator&#96; 实现我有些许疑惑的地方。\n\n首先&#xff0c;结构体中各字段没有给出注释&#xff0c;结合上下文的代码&#xff0c;我推测&#xff1a;\n1. 线段树的根的index是1&#xff0c;底层叶子节点表示每个物理页是否可用。\n2.  &#96;m&#96; 是定位第一个物理页结点在线段树中的index的。\n\n但是仔细分析了代码&#xff0c;并结合我自己的样例&#xff0c;发现程序实际会比预期多分配一层的线段树结点&#xff0c;造成不必要的浪费&#xff0c;而且导致实际访问到的线段树结点可能会超出a数组的长度 &#96;MAX_PHYSICAL_PAGES &lt;&lt; 1&#96; 。这是因为 m 可能取 n 的2倍左右&#xff0c;而代码在&#96;init&#96;的时候有一个 &#96;for i in (1..(self.m &lt;&lt; 1)) {...}&#96; \n\n同时&#xff0c;原有实现的 alloc 和 dealloc 程序也有若干有待优化的点&#xff08;例如提前结束循环&#xff09;\n\n综上&#xff0c;我对现有 &#96;SegmentTreeAllocator&#96; 实现表示质疑&#xff0c;并尝试给出在细节处理上稍有不同的下面这种实现&#xff0c;经本人的测试&#xff0c;运行结果暂时没有bug&#xff0c;表达逻辑可能有待优化&#xff0c;但理论上应该更比原实现更优。欢迎大家提出疑议和指正&#xff01;\n\n&#96;&#96;&#96;rust\npub struct SegmentTreeAllocator {\n    // assume the tree root&#39;s index is 1\n\n    // availability data buffer, 1 - available, 0 - occupied\n    a: [bool; MAX_PHYSICAL_PAGES &lt;&lt; 1],\n    // number of internal nodes\n    m: usize,\n    // number of ppn\n    n: usize,\n    // size of buffer used\n    size: usize,\n    offset: usize,\n}\n\n#[inline(always)]\nfn ceil_to_power_of_2(n: usize) -&gt; usize {\n    let mut p = 1;\n    while p &lt; n { p &lt;&lt;= 1; }\n    p\n}\n\n#[inline(always)]\nfn l_child(n: usize) -&gt; usize { (n &lt;&lt; 1) }\n\n#[inline(always)]\nfn r_child(n: usize) -&gt; usize { (n &lt;&lt; 1) | 1 }\n\n#[inline(always)]\nfn parent(n: usize) -&gt; usize { (n &gt;&gt; 1) }\n\nimpl SegmentTreeAllocator {\n    // init with ppn ranged [l, r)\n    pub fn init(&amp;mut self, l: usize, r: usize) {\n        self.n = r - l;\n        assert!(self.n &gt; 1);\n        self.m = ceil_to_power_of_2(self.n) - 1;\n        self.size = r_child(self.m);\n        self.offset = l;\n        for i in (1..=self.m &#43; self.n) { self.a[i] = true; }\n        for i in (self.m &#43; self.n &#43; 1..=self.size) { self.a[i] = false; };\n    }\n\n    // allocate a physical page (left comes first), return the ppn\n    pub fn alloc(&amp;mut self) -&gt; Option&lt;usize&gt; {\n        if !self.a[1] {\n            println!(&#34;No available physical page!&#34;);\n            return None;\n        }\n        let mut p: usize = 2;\n        while p &lt;= self.m { // not at the leaves\n            if self.a[p] {\n                p = l_child(p);\n            } else if self.a[p &#43; 1] {\n                p = l_child(p &#43; 1);\n            } else {\n                unreachable!()\n            }\n        }\n        if self.a[p] { // at some leaf\n            ;\n        } else if self.a[p &#43; 1] {\n            p = p &#43; 1;\n        } else {\n            unreachable!()\n        }\n        self.a[p] = false; // mark\n        let ppn = self.offset &#43; p - self.m - 1;\n        // update ancestors\n        p = parent(p);\n        while p &gt; 0 {\n            let available = self.a[l_child(p)] | self.a[r_child(p)];\n            if available { break; }\n            self.a[p] = false;\n            p = parent(p);\n        }\n        Some(ppn)\n    }\n\n    // deallocate a physical page &#96;p&#96;, panic if the specified page not found\n    pub fn dealloc(&amp;mut self, ppn: usize) {\n        assert!(ppn &gt;= self.offset);\n        let mut p = ppn - self.offset;\n        assert!(p &lt; self.n);\n        p &#43;= self.m &#43; 1;\n        if self.a[p] {\n            println!(&#34;Cannot dealloc physical page {}, which is already free!&#34;, p);\n            return;\n        }\n        self.a[p] = true;\n        // update ancestors\n        p = parent(p);\n        while p &gt; 0 {\n            let available = self.a[l_child(p)] | self.a[r_child(p)];\n            if !self.a[p] &amp;&amp; available { // has update\n                self.a[p] = true;\n                p = parent(p);\n            } else { // no update\n                break;\n            }\n        }\n    }\n}\n&#96;&#96;&#96;\n</md>"}, {"anon": "no", "uid": "k6ojtppjd4xxr", "subject": "关于rcore中的SegmentTreeAllocator实现的疑问和想法", "created": "2020-03-03T06:09:47Z", "content": "<md>首先感谢助教组精心编写的文档。rcore 实验物理内存页式管理一节中给出的 &#96;SegmentTreeAllocator&#96; 实现我有些许疑惑的地方。\n\n首先&#xff0c;结构体中各字段没有给出注释&#xff0c;结合上下文的代码&#xff0c;我推测&#xff1a;\n1. 线段树的根的index是1&#xff0c;底层叶子节点表示每个物理页是否可用。\n2.  &#96;m&#96; 是定位第一个物理页结点在线段树中的index的。\n\n但是仔细分析了代码&#xff0c;并结合我自己的样例&#xff0c;发现程序实际会比预期多分配一层的线段树结点&#xff0c;造成不必要的浪费&#xff0c;而且导致实际访问到的线段树结点可能会超出a数组的长度 &#96;MAX_PHYSICAL_PAGES &lt;&lt; 1&#96; 。这是因为 m 可能取 n 的2倍左右&#xff0c;而代码在&#96;init&#96;的时候有一个 &#96;for i in (1..(self.m &lt;&lt; 1)) {...}&#96; \n\n同时&#xff0c;原有实现的 alloc 和 dealloc 程序也有若干有待优化的点&#xff08;例如提前结束循环&#xff09;\n\n综上&#xff0c;我对现有 &#96;SegmentTreeAllocator&#96; 实现表示质疑&#xff0c;并尝试给出在细节处理上稍有不同的下面这种实现&#xff0c;经本人的测试&#xff0c;运行结果暂时没有bug&#xff0c;表达逻辑可能有待优化&#xff0c;但理论上应该更比原实现更优。欢迎大家提出疑议和指正&#xff01;\n\n&#96;&#96;&#96;rust\npub struct SegmentTreeAllocator {\n    // assume the tree root&#39;s index is 1\n\n    // availability data buffer, 1 - available, 0 - occupied\n    a: [bool; MAX_PHYSICAL_PAGES &lt;&lt; 1],\n    // number of internal nodes\n    m: usize,\n    // number of ppn\n    n: usize,\n    // size of buffer used\n    size: usize,\n    offset: usize,\n}\n\n#[inline(always)]\nfn ceil_to_power_of_2(n: usize) -&gt; usize {\n    let mut p = 1;\n    while p &lt; n { p &lt;&lt;= 1; }\n    p\n}\n\n#[inline(always)]\nfn l_child(n: usize) -&gt; usize { (n &lt;&lt; 1) }\n\n#[inline(always)]\nfn r_child(n: usize) -&gt; usize { (n &lt;&lt; 1) | 1 }\n\n#[inline(always)]\nfn parent(n: usize) -&gt; usize { (n &gt;&gt; 1) }\n\nimpl SegmentTreeAllocator {\n    // init with ppn ranged [l, r)\n    pub fn init(&amp;mut self, l: usize, r: usize) {\n        self.n = r - l;\n        assert!(self.n &gt; 1);\n        self.m = ceil_to_power_of_2(self.n) - 1;\n        self.size = r_child(self.m);\n        self.offset = l;\n        for i in (1..=self.m &#43; self.n) { self.a[i] = true; }\n        for i in (self.m &#43; self.n &#43; 1..=self.size) { self.a[i] = false; };\n    }\n\n    // allocate a physical page (left comes first), return the ppn\n    pub fn alloc(&amp;mut self) -&gt; Option&lt;usize&gt; {\n        if !self.a[1] {\n            println!(&#34;No available physical page!&#34;);\n            return None;\n        }\n        let mut p: usize = 2;\n        while p &lt;= self.m { // not at the leaves\n            if self.a[p] {\n                p = l_child(p);\n            } else if self.a[p &#43; 1] {\n                p = l_child(p &#43; 1);\n            } else {\n                unreachable!()\n            }\n        }\n        if self.a[p] { // at some leaf\n            ;\n        } else if self.a[p &#43; 1] {\n            p = p &#43; 1;\n        } else {\n            unreachable!()\n        }\n        self.a[p] = false; // mark\n        let ppn = self.offset &#43; p - self.m - 1;\n        // update ancestors\n        p = parent(p);\n        while p &gt; 0 {\n            let available = self.a[l_child(p)] | self.a[r_child(p)];\n            if available { break; }\n            self.a[p] = false;\n            p = parent(p);\n        }\n        Some(ppn)\n    }\n\n    // deallocate a physical page &#96;p&#96;, panic if the specified page not found\n    pub fn dealloc(&amp;mut self, ppn: usize) {\n        assert!(ppn &gt;= self.offset);\n        let mut p = ppn - self.offset;\n        assert!(p &lt; self.n);\n        p &#43;= self.m &#43; 1;\n        if self.a[p] {\n            println!(&#34;Cannot dealloc physical page {}, which is already free!&#34;, p);\n            return;\n        }\n        self.a[p] = true;\n        // update ancestors\n        p = parent(p);\n        while p &gt; 0 {\n            let available = self.a[l_child(p)] | self.a[r_child(p)];\n            if !self.a[p] &amp;&amp; available { // has update\n                self.a[p] = true;\n                p = parent(p);\n            } else { // no update\n                break;\n            }\n        }\n    }\n}\n&#96;&#96;&#96;\n</md>"}], "type": "note", "tags": ["lab2", "student"], "tag_good": [], "unique_views": 120, "children": [], "tag_good_arr": [], "id": "k7bhswcjid41r8", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 1, "num_favorites": 1, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169973725, "default_anonymity": "no"}, "error": null, "aid": "kyv0z659a8u4nh"}