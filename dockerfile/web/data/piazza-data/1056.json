{"result": {"folders": ["2017", "课堂问答", "lecture16", "lab6"], "nr": 1056, "data": {"embed_links": []}, "created": "2017-04-21T03:47:59Z", "bucket_order": 3, "no_answer_followup": 2, "change_log": [{"anon": "no", "uid": "hdjonbiyfs62ie", "data": "j1rapn6k1572uf", "type": "create", "when": "2017-04-21T03:47:59Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j1rapn6ify62ue", "type": "followup", "when": "2017-04-21T03:49:19Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j1rapn6ify62ue", "type": "followup", "when": "2017-04-21T03:49:46Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j1rapn6ify62ue", "type": "followup", "when": "2017-04-21T03:50:13Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j1rapn6ify62ue", "type": "followup", "when": "2017-04-21T03:50:30Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j1rapn6ify62ue", "type": "followup", "when": "2017-04-21T03:50:55Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j1rapn6ify62ue", "type": "followup", "when": "2017-04-21T03:51:12Z"}, {"anon": "no", "uid": "izb0cbqbyzd6wf", "to": "j1rapn6ify62ue", "type": "feedback", "when": "2017-04-21T06:50:27Z"}, {"anon": "no", "uid": "ie7xy0nh1811ls", "to": "j1rapn6ify62ue", "type": "feedback", "when": "2017-04-21T06:52:09Z"}, {"anon": "no", "uid": "ie7xy5sipx51qz", "to": "j1rapn6ify62ue", "type": "feedback", "when": "2017-04-21T07:08:00Z"}, {"anon": "no", "uid": "ie7xy8gtpwk1t5", "to": "j1rapn6ify62ue", "type": "feedback", "when": "2017-04-21T07:16:41Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j1rapn6ify62ue", "type": "feedback", "when": "2017-04-24T03:12:50Z"}, {"anon": "no", "uid": "ie7xy2fekwm1np", "to": "j1rapn6ify62ue", "type": "feedback", "when": "2018-04-27T06:43:29Z"}, {"anon": "no", "uid": "isvxeq6bspf1vn", "to": "j1rapn6ify62ue", "type": "feedback", "when": "2018-04-27T06:43:30Z"}, {"anon": "no", "uid": "im0vq5pac4t1xa", "to": "j1rapn6ify62ue", "type": "feedback", "when": "2018-04-27T06:44:24Z"}, {"anon": "no", "uid": "isvxeq6bspf1vn", "to": "j1rapn6ify62ue", "type": "feedback", "when": "2018-05-04T13:14:00Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "2017春季-第十六讲课堂实践练习", "created": "2017-04-21T03:47:59Z", "content": "<p>请两人一组完成“第十六讲 实验六 调度器”中指定小题的回答在此贴中回复&#xff0c;每组同学选做一个小题目。<br /> <br />题目&#xff1a;<br /><a href=\"https://chyyuu.gitbooks.io/os_course_exercises/content/all/06-2-lab6-spoc-discussion.html\">https://chyyuu.gitbooks.io/os_course_exercises/content/all/06-2-lab6-spoc-discussion.html</a> -&gt; 小组练习与思考题</p>\n<p></p>\n<p>(1)do_exit<br />(2)do_wait<br />(3)cpu_idle<br />(4)lock<br />(5)init_main<br />(6)trap</p>"}], "type": "note", "tags": ["2017", "instructor-note", "lab6", "lecture16", "课堂问答"], "tag_good": [], "unique_views": 150, "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>(1)do_exit</p>\n<p></p>\n<p>选择“(1)”的同学的回答结果写在此贴后面。</p>", "created": "2017-04-21T03:49:18Z", "bucket_order": 154, "bucket_name": "Week 4/16 - 4/22", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>do_exit() 在最后会直接调用 schedule()</p>", "created": "2017-04-21T07:16:41Z", "bucket_order": 154, "bucket_name": "Week 4/16 - 4/22", "type": "feedback", "tag_good": [], "uid": "ie7xy8gtpwk1t5", "children": [], "tag_good_arr": [], "id": "j1ri613e4uh58l", "updated": "2017-04-21T07:16:41Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>这个回答过于简略&#xff0c;并没有完整回答题目要求的内容。请补充。</p>", "created": "2017-04-24T03:12:50Z", "bucket_order": 153, "bucket_name": "Week 4/23 - 4/29", "type": "feedback", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [], "tag_good_arr": [], "id": "j1vjrzu2b8w1x2", "updated": "2017-04-24T03:12:50Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>魏钧宇 2015011263</p>", "created": "2018-04-27T06:43:30Z", "bucket_order": 101, "bucket_name": "Week 4/22 - 4/28", "type": "feedback", "tag_good": [], "uid": "isvxeq6bspf1vn", "children": [], "tag_good_arr": [], "id": "jghlcecjud6760", "updated": "2018-04-27T06:43:30Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>我们首先从用户程序exit.c入手分析&#xff0c;这个程序首先通过fork创建了一个子进程&#xff0c;这个子进程将经过一系列的让权操作&#xff08;yield&#xff09;之后执行exit(magic)退出</p>\n<p></p>\n<pre>cprintf(&#34;I am the child.\\n&#34;);\n        yield();\n        ...\n        exit(magic);</pre>\n<p>注意这里的exit是一个用户态的函数&#xff0c;这个exit在用户态的实现如下&#xff1a;</p>\n<p></p>\n<pre>void\nexit(int error_code) {\n    sys_exit(error_code);\n    cprintf(&#34;BUG: exit failed.\\n&#34;);\n    while (1);\n}</pre>\n<p>它会调用另一个用户态的函数sys_exit&#xff0c;同时确保这个调用是不会返回的&#xff0c;sys_exit通过内联汇编的形式执行系统调用进入到内核态&#xff1a;</p>\n<p></p>\n<p>系统调用会被trap_dispatch分配给do_exit来完成&#xff0c;do_exit的主要完成了以下几个功能&#xff1a;</p>\n<p>1. 清空mm结构&#xff0c;相关代码如下&#xff1a;</p>\n<p></p>\n<pre>struct mm_struct *mm = current-&gt;mm;\n    if (mm != NULL) {\n        lcr3(boot_cr3); //切换到内核页表(因为用户页表即将被清除&#xff0c;<span style=\"text-decoration:underline\">值得思考的是由于用户页表和内核页表会共享内核虚拟空间&#xff0c;所以这样的切换并不会导致跳转&#xff09;</span>\n        if (mm_count_dec(mm) == 0) {\n            exit_mmap(mm); //回收所有已被映射的物理页面&#xff0c;回收所有的二级页表\n            put_pgdir(mm); //回收一级页表&#xff08;页目录表&#xff09;\n            mm_destroy(mm);//回收mm结构\n        }\n        current-&gt;mm = NULL;\n    }</pre>\n<p></p>\n<p>2. 将当前进程设置为僵尸态&#xff0c;等待父进程来回收除了mm以外的和进程相关的资源&#xff08;比如进程控制块&#xff09;&#xff1a;</p>\n<pre>current-&gt;state = PROC_ZOMBIE;</pre>\n<p></p>\n<p>3. 如果当前进程的父进程正在等待子进程&#xff0c;则需要唤醒父进程&#xff08;在这里我们一条输出调试信息&#xff09;&#xff1a;</p>\n<pre>proc = current-&gt;parent;\n        if (proc-&gt;wait_state == WT_CHILD) {\n          cprintf(&#34;Process: %d Wake up parent&#34;, current -&gt; pid);<br />\t  wakeup_proc(proc);\n        }</pre>\n<p>其中的wakeup_proc函数完成了将父进程加入到进程就绪队列的任务&#xff1a;</p>\n<pre>void wakeup_proc(struct proc_struct *proc) {\n    assert(proc-&gt;state != PROC_ZOMBIE);\n    bool intr_flag;\n    local_intr_save(intr_flag);\n    {\n        if (proc-&gt;state != PROC_RUNNABLE) {\n            proc-&gt;state = PROC_RUNNABLE; //修改目标进程的状态为就绪态\n            proc-&gt;wait_state = 0;\n            if (proc != current) {\n                sched_class_enqueue(proc); // 将目标进程加入到就绪队列中\n            }\n        }\n        else {\n            warn(&#34;wakeup runnable process.\\n&#34;);\n        }\n    }\n    local_intr_restore(intr_flag);\n}</pre>\n<p>值得注意的是这里通过使用sched_class_enque函数实现了独立于具体的调度算法的加入就绪队列的函数</p>\n<p></p>\n<p>4. 如果当前进程还有子进程&#xff0c;就将它交给init进程托管&#xff08;这一段的代码相对比较复杂&#xff0c;且和调度无关&#xff0c;在此处就不再详细讨论&#xff09;</p>\n<p></p>\n<p>5. 执行schedule函数执行调度&#xff0c;相关代码如下&#xff08;在调用之前我使用cprintf输出了提示信息&#xff09;</p>\n<p></p>\n<p>do_exit结束&#xff08;注意和用户态的exit函数一样&#xff0c;do_exit同样是不可能出现返回的情况的&#xff09;接下来在schedule函数中将选择一个就绪进程来运行&#xff0c;上述do_exit在实际运行时输出了如下的调试信息&#xff08;这里的Process 3是子进程&#xff0c;Process 2是父进程&#xff09;&#xff1a;</p>\n<p></p>\n<p><img src=\"/img/1056-2325beaa0efb784c.png\" alt=\"\" /></p>\n<p></p>\n<p>由于子进程唤醒了父进程&#xff0c;所以父进程处于就绪态&#xff0c;同时被调度执行执行&#xff0c;由于在执行之前父进程正在等待子进程所以&#xff0c;一开始执行将在do_wait函数中进行</p>\n<p>do_wait的详细分析将由回答下一个问题的同学来进行&#xff0c;do_wait相关代码如下&#xff1a;</p>\n<p></p>\n<pre>int do_wait(int pid, int *code_store) {\n    struct mm_struct *mm = current-&gt;mm;\n   \t...\n    struct proc_struct *proc;\n    bool intr_flag, haskid;\nrepeat:\n    haskid = 0;\n    if (pid != 0) {\n        proc = find_proc(pid);\n        if (proc != NULL &amp;&amp; proc-&gt;parent == current) {\n            haskid = 1;\n            if (proc-&gt;state == PROC_ZOMBIE) { //父进程将在这里发现已经退出了等待被回收的子进程\n                goto found;\n            }\n        }\n    }\n    ...\n    if (haskid) {\n\t...\n        schedule(); //上一次弃权是在这里&#xff0c;下一次将恢复到这里继续执行&#xff0c;由于在我们的问题中子进程不是被杀死的&#xff0c;所以将从repeat处开始执行<br />\t...\n        goto repeat;\n    }\n    return -E_BAD_PROC;\n\nfound:\n\t...\n    if (code_store != NULL) { //父进程保存子进程的退出码\n        *code_store = proc-&gt;exit_code;\n    }\n    local_intr_save(intr_flag);\n    {\n        unhash_proc(proc); //将子进程的进程控制块从hash队列中删除\n        remove_links(proc); //将子进程的进程控制块从普通的link队列中删除\n    }\n    local_intr_restore(intr_flag);\n    put_kstack(proc); //清除子进程的内核栈\n    kfree(proc); //是否子进程的进程控制块\n    return 0;\n}</pre>\n<p>至此&#xff0c;整个exit的过程执行完毕&#xff01;</p>", "created": "2018-05-04T13:14:00Z", "bucket_order": 100, "bucket_name": "Week 4/29 - 5/5", "type": "feedback", "tag_good": [], "uid": "isvxeq6bspf1vn", "children": [], "tag_good_arr": [], "id": "jgrzdjh4wm42qq", "updated": "2018-05-04T13:14:00Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "j1rarch65nz77m", "updated": "2017-04-21T03:49:18Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>(2)do_wait</p>\n<p></p>\n<p>选择“(2)”的同学的回答结果写在此贴后面。</p>", "created": "2017-04-21T03:49:46Z", "bucket_order": 154, "bucket_name": "Week 4/16 - 4/22", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>未完待续...</p>\n<p>[wait() | waitpid()] &lt;ulib.c&gt;</p>\n<p>用户态程序可以调用wait函数或waitpid函数</p>\n<p>sys_wait() &lt;syscall.c&gt;</p>\n<p>直接将参数传递给do_wait函数<br />do_wait() &lt;proc.c&gt;</p>\n<p>如果是waitpid&#xff0c;则判断传入的pid是否是自己的孩子&#xff0c;而且这个pid已经变成僵尸&#xff1b;如果是wait&#xff0c;则遍历自己所有的孩子&#xff0c;从里面找出一个僵尸<br />schedule() &lt;sched.c&gt;<br />proc_run() &lt;proc.c&gt;<br />switch_to() &lt;switch.S&gt;</p>", "created": "2017-04-21T06:52:09Z", "bucket_order": 154, "bucket_name": "Week 4/16 - 4/22", "type": "feedback", "tag_good": [], "uid": "ie7xy0nh1811ls", "children": [], "tag_good_arr": [], "id": "j1rhahos8b6357", "updated": "2017-04-21T06:52:09Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>\n<p>repeat:<br />    haskid = 0;<br />    ......<br />    //搜索pid&#xff0c;如果子进程存在且为zombie&#xff0c;则置haskid为1&#xff0c;否则跳到found<br />    //if found childprocess and it becomes zombie <br />    if (haskid) {<br />        current-&gt;state = PROC_SLEEPING;<br />        current-&gt;wait_state = WT_CHILD;<br />        schedule();        //主动让权<br />        //再次回到该线程的时候&#xff0c;自己应该是被唤醒的<br />        if (current-&gt;flags &amp; PF_EXITING) { //检查自己是不是被kill了<br />            do_exit(-E_KILLED);<br />        }<br />        goto repeat; //重新搜索<br />    }<br />found:<br />    //退出do_wait函数&#xff0c;并设置返回值</p>\n<p></p>\n<p>线程更细的切换&#xff0c;还是调用switch_to&#xff0c;动态跟踪可以参考之前的结果</p>\n<p>https://github.com/oscourse-tsinghua/os2018-hzhwcmhf/blob/master/course_exercises/switch_to.md</p>", "created": "2018-04-27T06:43:29Z", "bucket_order": 101, "bucket_name": "Week 4/22 - 4/28", "type": "feedback", "tag_good": [], "uid": "ie7xy2fekwm1np", "children": [], "tag_good_arr": [], "id": "jghlcd7fcm6yo", "updated": "2018-04-27T06:43:29Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "j1rarxphqyo7gm", "updated": "2017-04-21T03:49:46Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>(3)cpu_idle</p>\n<p></p>\n<p>选择“(3)”的同学的回答结果写在此贴后面。</p>", "created": "2017-04-21T03:50:13Z", "bucket_order": 154, "bucket_name": "Week 4/16 - 4/22", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p><pre>void\ncpu_idle(void) {\n    while (1) {\n        if (current-&gt;need_resched) {\n            schedule();\n        }\n    }\n}</pre>\n<p>cpu_idle 只会单单循环&#xff0c;如果需要调度就调度。需要调度的条件和 Jiaao Ho 的回答相同。</p>", "created": "2017-04-21T07:08:00Z", "bucket_order": 154, "bucket_name": "Week 4/16 - 4/22", "type": "feedback", "tag_good": [], "uid": "ie7xy5sipx51qz", "children": [], "tag_good_arr": [], "id": "j1rhuvbqqu62zt", "updated": "2017-04-21T07:08:00Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "j1rasi8qlsz1fh", "updated": "2017-04-21T03:50:13Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>(4)lock</p>\n<p></p>\n<p>选择“(4)”的同学的回答结果写在此贴后面。</p>", "created": "2017-04-21T03:50:30Z", "bucket_order": 154, "bucket_name": "Week 4/16 - 4/22", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>王纪霆 2015011251</p>\n<p></p>\n<p>lock是lab6里对于互斥量的一个简单实现。具体涉及的代码如下所示&#xff1a;</p>\n<p></p>\n<pre>static inline bool\ntry_lock(lock_t *lock) {\n    return !test_and_set_bit(0, lock);\n}\n\nstatic inline void\nlock(lock_t *lock) {\n    while (!try_lock(lock)) {\n        schedule();\n    }\n}\n\nstatic inline void\nunlock(lock_t *lock) {\n    if (!test_and_clear_bit(0, lock)) {\n        panic(&#34;Unlock failed.\\n&#34;);\n    }\n}</pre>\n<p>也即&#xff0c;当对某一个信号量调用lock时&#xff0c;会尝试将其从0改为1。若本来已经为1&#xff0c;即已经被其他进程占用&#xff0c;则调用schedule让出cpu&#xff0c;如此&#xff0c;直到它获得资源为止。当一个进程使用完毕&#xff0c;则对lock进行clear&#xff0c;让出资源&#xff0c;使得正在等待获取该锁的进程可以占用该资源、从而执行下去。</p>\n<p></p>\n<p>另外&#xff0c;这里的原子操作是用硬件提供的指令完成的&#xff1a;</p>\n<p></p>\n<pre>static inline bool\ntest_and_set_bit(int nr, volatile void *addr) {\n    int oldbit;\n    asm volatile (&#34;btsl %2, %1; sbbl %0, %0&#34; : &#34;=r&#34; (oldbit), &#34;=m&#34; (*(volatile long *)addr) : &#34;Ir&#34; (nr) : &#34;memory&#34;);\n    return oldbit != 0;\n}</pre>\n<p>不过&#xff0c;似乎根据分析&#xff0c;这里这样写并不是原子操作&#xff0c;需要加上一条lock指令才行……&#xff1f;</p>", "created": "2018-04-27T06:44:24Z", "bucket_order": 101, "bucket_name": "Week 4/22 - 4/28", "type": "feedback", "tag_good": [], "uid": "im0vq5pac4t1xa", "children": [], "tag_good_arr": [], "id": "jghldk24rh02cb", "updated": "2018-04-27T06:44:24Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "j1rasvzny0e1ky", "updated": "2017-04-21T03:50:30Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>(5)init_main</p>\n<p></p>\n<p>选择“(5)”的同学的回答结果写在此贴后面。</p>", "created": "2017-04-21T03:50:55Z", "bucket_order": 154, "bucket_name": "Week 4/16 - 4/22", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "j1ratf18c5u4vd", "updated": "2017-04-21T03:50:55Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>(6)trap</p>\n<p></p>\n<p>选择“(6)”的同学的回答结果写在此贴后面。</p>", "created": "2017-04-21T03:51:12Z", "bucket_order": 154, "bucket_name": "Week 4/16 - 4/22", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>trap 函数里会判断</p>\n<p></p>\n<p>首先是如果 current 是 null, 即进程机制还没启动, 就不管了.</p>\n<p></p>\n<p>然后如果当前中断是在用户态触发的才会 schedule. 不然就没必要了 (反正在内核里).</p>\n<p></p>\n<p>如果是 PF_EXITING, 即正在关机, 就不用了.</p>\n<p></p>\n<p>最后一个判断如下.</p>\n<p></p>\n<pre>if (current-&gt;need_resched) { schedule(); }</pre>\n<p></p>\n<p>当前进程有 need_resched 这个 flag 的时候才会触发 schedule.</p>\n<p></p>\n<p>这个标志我找到有两种触发方式.</p>\n<p></p>\n<p>一种是 schedule/default_sched.c 里面, 当时间片用完时将它设为 1.</p>\n<p></p>\n<p>另一种是在 process/proc.c 里面调用 do_yeild 将其设为 1. 即在进程自身进行某些操作时才会触发 schedule.</p>\n<p></p>\n<p>查找 do_yield, 发现只有在 syscall 的 sys_yield 时才会调用. 可能是因为这里还没有涉及到 io 等操作而进入等待的情况, 所以还没有更多的地方会触发这种情况.</p>\n<p></p>\n<p>所以说不是所有的中断都会直接触发 schedule.</p>", "created": "2017-04-21T06:50:27Z", "bucket_order": 154, "bucket_name": "Week 4/16 - 4/22", "type": "feedback", "tag_good": [], "uid": "izb0cbqbyzd6wf", "children": [], "tag_good_arr": [], "id": "j1rh8abfmha2jg", "updated": "2017-04-21T06:50:27Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "j1ratru9luejh", "updated": "2017-04-21T03:51:12Z", "config": {}}], "tag_good_arr": [], "id": "j1rapn6ify62ue", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 8, "num_favorites": 0, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169044453, "default_anonymity": "no"}, "error": null, "aid": "kyv0f945bzt6d5"}