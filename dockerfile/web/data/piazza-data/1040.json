{"result": {"folders": ["2017", "lecture13", "lab4", "课堂问答"], "nr": 1040, "data": {"embed_links": []}, "created": "2017-04-10T08:17:07Z", "bucket_order": 3, "no_answer_followup": 1, "change_log": [{"anon": "no", "uid": "hdjonbiyfs62ie", "data": "j1buhdjf2pt7i3", "type": "create", "when": "2017-04-10T08:17:07Z"}, {"anon": "no", "uid": "izb0cbqbyzd6wf", "to": "j1buhdjddy7i2", "type": "followup", "when": "2017-04-11T01:21:19Z"}, {"anon": "no", "uid": "ie7xxz4di3o1ke", "to": "j1buhdjddy7i2", "type": "followup", "when": "2017-04-15T14:53:57Z"}, {"anon": "no", "uid": "iswj8urcumf2o2", "to": "j1buhdjddy7i2", "type": "followup", "when": "2018-04-17T01:06:47Z"}, {"anon": "no", "uid": "isvxeq6bspf1vn", "to": "j1buhdjddy7i2", "type": "followup", "when": "2018-04-18T16:47:33Z"}, {"anon": "no", "uid": "iswj8urcumf2o2", "to": "j1buhdjddy7i2", "type": "feedback", "when": "2018-04-20T03:50:33Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "2017春季-第十三讲课堂实践练习(5)", "created": "2017-04-10T08:17:07Z", "content": "<p>请两人一组完成“第十三讲 实验四 内核线程管理”中指定小题的回答在此贴中回复&#xff0c;每组同学选做一个数据结构分析和一个流程分析。</p>\n<p></p>\n<p>题目&#xff1a;<br /><a href=\"https://chyyuu.gitbooks.io/os_course_exercises/content/all/05-3-lab4-spoc-discussion.html\">https://chyyuu.gitbooks.io/os_course_exercises/content/all/05-3-lab4-spoc-discussion.html</a></p>\n<p></p>\n<p>视频相关思考题 -&gt; 13.3 执行流程 -&gt; 第8小题</p>\n<p></p>\n<p>分析内核线程initproc的创建流程&#xff0c;说明线程切换后执行的第一条是什么。</p>"}], "type": "note", "tags": ["2017", "instructor-note", "lab4", "lecture13", "课堂问答"], "tag_good": [], "unique_views": 159, "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>在创建 idle 之后用 kernel_thread(init_main, NULL, 0); 来创建 init_proc.</p>\n<p></p>\n<p>kernel_thread 中将 init_main 压入 %ebx, NULL (args) 压入 %edx. 然后调用 do_fork, 并跳转到 kernel_thread_entry.</p>\n<p></p>\n<p>kernel_thread_entry 在 entry.S 中以汇编语言完成. 这个函数的作用就是跳到 %ebx 中所保存的代码地址, 相当于调用 init_main().</p>\n<p></p>\n<p>init_main 中执行的第一个函数为 nr_free_pages(). 这个函数在 kern/mm/pmm.c 中. 用途为统计总物理页数.</p>\n<p></p>\n<p>待补充: ebx, edx 是放在 trap_frame 里面的. 它们是在什么时候被放进寄存器里的.</p>", "created": "2017-04-11T01:21:19Z", "bucket_order": 155, "bucket_name": "Week 4/9 - 4/15", "type": "followup", "tag_good": [], "uid": "izb0cbqbyzd6wf", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "j1cv2ihadwb4cy", "updated": "2017-04-11T01:21:19Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>补充楼上&#xff0c;ebx和edx的设置是在kernel_thread函数中完成的。这一点在实验指导书上有提及。</p>", "created": "2017-04-15T14:53:57Z", "bucket_order": 155, "bucket_name": "Week 4/9 - 4/15", "type": "followup", "tag_good": [], "uid": "ie7xxz4di3o1ke", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "j1jduyq1ttm31h", "updated": "2017-04-15T14:53:57Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>王延森 2015011285</p>", "created": "2018-04-17T01:06:47Z", "bucket_order": 102, "bucket_name": "Week 4/15 - 4/21", "type": "followup", "tag_good": [], "uid": "iswj8urcumf2o2", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>创建initproc前&#xff1a;</p>\n<p>       init线程在proc_init()过程中创建。在调用proc_init()之前&#xff0c;程序已经完成了如下过程&#xff1a;</p>\n<pre>    pmm_init();                 // init physical memory management\n\n    pic_init();                 // init interrupt controller\n    idt_init();                 // init interrupt descriptor table\n\n    vmm_init();                 // init virtual memory management\n    sched_init();               // init scheduler</pre>\n<p>其中除了sched_init()是调度器的初始化&#xff0c;是为了管理之后线程分配时间片的方法&#xff0c;在lab4之前还没有学到之外&#xff0c;其他的都在之前学过了。这些是创建线程的先决条件。</p>\n<p></p>\n<p>然后进入proc_init()过程&#xff1a;</p>\n<p>首先初始化进程的管理表&#xff1a;</p>\n<pre>    list_init(&amp;proc_list);\n    for (i = 0; i &lt; HASH_LIST_SIZE; i &#43;&#43;) {\n        list_init(hash_list &#43; i);\n    }</pre>\n<p>创建第一个线程idleproc&#xff1a;</p>\n<pre>    if ((idleproc = alloc_proc()) == NULL) {\n        panic(&#34;cannot alloc idleproc.\\n&#34;);\n    }\n\n    idleproc-&gt;pid = 0;\n    idleproc-&gt;state = PROC_RUNNABLE;\n    idleproc-&gt;kstack = (uintptr_t)bootstack;\n    idleproc-&gt;need_resched = 1;\n    \n    if ((idleproc-&gt;filesp = files_create()) == NULL) {\n        panic(&#34;create filesp (idleproc) failed.\\n&#34;);\n    }\n    files_count_inc(idleproc-&gt;filesp);\n    \n    set_proc_name(idleproc, &#34;idle&#34;);\n    nr_process &#43;&#43;;</pre>\n<p>这部分初始化并创建第一个进程idleproc&#xff0c;代码应该有其他的同学分析&#xff0c;我就不多说了。这一部分其实和initproc的初始化没什么关系&#xff0c;不看也罢。</p>\n<p></p>\n<p>创建initproc的过程&#xff1a;</p>\n<pre>    int pid = kernel_thread(init_main, NULL, 0);\n    if (pid &lt;= 0) {\n        panic(&#34;create init_main failed.\\n&#34;);\n    }\n\n    initproc = find_proc(pid);\n    set_proc_name(initproc, &#34;init&#34;);</pre>\n<p>四句话依次是&#xff1a;调用kernel_thread创建init线程&#xff0c;判断是不是成功创建了&#xff08;鲁棒性检查&#xff09;&#xff0c;之后将进程号赋给initproc变量&#xff0c;最终给我们的init线程命个名。</p>\n<p>所以可以看出最重要的是kernel_thread&#xff0c;继续分析&#xff1a;</p>\n<pre>int\nkernel_thread(int (*fn)(void *), void *arg, uint32_t clone_flags) {\n    struct trapframe tf;\n    memset(&amp;tf, 0, sizeof(struct trapframe));\n    tf.tf_cs = KERNEL_CS;\n    tf.tf_ds = tf.tf_es = tf.tf_ss = KERNEL_DS;\n    tf.tf_regs.reg_ebx = (uint32_t)fn;\n    tf.tf_regs.reg_edx = (uint32_t)arg;\n    tf.tf_eip = (uint32_t)kernel_thread_entry;\n    return do_fork(clone_flags | CLONE_VM, 0, &amp;tf);\n}</pre>\n<p>以上过程初始化了initproc的中断帧&#xff0c;从上到下依次对代码段特权级&#xff0c;数据段特权级&#xff0c;函数指针&#xff0c;传入的参数&#xff0c;执行的起点做了初始化&#xff0c;最终在return处调用do_fork&#xff0c;继续线程创建。</p>\n<p></p>\n<p>所以继续分析do_fork&#xff1a;</p>\n<pre>int\ndo_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf) {\n    int ret = -E_NO_FREE_PROC;\n    struct proc_struct *proc;\n    if (nr_process &gt;= MAX_PROCESS) {\n        goto fork_out;\n    }\n    ret = -E_NO_MEM;\n    if ((proc = alloc_proc()) == NULL) {\n        goto fork_out;\n    }\n    proc-&gt;parent = current;\n    assert(current-&gt;wait_state == 0);\n    if (setup_kstack(proc) != 0) {\n        goto bad_fork_cleanup_proc;\n    }\n    if (copy_fs(clone_flags, proc) != 0) { //for LAB8\n        goto bad_fork_cleanup_kstack;\n    }\n    if (copy_mm(clone_flags, proc) != 0) {\n        goto bad_fork_cleanup_fs;\n    }\n    copy_thread(proc, stack, tf);\n    bool intr_flag;\n    local_intr_save(intr_flag);\n    {\n        proc-&gt;pid = get_pid();\n        hash_proc(proc);\n        set_links(proc);\n    }\n    local_intr_restore(intr_flag);\n    wakeup_proc(proc);\n    ret = proc-&gt;pid;\nfork_out:\n    return ret;\nbad_fork_cleanup_fs:\n    put_fs(proc);\nbad_fork_cleanup_kstack:\n    put_kstack(proc);\nbad_fork_cleanup_proc:\n    kfree(proc);\n    goto fork_out;\n}</pre>\n<p>抛开鲁棒性检查不看&#xff0c;do_fork无非做了一下几件事&#xff1a;&#xff08;其实和非initproc的fork已经是一样的了&#xff09;</p>\n<p>       检查进程是不是达到了上限&#xff0c;当然作为initproc&#xff0c;第二个线程&#xff0c;肯定没有达到上限。</p>\n<p>       设置父进程&#xff1a;idleproc</p>\n<p>       初始化内核栈、复制文件结构&#xff08;还没上&#xff0c;储存工作处对应的路径&#xff0c;打开文件列表等信息&#xff0c;但是现在fs_init()还没有执行所以在initproc里没有什么实际的用&#xff09;、复制存储空间。</p>\n<p>       因为clone_flag是0所以这些都是新开的空间&#xff0c;内容上复制了上面idleproc初始化的内容。</p>\n<p>       copy_thread是进一步初始化中断帧&#xff0c;一会儿再说。</p>\n<p>       之后将initproc进程加入队列中&#xff0c;唤醒进程&#xff08;设置状态为runnable&#xff09;&#xff0c;开始执行。</p>\n<p></p>\n<p>到这分析就基本结束了&#xff0c;再稍微列一下copy_thread的内容&#xff1a;</p>\n<p></p>\n<pre>static void<br />copy_thread(struct proc_struct *proc, uintptr_t esp, struct trapframe *tf) {<br />    proc-&gt;tf = (struct trapframe *)(proc-&gt;kstack &#43; KSTACKSIZE) - 1;<br />    *(proc-&gt;tf) = *tf;<br />    proc-&gt;tf-&gt;tf_regs.reg_eax = 0;<br />    proc-&gt;tf-&gt;tf_esp = esp;<br />    proc-&gt;tf-&gt;tf_eflags |= FL_IF;<br /><br />    proc-&gt;context.eip = (uintptr_t)forkret;<br />    proc-&gt;context.esp = (uintptr_t)(proc-&gt;tf);<br />}</pre>\n<p>从上到下复制了已有的内容&#xff0c;进一步初始化&#xff0c;参考下下面的同学。</p>\n<p>注意下eip的内容复制成了forkret&#xff0c;实际上执行的第一条指令在forkret里。这也就是initproc执行的第一条指令了。</p>\n<pre>static void\nforkret(void) {\n    forkrets(current-&gt;tf);\n}</pre>\n<p>forkrets&#xff1a;</p>\n<pre>.globl forkrets\nforkrets:\n    # set stack to this new process&#39;s trapframe\n    movl 4(%esp), %esp\n    jmp __trapret</pre>\n<p>非要说执行的是什么指令的话&#xff0c;就是上面这条movl 4(%esp), %esp了。</p>", "created": "2018-04-20T03:50:33Z", "bucket_order": 102, "bucket_name": "Week 4/15 - 4/21", "type": "feedback", "tag_good": [], "uid": "iswj8urcumf2o2", "children": [], "tag_good_arr": [], "id": "jg7f30r8p6x2le", "updated": "2018-04-20T03:50:33Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "jg2ywv367ue7am", "updated": "2018-04-17T01:06:47Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>魏钧宇 2015011263</p>\n<p></p>\n<p>init线程的创建是从kernel_thread处开始的&#xff0c;下面是针对kernel_thread的分析</p>\n<pre>    int kernel_thread(int (*fn)(void *), void *arg, uint32_t clone_flags) {\n        struct trapframe tf;                                    //采用中断帧的形式来完成初始化过程\n        memset(&amp;tf, 0, sizeof(struct trapframe));\n        tf.tf_cs = KERNEL_CS;                                   //指定init的代码段为内核特权级&#xff08;因为是内核线程&#xff09;\n        tf.tf_ds = tf.tf_es = tf.tf_ss = KERNEL_DS;             //指定init的数据段也是内核特权级\n        tf.tf_regs.reg_ebx = (uint32_t)fn;                      //指定kernel_thread_entry跳转到init_main处开始执行\n        tf.tf_regs.reg_edx = (uint32_t)arg;                     //传入init_main的参数\n        tf.tf_eip = (uint32_t)kernel_thread_entry;              //指定init从kernel_thread_entry处开始正式执行\n        return do_fork(clone_flags | CLONE_VM, 0, &amp;tf);         //继续执行剩余的初始化过程&#xff0c;同时\n    }</pre>\n<p>kernel_thread又调用了fork</p>\n<pre>    int do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf) {\n        int ret = -E_NO_FREE_PROC;\n        struct proc_struct *proc;\n        if (nr_process &gt;= MAX_PROCESS) {                    //如果进程数目超出限制&#xff0c;在直接fork失败\n            goto fork_out;\n        }\n        ret = -E_NO_MEM;\n        proc = alloc_proc()                                 //分配新的进程控制块\n        if (proc == NULL){\n            cprintf(&#34;(In do fork) alloc proc failed&#34;);\n            goto fork_out;\n        }\n        if (setup_kstack(proc) != 0){                       //分配新的内核堆栈空间\n            cprintf(&#34;(In do fork) alloc kstack space failed&#34;);\n            goto bad_fork_cleanup_proc;\n        }\n        if (copy_mm(clone_flags, proc) != 0){               //分配新的存储空间&#xff08;在PA5中才会有较多涉及&#xff09;\n            cprintf(&#34;(In do fork) copy memory failed&#34;);\n            goto bad_fork_cleanup_kstack;\n        }\n        copy_thread(proc, 0, tf);                           //进一步初始化新线程的trapframe\n        hash_proc(proc);                                    //将新创建的init加入哈希队列\n        list_add(&amp;proc_list, proc -&gt; list_link);            //将新创建的init加入双向链表\n        wakeup_proc(proc);                                  //激活init线程\n        ret = get_pid();                                    //给新创建的init分配一个唯一的pid\n        fork_out:\n        return ret;                                         //父线程的fork返回值为唯一的pid\n\n        bad_fork_cleanup_kstack:\n        put_kstack(proc);\n        bad_fork_cleanup_proc:\n        kfree(proc);\n        goto fork_out;\n    }</pre>\n<p>fork函数中涉及到了几个重要的函数&#xff0c;setup_kstack分配了新的内核堆栈空间&#xff0c;copy_mm分配了新的存储空间&#xff08;但是在这里没有涉及&#xff09;&#xff0c;我们主要分析一下copy_thread函数完成的任务</p>\n<pre>    static void copy_thread(struct proc_struct *proc, uintptr_t esp, struct trapframe *tf) {\n        \n        proc-&gt;tf = (struct trapframe *)(proc-&gt;kstack &#43; KSTACKSIZE) - 1; //将中断帧放置到内核堆栈的最顶端的位置\n        *(proc-&gt;tf) = *tf;                                              //拷贝原来已经初始化好的部分\n        proc-&gt;tf-&gt;tf_regs.reg_eax = 0;                                  //设定子线程的fork的返回值为\n        proc-&gt;tf-&gt;tf_esp = esp;                                         //设定子线程的运行堆栈\n        proc-&gt;tf-&gt;tf_eflags |= FL_IF;                                   //指定子线程运行中断\n\n        proc-&gt;context.eip = (uintptr_t)forkret;                         //设定好子线程在context中的返回地址&#xff08;这个会在后面讲线程切换时&#xff0c;详细描述&#xff09;\n        proc-&gt;context.esp = (uintptr_t)(proc-&gt;tf);                      //设定好子线程在跳转到forkret以后的堆栈起始位置&#xff0c;需要和esp以及内核堆栈做区分\n    \n    }</pre>\n<p>copy_thread完成了init最初运行环境的搭建&#xff0c;我们将在后面更加详细地讨论线程切换的过程&#xff0c;包括init是如何正式开始运行的等问题</p>\n<p>具体的切换&#xff0c;可以参见我之前在<a href=\"https://www.piazza.com/class/i5j09fnsl7k5x0?cid=1038\">https://piazza.com/class/i5j09fnsl7k5x0?cid=1038</a>的回答</p>\n<p></p>\n<p>和idle_proc不一样&#xff0c;这里的init_proc有明确的调度过程&#xff0c;所以它执行的第一条指令应该在forkret中&#xff0c;因为在switch_to之后已经完成了包括页表&#xff0c;堆栈&#xff0c;current指针等一系列关键因素的切换&#xff0c;所以forkret应该可以算作是init_proc完成的</p>", "created": "2018-04-18T16:47:33Z", "bucket_order": 102, "bucket_name": "Week 4/15 - 4/21", "type": "followup", "tag_good": [], "uid": "isvxeq6bspf1vn", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "jg5byjf95w02bi", "updated": "2018-04-18T16:47:33Z", "config": {}}], "tag_good_arr": [], "id": "j1buhdjddy7i2", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 5, "num_favorites": 0, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169020054, "default_anonymity": "no"}, "error": null, "aid": "kyv0eqaezmj3yi"}