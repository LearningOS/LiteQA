{"result": {"folders": ["2017", "lecture17", "课堂问答"], "nr": 1060, "data": {"embed_links": []}, "created": "2017-04-24T03:59:44Z", "bucket_order": 3, "no_answer_followup": 1, "change_log": [{"anon": "no", "uid": "hdjonbiyfs62ie", "data": "j1vlgaw5cb6566", "type": "create", "when": "2017-04-24T03:59:44Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j1vlgaw2fk5565", "type": "followup", "when": "2017-04-24T04:01:26Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j1vlgaw2fk5565", "type": "followup", "when": "2017-04-24T04:01:35Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j1vlgaw2fk5565", "type": "followup", "when": "2017-04-24T04:01:53Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j1vlgaw2fk5565", "type": "followup", "when": "2017-04-24T04:01:56Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j1vlgaw2fk5565", "type": "followup", "when": "2017-04-24T04:02:06Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j1vlgaw2fk5565", "type": "followup", "when": "2017-04-24T04:02:15Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j1vlgaw2fk5565", "type": "followup", "when": "2017-04-24T04:02:27Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j1vlgaw2fk5565", "type": "followup", "when": "2017-04-24T04:02:36Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j1vlgaw2fk5565", "type": "followup", "when": "2017-04-24T04:02:45Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "to": "j1vlgaw2fk5565", "type": "followup", "when": "2017-04-24T04:03:01Z"}, {"anon": "no", "uid": "izb0cbqbyzd6wf", "to": "j1vlgaw2fk5565", "type": "feedback", "when": "2017-04-25T00:54:38Z"}, {"anon": "no", "uid": "ie7xy0nh1811ls", "to": "j1vlgaw2fk5565", "type": "feedback", "when": "2017-04-25T00:55:47Z"}, {"anon": "no", "uid": "itiooztjq0i1fk", "to": "j1vlgaw2fk5565", "type": "feedback", "when": "2017-04-25T01:05:16Z"}, {"anon": "no", "uid": "ie7xy1yxmql1n8", "to": "j1vlgaw2fk5565", "type": "feedback", "when": "2017-04-25T01:05:48Z"}, {"anon": "no", "uid": "izb0cbqbyzd6wf", "to": "j1vlgaw2fk5565", "type": "feedback", "when": "2017-04-25T01:13:46Z"}, {"anon": "no", "uid": "ie7xy1yxmql1n8", "to": "j1vlgaw2fk5565", "type": "feedback", "when": "2017-04-25T01:18:19Z"}, {"anon": "no", "uid": "ie7xxz4di3o1ke", "to": "j1vlgaw2fk5565", "type": "feedback", "when": "2017-04-25T01:28:02Z"}, {"anon": "no", "uid": "ie7xy6ut1rx1rv", "to": "j1vlgaw2fk5565", "type": "feedback", "when": "2017-04-25T01:28:12Z"}, {"anon": "no", "uid": "ierwkwdnmr42ta", "to": "j1vlgaw2fk5565", "type": "feedback", "when": "2017-04-25T01:32:10Z"}, {"anon": "no", "uid": "ie7xy49etbi1pg", "to": "j1vlgaw2fk5565", "type": "feedback", "when": "2017-04-25T03:07:48Z"}, {"anon": "no", "uid": "ie7xy8gtpwk1t5", "to": "j1vlgaw2fk5565", "type": "feedback", "when": "2017-05-04T03:57:48Z"}, {"anon": "no", "uid": "ie7xy1orb4a1mz", "to": "j1vlgaw2fk5565", "type": "feedback", "when": "2017-05-18T07:23:11Z"}, {"anon": "no", "uid": "i5g31e12hcr27s", "to": "j1vlgaw2fk5565", "type": "feedback", "when": "2017-05-18T13:05:33Z"}, {"anon": "no", "uid": "isvxeq6bspf1vn", "to": "j1vlgaw2fk5565", "type": "feedback", "when": "2018-05-06T06:48:36Z"}, {"anon": "no", "uid": "isvxeq6bspf1vn", "to": "j1vlgaw2fk5565", "type": "feedback", "when": "2018-05-06T06:48:55Z"}, {"anon": "stud", "to": "j1vlgaw2fk5565", "type": "feedback", "when": "2018-05-06T06:57:28Z", "uid_a": "a_0"}, {"anon": "stud", "to": "j1vlgaw2fk5565", "type": "feedback", "when": "2018-05-06T06:57:33Z", "uid_a": "a_0"}, {"anon": "stud", "to": "j1vlgaw2fk5565", "type": "feedback", "when": "2018-05-06T06:57:58Z", "uid_a": "a_0"}, {"anon": "stud", "to": "j1vlgaw2fk5565", "type": "feedback", "when": "2018-05-06T06:58:03Z", "uid_a": "a_0"}, {"anon": "no", "uid": "je2ib5nk89v6ca", "to": "j1vlgaw2fk5565", "type": "feedback", "when": "2018-05-06T06:58:47Z"}, {"anon": "stud", "to": "j1vlgaw2fk5565", "type": "feedback", "when": "2018-05-07T03:55:13Z", "uid_a": "a_0"}, {"anon": "no", "uid": "isvxeq6bspf1vn", "to": "j1vlgaw2fk5565", "type": "feedback", "when": "2018-05-07T03:55:45Z"}, {"anon": "no", "uid": "iswj8urcumf2o2", "to": "j1vlgaw2fk5565", "type": "feedback", "when": "2018-05-07T05:45:36Z"}, {"anon": "no", "uid": "iswj8urcumf2o2", "to": "j1vlgaw2fk5565", "type": "feedback", "when": "2018-05-07T05:57:24Z"}, {"anon": "no", "uid": "isvxeq6bspf1vn", "to": "j1vlgaw2fk5565", "type": "feedback", "when": "2018-05-07T11:41:36Z"}, {"anon": "no", "uid": "je2ib5nk89v6ca", "to": "j1vlgaw2fk5565", "type": "feedback", "when": "2018-05-07T17:44:58Z"}, {"anon": "no", "uid": "isyhiuebva42er", "to": "j1vlgaw2fk5565", "type": "feedback", "when": "2018-05-07T23:50:38Z"}, {"anon": "no", "uid": "isvxeq6bspf1vn", "to": "j1vlgaw2fk5565", "type": "feedback", "when": "2018-05-19T03:42:05Z"}, {"anon": "no", "uid": "isvxeq6bspf1vn", "to": "j1vlgaw2fk5565", "type": "feedback", "when": "2018-05-19T03:47:22Z"}, {"anon": "no", "uid": "isvxeq6bspf1vn", "to": "j1vlgaw2fk5565", "type": "feedback", "when": "2018-05-19T03:52:47Z"}, {"anon": "no", "uid": "jsjp7j7mu8BB", "to": "j1vlgaw2fk5565", "type": "followup", "when": "2019-04-28T16:17:44Z"}, {"anon": "no", "uid": "jsiyf76cGzf9", "to": "j1vlgaw2fk5565", "type": "followup", "when": "2019-04-29T01:14:46Z"}, {"anon": "no", "uid": "jshndz5tgxj4bq", "to": "j1vlgaw2fk5565", "type": "feedback", "when": "2019-04-29T01:41:59Z"}, {"anon": "no", "uid": "ju69lug52OdQ", "to": "j1vlgaw2fk5565", "type": "feedback", "when": "2019-05-02T02:51:43Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "2017春季-第十七讲课堂实践练习", "created": "2017-04-24T03:59:44Z", "content": "<p>请两人一组完成“第十七讲 同步互斥”中指定小题的回答在此贴中回复&#xff0c;要求每个小组完成约定的两个小题。</p>\n<p></p>\n<p>题目&#xff1a;</p>\n<p></p>\n<p><a href=\"https://chyyuu.gitbooks.io/os_course_exercises/content/all/07-1-spoc-discussion.html\">https://chyyuu.gitbooks.io/os_course_exercises/content/all/07-1-spoc-discussion.html</a> -&gt; 视频相关思考题 -&gt; 17.4 基于软件的同步方法</p>\n<p></p>\n<p>第4至12题&#xff1a;每个小组选做一个自己有兴趣的小题&#xff1b;</p>\n<p>第13题&#xff1a;每个小组必须完成&#xff1b;</p>"}], "type": "note", "tags": ["2017", "instructor-note", "lecture17", "课堂问答"], "tag_good": [], "unique_views": 205, "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>选择“第4小题”的同学的回答结果写在此贴后面。</p>", "created": "2017-04-24T04:01:26Z", "bucket_order": 159, "bucket_name": "Week 4/23 - 4/29", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>答&#xff1a; 有误. 有一进程 i 进入临界区后退出临界区&#xff0c;这时把turn 改为 j &#xff0c; 那么这时进程 i 再次想进去临界区就不可以的&#xff08;因为turn为j 进程id为i&#xff09;&#xff0c;所以有误。</p>", "created": "2017-04-25T01:05:16Z", "bucket_order": 159, "bucket_name": "Week 4/23 - 4/29", "type": "feedback", "tag_good": [], "uid": "itiooztjq0i1fk", "children": [], "tag_good_arr": [], "id": "j1wunssuc5waw", "updated": "2017-04-25T01:05:16Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>有误&#xff0c;这是ppt上的二进程同步的第一种尝试</p>\n<p>它能够满足忙则等待&#xff0c;因为总有一个进程后修改turn&#xff0c;那么先修改的turn的进程就能够进入。</p>\n<p>但是如果i进入临界区然后退出&#xff0c;退出时将turn修改为了j&#xff0c;此时 i 就必须等待 j 也执行完毕同样的操作以后才能够继续进入临界区&#xff0c;如果此时 j 恰好不在临界区内&#xff0c;那么明明临界区中没有进程&#xff0c;i依旧不能够进入临界区&#xff0c;不满足空闲则入的条件</p>", "created": "2018-05-19T03:42:05Z", "bucket_order": 104, "bucket_name": "Week 5/13 - 5/19", "type": "feedback", "tag_good": [], "uid": "isvxeq6bspf1vn", "children": [], "tag_good_arr": [], "id": "jhcuju58flz71b", "updated": "2018-05-19T03:42:05Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "j1vlii14jw94gz", "updated": "2017-04-24T04:01:26Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>选择“第5小题”的同学的回答结果写在此贴后面。</p>", "created": "2017-04-24T04:01:35Z", "bucket_order": 159, "bucket_name": "Week 4/23 - 4/29", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p><code>错误。</code></p>\n<p><code>flags[i] = FREE 且 flags[j] = FREE, 两个进程都通过了while循环&#xff0c;然后flags[i] = BUSY 且 flags[j] = BUSY. 然后两个进程同时进入了临界区。</code></p>", "created": "2017-04-25T01:32:10Z", "bucket_order": 159, "bucket_name": "Week 4/23 - 4/29", "type": "feedback", "tag_good": [], "uid": "ierwkwdnmr42ta", "children": [], "tag_good_arr": [], "id": "j1wvme51ts1vg", "updated": "2017-04-25T01:32:10Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>有误</p>\n<pre>INITIALIZATION:\n\ttypedef char boolean;\n\t...\n\tshared boolean flags[n - 1];\n\t...\n\tflags[i] = FREE;\n\t...\n\tflags[j] = FREE;\n\t...\nENTRY PROTOCOL (for Process i ):\n\t/* wait while the other process is in its CS */\n\twhile (flags[j ] == BUSY) {\n\t}\n---------------------------------&gt;\n\t/* claim the resource */\n\tflags[i ] = BUSY;\nEXIT PROTOCOL (for Process i ):\n\t/* release the resource */\n\tflags[i ] = FREE;</pre>\n<p>一开始 i j 的flag都是free&#xff0c;那么 i 执行 while 循环时能够通过检查&#xff0c;刚刚通过检查在图中的分割线处&#xff08;----&gt;&#xff09;被中断&#xff0c;调度器调度 j 执行&#xff0c;由于此时的 i 已经通过了 while循环检查但还没有修改自己的flags&#xff0c;j 也能够通过while检查&#xff0c;那么他们就会同时进入临界区中了。</p>", "created": "2018-05-19T03:47:22Z", "bucket_order": 104, "bucket_name": "Week 5/13 - 5/19", "type": "feedback", "tag_good": [], "uid": "isvxeq6bspf1vn", "children": [], "tag_good_arr": [], "id": "jhcuqmfvkb54re", "updated": "2018-05-19T03:47:22Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "j1vliow2jrh4kn", "updated": "2017-04-24T04:01:35Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>选择“第6小题”的同学的回答结果写在此贴后面。</p>", "created": "2017-04-24T04:01:53Z", "bucket_order": 159, "bucket_name": "Week 4/23 - 4/29", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>错的. </p>\n<p></p>\n<p>两边都执行 Flags[i] = BUSY.</p>\n<p></p>\n<p>然后两边后面的 while 都是死循环.</p>", "created": "2017-04-25T00:54:38Z", "bucket_order": 159, "bucket_name": "Week 4/23 - 4/29", "type": "feedback", "tag_good": [], "uid": "izb0cbqbyzd6wf", "children": [], "tag_good_arr": [], "id": "j1wua4fkbq94mz", "updated": "2017-04-25T00:54:38Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>这种同步机制不可行。</p>\n<p>如果进程i先执行flags[i] = BUSY&#xff0c;接下来切换到进程j&#xff0c;进程j执行flags[i] = BUSY&#xff0c;此时无论之后是否发生进程切换&#xff0c;两个进程都会卡在while(flags[i] == BUSY)。</p>", "created": "2017-04-25T00:55:47Z", "bucket_order": 159, "bucket_name": "Week 4/23 - 4/29", "type": "feedback", "tag_good": [], "uid": "ie7xy0nh1811ls", "children": [], "tag_good_arr": [], "id": "j1wublq5ly33r1", "updated": "2017-04-25T00:55:47Z", "config": {}}, {"anon": "stud", "folders": [], "data": {"embed_links": null}, "subject": "<p>张天扬 2015011306</p>", "created": "2018-05-06T06:57:28Z", "bucket_order": 106, "bucket_name": "Week 4/29 - 5/5", "type": "feedback", "tag_good": [], "uid_a": "a_0", "children": [], "tag_good_arr": [], "id": "jgugt184ex3269", "updated": "2018-05-06T06:57:28Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>李凯文 2014011756</p>\n<p>如果其中一个进程先执行了flags[i]=BUSY&#xff0c;然后切换到另一个进程执行flags[i]=BUSY&#xff0c;则此时两个进程的flags均为uBUSY&#xff0c;此后两个进程必定卡死在while循环中&#xff0c;不能满足空闲则入。</p>", "created": "2018-05-06T06:58:47Z", "bucket_order": 106, "bucket_name": "Week 4/29 - 5/5", "type": "feedback", "tag_good": [], "uid": "je2ib5nk89v6ca", "children": [], "tag_good_arr": [], "id": "jgugupx5d04b8", "updated": "2018-05-06T06:58:47Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>和上面的方法相比&#xff0c;这个方法能够实现忙则等待&#xff0c;但是无法实现空闲则入的条件</p>\n<pre>INITIALIZATION:\n\n\ttypedef char boolean;\n\t...\n\tshared boolean flags[n -1];\n\t...\n\tflags[i ] = FREE;\n\t...\n\tflags[j ] = FREE;\n\t...\nENTRY PROTOCOL (for Process i ):\n\t/* claim the resource */\n\tflags[i ] = BUSY;\n------------------------&gt;\n\t/* wait if the other process is using the resource */\n\twhile (flags[j ] == BUSY) {\n\t}\nEXIT PROTOCOL (for Process i ):\n\t/* release the resource */\n\tflags[i ] = FREE;</pre>\n<p>同样考虑初始情况&#xff0c;一开始 i j 都是free的&#xff0c;此时 i 先执行&#xff0c;执行到图中的分割线处&#xff08; ---&gt;&#xff09;被中断&#xff0c;调度器调度 j 执行&#xff0c;此时由于 i 的 flags标记已经修改&#xff0c; j 修改完 flags以后无法进入临界区&#xff0c;同理 i 也无法进入临界区&#xff0c;不满足空闲则入的条件。</p>", "created": "2018-05-19T03:52:47Z", "bucket_order": 104, "bucket_name": "Week 5/13 - 5/19", "type": "feedback", "tag_good": [], "uid": "isvxeq6bspf1vn", "children": [], "tag_good_arr": [], "id": "jhcuxl2iesg6mu", "updated": "2018-05-19T03:52:47Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "j1vlj2hcliq2qf", "updated": "2017-04-24T04:01:53Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>选择“第7小题”的同学的回答结果写在此贴后面。</p>", "created": "2017-04-24T04:01:56Z", "bucket_order": 159, "bucket_name": "Week 4/23 - 4/29", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>这里主要是没有机制来区分开i和j的状态&#xff0c;也就是i和j有可能一直保持运行于同一行&#xff0c;即便delay a while是一段随机的时间&#xff0c;也无法排除这一点。所以&#xff0c;有可能所有的都不断地位于这个循环之中&#xff0c;导致死锁</p>", "created": "2017-04-25T01:05:48Z", "bucket_order": 159, "bucket_name": "Week 4/23 - 4/29", "type": "feedback", "tag_good": [], "uid": "ie7xy1yxmql1n8", "children": [], "tag_good_arr": [], "id": "j1wuohl2x7fv7", "updated": "2017-04-25T01:05:48Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>比如这样一种情况&#xff0c;i和j都从代码第一行开始&#xff0c;i运行一行后切换到j运行&#xff0c;然后j也只运行一行就切换到i&#xff0c;以此方式执行下去&#xff0c;最终会导致两者都在while循环中永远出不去&#xff0c;具体执行为&#xff1a;flags[i] = FREE -&gt; flags[j] = FREE -&gt; i ENTRY -&gt; j ENTRY -&gt;flags[i] = BUSY -&gt; flags[j] = BUSY -&gt;i 进入while -&gt; j 进入 while -&gt;flags[i] = FREE -&gt; flags[j] = FREE -&gt; i delay a while -&gt; j delay a while -&gt;flags[i] = BUSY -&gt; flags[j] = BUSY -&gt;i 又进入while -&gt; j 又进入while......</p>", "created": "2017-04-25T01:18:19Z", "bucket_order": 159, "bucket_name": "Week 4/23 - 4/29", "type": "feedback", "tag_good": [], "uid": "ie7xy1yxmql1n8", "children": [], "tag_good_arr": [], "id": "j1wv4l4mfpv7db", "updated": "2017-04-25T01:18:19Z", "config": {}}, {"anon": "stud", "folders": [], "data": {"embed_links": null}, "subject": "<p>张天扬 2015011306</p>", "created": "2018-05-06T06:57:33Z", "bucket_order": 106, "bucket_name": "Week 4/29 - 5/5", "type": "feedback", "tag_good": [], "uid_a": "a_0", "children": [], "tag_good_arr": [], "id": "jgugt4d9t2k7j7", "updated": "2018-05-06T06:57:33Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "j1vlj58frqe4tx", "updated": "2017-04-24T04:01:56Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>选择“第8小题”的同学的回答结果写在此贴后面。</p>", "created": "2017-04-24T04:02:06Z", "bucket_order": 159, "bucket_name": "Week 4/23 - 4/29", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>这个算法没有错。</p>\n<p>假设同时有多个进程尝试进入临界区&#xff0c;如果此时有一个Flag先于其他被设置为busy&#xff0c;则该进程顺利进入临界区&#xff0c;其他进程都会陷入循环里。假设有多个Flag同时被设置为busy&#xff0c;那么多个进程同时进入循环&#xff0c;但非进程i会进入小循环从而释放自己的Flag&#xff0c;从而进程退出大循环&#xff0c;只有进程i进入了临界区。因此当临界区空闲时有且仅有一个程序进入临界区。</p>\n<p></p>\n<p>退出的时候会释放自己的flag&#xff0c;并将turn设置为其他程序的进程号&#xff0c;从而允许其他进程进入临界区。</p>", "created": "2017-04-25T01:28:12Z", "bucket_order": 159, "bucket_name": "Week 4/23 - 4/29", "type": "feedback", "tag_good": [], "uid": "ie7xy6ut1rx1rv", "children": [], "tag_good_arr": [], "id": "j1wvhadtfbs5kt", "updated": "2017-04-25T01:28:12Z", "config": {}}, {"anon": "stud", "folders": [], "data": {"embed_links": null}, "subject": "<p>王延森 2015011285</p>", "created": "2018-05-06T06:57:58Z", "bucket_order": 106, "bucket_name": "Week 4/29 - 5/5", "type": "feedback", "tag_good": [], "uid_a": "a_0", "children": [], "tag_good_arr": [], "id": "jgugto85byt7pg", "updated": "2018-05-06T06:57:58Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>这个算法是正确的&#xff08;二进程&#xff09;。算法正确的保证在于&#xff0c;在Entry protocol中&#xff0c;turn的值没有改变过。因此&#xff0c;一旦初始化之后&#xff0c;turn值确定&#xff0c;在二者同时申请资源的时候一定由turn值规定的人先拿到资源。</p>\n<p>分类讨论如下&#xff1a;</p>\n<p>1、在</p>\n<pre><code>    /* wait if the other process is using the resource */<br />    while (flags[j ] == BUSY) {<br /></code></pre>\n<p>之前&#xff0c;如果只有一个进程进入BUSY的状态&#xff0c;那么BUSY状态的进程只能是执行到这个while的进程&#xff08;因为声明自己BUSY在这句话之前&#xff09;&#xff0c;这时&#xff0c;该进程判断对方实际上不是BUSY&#xff0c;因此会直接申请资源。</p>\n<p></p>\n<p>2、在上面这句话之前&#xff0c;两个进程都进入了BUSY状态。</p>\n<pre><code>ENTRY PROTOCOL (for Process i ):\n    /* claim the resource */\n    flags[i ] = BUSY;\n    /* wait if the other process is using the resource */\n    while (flags[j ] == BUSY) {\n        /* if waiting for the resource, also wait our turn */\n        if (turn != i ) {\n            /* but release the resource while waiting */\n            flags[i ] = FREE;\n            while (turn != i ) {\n            }\n            flags[i ] = BUSY;\n        }\n    }<br /></code></pre>\n<p>注意&#xff0c;在这个循环中&#xff0c;turn的值是不会改变的&#xff0c;因此&#xff0c;进入循环前&#xff0c;turn的值一定是i或j中确定的一个&#xff0c;不妨设为i&#xff08;j的情况是对称的&#xff09;。那么对于i进程来说&#xff0c;循环体内的条件turn!=i永远都不会满足&#xff0c;这个循环对于它来说是个空循环&#xff0c;它只需要一直等待j变为非busy即可。而对于j来说&#xff0c;循环内条件满足&#xff0c;只要它能被分配到时间片&#xff0c;它就会把自己的flag设为FREE&#xff0c;并且等待turn变为自己。</p>\n<p>i在j变为free后&#xff0c;循环条件不满足&#xff0c;就可以开始占用资源了。资源使用完毕之后&#xff0c;i将turn设为j&#xff1a;</p>\n<p></p>\n<pre>EXIT PROTOCOL (for Process i ):<br />    /* pass the turn on, and release the resource */<br />    turn = j ;<br />    flags[i ] = FREE;</pre>\n<p>并申明自己释放了资源&#xff0c;j的循环条件不满足&#xff0c;可以开始执行。</p>\n<p>注意&#xff0c;即使这时i重新申请使用资源也没有意义&#xff0c;因为在它申请资源之后turn值不会改变&#xff0c;在两者同时都需要资源的时候&#xff0c;这次会由i让出资源&#xff0c;让j先占用&#xff0c;因此j总会得到资源并执行的。</p>", "created": "2018-05-07T05:45:36Z", "bucket_order": 105, "bucket_name": "Week 5/6 - 5/12", "type": "feedback", "tag_good": [], "uid": "iswj8urcumf2o2", "children": [], "tag_good_arr": [], "id": "jgvtogkfzzx15w", "updated": "2018-05-07T05:45:36Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "j1vljckc9wi6z8", "updated": "2017-04-24T04:02:06Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>选择“第9小题”的同学的回答结果写在此贴后面。</p>", "created": "2017-04-24T04:02:15Z", "bucket_order": 159, "bucket_name": "Week 4/23 - 4/29", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p><div>\n<blockquote style=\"color:#777777\">\n<p>此题针对二进程切换。turn的取值只有i和j。<br />while循环中的第二个条件turn != i等价于turn == j&#xff0c;即与peterson算法相同。<br />因此可以解决二进程切换问题。</p>\n</blockquote>\n<p><em>在Peterson算法中&#xff0c;想要进入临界区&#xff0c;必须出while循环。</em></p>\n<p>单进程时&#xff1a;</p>\n<ul><li>对于process i&#xff0c;flag[j]=free&#xff0c;顺利进入临界区。</li></ul>\n<p>双进程时&#xff1a;</p>\n<ol><li>如果process i 先执行了flag[i]=busy&#xff0c;然后切换到j&#xff0c;j执行到while时&#xff0c;turn=i&#xff0c;卡在while进不去。切换到i时&#xff0c;也卡在while无法进入。再切换到j时&#xff0c;j可以进入。即使此临界过程中再切到i&#xff0c;i仍然因为turn=j而无法进入&#xff0c;直到flag[j]=free。</li><li>如果process i 限制性了flag[i]=busy&#xff0c;然后切换到j&#xff0c;j执行了flag[j]=true就切换回来&#xff0c;切换到i&#xff0c;i卡在while。切换到j&#xff0c;j卡在while。切换回i&#xff0c;i可以进入。此时即使切换回j&#xff0c;仍然不可以进入&#xff0c;直到flag[i]=free。</li><li>如果process i 先执行了flag[i]=busy和turn=j&#xff0c;切换到j&#xff0c;j执行到while时&#xff0c;卡住。切换回i&#xff0c;i可以进入。切换到j&#xff0c;j仍然不可进入直到flag[i]=free。</li><li>如果process i 先执行了flag[i]=busy和turn=j&#xff0c;切换到j&#xff0c;j执行了flag[j]=true就切换回来。i卡住。切换到j&#xff0c;j进入临界区。i不可进入直到flag[j]=true。</li></ol>\n<p>总结&#xff1a;</p>\n<ul><li>如果没来得及立flag&#xff0c;则视为单进程情况。</li><li>若立了flag&#xff0c;则turn最终有一个仲裁写入顺序。最后写入的进程将卡住。切换到另外一个进程执行&#xff0c;在此过程中&#xff0c;刚才被卡住的进程无法进入临界区&#xff08;因为turn不满足&#xff09;&#xff0c;直到执行的进程free its flag.</li></ul>\n<div>​</div>\n</div>", "created": "2017-04-25T01:28:02Z", "bucket_order": 159, "bucket_name": "Week 4/23 - 4/29", "type": "feedback", "tag_good": [], "uid": "ie7xxz4di3o1ke", "children": [], "tag_good_arr": [], "id": "j1wvh2qzqkr5hj", "updated": "2017-04-25T01:28:02Z", "config": {}}, {"anon": "stud", "folders": [], "data": {"embed_links": null}, "subject": "<p>王延森 2015011285</p>", "created": "2018-05-06T06:58:03Z", "bucket_order": 106, "bucket_name": "Week 4/29 - 5/5", "type": "feedback", "tag_good": [], "uid_a": "a_0", "children": [], "tag_good_arr": [], "id": "jgugtrinccst", "updated": "2018-05-06T06:58:03Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>这一问就是实现了Peterson算法&#xff0c;完全没有任何改动……</p>\n<p>作为练习我就再写一下吧&#xff1a;</p>\n<p></p>\n<p>算法的重点在于&#xff0c;在循环是个空循环&#xff0c;在二者都到达循环之后&#xff0c;turn的值确定&#xff0c;由谁来执行也就随之确定了。</p>\n<pre><code>ENTRY PROTOCOL (for Process i ):\n    /* claim the resource */\n    flags[i ] = BUSY;\n\n    /* give away the turn */\n    turn = j ;\n    /* wait while the other process is using the resource *and* has the turn */\n    while ((flags[j ] == BUSY) &amp;&amp; (turn != i )) {\n    }</code></pre>\n<p>1、假设只有一个进程申明自己申请资源&#xff0c;换句话说&#xff0c;flags[i]与flags[j]中只有一个是BUSY&#xff0c;不妨假设为i。那么当进程i执行到循环时&#xff0c;flags[j]应为FREE&#xff0c;i循环条件不满足&#xff0c;直接占用资源并开始执行。</p>\n<p>2、加入两个进程都申明自己申请资源&#xff0c;那么到达循环时&#xff0c;turn值一定是确定的&#xff08;由较晚执行turn=j这一句话的进程决定&#xff09;。注意到&#xff0c;对于二进程来说&#xff0c;turn!=i只对一个进程成立&#xff0c;且对另一个进程一定不成立。那么在两个进程都是BUSY的情况下&#xff0c;不成立的那个获得资源&#xff08;也就是turn对应的进程获得资源&#xff09;。在资源使用完毕之后&#xff0c;退出时将自己置为FREE&#xff0c;此时另一个进程的循环条件也不满足&#xff0c;可以开始占用资源。</p>\n<p>注意&#xff0c;如果这时先使用资源的人再次申请资源&#xff0c;会在进入循环前先执行 turn=对方 的操作&#xff0c;这样对方的循环条件同样不满足&#xff0c;对方可以先使用资源。这就防止了同一个进程多次优先占用资源的情况。</p>", "created": "2018-05-07T05:57:24Z", "bucket_order": 105, "bucket_name": "Week 5/6 - 5/12", "type": "feedback", "tag_good": [], "uid": "iswj8urcumf2o2", "children": [], "tag_good_arr": [], "id": "jgvu3mtngw05bp", "updated": "2018-05-07T05:57:24Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p>", "created": "2019-05-02T02:51:43Z", "bucket_order": 54, "bucket_name": "Week 4/28 - 5/4", "type": "feedback", "tag_good": [], "uid": "ju69lug52OdQ", "children": [], "tag_good_arr": [], "id": "jv61zhx3bta3rd", "updated": "2019-05-02T02:51:43Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "j1vljk1kqoj7cy", "updated": "2017-04-24T04:02:15Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>选择“第10小题”的同学的回答结果写在此贴后面。</p>", "created": "2017-04-24T04:02:27Z", "bucket_order": 159, "bucket_name": "Week 4/23 - 4/29", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p><p>我觉得是正确的。如有错误&#xff0c;请指正</p>\n<ol><li>\n<p>一般情况&#xff1a;只有最接近 turn 的一个进程能执行到(1). 执行到 (2) 时 所有进程的 index 指向该进程&#xff0c;该进程退出 Repeat 进入临界区执行。</p>\n</li><li>\n<p>特殊情况&#xff1a;存在多个进程执行到 (1)&#xff0c;假设&#xff1a;</p>\n<ol><li>\n<p>当前turn=0&#xff0c;全idle</p>\n</li><li>\n<p>index=2 的进程 P2 先执行到 (1), flags[2] = ACTIVE</p>\n</li><li>\n<p>随后 index=1 的进程 P1 执行到 (1), flags[1] = ACTIVE</p>\n</li><li>\n<p>P2 执行到 (2), 局部变量 index = 1</p>\n</li><li>\n<p>随后 P1 执行到 (2), 局部变量 index = 2</p>\n</li><li>\n<p>P1、P2 都不满足 until 的退出条件&#xff0c;但此时 flags[1] != IDLE&#xff0c;P2 的下一次循环会被卡在 (1) 之前&#xff0c;回到一般情况。</p>\n</li><li>\n<p>由于这种情况不能无限发生&#xff0c;因此最终将有一进程进入临界区。</p>\n</li></ol></li></ol>\n<pre>  repeat {\n  ​\n          /* announce that we need the resource */\n          flags[i] = WAITING;\n  ​\n          /* scan processes from the one with the turn up to ourselves. */\n          /* repeat if necessary until the scan finds all processes idle */\n          index = turn;\n          while (index != i) {\n              if (flag[index] != IDLE) index = turn;\n              else index = index&#43;1 mod n;\n          }\n  ​\n          /* now tentatively claim the resource */\n          flags[i] = ACTIVE;\n  (1)\n          /* find the first active process besides ourselves, if any */\n          index = 0;\n          while ((index &lt; n) &amp;&amp; ((index == i) || (flags[index] != ACTIVE))) {\n              index = index&#43;1;\n          }\n  (2)\n      /* if there were no other active processes, AND if we have the turn\n         or else whoever has it is idle, then proceed.  Otherwise, repeat\n         the whole sequence. */\n      } until ((index &gt;= n) &amp;&amp; ((turn == i) || (flags[turn] == IDLE)));</pre>", "created": "2017-05-04T03:57:48Z", "bucket_order": 158, "bucket_name": "Week 4/30 - 5/6", "type": "feedback", "tag_good": [], "uid": "ie7xy8gtpwk1t5", "children": [], "tag_good_arr": [], "id": "j29vscmx6ro1gm", "updated": "2017-05-04T03:57:48Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>魏钧宇 2015011263</p>", "created": "2018-05-06T06:48:36Z", "bucket_order": 106, "bucket_name": "Week 4/29 - 5/5", "type": "feedback", "tag_good": [], "uid": "isvxeq6bspf1vn", "children": [], "tag_good_arr": [], "id": "jgughmj7yk8633", "updated": "2018-05-06T06:48:36Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p><pre>repeat {\n    /* announce that we need the resource */\n    flags[i] = WAITING; //&#xff08;0&#xff09;语句<br />\t//循环1开始<br />    index = turn;\n    while (index != i) {\n        if (flag[index] != IDLE) index = turn;//条件1\n        else index = index&#43;1 mod n;\n    }\n    \t//循环1结尾\n    flags[i] = ACTIVE; //&#xff08;1&#xff09;语句<br />\t//循环2开始\n    /* find the first active process besides ourselves, if any */\n    index = 0;\n    while ((index &lt; n) &amp;&amp; //条件2 <br />\t((index == i) || (flags[index] != ACTIVE)))  //条件3<br />    {\n        index = index&#43;1;\n    }\n    \t//循环2结尾<br />//最终判断\n} until ((index &gt;= n)  //条件4<br />\t&amp;&amp; ((turn == i)|| (flags[turn] == IDLE))); //条件5</pre>\n<p>这个方法是Wiki上的Eisenberg同步算法&#xff0c;我认为这个方法能够满足&#xff1a;</p>\n<p>&#xff08;1&#xff09;只有一个进程时能够顺利进入临界区</p>\n<p>&#xff08;2&#xff09;如果临界区内有其他进程&#xff0c;别的进程不会进入临界区&#xff08;满足忙则等待&#xff09;</p>\n<p>&#xff08;3&#xff09;不会有两个进程同时进入临界区&#xff08;满足互斥进入&#xff09;</p>\n<p>&#xff08;4&#xff09;对于空闲则入的情况&#xff0c;我认为在绝大多数情况下是没有问题&#xff0c;但可以构造出一个极端的调度例子让这个同步算法无法满足空闲则入的情况。</p>\n<p></p>\n<p>&#xff08;1&#xff09;比较显然&#xff0c;如果只有一个进程&#xff0c;首先将自己的状态标为WATING&#xff0c;进入循环1&#xff0c;由于此时只有一个进程&#xff0c;而且它的态为Wating&#xff0c;所以顺利完成这个循环&#xff0c;将自己的状态标为Active&#xff0c;进入循环2&#xff0c;由于此时所有进程的状态都为Active的&#xff0c;所以index会最终增长为n&#xff0c;最后在判断时我们发现flags[0] == IDIE而且index = n&#xff0c;通过最终判断&#xff0c;进入临界区。</p>\n<p></p>\n<p>&#xff08;1&#xff09;证讫</p>\n<p>-----------这是一条分割线---------------</p>\n<p>我们使用数学归纳法来证明&#xff08;2&#xff09;&#xff0c;&#xff08;3&#xff09;</p>\n<p>如果只有一个进程&#xff0c;显然满足&#xff08;2&#xff09;&#xff0c;&#xff08;3&#xff09;&#xff0c;假设对于n个进程&#xff08;2&#xff09;&#xff0c;&#xff08;3&#xff09;都成立&#xff0c;那么对于n&#43;1个进程的情况有&#xff08;我们设新添加的进程为 j &#xff09;&#xff1a;</p>\n<p></p>\n<p>首先来说明&#xff08;2&#xff09;&#xff0c;假设此时临界区内有一个进程&#xff08;设为 i &#xff09;&#xff0c;那么对于临界区外的其他进程&#xff08;除j以外&#xff09;来说&#xff0c;由归纳假设&#xff0c;他们都不会进入临界区&#xff0c;现在来考虑 j &#xff1a;</p>\n<p>由于此时的turn为 i &#xff08;因为i进入临界区以前一定会修改turn&#xff09;&#xff0c;所以在循环1中的条件1就一定会满足&#xff0c;于是index就一直保持在turn不动&#xff0c;也就是说新来的这个进程 j 无法退出循环 1</p>\n<p>由此对于n &#43; 1个进程&#xff08;2&#xff09;也成立&#xff0c;因此对于所有自然数n&#xff08;2&#xff09;都成立</p>\n<p></p>\n<p>&#xff08;2&#xff09;证讫</p>\n<p>-----------这是一条分割线---------------</p>\n<p></p>\n<p>接下来证明&#xff08;3&#xff09;&#xff0c;此时临界区内没有进程&#xff0c;所有进程都在临界区外竞争进入临界区&#xff0c;那么由归纳假设&#xff0c;其他的n个进程之间不可能出现两两一起进入临界区的情况&#xff0c;我们只需要保证新添加的这个进程 j 不会和其他的n个进程不会出现同时进入临界区的情况&#xff0c;也就是说这个问题中的 n 进程竞争被简化为了 2 进程竞争&#xff0c;我们设另一个与 j 竞争的进程为 i&#xff0c;设此时的turn = w</p>\n<p>如果此时的 w &lt; j &lt; i&#xff08;在循环队列的意义下&#xff09; i 在1循环中刚刚检查完 j &#xff0c;j 就执行了&#xff08;0&#xff09;语句修改自己的状态&#xff0c;同时由于 j 没有检查过 i 所以也会通过 1 循环&#xff0c;这样就会出现 i , j 同时达到&#xff08;1&#xff09;语句的情况&#xff0c;对于这种情况我们发现 i , j 在执行2循环都会因为条件3而退出&#xff08;因为对于各自来说都存在一个编号不是自己同时由满足 flags 为active的进程&#xff09;这样他们的index都不可能达到 n &#xff08;事实上 i 的index为 j &#xff0c;j 的 index为 i&#xff09;这样他们在最终判断时就一定无法满足条件4&#xff0c;于是都无法进入到临界区&#xff0c;这样对于 n &#43; 1个进程就满足了互斥进入</p>\n<p>对于其他的情况&#xff0c;i j 只能有一个达到&#xff08;1&#xff09;语句&#xff0c;于是就只能有一个进程进入临界区&#xff0c;另一个进程在循环1中等待</p>\n<p>综上 n &#43; 1 个进程也满足互斥进入&#xff0c;所以对于所有的自然数 n &#xff08;3&#xff09;成立</p>\n<p></p>\n<p>&#xff08;3&#xff09;证讫</p>\n<p>-----------这是一条分割线---------------</p>\n<p></p>\n<p>最后我们来说明&#xff08;4&#xff09;&#xff0c;我们可以构造只有两个进程的反例&#xff0c;假设他们为 i 和 j&#xff0c;那么我可以设计一种特殊的调度策略&#xff0c;让他就按照我刚刚证明&#xff08;3&#xff09;的时候说的特殊情况进行调度&#xff0c;即永远保持 w &lt; j &lt; i&#xff0c;然后一等到 i 检查完 j&#xff0c;就让 j 开始执行&#xff0c;这样明明临界区是空的&#xff0c; i j 却都无法进入临界区&#xff0c;不满足空闲则入的要求</p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>", "created": "2018-05-07T11:41:36Z", "bucket_order": 105, "bucket_name": "Week 5/6 - 5/12", "type": "feedback", "tag_good": [], "uid": "isvxeq6bspf1vn", "children": [], "tag_good_arr": [], "id": "jgw6e9oyaab7n1", "updated": "2018-05-07T11:41:36Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>李凯文 2014011756</p>\n<p>关于魏钧宇同学提出的反例&#xff0c;我认为仍然满足空闲则入&#xff0c;在turn=w&lt;=j&lt;i的情况&#xff08;turn要在0&#xff5e;n-1之间&#xff0c;如果是两个进程是不可能有turn=w&lt;j&lt;i的&#xff0c;只能是turn=w=j&lt;i&#xff09;下&#xff0c;按照魏钧宇同学给出的反例流程&#xff0c;i&#xff0c;j都将再次进入repeat循环&#xff0c;而这时&#xff0c;由于flags早在第一次进入的时候就已经不是IDLE了&#xff0c;所以对于进程i&#xff0c;是不能够通过循环1的&#xff0c;于是到达循环2的就只有进程j&#xff0c;所以只要进程i执行过第二次repeat中的将flags由ACTIVE置为WAITING&#xff0c;进程j早晚可以通过循环2将index加到n&#xff0c;如果仅仅是这两个进程竞争&#xff0c;那么进程j必然可以进入临界区(除非调度器就是始终不给进程i分配资源让其改flags&#xff1f;&#xff1f;)。</p>\n<p></p>\n<p>从流程上的证明在周五课后我也给出了一个Post&#xff0c;然后向老师建议通过分类讨论的方式来更全面地证明&#xff0c;这里看是不是加上魏钧宇同学的数学归纳法证明之后就可以从两个角度证明这个算法的正确性了&#xff1f;</p>\n<p></p>\n<p>魏钧宇同学证明了互斥进入&#xff0c;基于下面三点</p>\n<p>&#xff08;1&#xff09;只有一个进程时能够顺利进入临界区</p>\n<p>&#xff08;2&#xff09;如果临界区内有其他进程&#xff0c;别的进程不会进入临界区&#xff08;满足忙则等待&#xff09;</p>\n<p>&#xff08;3&#xff09;不会有两个进程同时进入临界区&#xff08;满足互斥进入&#xff09;</p>\n<p></p>\n<p>下面给出空闲则入的证明&#xff1a;</p>\n<p>使用反证法&#xff1a;</p>\n<p>如果不满足空闲则入&#xff0c;那么必然存在一种情况&#xff0c;所有进入竞争区的进程都在repeat循环里出不来</p>\n<p>首先看repeat循环的特点是&#xff0c;</p>\n<p>&#xff08;a&#xff09;只要进入了这个竞争区&#xff0c;flags就一定不是IDLE&#xff1b;</p>\n<p>&#xff08;b&#xff09;最靠近turn的进程必然能够通过循环1</p>\n<p></p>\n<p>因此&#xff0c;如果所有进程都出不去&#xff0c;那么经过充分而有限的时间t‘&#xff08;我们假设每个进程都有机会获得CPU&#xff09;&#xff0c;所有竞争区的进程的flags必定都非IDLE&#xff0c;而且在更充分的时间t0后&#xff0c;所有进程在循环1中判断时&#xff0c;涉及的在竞争区内的进程的flags都非IDLE&#xff0c;那么这时&#xff0c;就只有最靠近turn的那个进程能够通过循环1。</p>\n<p></p>\n<p>即使在这个充分而有限的时间t0内有新进程进入&#xff0c;根据假设&#xff0c;所有进程还是都出不去&#xff0c;那么仍然会有一个时间t1&#xff0c;使只有最靠近turn的那个进程通过循环1&#xff0c;由于进程总数是有限的&#xff0c;所以这种时间的增长是有限的&#xff0c;于是在一个有限的时间t后&#xff0c;只有最靠近turn的那个进程能够通过循环1。</p>\n<p></p>\n<p>显然&#xff0c;此时这个进程可以通过循环2将index加到n&#xff0c;由于其距离turn最近&#xff0c;说明turn就是该进程或者turn的flags为IDLE&#xff0c;于是该进程进入临界区&#xff08;即使此时turn对应的那个进程进入repeat改了flags也没关系&#xff0c;只是再次增大了t而已&#xff09;</p>\n<p></p>\n<p>综上&#xff0c;假设错误&#xff0c;满足空闲则入.</p>\n<p>由此&#xff0c;该算法正确 (只要保证调度过程不会有某一进程在无限时间内获取不到CPU的情况&#xff0c;显然这一点一般是可以保证的)</p>\n<p></p>\n<p>实际上&#xff0c;只有turn对应的进程没有指向进入repeat的一个进程&#xff0c;并且发生了很多次非常极端的情况时&#xff0c;上面的t才会比较长&#xff0c;而上面证明了t依然有限&#xff0c;所以该算法有效。</p>\n<p></p>\n<p>----------------------------------------------</p>\n<p></p>\n<p>刚想起另一种简单的思路&#xff0c;</p>\n<p>1.证明互斥进入</p>\n<p>  实际上循环2就已经实现了互斥进入&#xff0c;即只能有一个进程进入临界区&#xff0c;即只有第一个设置ACTIVE的才有可能进入临界区。</p>\n<p></p>\n<p>  这里的第一个是指在写之前flags全不是ACTIVE&#xff0c;写后一个变为ACTIVE&#xff0c;如果有进程写了然后循环回去又改成了WAITING&#xff0c;则下一个第一个改ACTIVE的才有可能进入临界区。</p>\n<p></p>\n<p>  因为先设置ACTIVE并还没有循环回去的进程会让其他进程数ACTIVE数目时都发现不只自己&#xff0c;这样就进不到临界区。</p>\n<p></p>\n<p>  因此循环2保证了在临界区没有进程时最多一个进程可能进入临界区</p>\n<p>  然后&#xff0c;如果有一个进程进入了临界区&#xff0c;那么&#xff0c;该进程的flags必定为ACTIVE&#xff0c;继而阻止了其他所有进程在循环2中将index加到n&#xff0c;所以这时没有进程能再进去&#xff0c;除非临界区的进程退出临界区&#xff0c;改了自己的flags。</p>\n<p></p>\n<p>综上&#xff0c;互斥进入得证。</p>\n<p></p>\n<p>而空闲则入&#xff0c;仍采用上面的反证法&#xff0c;基本思路是&#xff0c;如果无限循环&#xff0c;那么能通过循环1的越来越少&#xff0c;由于进程数目有限&#xff0c;总会有减到1的时候&#xff0c;这时这个进程必定能进入临界区&#xff0c;与假设矛盾。</p>", "created": "2018-05-07T17:44:58Z", "bucket_order": 105, "bucket_name": "Week 5/6 - 5/12", "type": "feedback", "tag_good": [], "uid": "je2ib5nk89v6ca", "children": [], "tag_good_arr": [], "id": "jgwjdk6880l73n", "updated": "2018-05-07T17:44:58Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p><p>为了方便&#xff0c;将while循环依次称为while 1-3.</p>\n<p></p>\n<p>首先我们观察 / 证明如下性质</p>\n<ol><li>\n<p>若i进入临界区&#xff0c;则其他介于turn和i之间的进程不会进入临界区&#xff08;下称“其他进程”&#xff09;。特殊地&#xff0c;i可以是turn.</p>\n<p>“则”部分&#xff1a;</p>\n<ol><li>\n<p>若“其他进程”j在i进行while-2时已经执行了flags[j] = ACTIVE, 则i不会进入临界区&#xff0c;矛盾</p>\n</li><li>\n<p>若“其他进程”j在i进行while-2时尚未执行flags[j] = ACTIVE, 则j会在while-2找出一个index &lt;= i&#xff0c;进行下一轮repeat-until</p>\n</li></ol>\n<p> </p>\n<p></p>\n<p></p>\n<p>“并且”部分由while-2保证。</p>\n</li></ol><ol start=\"2\"><li>\n<p>若进程i进入临界区&#xff0c;flags[i] == ACTIVE, flags[j] != ACTIVE for 0 &lt;= j &lt; n and j != i</p>\n<p>如果能将repeat-until条件中的index值替代为一个确定其值的等价的原子函数操作&#xff08;while-2 )&#xff08;下称理想情况&#xff0c;将得到的index值记为index-ideal; 对应地&#xff0c;记作现实情况和index-real&#xff09;&#xff0c;那么这是显然的。</p>\n<p></p>\n<p>实际情况中&#xff0c;while-2过程中别的进程j有可能将flags[j]设为ACTIVE, 也可能从ACTIVE改回WAITING. 但由性质1&#xff0c;若理想情况中i将要通过repeat-until的检查&#xff0c;则不存在进程j, turn &lt;= j &lt; i&#xff08;循环意义上&#xff09;&#xff0c;s.t. j在函数i进行while 2过程中将flags[j]从ACTIVE改回WAITING. 因此进程i在现实情况中通过repeat-until判断时, n = index-real &lt;= index-ideal, 在理想情况也通过判断。</p>\n<p></p>\n</li><li>\n<p>经过足够长时间&#xff0c;至少有一个进程会进入临界区</p>\n<p>考虑距离turn最近并且执行了flags[i] = ACTIVE语句的进程i。对于其他任意一个进程j, repeat-until失败一次之后&#xff1a;如果turn &lt;= j &lt; i (循环意义上)&#xff0c;由i的定义, j没有将flags[j]改为ACTIVE&#xff1b;如果i &lt; j &lt; turn&#xff08;循环意义上&#xff09;&#xff0c;j会卡在while-1. 综上&#xff0c;当所有进程j (i &lt; j &lt; turn)都卡在while-1之后&#xff0c;repeat-until的条件对于i必然满足&#xff0c;i可以进入临界区。</p>\n</li></ol>\n<p></p>\n<p>由性质3知算法不会死锁&#xff0c;由性质2知只有1个进程进入临界区&#xff0c;保证了忙则等待&#xff1b;再结合性质1&#xff0c;保证了空闲则入&#xff08;尽管有一定的次序&#xff09;。</p>\n<p></p>\n<p>值得注意的一点是&#xff0c;两次进入临界区的进程可以是同一个进程&#xff0c;似乎可能带来饥饿。但while-3部分会试图将turn交给下一个等待的进程&#xff08;或者保持不变&#xff09;&#xff1b;只要有一个其他进程执行了一次flags[i] = WAITING&#xff08;语句0&#xff09;&#xff0c;就能将turn交出去。因此大多数情况下&#xff0c;进程i执行与进程j进入临界区之间(i != j)&#xff0c;至多有(j - i - 1 &#43; n) % n个进程进入临界区&#xff0c;体现了优先等待。</p>", "created": "2019-04-29T01:41:59Z", "bucket_order": 54, "bucket_name": "Week 4/28 - 5/4", "type": "feedback", "tag_good": [], "uid": "jshndz5tgxj4bq", "children": [], "tag_good_arr": [], "id": "jv1p69i08vw63f", "updated": "2019-04-29T01:41:59Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "j1vljsrc4a1562", "updated": "2017-04-24T04:02:27Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>选择“第11小题”的同学的回答结果写在此贴后面。</p>", "created": "2017-04-24T04:02:36Z", "bucket_order": 159, "bucket_name": "Week 4/23 - 4/29", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>错的.</p>\n<p></p>\n<p>用一个 flag 来记录每个进程检查所有其它进程锁检查到第几个了.</p>\n<p></p>\n<p>用 turn 表示检查到这一步的最后一个进程是不是自己.</p>\n<p></p>\n<p>每次标完之后等有别的进程都没有检查到我当前的进度, 或者是已经有进程比我快了, 然后就去标下个进程.</p>\n<p></p>\n<p>如果当前进程已经检查完所有其它进程就能进临界区了.</p>\n<p></p>\n<p>如果每次 标 flag - 等待 都是原子操作那么毫无问题.</p>\n<p></p>\n<p>可能出现问题的地方在于, 如果<strong>多于两个</strong>进程都首先把 flags[i] 设为最大, 然后再进入 wait. 这时候 trun 只能是其中一个的 pid. 那么另外的至少两个进程就都进临界区去执行了.</p>\n<p></p>\n<p>补充: 只有两个的时候是正确的.</p>\n<p></p>\n<p>numprocs = 2</p>\n<p></p>\n<p>那么 count 就是 0.</p>\n<p></p>\n<p>分几种情况讨论. 第二个在 wait, 枚举第一个执行到哪里.</p>\n<p></p>\n<ol><li>第一个执行到 flags[i] = count 前面: flags[1] = -1 &lt; count. 可以进临界区. 这时候 turn[2] = 2, flags[1] = 0. 第一个等待直到第二个执行 flags[2] = -1; 没有问题.</li><li>第一个执行到 flags[i] = count 后面: 第二个要等一下, 然后第一个执行 turn[0] = 1, 第二个就可以进临界区了. 然后和上面一样.</li><li>第一个执行到 turn[count] = i 后面: 第二个直接进了. 第一个等第二个完.</li><li>两个换顺序之后是一样的.</li></ol>\n<p></p>\n<p>所以在我能枚举到的情况里都是对的. 所以我姑且认为它是对的.</p>\n<p></p>\n<p></p>", "created": "2017-04-25T01:13:46Z", "bucket_order": 159, "bucket_name": "Week 4/23 - 4/29", "type": "feedback", "tag_good": [], "uid": "izb0cbqbyzd6wf", "children": [], "tag_good_arr": [], "id": "j1wuyq5j4jm78s", "updated": "2017-04-25T01:13:46Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>请问一下&#xff0c;“<strong>多于两个</strong>进程都首先把 flags[i] 设为最大”的情况&#xff0c;要怎么构造出呢&#xff1f;<br />我思考时发现怎么也找不到一种情况让3个及以上flags[i]变为最大……</p>", "created": "2017-05-18T07:23:11Z", "bucket_order": 156, "bucket_name": "Week 5/14 - 5/20", "type": "feedback", "tag_good": [], "uid": "ie7xy1orb4a1mz", "children": [], "tag_good_arr": [], "id": "j2u3aeg7hvp25u", "updated": "2017-05-18T07:23:11Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>我的理解是for循环内部的操作不保证原子性&#xff0c;因此可能第一轮的时候就有多个进程把自己的flags[i]设为0&#xff08;进程设置完flags[i]之后就被切换掉了&#xff09;</p>", "created": "2017-05-18T13:05:33Z", "bucket_order": 156, "bucket_name": "Week 5/14 - 5/20", "type": "feedback", "tag_good": [], "uid": "i5g31e12hcr27s", "children": [], "tag_good_arr": [], "id": "j2ufiogpyy36sf", "updated": "2017-05-18T13:05:33Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>魏钧宇 2015011263</p>", "created": "2018-05-06T06:48:55Z", "bucket_order": 106, "bucket_name": "Week 4/29 - 5/5", "type": "feedback", "tag_good": [], "uid": "isvxeq6bspf1vn", "children": [], "tag_good_arr": [], "id": "jgugi0s1xao67p", "updated": "2018-05-06T06:48:55Z", "config": {}}, {"anon": "stud", "folders": [], "data": {"embed_links": null}, "subject": "<p>对于只有两个进程时&#xff0c;这个同步方案是正确的&#xff0c;因为此时的循环只有两重&#xff0c;我们可以枚举两个进程的位置&#xff1a;</p>\n<p>1. 当前临界区内有进程&#xff08;设为进程p&#xff09;在执行&#xff0c;判断另一个进程&#xff08;设为进程q&#xff09;是否有可能再进入临界区&#xff1a;</p>\n<p>首先我们有flags[p] = 1&#xff0c;枚举另一个进程的情况&#xff1a;</p>\n<p>如果q在第一重循环内&#xff0c;由于它是最后一个进程&#xff0c;所以一定不会满足 turn[count] != q 的情况&#xff0c;另一方面&#xff0c;由于flags[q] &lt;= 0&#xff0c;所以也不满足 for all k != i, flag[k]&lt;count&#xff0c;所以它无法进入第二重循环&#xff0c;更谈不上进入临界区了</p>\n<p>如果q在第二重循环内&#xff0c;由于它是最后一个进程&#xff0c;所以不会满足 turn[count] != q 的情况&#xff0c;因此不可能进入临界区</p>\n<p>综上所属满足临界区内有进程时&#xff0c;另一个进程不会进入的情况</p>\n<p></p>\n<p>2. 如果两个进程都不在临界区&#xff0c;考虑是否只有一个进程能进入临界区&#xff1a;</p>\n<p>如果两个进程都在第二重循环内&#xff1a;总有一个后修改turn的进程不可能进入到临界区中</p>\n<p>如果两个进程一个在第二重循环&#xff0c;一个在第一重循环中&#xff1a;只要第二重循环的那个进程修改了flag&#xff0c;那么另一个进程就不可能进入下一重循环了</p>\n<p>如果两个进程都在第一重循环内&#xff1a;那么他们中总会有一个先进入到第二重循环&#xff08;设为p&#xff09;&#xff0c;那么这个问题就等价于一个在第一重循环&#xff0c;一个在第二重循环的问题了</p>\n<p>综上&#xff0c;无论在何种情况下&#xff0c;总会有一个进程后修改turn&#xff0c;那么这个进程就一定无法进入了临界区了</p>\n<p></p>\n<p>但是对于多个进程的情况&#xff0c;我们考虑一个极端的状态&#xff0c;假设有两个进程都位于最后一重循环中&#xff0c;到他们都没有修改flags&#xff0c;这时&#xff0c;倒数第二重循环中的所有进程就都能够随意进入最后一重循环中&#xff0c;于是此时就会有多于两个的进程同时进入最后一重循环中&#xff0c;即便此时turn 能够过滤掉一个进程&#xff08;最后一个修改turn的进程&#xff09;对于其他进程也无力回天了&#xff0c;于是就会有多个进程同时进入临界区了。</p>", "created": "2018-05-07T03:55:13Z", "bucket_order": 105, "bucket_name": "Week 5/6 - 5/12", "type": "feedback", "tag_good": [], "uid_a": "a_0", "children": [], "tag_good_arr": [], "id": "jgvpqhquj8c1vx", "updated": "2018-05-07T03:55:13Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>对于只有两个进程时&#xff0c;这个同步方案是正确的&#xff0c;因为此时的循环只有两重&#xff0c;我们可以枚举两个进程的位置&#xff1a;</p>\n<p>1. 当前临界区内有进程&#xff08;设为进程p&#xff09;在执行&#xff0c;判断另一个进程&#xff08;设为进程q&#xff09;是否有可能再进入临界区&#xff1a;</p>\n<p>首先我们有flags[p] = 1&#xff0c;枚举另一个进程的情况&#xff1a;</p>\n<p>如果q在第一重循环内&#xff0c;由于它是最后一个进程&#xff0c;所以一定不会满足 turn[count] != q 的情况&#xff0c;另一方面&#xff0c;由于flags[q] &lt;= 0&#xff0c;所以也不满足 for all k != i, flag[k]&lt;count&#xff0c;所以它无法进入第二重循环&#xff0c;更谈不上进入临界区了</p>\n<p>如果q在第二重循环内&#xff0c;由于它是最后一个进程&#xff0c;所以不会满足 turn[count] != q 的情况&#xff0c;因此不可能进入临界区</p>\n<p>综上所属满足临界区内有进程时&#xff0c;另一个进程不会进入的情况</p>\n<p> </p>\n<p>2. 如果两个进程都不在临界区&#xff0c;考虑是否只有一个进程能进入临界区&#xff1a;</p>\n<p>如果两个进程都在第二重循环内&#xff1a;总有一个后修改turn的进程不可能进入到临界区中</p>\n<p>如果两个进程一个在第二重循环&#xff0c;一个在第一重循环中&#xff1a;只要第二重循环的那个进程修改了flag&#xff0c;那么另一个进程就不可能进入下一重循环了</p>\n<p>如果两个进程都在第一重循环内&#xff1a;那么他们中总会有一个先进入到第二重循环&#xff08;设为p&#xff09;&#xff0c;那么这个问题就等价于一个在第一重循环&#xff0c;一个在第二重循环的问题了</p>\n<p>综上&#xff0c;无论在何种情况下&#xff0c;总会有一个进程后修改turn&#xff0c;那么这个进程就一定无法进入了临界区了</p>\n<p> </p>\n<p>但是对于多个进程的情况&#xff0c;我们考虑一个极端的状态&#xff0c;假设有两个进程都位于最后一重循环中&#xff0c;到他们都没有修改flags&#xff0c;这时&#xff0c;倒数第二重循环中的所有进程就都能够随意进入最后一重循环中&#xff0c;于是此时就会有多于两个的进程同时进入最后一重循环中&#xff0c;即便此时turn 能够过滤掉一个进程&#xff08;最后一个修改turn的进程&#xff09;对于其他进程也无力回天了&#xff0c;于是就会有多个进程同时进入临界区了。</p>", "created": "2018-05-07T03:55:45Z", "bucket_order": 105, "bucket_name": "Week 5/6 - 5/12", "type": "feedback", "tag_good": [], "uid": "isvxeq6bspf1vn", "children": [], "tag_good_arr": [], "id": "jgvpr71btgc29f", "updated": "2018-05-07T03:55:45Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "j1vlk034cqx2jv", "updated": "2017-04-24T04:02:36Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>选择“第12小题”的同学的回答结果写在此贴后面。</p>", "created": "2017-04-24T04:02:45Z", "bucket_order": 159, "bucket_name": "Week 4/23 - 4/29", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>该算法是正确的&#xff0c;考虑死锁和多个进程进入临界区这两类错误&#xff1a;</p>\n<p>        死锁&#xff1a;</p>\n<p>                可能的死锁点&#xff08;检查点&#xff09;有 ①</p>\n<pre><code>while (choosing[j]) {}</code></pre>\n<p>                                         ②</p>\n<pre><code> if ((num[j] &gt; 0) &amp;&amp;\n          ((num[j] &lt; num[i]) ||\n          (num[j] == num[i]) &amp;&amp; (j &lt; i))) {\n            while (num[j] &gt; 0) {}\n        }</code></pre>\n<p>           1.进程死锁在①&#xff1a;</p>\n<p>                  这是不可能的&#xff0c;因为执行到①处时必然已经执行</p>\n<pre><code>choosing[i] = FALSE;</code></pre>\n<p>           2.进程分别死锁在①&#xff0c;②&#xff1a;</p>\n<p>                  同上&#xff0c;死锁在①是不会发生的。</p>\n<p>           3.进程死锁在②&#xff1a;</p>\n<p>                  在②死锁&#xff0c;首先要满足(num[j] &gt; 0)&#xff0c;这个由num[i] = max(num[0], ..., num[n-1]) &#43; 1;是保证满足的。</p>\n<p>                  其次还要满足(num[j] &lt; num[i]) || (num[j] == num[i]) &amp;&amp; (j &lt; i))&#xff0c;如果num最小值唯一&#xff0c;则该最小值使得其不满足该条件&#xff0c;拥有该最小值的进程不会被死锁。如果最小值不唯一&#xff0c;则后一个条件必然不被满足&#xff0c;因为不存在序号相同的两个进程&#xff0c;序号最小的进程不会被阻塞。所以不可能有多个进程同时满足该条件&#xff0c;也就不会死锁。</p>\n<p>           所以死锁是不会发生的。</p>\n<p></p>\n<p></p>\n<p><code>   多个进程进入临界区&#xff1a;</code></p>\n<p>         考虑一个进程j进入临界区后&#xff0c;另一个进程i如何跨过检查点进入临界区。</p>\n<p>         检查点①&#xff1a;</p>\n<p>                i抵达该检查点以后&#xff0c;j可能已经执行了</p>\n<pre><code>choosing[i] = FALSE;</code></pre>\n<p>               所以该检查点不能阻挡其他进程。</p>\n<p>        关键在于i,j能否同时通过检查点②&#xff1a;</p>\n<p>               首先看第一个条件(num[j] &gt; 0)&#xff0c;如果j已经通过②&#xff0c;那么num[j] = max(num[0], ..., num[n-1]) &#43; 1;必然已经得以执行&#xff0c;对于i&#xff0c;这个条件是满足的。</p>\n<p>               第二个条件(num[j] &lt; num[i]) || (num[j] == num[i]) &amp;&amp; (j &lt; i))。如果j通过时num[i]未被赋值&#xff0c;则当num[i]被赋值的时候由于num[j]已经被赋值&#xff0c;所以num[i] &gt; num[j]&#xff0c;这时i会被阻塞。如果j通过时num[i]已经赋值&#xff0c;则由于j能通过&#xff0c;必有num[i] &gt;= num[j]。如果 num[i] &gt; num[j], 则i会被阻塞。如果num[i] == num[j]&#xff0c;因为j能通过&#xff0c;所以 j  &lt;= i。又 j != i&#xff0c;所以j &lt; i&#xff0c;所以i会被阻塞。</p>\n<p>              综上&#xff0c;在j已经通过②时&#xff0c;其他进程将不能通过②&#xff0c;因此也不会发生多个进程进入临界区的错误。</p>\n<p></p>\n<p></p>\n<p></p>", "created": "2017-04-25T03:07:48Z", "bucket_order": 159, "bucket_name": "Week 4/23 - 4/29", "type": "feedback", "tag_good": [], "uid": "ie7xy49etbi1pg", "children": [], "tag_good_arr": [], "id": "j1wz1dcqx4m7k", "updated": "2017-04-25T03:07:48Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p>我觉得学长的分析完全没有问题。通过了choosing两次置位且还没有将num[i]清0的线程之间必然有唯一确定的先后关系&#xff0c;线程进入临界区之前会检查所有其他线程&#xff0c;满足自己是这种先后关系中最先的进程之后才会进入临界区。还有正在choosing的线程的num必然大于其余已经选择过num的线程。</p>\n<p>在这里提2点疑问&#xff1a;</p>\n<p>1. 整型溢出怎么办&#xff1f;</p>\n<p>2. n是最大进程数吗&#xff1f;是最大线程数吗&#xff1f;如何保证其他进程不非法篡改num和choosing&#xff1f;</p>", "created": "2018-05-07T23:50:38Z", "bucket_order": 105, "bucket_name": "Week 5/6 - 5/12", "type": "feedback", "tag_good": [], "uid": "isyhiuebva42er", "children": [], "tag_good_arr": [], "id": "jgwwft1w85m391", "updated": "2018-05-07T23:50:38Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "j1vlk6xgdd45ce", "updated": "2017-04-24T04:02:45Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>选择“第13小题”的同学的回答结果写在此贴后面。</p>", "created": "2017-04-24T04:03:01Z", "bucket_order": 159, "bucket_name": "Week 4/23 - 4/29", "type": "followup", "tag_good": [], "uid": "hdjonbiyfs62ie", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "j1vlkiuyfma333", "updated": "2017-04-24T04:03:01Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>第1小题</p>\n<p>通过枚举和分类检查Peterson算法正确性</p>\n<p>Peterson算法是针对两个线程的&#xff0c;代码如下</p>\n<pre>do {\n      flag[i] = true;\n      turn = j;\n      while ( flag[j] &amp;&amp; turn == j);\n            CRITICAL SECTION\n      flag[i] = false;\n            REMAINDER SECTION\n} while (true);</pre>\n<p>按写变量的顺序进行情况分类</p>\n<p>情况1 只有一个线程进入&#xff0c;由于对称性&#xff0c;不妨设 i 打算进入而 j 不想。则 flag[i] == true,, flag[j] == false, turn == j 则 i 进程 while 语句条件不满足&#xff08;flag[j] == false&#xff09;&#xff0c;直接进入CRITICAL SECTION&#xff0c;满足空闲则入</p>\n<p>情况2 两个线程同时想要进入&#xff0c;但 turn 同时只能有一个值。由对称性&#xff0c;不妨设 i 先修改 turn 而 j 后修改 turn。这里注意到&#xff0c;如果 j 修改 turn 前 i 就进入 while 语句&#xff0c;那么将和情况 1 没有区别&#xff0c;所以这里 j 修改 turn 时&#xff0c;i 应当还没有进入 while 语句。所以 j 修改完 turn 后&#xff0c;flag[i] == true, flag[j] == true, turn == i&#xff0c;所以此时 i 不满足 while 条件&#xff08;turn != j&#xff09;&#xff0c;进入临界区&#xff0c;而 j 满足 while 语句&#xff0c;进入 while 循环。满足空闲则入与忙则等待。当 i 走出临界区后&#xff0c;flag[j] == false&#xff0c;j 不满足 while 条件&#xff0c;进入临界区。</p>\n<p>综合情况 1 与 2 以及 i 和 j 之间的对称性&#xff0c;Peterson算法正确</p>", "created": "2019-04-28T16:17:44Z", "bucket_order": 54, "bucket_name": "Week 4/28 - 5/4", "type": "followup", "tag_good": [], "uid": "jsjp7j7mu8BB", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "jv150nfzq852qp", "updated": "2019-04-28T16:17:44Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>第2小题</p>\n<p>通过枚举和分类验证Dekkers证明的正确性</p>\n<pre>flag[0] = false; flag[1] = false; turn = 0;<br /><br />do {<br />      \tflag[i] = true;\t<br />      \twhile ( flag[j] ) {   \t\t\t//&#xff08;0&#xff09;\t<br />\t\tif (turn != i) {\t<br />\t\t\tflag[i] = false;\t<br />\t\t\twhile ( turn != i);\t//&#xff08;1&#xff09;<br />\t\t\tflag[i] = true;<br />\t\t}<br />\t}\t<br />        CRITICAL SECTION<br />      \tflag[i] = false;<br />\tturn = j;<br />        REMAINDER SECTION<br />} while (true);</pre>\n<p>分类进行讨论</p>\n<p>1. 如果先写了flag[i]被写&#xff0c;flag[j]还未被写&#xff0c;但线程i已经运行到(0)处&#xff0c;那么线程i就能进入临界区&#xff0c;线程j只能等在(0)处的循环中。</p>\n<p>2. 如果flag[i], flag[j]都已经被写&#xff0c;turn为i时&#xff0c;当线程i进入(0)处循环时&#xff0c;会一直等在(0)处。而线程j进入循环后&#xff0c;由于turn != j&#xff0c;就会将flag[j]置为false后&#xff0c;等在(1)处循环。此时线程i就能够跳出(0)处循环</p>", "created": "2019-04-29T01:14:46Z", "bucket_order": 54, "bucket_name": "Week 4/28 - 5/4", "type": "followup", "tag_good": [], "uid": "jsiyf76cGzf9", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "jv1o79v19ah3r4", "updated": "2019-04-29T01:14:46Z", "config": {}}], "tag_good_arr": [], "id": "j1vlgaw2fk5565", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 20, "num_favorites": 1, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169057056, "default_anonymity": "no"}, "error": null, "aid": "kyv0fiu8vodc"}