{"result": {"folders": ["lab4"], "nr": 340, "data": {"embed_links": []}, "created": "2015-04-21T09:22:32Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"uid": "i72xyao1QhO", "anon": "no", "when": "2015-04-21T09:22:32Z", "data": "i8r3s6ayrch6b9", "type": "create"}, {"to": "i8r3s6av6dj6b8", "uid": "hs2swpdtr91gu", "anon": "no", "when": "2015-04-23T04:49:05Z", "data": "i8tow7jqnbr5eh", "type": "i_answer"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "i72xyao1QhO", "subject": "对于关中断的问题!", "created": "2015-04-21T09:22:32Z", "content": "<p>    对于lab4 (课堂练习中的代码, related_info/lab4)的进程调度,  估计关中断没什么作用, 因为这里面的调度都是主动调度(通过的调用schedule来实现), 没有牵扯到时钟里面的调度, 所以哪怕不关中断, 程序也能正常运行.</p>\n<p>    但是对于关中断的机制代码中连续多次关中断是有专门的意图还是误写?如下:</p>\n<p>在schedule中, 有一次关中断:</p>\n<p>&#96;&#96;&#96;</p>\n<p>    local_intr_save(intr_flag);</p>\n<p>&#96;&#96;&#96;</p>\n<p>然后, 准备运行下一个就绪进程时, 调用proc_run, 如下:</p>\n<p>&#96;&#96;&#96;</p>\n<p>    if (next != current) {<br />            proc_run(next);<br />    }</p>\n<p>&#96;&#96;&#96;</p>\n<p> 其实在proc_run中又有local_intr_save(intr_flag);操作, 这不是相当于多次进行同一个操作了?虽然没问题, 但我实在想不出其必要性!!</p>\n<p></p>\n<p></p>\n<p>另外, 对于前面关中断有个小困扰的地方, 在这里说说我的理解:</p>\n<p>       前面每次在调用进程切换schedule的时候;都会关中断, 然后切换到下一个进程的地方, 其实对于每次关中断都是主动的进程来说, 这是没有问题的, 或者简单来说, 上个进程的关中断可由下一个进程的开中断来平衡, 所以总的来说, 中断的处理是平衡的.</p>\n<p>       但是对于新建的进程来说, 所有环境本应该都是和父进程一模一样, 但是ucore中为了简化, 将子进程的函数栈帧做了更改, 如下:</p>\n<p>&#96;&#96;&#96;</p>\n<p>copy_thread(struct proc_struct *proc, uintptr_t esp, struct trapframe *tf) {<br />    proc-&gt;tf = (struct trapframe *)(proc-&gt;kstack &#43; KSTACKSIZE) - 1;<br />    *(proc-&gt;tf) = *tf;<br />    proc-&gt;tf-&gt;tf_regs.reg_eax = 0;<br />    proc-&gt;tf-&gt;tf_esp = esp;<br />    proc-&gt;tf-&gt;tf_eflags |= FL_IF;<br /><br />    proc-&gt;context.eip = (uintptr_t)forkret;<br />    proc-&gt;context.esp = (uintptr_t)(proc-&gt;tf);<br />}</p>\n<p>&#96;&#96;&#96;</p>\n<p>    对于函数的返回地址和堆栈都修改了, 当时还奇怪为什么只有两2个page来做父子进程的栈, 其实根本就没有拷贝父进程的堆栈, 在kernel_thread_entry处的处理如下:</p>\n<p>&#96;&#96;&#96;</p>\n<p>kernel_thread_entry:        # void kernel_thread(void)<br /><br />    pushl %edx              # push arg<br />    call *%ebx              # call fn<br /><br />    pushl %eax              # save the return value of fn(arg)<br />    call do_exit            # call do_exit to terminate current thread</p>\n<p>&#96;&#96;&#96;</p>\n<p>    也就是说, 只要执行完函数后就会退出, 所以完全不管父进程的中断的情况, 但是在初始化栈帧的时候, 强制的将中断打开, 如: proc-&gt;tf-&gt;tf_eflags |= FL_IF;</p>\n<p>     这个在外界没有关中断的情况下是没有问题的, 但是如果出现这种情况: 在关中断的情况下, 创建出一个进程, 并主动切换到该进程, 就相当于开了一次中断.(总感觉有问题, 但想不出什么好的例子来证明!!)</p>"}], "type": "question", "tags": ["lab4", "student"], "tag_good": [], "unique_views": 103, "children": [{"folders": [], "data": {"embed_links": []}, "children": [], "created": "2015-04-23T04:49:05Z", "bucket_order": 3, "tag_endorse": [], "bucket_name": "Today", "id": "i8tow7jlsgq5eg", "history": [{"anon": "no", "uid": "hs2swpdtr91gu", "subject": "", "created": "2015-04-23T04:49:05Z", "content": "<p>实验的代码中可能会存在一些冗余&#xff0c;但是主要是为了对操作系统的原理有一个具体的理解。从实现来说&#xff0c;调度需要关闭中断&#xff0c;同时proc_run被封装成了一个函数&#xff0c;仅考虑这个函数本身&#xff0c;它在执行过程中切换寄存器的操作也必须处于中断关闭的情况下。</p>\n<p>对于第二个问题&#xff0c;目前的实验代码中应该不会出现这种情况&#xff0c;因为只是在proc_init()中创建了新线程。</p>\n<p></p>"}], "type": "i_answer", "tag_endorse_arr": [], "config": {}, "is_tag_endorse": false}], "tag_good_arr": [], "no_answer": 0, "id": "i8r3s6av6dj6b8", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 3, "num_favorites": 0, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643167652435, "default_anonymity": "no"}, "error": null, "aid": "kyuzlf0z82n3v1"}