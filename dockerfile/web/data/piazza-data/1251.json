{"result": {"folders": ["lab5"], "nr": 1251, "data": {"embed_links": []}, "created": "2018-10-17T02:56:07Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "jl3wcjkdpaRA", "data": "jnckech1aki1bh", "type": "create", "when": "2018-10-17T02:56:07Z"}, {"anon": "no", "uid": "jl3wcjkdpaRA", "data": "jncl1fku4k01gk", "to": "jnckecgyqp31bg", "type": "s_answer", "when": "2018-10-17T03:14:04Z"}, {"anon": "no", "uid": "jl3wcjkdpaRA", "data": "jncl2mbidcc2hs", "type": "update", "when": "2018-10-17T03:14:59Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "jl3wcjkdpaRA", "subject": "lab5有一个关于current-&gt;tf的疑问", "created": "2018-10-17T03:14:59Z", "content": "<p>在lab5中&#xff0c;user_main 是通过产生SYS_exec系统调用来创建新的用户进程的&#xff0c;但是有一个疑问&#xff1a;</p>\n<pre>asm volatile (\n        &#34;int %1;&#34;\n        : &#34;=a&#34; (ret)\n        : &#34;i&#34; (T_SYSCALL), &#34;0&#34; (SYS_exec), &#34;d&#34; (name), &#34;c&#34; (len), &#34;b&#34; (binary), &#34;D&#34; (size)\n        : &#34;memory&#34;);</pre>\n<p>这里把name&#xff0c;len&#xff0c;binary这些参数都通过寄存器保存&#xff0c;然后压入栈中产生trapframe结构&#xff0c;然后在trap_dispatch里执行syscall() 我的疑问就是syscall()里获取这些参数为什么是通过current-&gt;tf结构体呢&#xff1f;</p>\n<p>如果是用户态-&gt;内核态&#xff0c;那么因为使用内核栈&#xff0c;current-&gt;tf是始终指向正确的trapframe的</p>\n<p>但是现在是内核态-&gt;内核态&#xff0c;user_main进程是内核线程&#xff0c;此时current-&gt;tf始终应该指向内核栈的存放trapframe的高地址处&#xff0c;但是执行syscall系统调用时&#xff0c;是直接在内核栈上把必须的寄存器压栈形成trapframe结构的&#xff0c;所以说感觉不能通过current-&gt;tf来获取这些寄存器&#xff0c;即系统调用的参数值&#xff0c;而应该使用trap_dispatch的参数tf&#xff0c;让我惊讶的是&#xff0c;在trap_dispatch中输出current-&gt;tf 和 参数tf&#xff0c;发现他们是一个地址&#xff1f;&#xff1f;也就是说current-&gt;tf在进入中断处理的过程中被修改了&#xff1f;&#xff1f;</p>\n<p>那么为什么current-&gt;tf 会被修改呢&#xff1f;按照我的理解它应该是一直指向内核栈的高位地址的trapframe结构体的&#xff1f;</p>\n<p><img src=\"/img/1251-daaea136c402089c.jpg\" alt=\"\" /></p>"}, {"anon": "no", "uid": "jl3wcjkdpaRA", "subject": "lab5有一个关于current-&gt;tf的疑问", "created": "2018-10-17T02:56:07Z", "content": "<p>在lab5中&#xff0c;user_main 是通过产生SYS_exec系统调用来创建新的用户进程的&#xff0c;但是有一个疑问&#xff1a;</p>\n<pre>asm volatile (\n        &#34;int %1;&#34;\n        : &#34;=a&#34; (ret)\n        : &#34;i&#34; (T_SYSCALL), &#34;0&#34; (SYS_exec), &#34;d&#34; (name), &#34;c&#34; (len), &#34;b&#34; (binary), &#34;D&#34; (size)\n        : &#34;memory&#34;);</pre>\n<p>这里把name&#xff0c;len&#xff0c;binary这些参数都通过寄存器保存&#xff0c;然后压入栈中产生trapframe结构&#xff0c;然后在trap_dispatch里执行syscall() 我的疑问就是syscall()里获取这些参数为什么是通过current-&gt;tf结构体呢&#xff1f;</p>\n<p>如果是用户态-&gt;内核态&#xff0c;那么因为使用内核栈&#xff0c;current-&gt;tf是始终指向正确的trapframe的</p>\n<p>但是现在是内核态-&gt;内核态&#xff0c;user_main进程是内核线程&#xff0c;此时current-&gt;tf始终应该指向内核栈的存放trapframe的高地址处&#xff0c;但是执行syscall系统调用时&#xff0c;是直接在内核栈上把必须的寄存器压栈形成trapframe结构的&#xff0c;所以说感觉不能通过current-&gt;tf来获取这些寄存器&#xff0c;即系统调用的参数值&#xff0c;而应该使用trap_dispatch的参数tf&#xff0c;让我惊讶的是&#xff0c;在trap_dispatch中输出current-&gt;tf 和 参数tf&#xff0c;发现他们是一个地址&#xff1f;&#xff1f;也就是说current-&gt;tf在进入中断处理的过程中被修改了&#xff1f;&#xff1f;</p>\n<p>那么为什么current-&gt;tf 会被修改呢&#xff1f;按照我的理解它应该是一直指向内核栈的高位地址的trapframe结构体的&#xff1f;</p>\n<p><img src=\"/img/1251-daaea136c402089c.jpg\" alt=\"\" /></p>"}], "type": "note", "tags": ["lab5", "student"], "tag_good": [], "unique_views": 109, "children": [{"folders": [], "data": {"embed_links": []}, "children": [], "created": "2018-10-17T03:14:04Z", "bucket_order": 3, "tag_endorse": [], "bucket_name": "Today", "id": "jncl1fkm4091gj", "history": [{"anon": "no", "uid": "jl3wcjkdpaRA", "subject": "", "created": "2018-10-17T03:14:04Z", "content": "<p>我漏看trap了。。trap函数不是一开始的trap函数了&#xff0c;5555555感觉时间都被浪费了。</p>\n<p>trap中改变了current-&gt;tf</p>"}], "type": "s_answer", "tag_endorse_arr": [], "config": {}}], "tag_good_arr": [], "id": "jnckecgyqp31bg", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 2, "num_favorites": 1, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169511195, "default_anonymity": "no"}, "error": null, "aid": "kyv0p997mz51nx"}