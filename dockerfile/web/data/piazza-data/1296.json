{"result": {"history_size": 12, "folders": ["lecture9", "课堂问答"], "nr": 1296, "data": {"embed_links": []}, "created": "2019-03-26T16:41:54Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "jspklr3s9oOe", "data": "jtq0clt6fnr715", "type": "create", "when": "2019-03-26T16:41:54Z"}, {"anon": "no", "uid": "jspklr3s9oOe", "data": "jtq0d6qhanq7jm", "type": "update", "when": "2019-03-26T16:42:21Z"}, {"anon": "no", "uid": "jspklr3s9oOe", "data": "jtq0gj6lwz332n", "type": "update", "when": "2019-03-26T16:44:57Z"}, {"anon": "no", "uid": "jspklr3s9oOe", "data": "jtq0grens5f38q", "type": "update", "when": "2019-03-26T16:45:08Z"}, {"anon": "no", "uid": "jspklr3s9oOe", "data": "jtq0j5eim8t5dw", "type": "update", "when": "2019-03-26T16:46:59Z"}, {"anon": "no", "uid": "jspklr3s9oOe", "data": "jtq0m9ex43114p", "type": "update", "when": "2019-03-26T16:49:24Z"}, {"anon": "no", "uid": "jspklr3s9oOe", "data": "jtq0ngmyv4l2yh", "type": "update", "when": "2019-03-26T16:50:20Z"}, {"anon": "no", "uid": "jspklr3s9oOe", "data": "jtq0o0zj2bc3dc", "type": "update", "when": "2019-03-26T16:50:47Z"}, {"anon": "no", "uid": "jspklr3s9oOe", "data": "jtq0oqcdkoe3w8", "type": "update", "when": "2019-03-26T16:51:20Z"}, {"anon": "no", "uid": "jspklr3s9oOe", "data": "jtq0pb5fyyv4sm", "type": "update", "when": "2019-03-26T16:51:46Z"}, {"anon": "no", "uid": "jspklr3s9oOe", "data": "jtq0pozax9k59i", "type": "update", "when": "2019-03-26T16:52:04Z"}, {"anon": "no", "uid": "jspklr3s9oOe", "data": "jtqoihsbb574by", "type": "update", "when": "2019-03-27T03:58:19Z"}, {"anon": "no", "uid": "jspklr3s9oOe", "data": "jtqvmkgxzp039", "to": "jtq0clt4a48714", "type": "s_answer", "when": "2019-03-27T07:17:27Z"}, {"anon": "no", "uid": "jsiyf76cGzf9", "to": "jtq0clt4a48714", "type": "followup", "when": "2019-03-28T00:43:07Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "jspklr3s9oOe", "subject": "OPT算法正确性的证明", "created": "2019-03-27T03:58:19Z", "content": "<h3>OPT算法正确性的证明</h3>\n在第九讲页面置换算法中介绍了许多种不同的页面置换算法&#xff0c;其中OPT算法即最优算法是说&#xff0c;当我们给出访存序列之后&#xff0c;使用贪心的置换下一次访存最晚的页面总是最优的。但查阅网上资料后并没有给出比较严谨的证明。我们给出了一个使用调整法的证明&#xff0c;其说明了在第一次发生缺页和换出时&#xff0c;将换出的页面调整为下一次引用更晚的&#xff0c;总是可以构造出换出方案&#xff0c;使得缺页次数不多于原先的方案。\n由于水平&amp;时间有限&#xff0c;证明可能出现漏洞和错误&#xff0c;欢迎大家指出。\n定义$$Miss(A)$$表示某个时刻内存状态为$$A$$&#xff0c;在处理之后访存序列时最小的缺页次数。先证明一个引理&#xff1a;如果内存状态$$A,B$$仅有一页不同&#xff0c;那么$$Miss(A)\\ge Miss(B)-1$$。\n<strong>证明</strong>&#xff1a;考虑对访存序列长度做归纳。\n<ul><li>当$$len=1$$时是显然的。\n</li><li>假设$$len=n$$时成立&#xff0c;我们只需证明$$len=n&#43;1$$时成立。设$$A=[other, a], B = [other, b]$$&#xff0c;考虑第一次访存的情况&#xff1a;\n<ol><li>访问$$other$$中的内容&#xff0c;$$A,B$$均命中&#xff0c;根据归纳假设显然。</li><li>访问$$a$$&#xff0c;$$A$$命中&#xff0c;$$B$$发生缺页&#xff0c;我们可以将$$B$$中$$b$$换出&#xff0c;$$a$$换入&#xff0c;$$A,B$$在这次访存之后相同$$Miss(A&#39;)=Miss(B&#39;)$$&#xff0c;那么有$$Miss(A)\\ge Miss(B)&#43;1$$。</li><li>访问$$b$$&#xff0c;$$A$$出现缺页&#xff0c;$$B$$命中。设$$A$$换出了一页$$p$$并将$$b$$换入&#xff0c;那么这次缺页之后$$A, B$$仅有一页不同&#xff1a;$$A&#39;=[other-{p}, a, b], B &#39;= [other, b]$$&#xff0c;根据归纳假设也可以说明这一点。</li></ol>\n</li></ul>\n现在我们证明&#xff0c;OPT算法总是正确的。对访存序列的长度做归纳。我们假设$$nextpos(a)$$表示块下一次被访问的位置&#xff0c;$$len$$表示访存序列长度。\n<ul><li>当$$len=1$$时是显然的。\n</li><li>假设$$len=n$$时成立&#xff0c;我们只需证明$$len=n&#43;1$$时成立。考虑第一次访存的情况&#xff1a;\n<ol><li>未缺页&#xff0c;不发生换入换出&#xff0c;根据归纳假设显然。\n</li><li>发生缺页&#xff0c;设当前内存状态为$$A$$。若我们没有按照OPT算法将下一次访问最晚的页面换出&#xff0c;而是换出了另外一个页面$$a$$&#xff0c;则必有$$b\\in A$$&#xff0c;满足$$nextpos(a)&lt;nextpos(b)$$。我们只需说明这次如果换出$$b$$&#xff0c;答案不会更劣。\n考虑在原先的方案中$$b$$在什么时候被换出。\n<ol><li>$$b$$在$$nextpos(a)$$之前被换出&#xff0c;如果我们第一次换出的是$$b$$&#xff0c;那么只会简单的将内存中的$$b$$替换成$$a$$&#xff0c;并不会引起任何缺页或命中的变化。</li><li>$$b​$$在$$nextpos(a)​$$时被换出&#xff0c;$$a​$$被换入&#xff0c;内存状态$$A[other, b]\\to A&#39;[other, a]​$$。如果我们第一次换出的是$$b​$$&#xff0c;在$$nextpos(a) ​$$之前的缺页和命中并没有任何变化&#xff0c;而$$nextpos(a)​$$时并不会发生缺页&#xff0c;且此时内存状态也为$$A&#39;​$$。因此调整后总的缺页次数严格小于之前。</li><li>$$b$$在$$nextpos(a)$$之后被换出。考虑在$$nextpos(a)$$时发生了一次缺页且没有换出$$b$$&#xff0c;内存状态$$A[other, b]\\to A&#39;[other-\\{p\\}, b, a]$$。而如果我们一开始换出的是$$b$$&#xff0c;这一次没有发生缺页&#xff0c;且内存状态是$$B[other, a]$$。注意到$$A&#39;$$和$$B$$只有一位不同&#xff0c;根据之前的引理&#xff0c;有$$Miss(A&#39;)\\ge Miss(B)-1$$。而在第$$nextpos(a)$$次我们减少了一次缺页&#xff0c;因此总的缺页数&#xff1a;$$Miss(Before)\\ge (Miss(After)-1)&#43;1=Miss(After)$$ </li></ol>\n</li></ol>\n</li></ul>\n在查阅其他资料后&#xff0c;我仍然有两个暂时未解决问题&#xff1a;\n<ul><li>在belady的原始论文 <a href=\"http://users.informatik.uni-halle.de/~hinnebur/Lehre/Web_DBIIb/uebung3_belady_opt_buffer.pdf\" target=\"_blank\">http://users.informatik.uni-halle.de/~hinnebur/Lehre/Web_DBIIb/uebung3_belady_opt_buffer.pdf</a> 中&#xff0c;关于最优算法<code>MIN</code>算法的描述似乎和现在的OPT不同&#xff0c;为何这里说明了<code>MIN</code>算法而不是更简单的OPT算法&#xff1f;</li><li>在论文中说&#xff0c;通过维护写标记并简单修改算法&#xff0c;可以使得<code>push &#43; pull</code>&#xff08;即换入换出的总次数&#xff09;最小化&#xff0c;而不是缺页次数最小化。显然&#xff0c;前者更符合实际&#xff08;事实上<code>pull &#43; c * pull</code>应当更符合&#xff0c;还不知道有没有对应的算法&#xff09;。但是我们的课程中并没有提到类似的问题。且论文中也没有给出这种算法正确性的证明。</li></ul>"}, {"anon": "no", "uid": "jspklr3s9oOe", "subject": "OPT算法正确性的证明", "created": "2019-03-26T16:52:04Z", "content": "<h3>OPT算法正确性的证明</h3>\n在第九讲页面置换算法中介绍了许多种不同的页面置换算法&#xff0c;其中OPT算法即最优算法是说&#xff0c;当我们给出访存序列之后&#xff0c;使用贪心的置换下一次访存最晚的页面总是最优的。但查阅网上资料后并没有给出比较严谨的证明。我们给出了一个使用调整法的证明&#xff0c;其说明了在第一次发生缺页和换出时&#xff0c;将换出的页面调整为下一次引用更晚的&#xff0c;总是可以构造出换出方案&#xff0c;使得缺页次数不多于原先的方案。\n由于水平&amp;时间有限&#xff0c;证明可能出现漏洞和错误&#xff0c;欢迎大家指出。\n定义$$Miss(A)$$表示某个时刻内存状态为$$A$$&#xff0c;在处理之后访存序列时最小的缺页次数。先证明一个引理&#xff1a;如果内存状态$$A,B$$仅有一页不同&#xff0c;那么$$Miss(A)\\ge Miss(B)-1$$。\n<strong>证明</strong>&#xff1a;考虑对访存序列长度做归纳。\n<ul><li>当$$len=1$$时是显然的。\n</li><li>假设$$len=n$$时成立&#xff0c;我们只需证明$$len=n&#43;1$$时成立。设$$A=[other, a], B = [other, b]$$&#xff0c;考虑第一次访存的情况&#xff1a;\n<ol><li>访问$$other$$中的内容&#xff0c;$$A,B$$均命中&#xff0c;根据归纳假设显然。</li><li>访问$$a$$&#xff0c;$$A$$命中&#xff0c;$$B$$发生缺页&#xff0c;我们可以将$$B$$中$$b$$换出&#xff0c;$$a$$换入&#xff0c;$$A,B$$在这次访存之后相同$$Miss(A&#39;)=Miss(B&#39;)$$&#xff0c;那么有$$Miss(A)\\ge Miss(B)&#43;1$$。</li><li>访问$$b$$&#xff0c;$$A$$出现缺页&#xff0c;$$B$$命中。设$$A$$换出了一页$$p$$并将$$b$$换入&#xff0c;那么这次缺页之后$$A, B$$仅有一页不同&#xff1a;$$A&#39;=[other-{p}, a, b], B &#39;= [other, b]$$&#xff0c;根据归纳假设也可以说明这一点。</li></ol>\n</li></ul>\n现在我们证明&#xff0c;OPT算法总是正确的。对访存序列的长度做归纳。我们假设$$nextpos(a)$$表示块下一次被访问的位置&#xff0c;$$len$$表示访存序列长度。\n<ul><li>当$$len=1$$时是显然的。\n</li><li>假设$$len=n$$时成立&#xff0c;我们只需证明$$len=n&#43;1$$时成立。考虑第一次访存的情况&#xff1a;\n<ol><li>未缺页&#xff0c;不发生换入换出&#xff0c;根据归纳假设显然。\n</li><li>发生缺页&#xff0c;设当前内存状态为$$A$$。若我们没有按照OPT算法将下一次访问最晚的页面换出&#xff0c;而是换出了另外一个页面$$a$$&#xff0c;则必有$$b\\in A$$&#xff0c;满足$$nextpos(a)&lt;nextpos(b)$$。我们只需说明这次如果换出$$b$$&#xff0c;答案不会更劣。\n考虑在原先的方案中$$b$$在什么时候被换出。\n<ol><li>$$b$$在$$nextpos(a)$$之前被换出&#xff0c;如果我们第一次换出的是$$b$$&#xff0c;那么只会简单的将内存中的$$b$$替换成$$a$$&#xff0c;并不会引起任何缺页或命中的变化。</li><li>$$b​$$在$$nextpos(a)​$$时被换出&#xff0c;$$a​$$被换入&#xff0c;内存状态$$A[other, b]\\to A&#39;[other, a]​$$。如果我们第一次换出的是$$b​$$&#xff0c;在$$nextpos(a) ​$$之前的缺页和命中并没有任何变化&#xff0c;而$$nextpos(a)​$$时并不会发生缺页&#xff0c;且此时内存状态也为$$A&#39;​$$。因此调整后总的缺页次数严格小于之前。</li><li>$$b$$在$$nextpos(a)$$之后被换出。考虑在$$nextpos(a)$$时发生了一次缺页且没有换出$$b$$&#xff0c;内存状态$$A[other, b]\\to A&#39;[other-\\{p\\}, b, a]$$。而如果我们一开始换出的是$$b$$&#xff0c;这一次没有发生缺页&#xff0c;且内存状态是$$B[other, a]$$。注意到$$A&#39;$$和$$B$$只有一位不同&#xff0c;根据之前的引理&#xff0c;有$$Miss(A&#39;)\\ge Miss(B)-1$$。而在第$$nextpos(a)$$次我们减少了一次缺页&#xff0c;因此总的缺页数&#xff1a;$$Miss(Before)\\ge (Miss(After)-1)&#43;1=Miss(After)$$ </li></ol>\n</li></ol>\n</li></ul>\n在查阅其他资料后&#xff0c;我仍然有两个暂时未解决问题&#xff1a;\n<ul><li>在belady的原始论文 <a href=\"http://users.informatik.uni-halle.de/~hinnebur/Lehre/Web_DBIIb/uebung3_belady_opt_buffer.pdf\" target=\"_blank\">http://users.informatik.uni-halle.de/~hinnebur/Lehre/Web_DBIIb/uebung3_belady_opt_buffer.pdf</a> 中&#xff0c;关于最优算法<code>MIN</code>算法的描述似乎和现在的OPT不同&#xff0c;为何这里说明了<code>MIN</code>算法而不是更简单的OPT算法&#xff1f;</li><li>在论文中说&#xff0c;通过维护写标记并简单修改算法&#xff0c;可以使得<code>push &#43; pull</code>&#xff08;即换入换出的总次数&#xff09;最小化&#xff0c;而不是缺页次数最小化。显然&#xff0c;前者更符合实际&#xff08;事实上<code>pull &#43; c * pull</code>应当更符合&#xff0c;还不知道有没有对应的算法&#xff09;。但是我们的课程中并没有提到类似的问题。且论文中也没有给出这种算法正确性的证明。</li></ul>"}, {"anon": "no", "uid": "jspklr3s9oOe", "subject": "OPT算法正确性的证明", "created": "2019-03-26T16:51:46Z", "content": "<h2>OPT算法的一个证明</h2>\n<p>给定一个访问内存的$$a_1, a_2, \\dots, a_n$$&#xff0c;$$a_i\\le MaxPage$$&#xff0c;物理内存的大小为$$M$$。OPT算法能够使得缺页次数最少。</p>\n<h3>OPT算法缺页次数</h3>\n<p>OPT算法的第$$i$$次访存发生缺页&#xff0c;那么这是$$a_i$$的第一次访问&#xff0c;或者上一次访问到这次访问之间&#xff0c;访问不同页的数量$$\\ge M$$。</p>\n<p>证明&#xff1a;&#xff08;$$\\Rightarrow$$&#xff09;假设某一次访存操作$$a_i$$发生缺页&#xff0c;且这不是$$a_i$$的第一次访问&#xff0c;记上一次访问是$$a_j=a_i$$。那么一定存在某个$$j&lt;k&lt;i$$&#xff0c;满足$$a_k$$时发生了缺页&#xff0c;且将$$a_i$$这一页置换了出去。根据OPT算法的定义&#xff0c;$$a_i$$一定是当前所有在物理内存中下一次访问最晚的。换言之&#xff0c;在换入$$a_k$$之前内存中除$$a_i$$外的$$M-1$$个的下一次访问时间均早于$$i$$&#xff0c;也即有$$M-1$$个不同的访存发生在$$(j, i)$$之间&#xff0c;再加上$$a_k$$这次访存&#xff08;由于发生了缺页&#xff0c;其不与这$$M-1$$个内存中已有的页相同&#xff09;&#xff0c;有至少$$M$$个不同的访存发生在$$(j, i)$$之间。</p>\n<h3>OPT算法正确性的证明</h3>\n<p>在第九讲页面置换算法中介绍了许多种不同的页面置换算法&#xff0c;其中OPT算法即最优算法是说&#xff0c;当我们给出访存序列之后&#xff0c;使用贪心的置换下一次访存最晚的页面总是最优的。但查阅网上资料后并没有给出比较严谨的证明。我们给出了一个使用调整法的证明&#xff0c;其说明了在第一次发生缺页和换出时&#xff0c;将换出的页面调整为下一次引用更晚的&#xff0c;总是可以构造出换出方案&#xff0c;使得缺页次数不多于原先的方案。</p>\n<p>由于水平&amp;时间有限&#xff0c;证明可能出现漏洞和错误&#xff0c;欢迎大家指出。</p>\n<p>定义$$Miss(A)$$表示某个时刻内存状态为$$A$$&#xff0c;在处理之后访存序列时最小的缺页次数。先证明一个引理&#xff1a;如果内存状态$$A,B$$仅有一页不同&#xff0c;那么$$Miss(A)\\ge Miss(B)-1$$。</p>\n<p><strong>证明</strong>&#xff1a;考虑对访存序列长度做归纳。</p>\n<ul><li><p>当$$len=1$$时是显然的。</p>\n</li><li><p>假设$$len=n$$时成立&#xff0c;我们只需证明$$len=n&#43;1$$时成立。设$$A=[other, a], B = [other, b]$$&#xff0c;考虑第一次访存的情况&#xff1a;</p>\n<ol><li>访问$$other$$中的内容&#xff0c;$$A,B$$均命中&#xff0c;根据归纳假设显然。</li><li>访问$$a$$&#xff0c;$$A$$命中&#xff0c;$$B$$发生缺页&#xff0c;我们可以将$$B$$中$$b$$换出&#xff0c;$$a$$换入&#xff0c;$$A,B$$在这次访存之后相同$$Miss(A&#39;)=Miss(B&#39;)$$&#xff0c;那么有$$Miss(A)\\ge Miss(B)&#43;1$$。</li><li>访问$$b$$&#xff0c;$$A$$出现缺页&#xff0c;$$B$$命中。设$$A$$换出了一页$$p$$并将$$b$$换入&#xff0c;那么这次缺页之后$$A, B$$仅有一页不同&#xff1a;$$A&#39;=[other-{p}, a, b], B &#39;= [other, b]$$&#xff0c;根据归纳假设也可以说明这一点。</li></ol>\n</li></ul>\n<p>现在我们证明&#xff0c;OPT算法总是正确的。对访存序列的长度做归纳。我们假设$$nextpos(a)$$表示块下一次被访问的位置&#xff0c;$$len$$表示访存序列长度。</p>\n<ul><li><p>当$$len=1$$时是显然的。</p>\n</li><li><p>假设$$len=n$$时成立&#xff0c;我们只需证明$$len=n&#43;1$$时成立。考虑第一次访存的情况&#xff1a;</p>\n<ol><li><p>未缺页&#xff0c;不发生换入换出&#xff0c;根据归纳假设显然。</p>\n</li><li><p>发生缺页&#xff0c;设当前内存状态为$$A$$。若我们没有按照OPT算法将下一次访问最晚的页面换出&#xff0c;而是换出了另外一个页面$$a$$&#xff0c;则必有$$b\\in A$$&#xff0c;满足$$nextpos(a)&lt;nextpos(b)$$。我们只需说明这次如果换出$$b$$&#xff0c;答案不会更劣。</p>\n<p>考虑在原先的方案中$$b$$在什么时候被换出。</p>\n<ol><li>$$b$$在$$nextpos(a)$$之前被换出&#xff0c;如果我们第一次换出的是$$b$$&#xff0c;那么只会简单的将内存中的$$b$$替换成$$a$$&#xff0c;并不会引起任何缺页或命中的变化。</li><li>$$b​$$在$$nextpos(a)​$$时被换出&#xff0c;$$a​$$被换入&#xff0c;内存状态$$A[other, b]\\to A&#39;[other, a]​$$。如果我们第一次换出的是$$b​$$&#xff0c;在$$nextpos(a) ​$$之前的缺页和命中并没有任何变化&#xff0c;而$$nextpos(a)​$$时并不会发生缺页&#xff0c;且此时内存状态也为$$A&#39;​$$。因此调整后总的缺页次数严格小于之前。</li><li>$$b$$在$$nextpos(a)$$之后被换出。考虑在$$nextpos(a)$$时发生了一次缺页且没有换出$$b$$&#xff0c;内存状态$$A[other, b]\\to A&#39;[other-\\{p\\}, b, a]$$。而如果我们一开始换出的是$$b$$&#xff0c;这一次没有发生缺页&#xff0c;且内存状态是$$B[other, a]$$。注意到$$A&#39;$$和$$B$$只有一位不同&#xff0c;根据之前的引理&#xff0c;有$$Miss(A&#39;)\\ge Miss(B)-1$$。而在第$$nextpos(a)$$次我们减少了一次缺页&#xff0c;因此总的缺页数&#xff1a;$$Miss(Before)\\ge (Miss(After)-1)&#43;1=Miss(After)$$ </li></ol>\n</li></ol>\n</li></ul>\n<p>在查阅其他资料后&#xff0c;我仍然有两个暂时未解决问题&#xff1a;</p>\n<ul><li>在belady的原始论文 <a href=\"http://users.informatik.uni-halle.de/~hinnebur/Lehre/Web_DBIIb/uebung3_belady_opt_buffer.pdf\" target=\"_blank\">http://users.informatik.uni-halle.de/~hinnebur/Lehre/Web_DBIIb/uebung3_belady_opt_buffer.pdf</a> 中&#xff0c;关于最优算法<code>MIN</code>算法的描述似乎和现在的OPT不同&#xff0c;为何这里说明了<code>MIN</code>算法而不是更简单的OPT算法&#xff1f;</li><li>在论文中说&#xff0c;通过维护写标记并简单修改算法&#xff0c;可以使得<code>push &#43; pull</code>&#xff08;即换入换出的总次数&#xff09;最小化&#xff0c;而不是缺页次数最小化。显然&#xff0c;前者更符合实际&#xff08;事实上<code>pull &#43; c * pull</code>应当更符合&#xff0c;还不知道有没有对应的算法&#xff09;。但是我们的课程中并没有提到类似的问题。且论文中也没有给出这种算法正确性的证明。</li></ul>\n<p> </p>"}, {"anon": "no", "uid": "jspklr3s9oOe", "subject": "OPT算法正确性的证明", "created": "2019-03-26T16:51:20Z", "content": "<h3>OPT算法正确性的证明</h3>\n在第九讲页面置换算法中介绍了许多种不同的页面置换算法&#xff0c;其中OPT算法即最优算法是说&#xff0c;当我们给出访存序列之后&#xff0c;使用贪心的置换下一次访存最晚的页面总是最优的。但查阅网上资料后并没有给出比较严谨的证明。我们给出了一个使用调整法的证明&#xff0c;其说明了在第一次发生缺页和换出时&#xff0c;将换出的页面调整为下一次引用更晚的&#xff0c;总是可以构造出换出方案&#xff0c;使得缺页次数不多于原先的方案。\n由于水平&amp;时间有限&#xff0c;证明可能出现漏洞和错误&#xff0c;欢迎大家指出。\n定义$$Miss(A)$$表示某个时刻内存状态为$A$&#xff0c;在处理之后访存序列时最小的缺页次数。先证明一个引理&#xff1a;如果内存状态$A,B$仅有一页不同&#xff0c;那么$Miss(A)\\ge Miss(B)-1$。\n<strong>证明</strong>&#xff1a;考虑对访存序列长度做归纳。\n<ul><li>当$len=1$时是显然的。\n</li><li>假设$len=n$时成立&#xff0c;我们只需证明$len=n&#43;1$时成立。设$A=[other, a], B = [other, b]$&#xff0c;考虑第一次访存的情况&#xff1a;\n<ol><li>访问$other$中的内容&#xff0c;$A,B$均命中&#xff0c;根据归纳假设显然。</li><li>访问$a$&#xff0c;$A$命中&#xff0c;$B$发生缺页&#xff0c;我们可以将$B$中$b$换出&#xff0c;$a$换入&#xff0c;$A,B$在这次访存之后相同$Miss(A&#39;)=Miss(B&#39;)$&#xff0c;那么有$Miss(A)\\ge Miss(B)&#43;1$。</li><li>访问$b$&#xff0c;$A$出现缺页&#xff0c;$B$命中。设$A$换出了一页$p$并将$b$换入&#xff0c;那么这次缺页之后$A, B$仅有一页不同&#xff1a;$A&#39;=[other-{p}, a, b], B &#39;= [other, b]$&#xff0c;根据归纳假设也可以说明这一点。</li></ol>\n</li></ul>\n现在我们证明&#xff0c;OPT算法总是正确的。对访存序列的长度做归纳。我们假设$nextpos(a)$表示块下一次被访问的位置&#xff0c;$len$表示访存序列长度。\n<ul><li>当$len=1$时是显然的。\n</li><li>假设$len=n$时成立&#xff0c;我们只需证明$len=n&#43;1$时成立。考虑第一次访存的情况&#xff1a;\n<ol><li>未缺页&#xff0c;不发生换入换出&#xff0c;根据归纳假设显然。\n</li><li>发生缺页&#xff0c;设当前内存状态为$A$。若我们没有按照OPT算法将下一次访问最晚的页面换出&#xff0c;而是换出了另外一个页面$a$&#xff0c;则必有$b\\in A$&#xff0c;满足$nextpos(a)\n\n考虑在原先的方案中$b$在什么时候被换出。\n<ol><li>$b$在$nextpos(a)$之前被换出&#xff0c;如果我们第一次换出的是$b$&#xff0c;那么只会简单的将内存中的$b$替换成$a$&#xff0c;并不会引起任何缺页或命中的变化。</li><li>$b​$在$nextpos(a)​$时被换出&#xff0c;$a​$被换入&#xff0c;内存状态$A[other, b]\\to A&#39;[other, a]​$。如果我们第一次换出的是$b​$&#xff0c;在$nextpos(a) ​$之前的缺页和命中并没有任何变化&#xff0c;而$nextpos(a)​$时并不会发生缺页&#xff0c;且此时内存状态也为$A&#39;​$。因此调整后总的缺页次数严格小于之前。</li><li>$b$在$nextpos(a)$之后被换出。考虑在$nextpos(a)$时发生了一次缺页且没有换出$b$&#xff0c;内存状态$A[other, b]\\to A&#39;[other-\\{p\\}, b, a]$。而如果我们一开始换出的是$b$&#xff0c;这一次没有发生缺页&#xff0c;且内存状态是$B[other, a]$。注意到$A&#39;$和$B$只有一位不同&#xff0c;根据之前的引理&#xff0c;有$Miss(A&#39;)\\ge Miss(B)-1$。而在第$nextpos(a)$次我们减少了一次缺页&#xff0c;因此总的缺页数&#xff1a;$Miss(Before)\\ge (Miss(After)-1)&#43;1=Miss(After)$ </li></ol>\n</li></ol>\n</li></ul>\n在查阅其他资料后&#xff0c;我仍然有两个暂时未解决问题&#xff1a;\n<ul><li>在belady的原始论文 <a href=\"http://users.informatik.uni-halle.de/~hinnebur/Lehre/Web_DBIIb/uebung3_belady_opt_buffer.pdf\" target=\"_blank\">http://users.informatik.uni-halle.de/~hinnebur/Lehre/Web_DBIIb/uebung3_belady_opt_buffer.pdf</a> 中&#xff0c;关于最优算法<code>MIN</code>算法的描述似乎和现在的OPT不同&#xff0c;为何这里说明了<code>MIN</code>算法而不是更简单的OPT算法&#xff1f;</li><li>在论文中说&#xff0c;通过维护写标记并简单修改算法&#xff0c;可以使得<code>push &#43; pull</code>&#xff08;即换入换出的总次数&#xff09;最小化&#xff0c;而不是缺页次数最小化。显然&#xff0c;前者更符合实际&#xff08;事实上<code>pull &#43; c * pull</code>应当更符合&#xff0c;还不知道有没有对应的算法&#xff09;。但是我们的课程中并没有提到类似的问题。且论文中也没有给出这种算法正确性的证明。</li></ul>"}, {"anon": "no", "uid": "jspklr3s9oOe", "subject": "OPT算法正确性的证明", "created": "2019-03-26T16:50:47Z", "content": "<h3>OPT算法正确性的证明</h3>\n在第九讲页面置换算法中介绍了许多种不同的页面置换算法&#xff0c;其中OPT算法即最优算法是说&#xff0c;当我们给出访存序列之后&#xff0c;使用贪心的置换下一次访存最晚的页面总是最优的。但查阅网上资料后并没有给出比较严谨的证明。我们给出了一个使用调整法的证明&#xff0c;其说明了在第一次发生缺页和换出时&#xff0c;将换出的页面调整为下一次引用更晚的&#xff0c;总是可以构造出换出方案&#xff0c;使得缺页次数不多于原先的方案。\n由于水平&amp;时间有限&#xff0c;证明可能出现漏洞和错误&#xff0c;欢迎大家指出。\n定义$Miss(A)$表示某个时刻内存状态为$A$&#xff0c;在处理之后访存序列时最小的缺页次数。先证明一个引理&#xff1a;如果内存状态$A,B$仅有一页不同&#xff0c;那么$Miss(A)\\ge Miss(B)-1$。\n<strong>证明</strong>&#xff1a;考虑对访存序列长度做归纳。\n<ul><li>当$len=1$时是显然的。\n</li><li>假设$len=n$时成立&#xff0c;我们只需证明$len=n&#43;1$时成立。设$A=[other, a], B = [other, b]$&#xff0c;考虑第一次访存的情况&#xff1a;\n<ol><li>访问$other$中的内容&#xff0c;$A,B$均命中&#xff0c;根据归纳假设显然。</li><li>访问$a$&#xff0c;$A$命中&#xff0c;$B$发生缺页&#xff0c;我们可以将$B$中$b$换出&#xff0c;$a$换入&#xff0c;$A,B$在这次访存之后相同$Miss(A&#39;)=Miss(B&#39;)$&#xff0c;那么有$Miss(A)\\ge Miss(B)&#43;1$。</li><li>访问$b$&#xff0c;$A$出现缺页&#xff0c;$B$命中。设$A$换出了一页$p$并将$b$换入&#xff0c;那么这次缺页之后$A, B$仅有一页不同&#xff1a;$A&#39;=[other-{p}, a, b], B &#39;= [other, b]$&#xff0c;根据归纳假设也可以说明这一点。</li></ol>\n</li></ul>\n现在我们证明&#xff0c;OPT算法总是正确的。对访存序列的长度做归纳。我们假设$nextpos(a)$表示块下一次被访问的位置&#xff0c;$len$表示访存序列长度。\n<ul><li>当$len=1$时是显然的。\n</li><li>假设$len=n$时成立&#xff0c;我们只需证明$len=n&#43;1$时成立。考虑第一次访存的情况&#xff1a;\n<ol><li>未缺页&#xff0c;不发生换入换出&#xff0c;根据归纳假设显然。\n</li><li>发生缺页&#xff0c;设当前内存状态为$A$。若我们没有按照OPT算法将下一次访问最晚的页面换出&#xff0c;而是换出了另外一个页面$a$&#xff0c;则必有$b\\in A$&#xff0c;满足$nextpos(a)\n\n考虑在原先的方案中$b$在什么时候被换出。\n<ol><li>$b$在$nextpos(a)$之前被换出&#xff0c;如果我们第一次换出的是$b$&#xff0c;那么只会简单的将内存中的$b$替换成$a$&#xff0c;并不会引起任何缺页或命中的变化。</li><li>$b​$在$nextpos(a)​$时被换出&#xff0c;$a​$被换入&#xff0c;内存状态$A[other, b]\\to A&#39;[other, a]​$。如果我们第一次换出的是$b​$&#xff0c;在$nextpos(a) ​$之前的缺页和命中并没有任何变化&#xff0c;而$nextpos(a)​$时并不会发生缺页&#xff0c;且此时内存状态也为$A&#39;​$。因此调整后总的缺页次数严格小于之前。</li><li>$b$在$nextpos(a)$之后被换出。考虑在$nextpos(a)$时发生了一次缺页且没有换出$b$&#xff0c;内存状态$A[other, b]\\to A&#39;[other-\\{p\\}, b, a]$。而如果我们一开始换出的是$b$&#xff0c;这一次没有发生缺页&#xff0c;且内存状态是$B[other, a]$。注意到$A&#39;$和$B$只有一位不同&#xff0c;根据之前的引理&#xff0c;有$Miss(A&#39;)\\ge Miss(B)-1$。而在第$nextpos(a)$次我们减少了一次缺页&#xff0c;因此总的缺页数&#xff1a;$Miss(Before)\\ge (Miss(After)-1)&#43;1=Miss(After)$ </li></ol>\n</li></ol>\n</li></ul>\n在查阅其他资料后&#xff0c;我仍然有两个暂时未解决问题&#xff1a;\n<ul><li>在belady的原始论文 <a href=\"http://users.informatik.uni-halle.de/~hinnebur/Lehre/Web_DBIIb/uebung3_belady_opt_buffer.pdf\" target=\"_blank\">http://users.informatik.uni-halle.de/~hinnebur/Lehre/Web_DBIIb/uebung3_belady_opt_buffer.pdf</a> 中&#xff0c;关于最优算法<code>MIN</code>算法的描述似乎和现在的OPT不同&#xff0c;为何这里说明了<code>MIN</code>算法而不是更简单的OPT算法&#xff1f;</li><li>在论文中说&#xff0c;通过维护写标记并简单修改算法&#xff0c;可以使得<code>push &#43; pull</code>&#xff08;即换入换出的总次数&#xff09;最小化&#xff0c;而不是缺页次数最小化。显然&#xff0c;前者更符合实际&#xff08;事实上<code>pull &#43; c * pull</code>应当更符合&#xff0c;还不知道有没有对应的算法&#xff09;。但是我们的课程中并没有提到类似的问题。且论文中也没有给出这种算法正确性的证明。</li></ul>"}, {"anon": "no", "uid": "jspklr3s9oOe", "subject": "OPT算法正确性的证明", "created": "2019-03-26T16:50:20Z", "content": "<h2>OPT算法的一个证明</h2>\n<p>给定一个访问内存的$a_1, a_2, \\dots, a_n$&#xff0c;$a_i\\le MaxPage$&#xff0c;物理内存的大小为$M$。OPT算法能够使得缺页次数最少。</p>\n<h3>OPT算法缺页次数</h3>\n<p>OPT算法的第$i$次访存发生缺页&#xff0c;那么这是$a_i$的第一次访问&#xff0c;或者上一次访问到这次访问之间&#xff0c;访问不同页的数量$\\ge M$。</p>\n<p>证明&#xff1a;&#xff08;$\\Rightarrow$&#xff09;假设某一次访存操作$a_i$发生缺页&#xff0c;且这不是$a_i$的第一次访问&#xff0c;记上一次访问是$a_j=a_i$。那么一定存在某个$j\n</p><h3>OPT算法正确性的证明</h3>\n<p>在第九讲页面置换算法中介绍了许多种不同的页面置换算法&#xff0c;其中OPT算法即最优算法是说&#xff0c;当我们给出访存序列之后&#xff0c;使用贪心的置换下一次访存最晚的页面总是最优的。但查阅网上资料后并没有给出比较严谨的证明。我们给出了一个使用调整法的证明&#xff0c;其说明了在第一次发生缺页和换出时&#xff0c;将换出的页面调整为下一次引用更晚的&#xff0c;总是可以构造出换出方案&#xff0c;使得缺页次数不多于原先的方案。</p>\n<p>由于水平&amp;时间有限&#xff0c;证明可能出现漏洞和错误&#xff0c;欢迎大家指出。</p>\n<p>定义$Miss(A)$表示某个时刻内存状态为$A$&#xff0c;在处理之后访存序列时最小的缺页次数。先证明一个引理&#xff1a;如果内存状态$A,B$仅有一页不同&#xff0c;那么$Miss(A)\\ge Miss(B)-1$。</p>\n<p><strong>证明</strong>&#xff1a;考虑对访存序列长度做归纳。</p>\n<ul><li><p>当$len=1$时是显然的。</p>\n</li><li><p>假设$len=n$时成立&#xff0c;我们只需证明$len=n&#43;1$时成立。设$A=[other, a], B = [other, b]$&#xff0c;考虑第一次访存的情况&#xff1a;</p>\n<ol><li>访问$other$中的内容&#xff0c;$A,B$均命中&#xff0c;根据归纳假设显然。</li><li>访问$a$&#xff0c;$A$命中&#xff0c;$B$发生缺页&#xff0c;我们可以将$B$中$b$换出&#xff0c;$a$换入&#xff0c;$A,B$在这次访存之后相同$Miss(A&#39;)=Miss(B&#39;)$&#xff0c;那么有$Miss(A)\\ge Miss(B)&#43;1$。</li><li>访问$b$&#xff0c;$A$出现缺页&#xff0c;$B$命中。设$A$换出了一页$p$并将$b$换入&#xff0c;那么这次缺页之后$A, B$仅有一页不同&#xff1a;$A&#39;=[other-{p}, a, b], B &#39;= [other, b]$&#xff0c;根据归纳假设也可以说明这一点。</li></ol>\n</li></ul>\n<p>现在我们证明&#xff0c;OPT算法总是正确的。对访存序列的长度做归纳。我们假设$nextpos(a)$表示块下一次被访问的位置&#xff0c;$len$表示访存序列长度。</p>\n<ul><li><p>当$len=1$时是显然的。</p>\n</li><li><p>假设$len=n$时成立&#xff0c;我们只需证明$len=n&#43;1$时成立。考虑第一次访存的情况&#xff1a;</p>\n<ol><li><p>未缺页&#xff0c;不发生换入换出&#xff0c;根据归纳假设显然。</p>\n</li><li><p>发生缺页&#xff0c;设当前内存状态为$A$。若我们没有按照OPT算法将下一次访问最晚的页面换出&#xff0c;而是换出了另外一个页面$a$&#xff0c;则必有$b\\in A$&#xff0c;满足$nextpos(a)\n</p><p>考虑在原先的方案中$b$在什么时候被换出。</p>\n<ol><li>$b$在$nextpos(a)$之前被换出&#xff0c;如果我们第一次换出的是$b$&#xff0c;那么只会简单的将内存中的$b$替换成$a$&#xff0c;并不会引起任何缺页或命中的变化。</li><li>$b​$在$nextpos(a)​$时被换出&#xff0c;$a​$被换入&#xff0c;内存状态$A[other, b]\\to A&#39;[other, a]​$。如果我们第一次换出的是$b​$&#xff0c;在$nextpos(a) ​$之前的缺页和命中并没有任何变化&#xff0c;而$nextpos(a)​$时并不会发生缺页&#xff0c;且此时内存状态也为$A&#39;​$。因此调整后总的缺页次数严格小于之前。</li><li>$b$在$nextpos(a)$之后被换出。考虑在$nextpos(a)$时发生了一次缺页且没有换出$b$&#xff0c;内存状态$A[other, b]\\to A&#39;[other-\\{p\\}, b, a]$。而如果我们一开始换出的是$b$&#xff0c;这一次没有发生缺页&#xff0c;且内存状态是$B[other, a]$。注意到$A&#39;$和$B$只有一位不同&#xff0c;根据之前的引理&#xff0c;有$Miss(A&#39;)\\ge Miss(B)-1$。而在第$nextpos(a)$次我们减少了一次缺页&#xff0c;因此总的缺页数&#xff1a;$Miss(Before)\\ge (Miss(After)-1)&#43;1=Miss(After)$ </li></ol>\n</li></ol>\n</li></ul>\n<p>在查阅其他资料后&#xff0c;我仍然有两个暂时未解决问题&#xff1a;</p>\n<ul><li>在belady的原始论文 <a href=\"http://users.informatik.uni-halle.de/~hinnebur/Lehre/Web_DBIIb/uebung3_belady_opt_buffer.pdf\" target=\"_blank\">http://users.informatik.uni-halle.de/~hinnebur/Lehre/Web_DBIIb/uebung3_belady_opt_buffer.pdf</a> 中&#xff0c;关于最优算法<code>MIN</code>算法的描述似乎和现在的OPT不同&#xff0c;为何这里说明了<code>MIN</code>算法而不是更简单的OPT算法&#xff1f;</li><li>在论文中说&#xff0c;通过维护写标记并简单修改算法&#xff0c;可以使得<code>push &#43; pull</code>&#xff08;即换入换出的总次数&#xff09;最小化&#xff0c;而不是缺页次数最小化。显然&#xff0c;前者更符合实际&#xff08;事实上<code>pull &#43; c * pull</code>应当更符合&#xff0c;还不知道有没有对应的算法&#xff09;。但是我们的课程中并没有提到类似的问题。且论文中也没有给出这种算法正确性的证明。</li></ul>\n<p> </p>"}, {"anon": "no", "uid": "jspklr3s9oOe", "subject": "OPT算法正确性的证明", "created": "2019-03-26T16:49:24Z", "content": "<div><h2>OPT算法的一个证明</h2><p>给定一个访问内存的<span style=\"font-size:100%\"></span>&#xff0c;<span style=\"font-size:100%\"></span>&#xff0c;物理内存的大小为<span style=\"font-size:100%\"></span>。OPT算法能够使得缺页次数最少。</p><h3>OPT算法缺页次数</h3><p>OPT算法的第<span style=\"font-size:100%\"></span>次访存发生缺页&#xff0c;那么这是<span style=\"font-size:100%\"></span>的第一次访问&#xff0c;或者上一次访问到这次访问之间&#xff0c;访问不同页的数量<span style=\"font-size:100%\"></span>。</p><p>证明&#xff1a;&#xff08;<span style=\"font-size:100%\"></span>&#xff09;假设某一次访存操作<span style=\"font-size:100%\"></span>发生缺页&#xff0c;且这不是<span style=\"font-size:100%\"></span>的第一次访问&#xff0c;记上一次访问是<span style=\"font-size:100%\"></span>。那么一定存在某个<span style=\"font-size:100%\"></span>&#xff0c;满足<span style=\"font-size:100%\"></span>时发生了缺页&#xff0c;且将<span style=\"font-size:100%\"></span>这一页置换了出去。根据OPT算法的定义&#xff0c;<span style=\"font-size:100%\"></span>一定是当前所有在物理内存中下一次访问最晚的。换言之&#xff0c;在换入<span style=\"font-size:100%\"></span>之前内存中除<span style=\"font-size:100%\"></span>外的<span style=\"font-size:100%\"></span>个的下一次访问时间均早于<span style=\"font-size:100%\"></span>&#xff0c;也即有<span style=\"font-size:100%\"></span>个不同的访存发生在<span style=\"font-size:100%\"></span>之间&#xff0c;再加上<span style=\"font-size:100%\"></span>这次访存&#xff08;由于发生了缺页&#xff0c;其不与这<span style=\"font-size:100%\"></span>个内存中已有的页相同&#xff09;&#xff0c;有至少<span style=\"font-size:100%\"></span>个不同的访存发生在<span style=\"font-size:100%\"></span>之间。</p><h3>OPT算法正确性的证明</h3><p>在第九讲页面置换算法中介绍了许多种不同的页面置换算法&#xff0c;其中OPT算法即最优算法是说&#xff0c;当我们给出访存序列之后&#xff0c;使用贪心的置换下一次访存最晚的页面总是最优的。但查阅网上资料后并没有给出比较严谨的证明。我们给出了一个使用调整法的证明&#xff0c;其说明了在第一次发生缺页和换出时&#xff0c;将换出的页面调整为下一次引用更晚的&#xff0c;总是可以构造出换出方案&#xff0c;使得缺页次数不多于原先的方案。</p><p>由于水平&amp;时间有限&#xff0c;证明可能出现漏洞和错误&#xff0c;欢迎大家指出。</p><p>定义<span style=\"font-size:100%\"></span>表示某个时刻内存状态为<span style=\"font-size:100%\"></span>&#xff0c;在处理之后访存序列时最小的缺页次数。先证明一个引理&#xff1a;如果内存状态<span style=\"font-size:100%\"></span>仅有一页不同&#xff0c;那么<span style=\"font-size:100%\"></span>。</p><p><strong>证明</strong>&#xff1a;考虑对访存序列长度做归纳。</p><ul><li><p>当<span style=\"font-size:100%\"></span>时是显然的。</p></li><li><p>假设<span style=\"font-size:100%\"></span>时成立&#xff0c;我们只需证明<span style=\"font-size:100%\"></span>时成立。设<span style=\"font-size:100%\"></span>&#xff0c;考虑第一次访存的情况&#xff1a;</p><ol><li>访问<span style=\"font-size:100%\"></span>中的内容&#xff0c;<span style=\"font-size:100%\"></span>均命中&#xff0c;根据归纳假设显然。</li><li>访问<span style=\"font-size:100%\"></span>&#xff0c;<span style=\"font-size:100%\"></span>命中&#xff0c;<span style=\"font-size:100%\"></span>发生缺页&#xff0c;我们可以将<span style=\"font-size:100%\"></span>中<span style=\"font-size:100%\"></span>换出&#xff0c;<span style=\"font-size:100%\"></span>换入&#xff0c;<span style=\"font-size:100%\"></span>在这次访存之后相同<span style=\"font-size:100%\"></span>&#xff0c;那么有<span style=\"font-size:100%\"></span>。</li><li>访问<span style=\"font-size:100%\"></span>&#xff0c;<span style=\"font-size:100%\"></span>出现缺页&#xff0c;<span style=\"font-size:100%\"></span>命中。设<span style=\"font-size:100%\"></span>换出了一页<span style=\"font-size:100%\"></span>并将<span style=\"font-size:100%\"></span>换入&#xff0c;那么这次缺页之后<span style=\"font-size:100%\"></span>仅有一页不同&#xff1a;<span style=\"font-size:100%\"></span>&#xff0c;根据归纳假设也可以说明这一点。</li></ol></li></ul><p>现在我们证明&#xff0c;OPT算法总是正确的。对访存序列的长度做归纳。我们假设<span style=\"font-size:100%\"></span>表示块下一次被访问的位置&#xff0c;<span style=\"font-size:100%\"></span>表示访存序列长度。</p><ul><li><p>当<span style=\"font-size:100%\"></span>时是显然的。</p></li><li><p>假设<span style=\"font-size:100%\"></span>时成立&#xff0c;我们只需证明<span style=\"font-size:100%\"></span></p></li></ul></div>"}, {"anon": "no", "uid": "jspklr3s9oOe", "subject": "OPT算法正确性的证明", "created": "2019-03-26T16:46:59Z", "content": "<p><md><br />## OPT算法的一个证明<br /><br />给定一个访问内存的$a_1, a_2, \\dots, a_n$&#xff0c;$a_i\\le MaxPage$&#xff0c;物理内存的大小为$M$。OPT算法能够使得缺页次数最少。<br /><br />### OPT算法缺页次数<br /><br />OPT算法的第$i$次访存发生缺页&#xff0c;那么这是$a_i$的第一次访问&#xff0c;或者上一次访问到这次访问之间&#xff0c;访问不同页的数量$\\ge M$。<br /><br />证明&#xff1a;&#xff08;$\\Rightarrow$&#xff09;假设某一次访存操作$a_i$发生缺页&#xff0c;且这不是$a_i$的第一次访问&#xff0c;记上一次访问是$a_j=a_i$。那么一定存在某个$j&lt;k&lt;i$&#xff0c;满足$a_k$时发生了缺页&#xff0c;且将$a_i$这一页置换了出去。根据OPT算法的定义&#xff0c;$a_i$一定是当前所有在物理内存中下一次访问最晚的。换言之&#xff0c;在换入$a_k$之前内存中除$a_i$外的$M-1$个的下一次访问时间均早于$i$&#xff0c;也即有$M-1$个不同的访存发生在$(j, i)$之间&#xff0c;再加上$a_k$这次访存&#xff08;由于发生了缺页&#xff0c;其不与这$M-1$个内存中已有的页相同&#xff09;&#xff0c;有至少$M$个不同的访存发生在$(j, i)$之间。<br /><br />### OPT算法正确性的证明<br /><br />在第九讲页面置换算法中介绍了许多种不同的页面置换算法&#xff0c;其中OPT算法即最优算法是说&#xff0c;当我们给出访存序列之后&#xff0c;使用贪心的置换下一次访存最晚的页面总是最优的。但查阅网上资料后并没有给出比较严谨的证明。我们给出了一个使用调整法的证明&#xff0c;其说明了在第一次发生缺页和换出时&#xff0c;将换出的页面调整为下一次引用更晚的&#xff0c;总是可以构造出换出方案&#xff0c;使得缺页次数不多于原先的方案。<br /><br />由于水平&amp;时间有限&#xff0c;证明可能出现漏洞和错误&#xff0c;欢迎大家指出。<br /><br />定义$Miss(A)$表示某个时刻内存状态为$A$&#xff0c;在处理之后访存序列时最小的缺页次数。先证明一个引理&#xff1a;如果内存状态$A,B$仅有一页不同&#xff0c;那么$Miss(A)\\ge Miss(B)-1$。<br /><br />**证明**&#xff1a;考虑对访存序列长度做归纳。<br /><br />- 当$len=1$时是显然的。<br />- 假设$len=n$时成立&#xff0c;我们只需证明$len=n&#43;1$时成立。设$A=[other, a], B = [other, b]$&#xff0c;考虑第一次访存的情况&#xff1a;<br />  1. 访问$other$中的内容&#xff0c;$A,B$均命中&#xff0c;根据归纳假设显然。<br />  2. 访问$a$&#xff0c;$A$命中&#xff0c;$B$发生缺页&#xff0c;我们可以将$B$中$b$换出&#xff0c;$a$换入&#xff0c;$A,B$在这次访存之后相同$Miss(A&#39;)=Miss(B&#39;)$&#xff0c;那么有$Miss(A)\\ge Miss(B)&#43;1$。<br />  3. 访问$b$&#xff0c;$A$出现缺页&#xff0c;$B$命中。设$A$换出了一页$p$并将$b$换入&#xff0c;那么这次缺页之后$A, B$仅有一页不同&#xff1a;$A&#39;=[other-{p}, a, b], B &#39;= [other, b]$&#xff0c;根据归纳假设也可以说明这一点。<br /><br />现在我们证明&#xff0c;OPT算法总是正确的。对访存序列的长度做归纳。我们假设$nextpos(a)$表示块下一次被访问的位置&#xff0c;$len$表示访存序列长度。<br /><br />- 当$len=1$时是显然的。<br /><br />- 假设$len=n$时成立&#xff0c;我们只需证明$len=n&#43;1$时成立。考虑第一次访存的情况&#xff1a;<br /><br />  1. 未缺页&#xff0c;不发生换入换出&#xff0c;根据归纳假设显然。<br /><br />  2. 发生缺页&#xff0c;设当前内存状态为$A$。若我们没有按照OPT算法将下一次访问最晚的页面换出&#xff0c;而是换出了另外一个页面$a$&#xff0c;则必有$b\\in A$&#xff0c;满足$nextpos(a)&lt;nextpos(b)$。我们只需说明这次如果换出$b$&#xff0c;答案不会更劣。<br /><br />     考虑在原先的方案中$b$在什么时候被换出。<br /><br />     1. $b$在$nextpos(a)$之前被换出&#xff0c;如果我们第一次换出的是$b$&#xff0c;那么只会简单的将内存中的$b$替换成$a$&#xff0c;并不会引起任何缺页或命中的变化。<br />     2. $b$在$nextpos(a)$时被换出&#xff0c;$a$被换入&#xff0c;内存状态$A[other, b]\\to A&#39;[other, a]$。如果我们第一次换出的是$b$&#xff0c;在$nextpos(a) $之前的缺页和命中并没有任何变化&#xff0c;而$nextpos(a)$时并不会发生缺页&#xff0c;且此时内存状态也为$A&#39;$。因此调整后总的缺页次数严格小于之前。<br />     3. $b$在$nextpos(a)$之后被换出。考虑在$nextpos(a)$时发生了一次缺页且没有换出$b$&#xff0c;内存状态$A[other, b]\\to A&#39;[other-\\{p\\}, b, a]$。而如果我们一开始换出的是$b$&#xff0c;这一次没有发生缺页&#xff0c;且内存状态是$B[other, a]$。注意到$A&#39;$和$B$只有一位不同&#xff0c;根据之前的引理&#xff0c;有$Miss(A&#39;)\\ge Miss(B)-1$。而在第$nextpos(a)$次我们减少了一次缺页&#xff0c;因此总的缺页数&#xff1a;$Miss(Before)\\ge (Miss(After)-1)&#43;1=Miss(After)$ <br /><br />在查阅其他资料后&#xff0c;我仍然有两个暂时未解决问题&#xff1a;<br /><br />- 在belady的原始论文 http://users.informatik.uni-halle.de/~hinnebur/Lehre/Web_DBIIb/uebung3_belady_opt_buffer.pdf 中&#xff0c;关于最优算法&#96;MIN&#96;算法的描述似乎和现在的OPT不同&#xff0c;为何这里说明了&#96;MIN&#96;算法而不是更简单的OPT算法&#xff1f;<br />- 在论文中说&#xff0c;通过维护写标记并简单修改算法&#xff0c;可以使得&#96;push &#43; pull&#96;&#xff08;即换入换出的总次数&#xff09;最小化&#xff0c;而不是缺页次数最小化。显然&#xff0c;前者更符合实际&#xff08;事实上&#96;pull &#43; c * pull&#96;应当更符合&#xff0c;还不知道有没有对应的算法&#xff09;。但是我们的课程中并没有提到类似的问题。且论文中也没有给出这种算法正确性的证明。<br /></md></p>"}, {"anon": "no", "uid": "jspklr3s9oOe", "subject": "OPT算法正确性的证明", "created": "2019-03-26T16:45:08Z", "content": "<p></p><h2 style=\"font-family:&#34;Open Sans&#34;,&#34;Clear Sans&#34;,&#34;Helvetica Neue&#34;,&#34;Helvetica&#34;,&#34;Arial&#34;,sans-serif;text-align:start;font-weight:bold;font-style:normal;color:#333333\">OPT算法的一个证明</h2>\n<p style=\"font-family:&#34;Open Sans&#34;,&#34;Clear Sans&#34;,&#34;Helvetica Neue&#34;,&#34;Helvetica&#34;,&#34;Arial&#34;,sans-serif;text-align:start;font-weight:400;font-size:16px;font-style:normal;color:#333333\">给定一个访问内存的<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​&#xff0c;<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​&#xff0c;物理内存的大小为<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​。OPT算法能够使得缺页次数最少。</p>\n<h3 style=\"font-family:&#34;Open Sans&#34;,&#34;Clear Sans&#34;,&#34;Helvetica Neue&#34;,&#34;Helvetica&#34;,&#34;Arial&#34;,sans-serif;text-align:start;font-weight:bold;font-style:normal;color:#333333\">OPT算法缺页次数</h3>\n<p style=\"font-family:&#34;Open Sans&#34;,&#34;Clear Sans&#34;,&#34;Helvetica Neue&#34;,&#34;Helvetica&#34;,&#34;Arial&#34;,sans-serif;text-align:start;font-weight:400;font-size:16px;font-style:normal;color:#333333\">OPT算法的第<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​次访存发生缺页&#xff0c;那么这是<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​的第一次访问&#xff0c;或者上一次访问到这次访问之间&#xff0c;访问不同页的数量<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​。</p>\n<p style=\"font-family:&#34;Open Sans&#34;,&#34;Clear Sans&#34;,&#34;Helvetica Neue&#34;,&#34;Helvetica&#34;,&#34;Arial&#34;,sans-serif;text-align:start;font-weight:400;font-size:16px;font-style:normal;color:#333333\">证明&#xff1a;&#xff08;<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​&#xff09;假设某一次访存操作<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​发生缺页&#xff0c;且这不是<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​的第一次访问&#xff0c;记上一次访问是<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​。那么一定存在某个<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​&#xff0c;满足<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​时发生了缺页&#xff0c;且将<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​这一页置换了出去。根据OPT算法的定义&#xff0c;<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​一定是当前所有在物理内存中下一次访问最晚的。换言之&#xff0c;在换入<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​之前内存中除<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​外的<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​个的下一次访问时间均早于<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​&#xff0c;也即有<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​个不同的访存发生在<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​之间&#xff0c;再加上<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​这次访存&#xff08;由于发生了缺页&#xff0c;其不与这<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​个内存中已有的页相同&#xff09;&#xff0c;有至少<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​个不同的访存发生在<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​之间。</p>\n<h3 style=\"font-family:&#34;Open Sans&#34;,&#34;Clear Sans&#34;,&#34;Helvetica Neue&#34;,&#34;Helvetica&#34;,&#34;Arial&#34;,sans-serif;text-align:start;font-weight:bold;font-style:normal;color:#333333\">OPT算法正确性的证明</h3>\n<p style=\"font-family:&#34;Open Sans&#34;,&#34;Clear Sans&#34;,&#34;Helvetica Neue&#34;,&#34;Helvetica&#34;,&#34;Arial&#34;,sans-serif;text-align:start;font-weight:400;font-size:16px;font-style:normal;color:#333333\">在第九讲页面置换算法中介绍了许多种不同的页面置换算法&#xff0c;其中OPT算法即最优算法是说&#xff0c;当我们给出访存序列之后&#xff0c;使用贪心的置换下一次访存最晚的页面总是最优的。但查阅网上资料后并没有给出比较严谨的证明。我们给出了一个使用调整法的证明&#xff0c;其说明了在第一次发生缺页和换出时&#xff0c;将换出的页面调整为下一次引用更晚的&#xff0c;总是可以构造出换出方案&#xff0c;使得缺页次数不多于原先的方案。</p>\n<p style=\"font-family:&#34;Open Sans&#34;,&#34;Clear Sans&#34;,&#34;Helvetica Neue&#34;,&#34;Helvetica&#34;,&#34;Arial&#34;,sans-serif;text-align:start;font-weight:400;font-size:16px;font-style:normal;color:#333333\">由于水平&amp;时间有限&#xff0c;证明可能出现漏洞和错误&#xff0c;欢迎大家指出。</p>\n<p style=\"font-family:&#34;Open Sans&#34;,&#34;Clear Sans&#34;,&#34;Helvetica Neue&#34;,&#34;Helvetica&#34;,&#34;Arial&#34;,sans-serif;text-align:start;font-weight:400;font-size:16px;font-style:normal;color:#333333\">定义<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​表示某个时刻内存状态为<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​&#xff0c;在处理之后访存序列时最小的缺页次数。先证明一个引理&#xff1a;如果内存状态<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​仅有一页不同&#xff0c;那么<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​。</p>\n<p style=\"font-family:&#34;Open Sans&#34;,&#34;Clear Sans&#34;,&#34;Helvetica Neue&#34;,&#34;Helvetica&#34;,&#34;Arial&#34;,sans-serif;text-align:start;font-weight:400;font-size:16px;font-style:normal;color:#333333\"><strong>证明</strong>&#xff1a;考虑对访存序列长度做归纳。</p>\n<ul style=\"font-family:&#34;Open Sans&#34;,&#34;Clear Sans&#34;,&#34;Helvetica Neue&#34;,&#34;Helvetica&#34;,&#34;Arial&#34;,sans-serif;text-align:start;font-weight:400;font-size:16px;font-style:normal;color:#333333\"><li>\n<p>当<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​时是显然的。</p>\n</li><li>\n<p>假设<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span></p></li></ul>"}, {"anon": "no", "uid": "jspklr3s9oOe", "subject": "OPT算法正确性的证明", "created": "2019-03-26T16:44:57Z", "content": "<p><md><br />OPT算法的一个证明<br /> <br /><br />给定一个访问内存的<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />&#xff0c;<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />&#xff0c;物理内存的大小为<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />。OPT算法能够使得缺页次数最少。<br /> <br /><br />OPT算法缺页次数<br /> <br /><br />OPT算法的第<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />次访存发生缺页&#xff0c;那么这是<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />的第一次访问&#xff0c;或者上一次访问到这次访问之间&#xff0c;访问不同页的数量<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />。<br /> <br /><br />证明&#xff1a;&#xff08;<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />&#xff09;假设某一次访存操作<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />发生缺页&#xff0c;且这不是<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />的第一次访问&#xff0c;记上一次访问是<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />。那么一定存在某个<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />&#xff0c;满足<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />时发生了缺页&#xff0c;且将<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />这一页置换了出去。根据OPT算法的定义&#xff0c;<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />一定是当前所有在物理内存中下一次访问最晚的。换言之&#xff0c;在换入<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />之前内存中除<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />外的<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />个的下一次访问时间均早于<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />&#xff0c;也即有<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />个不同的访存发生在<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />之间&#xff0c;再加上<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />这次访存&#xff08;由于发生了缺页&#xff0c;其不与这<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />个内存中已有的页相同&#xff09;&#xff0c;有至少<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br />个不同的访存发生在<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />之间。<br /> <br /><br />OPT算法正确性的证明<br /> <br /><br />在第九讲页面置换算法中介绍了许多种不同的页面置换算法&#xff0c;其中OPT算法即最优算法是说&#xff0c;当我们给出访存序列之后&#xff0c;使用贪心的置换下一次访存最晚的页面总是最优的。但查阅网上资料后并没有给出比较严谨的证明。我们给出了一个使用调整法的证明&#xff0c;其说明了在第一次发生缺页和换出时&#xff0c;将换出的页面调整为下一次引用更晚的&#xff0c;总是可以构造出换出方案&#xff0c;使得缺页次数不多于原先的方案。<br /> <br /><br />由于水平&amp;时间有限&#xff0c;证明可能出现漏洞和错误&#xff0c;欢迎大家指出。<br /> <br /><br />定义<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />表示某个时刻内存状态为<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />&#xff0c;在处理之后访存序列时最小的缺页次数。先证明一个引理&#xff1a;如果内存状态<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />仅有一页不同&#xff0c;那么<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br />。<br /> <br /><br /><br /><br />证明<br /><br /><br />&#xff1a;考虑对访存序列长度做归纳。<br /> <br /> <br /> <br /><br />当<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />时是显然的。<br /> <br /> <br /> <br /><br />假设<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />时成立&#xff0c;我们只需证明<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />时成立。设<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />&#xff0c;考虑第一次访存的情况&#xff1a;<br /> <br /> <br /> <br /><br />访问<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />中的内容&#xff0c;<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />均命中&#xff0c;根据归纳假设显然。<br /> <br /> <br /> <br />访问<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br />&#xff0c;<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />命中&#xff0c;<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />发生缺页&#xff0c;我们可以将<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />中<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />换出&#xff0c;<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />换入&#xff0c;<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />在这次访存之后相同<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />&#xff0c;那么有<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br />。<br /> <br /> <br /> <br />访问<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br />&#xff0c;​<br />出现缺页&#xff0c;<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />命中。设​<br />换出了一页<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />并将​<br />换入&#xff0c;那么这次缺页之后<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />仅有一页不同&#xff1a;<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />&#xff0c;根据归纳假设也可以说明这一点。<br /> <br /> <br /><br /> <br /> <br /><br />现在我们证明&#xff0c;OPT算法总是正确的。对访存序列的长度做归纳。我们假设<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />表示块下一次被访问的位置&#xff0c;<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />表示访存序列长度。<br /> <br /> <br /> <br />当<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br />时是显然的。<br /> <br /> <br /> <br />假设<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br />时成立&#xff0c;我们只需证明<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />时成立。考虑第一次访存的情况&#xff1a;<br /> <br /> <br /> <br /><br />未缺页&#xff0c;不发生换入换出&#xff0c;根据归纳假设显然。<br /> <br /> <br /> <br /><br />发生缺页&#xff0c;设当前内存状态为​<br />。若我们没有按照OPT算法将下一次访问最晚的页面换出&#xff0c;而是换出了另外一个页面<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />&#xff0c;则必有<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br />&#xff0c;满足<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />。我们只需说明这次如果换出​<br />&#xff0c;答案不会更劣。<br /> <br /><br />考虑在原先的方案中​<br />在什么时候被换出。<br /> <br /> <br /> <br />​<br />在​<br />之前被换出&#xff0c;如果我们第一次换出的是​<br />&#xff0c;那么只会简单的将内存中的​<br />替换成​<br />&#xff0c;并不会引起任何缺页或命中的变化。<br /> <br /> <br /> <br />​在​<br />时被换出&#xff0c;​<br />被换入&#xff0c;内存状态<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />。如果我们第一次换出的是​<br />&#xff0c;在<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />之前的缺页和命中并没有任何变化&#xff0c;而​<br />时并不会发生缺页&#xff0c;且此时内存状态也为<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />。因此调整后总的缺页次数严格小于之前。<br /> <br /> <br /> <br />​在​<br />之后被换出。考虑在​<br />时发生了一次缺页且没有换出​<br />&#xff0c;内存状态<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />。而如果我们一开始换出的是​<br />&#xff0c;这一次没有发生缺页&#xff0c;且内存状态是<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />。注意到​<br />和​<br />只有一位不同&#xff0c;根据之前的引理&#xff0c;有<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br />。而在第​<br />次我们减少了一次缺页&#xff0c;因此总的缺页数&#xff1a;<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />​<br /><br /> <br /> <br /> <br /><br /> <br /><br /> <br /> <br /><br />在查阅其他资料后&#xff0c;我仍然有两个暂时未解决问题&#xff1a;<br /> <br /> <br /> <br /><br />在belady的原始论文 <br /><a href=\"http://users.informatik.uni-halle.de/~hinnebur/Lehre/Web_DBIIb/uebung3_belady_opt_buffer.pdf\">http://users.informatik.uni-halle.de/~hinnebur/Lehre/Web_DBIIb/uebung3_belady_opt_buffer.pdf</a><br /> 中&#xff0c;关于最优算法<br /><br />MIN<br /><br />算法的描述似乎和现在的OPT不同&#xff0c;为何这里说明了<code>MIN</code><br />算法而不是更简单的OPT算法&#xff1f;<br /> <br /> <br /> <br /><br />在论文中说&#xff0c;通过维护写标记并简单修改算法&#xff0c;可以使得<br /><br />push &#43; pull<br /><br />&#xff08;即换入换出的总次数&#xff09;最小化&#xff0c;而不是缺页次数最小化。显然&#xff0c;前者更符合实际&#xff08;事实上<br /><br />pull &#43; c * pull<br /><br />应当更符合&#xff0c;还不知道有没有对应的算法&#xff09;。但是我们的课程中并没有提到类似的问题。且论文中也没有给出这种算法正确性的证明。<br /></md></p>"}, {"anon": "no", "uid": "jspklr3s9oOe", "subject": "OPT算法正确性的证明", "created": "2019-03-26T16:42:21Z", "content": "<p></p><h3 style=\"font-family:&#34;Open Sans&#34;,&#34;Clear Sans&#34;,&#34;Helvetica Neue&#34;,&#34;Helvetica&#34;,&#34;Arial&#34;,sans-serif;text-align:start;font-weight:bold;font-style:normal;color:#333333\">OPT算法正确性的证明</h3>\n<p style=\"font-family:&#34;Open Sans&#34;,&#34;Clear Sans&#34;,&#34;Helvetica Neue&#34;,&#34;Helvetica&#34;,&#34;Arial&#34;,sans-serif;text-align:start;font-weight:400;font-size:16px;font-style:normal;color:#333333\">在第九讲页面置换算法中介绍了许多种不同的页面置换算法&#xff0c;其中OPT算法即最优算法是说&#xff0c;当我们给出访存序列之后&#xff0c;使用贪心的置换下一次访存最晚的页面总是最优的。但查阅网上资料后并没有给出比较严谨的证明。我们给出了一个使用调整法的证明&#xff0c;其说明了在第一次发生缺页和换出时&#xff0c;将换出的页面调整为下一次引用更晚的&#xff0c;总是可以构造出换出方案&#xff0c;使得缺页次数不多于原先的方案。</p>\n<p style=\"font-family:&#34;Open Sans&#34;,&#34;Clear Sans&#34;,&#34;Helvetica Neue&#34;,&#34;Helvetica&#34;,&#34;Arial&#34;,sans-serif;text-align:start;font-weight:400;font-size:16px;font-style:normal;color:#333333\">由于水平&amp;时间有限&#xff0c;证明可能出现漏洞和错误&#xff0c;欢迎大家指出。</p>\n<p style=\"font-family:&#34;Open Sans&#34;,&#34;Clear Sans&#34;,&#34;Helvetica Neue&#34;,&#34;Helvetica&#34;,&#34;Arial&#34;,sans-serif;text-align:start;font-weight:400;font-size:16px;font-style:normal;color:#333333\">定义<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​表示某个时刻内存状态为<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​&#xff0c;在处理之后访存序列时最小的缺页次数。先证明一个引理&#xff1a;如果内存状态<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​仅有一页不同&#xff0c;那么<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​。</p>\n<p style=\"font-family:&#34;Open Sans&#34;,&#34;Clear Sans&#34;,&#34;Helvetica Neue&#34;,&#34;Helvetica&#34;,&#34;Arial&#34;,sans-serif;text-align:start;font-weight:400;font-size:16px;font-style:normal;color:#333333\"><strong>证明</strong>&#xff1a;考虑对访存序列长度做归纳。</p>\n<ul style=\"font-family:&#34;Open Sans&#34;,&#34;Clear Sans&#34;,&#34;Helvetica Neue&#34;,&#34;Helvetica&#34;,&#34;Arial&#34;,sans-serif;text-align:start;font-weight:400;font-size:16px;font-style:normal;color:#333333\"><li>\n<p>当<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​时是显然的。</p>\n</li><li>\n<p>假设<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​时成立&#xff0c;我们只需证明<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​时成立。设<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​&#xff0c;考虑第一次访存的情况&#xff1a;</p>\n<ol><li>\n<p>访问<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​中的内容&#xff0c;<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​均命中&#xff0c;根据归纳假设显然。</p>\n</li><li>\n<p>访问<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​&#xff0c;<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​命中&#xff0c;<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​发生缺页&#xff0c;我们可以将<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​中<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​换出&#xff0c;<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​换入&#xff0c;<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​在这次访存之后相同<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​&#xff0c;那么有<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​。</p>\n</li><li>\n<p>访问<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​&#xff0c;<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​出现缺页&#xff0c;<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​命中。设<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​换出了一页<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​并将<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​换入&#xff0c;那么这次缺页之后<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​仅有一页不同&#xff1a;<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span></p></li></ol></li></ul>"}, {"anon": "no", "uid": "jspklr3s9oOe", "subject": "OPT算法正确性的证明", "created": "2019-03-26T16:41:54Z", "content": "<p></p><p style=\"font-family:&#34;Open Sans&#34;,&#34;Clear Sans&#34;,&#34;Helvetica Neue&#34;,&#34;Helvetica&#34;,&#34;Arial&#34;,sans-serif;text-align:start;font-weight:400;font-size:16px;font-style:normal;color:#333333\"></p>\n<h3 style=\"font-family:&#34;Open Sans&#34;,&#34;Clear Sans&#34;,&#34;Helvetica Neue&#34;,&#34;Helvetica&#34;,&#34;Arial&#34;,sans-serif;text-align:start;font-weight:bold;font-style:normal;color:#333333\">OPT算法正确性的证明</h3>\n<p style=\"font-family:&#34;Open Sans&#34;,&#34;Clear Sans&#34;,&#34;Helvetica Neue&#34;,&#34;Helvetica&#34;,&#34;Arial&#34;,sans-serif;text-align:start;font-weight:400;font-size:16px;font-style:normal;color:#333333\"></p>\n<p style=\"font-family:&#34;Open Sans&#34;,&#34;Clear Sans&#34;,&#34;Helvetica Neue&#34;,&#34;Helvetica&#34;,&#34;Arial&#34;,sans-serif;text-align:start;font-weight:400;font-size:16px;font-style:normal;color:#333333\">在第九讲页面置换算法中介绍了许多种不同的页面置换算法&#xff0c;其中OPT算法即最优算法是说&#xff0c;当我们给出访存序列之后&#xff0c;使用贪心的置换下一次访存最晚的页面总是最优的。但查阅网上资料后并没有给出比较严谨的证明。我们给出了一个使用调整法的证明&#xff0c;其说明了在第一次发生缺页和换出时&#xff0c;将换出的页面调整为下一次引用更晚的&#xff0c;总是可以构造出换出方案&#xff0c;使得缺页次数不多于原先的方案。</p>\n<p style=\"font-family:&#34;Open Sans&#34;,&#34;Clear Sans&#34;,&#34;Helvetica Neue&#34;,&#34;Helvetica&#34;,&#34;Arial&#34;,sans-serif;text-align:start;font-weight:400;font-size:16px;font-style:normal;color:#333333\"></p>\n<p style=\"font-family:&#34;Open Sans&#34;,&#34;Clear Sans&#34;,&#34;Helvetica Neue&#34;,&#34;Helvetica&#34;,&#34;Arial&#34;,sans-serif;text-align:start;font-weight:400;font-size:16px;font-style:normal;color:#333333\">由于水平&amp;时间有限&#xff0c;证明可能出现漏洞和错误&#xff0c;欢迎大家指出。</p>\n<p style=\"font-family:&#34;Open Sans&#34;,&#34;Clear Sans&#34;,&#34;Helvetica Neue&#34;,&#34;Helvetica&#34;,&#34;Arial&#34;,sans-serif;text-align:start;font-weight:400;font-size:16px;font-style:normal;color:#333333\">定义<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​表示某个时刻内存状态为<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​&#xff0c;在处理之后访存序列时最小的缺页次数。先证明一个引理&#xff1a;如果内存状态<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​仅有一页不同&#xff0c;那么<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​。</p>\n<p style=\"font-family:&#34;Open Sans&#34;,&#34;Clear Sans&#34;,&#34;Helvetica Neue&#34;,&#34;Helvetica&#34;,&#34;Arial&#34;,sans-serif;text-align:start;font-weight:400;font-size:16px;font-style:normal;color:#333333\"></p>\n<p style=\"font-family:&#34;Open Sans&#34;,&#34;Clear Sans&#34;,&#34;Helvetica Neue&#34;,&#34;Helvetica&#34;,&#34;Arial&#34;,sans-serif;text-align:start;font-weight:400;font-size:16px;font-style:normal;color:#333333\"><strong>证明</strong>&#xff1a;考虑对访存序列长度做归纳。</p>\n<p style=\"font-family:&#34;Open Sans&#34;,&#34;Clear Sans&#34;,&#34;Helvetica Neue&#34;,&#34;Helvetica&#34;,&#34;Arial&#34;,sans-serif;text-align:start;font-weight:400;font-size:16px;font-style:normal;color:#333333\"></p>\n<ul style=\"font-family:&#34;Open Sans&#34;,&#34;Clear Sans&#34;,&#34;Helvetica Neue&#34;,&#34;Helvetica&#34;,&#34;Arial&#34;,sans-serif;text-align:start;font-weight:400;font-size:16px;font-style:normal;color:#333333\"><li>\n<p>当<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​时是显然的。</p>\n</li><li>\n<p>假设<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​时成立&#xff0c;我们只需证明<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​时成立。设<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​&#xff0c;考虑第一次访存的情况&#xff1a;</p>\n<ol><li>\n<p>访问<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​中的内容&#xff0c;<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​均命中&#xff0c;根据归纳假设显然。</p>\n</li><li>\n<p>访问<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​&#xff0c;<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​命中&#xff0c;<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​发生缺页&#xff0c;我们可以将<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​中<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​换出&#xff0c;<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​换入&#xff0c;<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​在这次访存之后相同<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​&#xff0c;那么有<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​。</p>\n</li><li>\n<p>访问<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​&#xff0c;<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​出现缺页&#xff0c;<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​命中。设<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​换出了一页<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​并将<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​换入&#xff0c;那么这次缺页之后<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span>​仅有一页不同&#xff1a;<span style=\"color:#888888\"></span><span style=\"text-align:left;font-weight:normal;font-size:16px;font-style:normal;direction:ltr\"></span></p></li></ol></li></ul>"}], "type": "question", "tags": ["lecture9", "student", "课堂问答"], "tag_good": [], "unique_views": 189, "children": [{"history_size": 1, "folders": [], "data": {"embed_links": []}, "created": "2019-03-27T07:17:27Z", "bucket_order": 3, "tag_endorse": [], "bucket_name": "Today", "history": [{"anon": "no", "uid": "jspklr3s9oOe", "subject": "", "created": "2019-03-27T07:17:27Z", "content": "<p>找到了一个证明的lecture&#xff0c;可供参考&#xff1a;<a href=\"https://cseweb.ucsd.edu/classes/wi12/cse202-a/lecture4-final.pdf\" target=\"_blank\">https://cseweb.ucsd.edu/classes/wi12/cse202-a/lecture4-final.pdf</a></p>"}], "type": "s_answer", "tag_endorse_arr": [], "children": [], "id": "jtqvmkgqtgb38", "config": {}, "is_tag_endorse": false}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>2016011277 孙桢波</p>\n<p></p>\n<md><br />设帧数为n时&#xff0c;内存中逻辑页面的集合为S(n)&#xff0c;可以证明在任意时间 $$S(n) \\subseteq S(n&#43;1)$$<br /></md>\n<p>设L(n)表示将S(n)中元素按将来访问时间排序从大到小排序的结果。</p>\n<p></p>\n<p>在访问序列中&#xff0c;按第一次出现的顺序&#xff0c;将逻辑页面编号为1, 2, 3, ...&#xff08;如访问顺序为1, 2, 1, 3, 2, 4...)&#xff0c;并令$$t_k$$表示编号为k的页面第一次出现的时间</p>\n<p></p>\n<p>假设&#xff1a;每一个时间点 t&#xff0c;都有 $$S(n) \\subseteq S(n&#43;1)$$。</p>\n<p></p>\n<p>证明如下&#xff1a;</p>\n<ol><li>t = 0 时&#xff0c;S(n) = S(n&#43;1) = $$\\emptyset$$&#xff0c;满足假设</li><li>$$ t &lt; t_{n&#43;1} $$时&#xff0c;此时S(n)和S(n&#43;1)的物理帧还没满&#xff0c;所以发生缺页时都会填入新页<ol><li>$$t_{k-1} &lt; t &lt; t_k, k \\le n &#43; 1$$&#xff0c;访问的页面编号不超过k - 1&#xff0c;而这些页面在之前已经被加载&#xff0c;所以不发生页缺失&#xff0c;S(n) = S(n&#43;1) = {1, 2, ..., k-1}&#xff0c;满足假设</li><li>$$t = t_k, k \\le n$$&#xff0c;第一次访问编号k的页面&#xff0c;同时发生缺失&#xff0c;之后S(n)  = S(n&#43;1) = {1, 2, ..., k}, 满足假设</li></ol></li><li>$$ t = t_{n &#43; 1}$$时\n<ul><li>此时&#xff0c;S(n)和S(n&#43;1)同时发生缺页&#xff0c;S(n)换出一页再换入编号为n&#43;1的页&#xff0c;而S(n&#43;1)直接加载编号为n&#43;1的页&#xff0c;所以$$S(n) \\subseteq S(n&#43;1)$$。</li></ul>\n</li><li>$$ t &gt; t_{n&#43;1}$$时&#xff0c;S(n)和S(n&#43;1)的物理内存都已经满了&#xff0c;可用归纳法证明上述假设<br /><ol><li>初始状态 $$ t = t_{n&#43;1}$$时&#xff0c;满足假设&#xff08;见3&#xff09;</li><li>假设t = m 时有$$S(n) \\subseteq S(n&#43;1)$$&#xff0c;则当t = m &#43; 1时<br />\n<ul><li>如果S(n)和S(n&#43;1)都访问正常&#xff0c;则S(n)和S(n&#43;1)都不发生变化。</li><li>如果S(n)访问异常&#xff0c;S(n&#43;1)访问正常&#xff0c;设访问前$$S(n&#43;1) = S(n) \\cup \\{x\\}$$&#xff0c;那么易知此时访问的是x&#xff0c;所以S(n)换出一页再换入x后&#xff0c;仍然满足$$S(n) \\subseteq S(n&#43;1)$$</li><li>如果S(n)和S(n&#43;1)均访问异常&#xff0c;设访问前$$S(n) = \\{s_1, s_2, ..., s_n\\}$$, $$S(n &#43; 1) = \\{s_1, s_2, ..., s_n, x\\}$$&#xff0c;将两者中元素按未来访问时间从大到小排序&#xff0c;可得到L(n)为$$\\{s&#39;_1, s&#39;_2, ..., s&#39;_{n-1}, s&#39;_n\\}$$, L(n&#43;1)为$$\\{s&#39;_1, s&#39;_2, ..., s&#39;_i, x, s&#39;_{i&#43;1}, ..., s&#39;_n\\}$$\n<ul><li>如果$$x &lt; s&#39;_n$$&#xff0c;则S(n)换出s&#39;n, S(n&#43;1)换出x, 再同时换入新页&#xff0c;依然满足$$S(n) \\subseteq S(n&#43;1)$$</li><li>如果$$x &gt; s&#39;_n$$, 则S(n)和S(n&#43;1)同时换出$$s&#39;_n$$换入新页&#xff0c;所以满足$$S(n) \\subseteq S(n&#43;1)$$</li></ul>\n</li></ul>\n</li></ol></li></ol>\n<p>综上所述&#xff0c;可以证得。</p>\n<p>所以易证不会出现Belady现象</p>\n<p></p>", "created": "2019-03-28T00:43:07Z", "bucket_order": 141, "bucket_name": "Week 3/24 - 3/30", "type": "followup", "tag_good": [{"role": "student", "name": "lizhenyucs@foxmail.com", "endorser": {}, "admin": false, "photo": null, "id": "k6ohbzaaubpz4", "photo_url": null, "published": true, "us": false, "facebook_id": null}, {"role": "student", "name": "AIyin", "endorser": {}, "admin": false, "photo": null, "id": "kv4x9ru7w196tt", "photo_url": null, "us": false, "facebook_id": null}], "uid": "jsiyf76cGzf9", "children": [], "tag_good_arr": ["k6ohbzaaubpz4", "kv4x9ru7w196tt"], "no_answer": 0, "id": "jtrwzbadpno4k8", "updated": "2019-03-28T00:43:07Z", "config": {}}], "tag_good_arr": [], "no_answer": 0, "id": "jtq0clt4a48714", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 3, "num_favorites": 2, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169684390, "default_anonymity": "no"}, "error": null, "aid": "kyv0syw65ef1q8"}