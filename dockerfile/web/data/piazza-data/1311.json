{"result": {"folders": ["lab1", "课堂问答", "2019"], "nr": 1311, "data": {"embed_links": []}, "created": "2019-04-23T08:19:43Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "jshne0ytr8i4nb", "data": "jutiqn6ymh19l", "type": "create", "when": "2019-04-23T08:19:43Z"}, {"anon": "no", "uid": "jshne0ytr8i4nb", "data": "jutkgxpqvq16fu", "type": "update", "when": "2019-04-23T09:08:09Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "data": "jutl1z9i31n6l", "type": "update", "when": "2019-04-23T09:24:31Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "ide小结", "created": "2019-04-23T09:24:31Z", "content": "<p>核心问题&#xff1a;Ide 是什么&#xff0c;和bootloader的关系<br />ide是电子集成驱动器&#xff0c;它的本意是指把硬盘控制器与盘体集成在一起的硬盘驱动器。一般每个主板上有两个IDE接口&#xff08;IDE1和IDE2&#xff09;&#xff0c;每个接口可以分别接两个硬盘或者两个光驱&#xff08;这也是为什么传统只有4个硬盘的原因吧&#xff09;一般来讲&#xff0c;主要的IDE接口是接硬盘的&#xff0c;次要的接光驱。<br />访问第一个硬盘的扇区可设置IO地址寄存器0x1f0-0x1f7实现的。一般第一个IDE通道通过访问IO地址0x1f0-0x1f7来实现&#xff0c;第二个IDE通道通过访问0x170-0x17f实现。每个通道的主从盘的选择通过第6个IO偏移地址寄存器来设置。<br /><img src=\"/img/1311-ecbe376683956d03.png\" alt=\"\" /><br />考虑到硬盘的最小访问单位是一个扇区&#xff0c;而一个扇区的大小为512&#xff08;2\\^8&#xff09;字节&#xff0c;所以需要8个连续扇区才能放置一个4KB的页。在ucore中&#xff0c;用了第二个IDE硬盘来保存被换出的扇区&#xff0c;根据实验三的输出信息<br />“ide 1: 262144(sectors), &#39;QEMU HARDDISK&#39;.”<br /><br />来自 &lt;https://blog.csdn.net/cs_assult/article/details/46553949&gt; <br />pizza问答&#xff1a;https://piazza.com/class/i5j09fnsl7k5x0?cid=1310<br /><br />相关问题&#xff1a;bootloader如何加载磁盘数据&#xff1f;<br />Bootloader的作用是加载内核到内存&#xff0c;是内开始执行&#xff0c;Grub是linux上面一个功能强大的bootloader<br /><br />来自 &lt;https://blog.csdn.net/tiankefeng19850520/article/details/22663111&gt; <br /><br />bootloader让CPU进入保护模式后&#xff0c;下一步的工作就是从硬盘上加载并运行OS。考虑到实现的简单性&#xff0c;bootloader的访问硬盘都是LBA模式的PIO&#xff08;Program IO&#xff09;方式&#xff0c;即所有的IO操作是通过CPU访问硬盘的IO地址寄存器完成。<br />当前 硬盘数据是储存到硬盘扇区中&#xff0c;一个扇区大小为512字节。读一个扇区的流程&#xff08;可参看boot/bootmain.c中的readsect函数实现&#xff09;大致如下&#xff1a;<br />1. 等待磁盘准备好<br />2. 发出读取扇区的命令<br />3. 等待磁盘准备好<br />4. 把磁盘扇区数据读到指定内存<br />&#96;&#96;&#96; c<br />/* readsect - read a single sector at &#64;secno into &#64;dst */<br />static void<br />readsect(void *dst, uint32_t secno) {<br /> // wait for disk to be ready<br /> waitdisk();<br /><br /> outb(0x1F2, 1); // count = 1<br /> outb(0x1F3, secno &amp; 0xFF);<br /> outb(0x1F4, (secno &gt;&gt; 8) &amp; 0xFF);<br /> outb(0x1F5, (secno &gt;&gt; 16) &amp; 0xFF);<br /> outb(0x1F6, ((secno &gt;&gt; 24) &amp; 0xF) | 0xE0);<br /> outb(0x1F7, 0x20); // cmd 0x20 - read sectors<br /><br /> // wait for disk to be ready<br /> waitdisk();<br /><br /> // read a sector<br /> insl(0x1F0, dst, SECTSIZE / 4);<br />} &#96;&#96;&#96;<br /> 以及在ide_init()也有相关的实现<br />&#96;&#96;&#96; c<br />/* wait device ready */<br /> ide_wait_ready(iobase, 0);<br /><br /> /* step1: select drive */<br /> outb(iobase &#43; ISA_SDH, 0xE0 | ((ideno &amp; 1) &lt;&lt; 4));<br /> ide_wait_ready(iobase, 0);<br /><br /> /* step2: send ATA identify command */<br /> outb(iobase &#43; ISA_COMMAND, IDE_CMD_IDENTIFY);<br /> ide_wait_ready(iobase, 0);<br /><br /> /* step3: polling */<br /> if (inb(iobase &#43; ISA_STATUS) == 0 || ide_wait_ready(iobase, 1) != 0) {<br /> continue ;<br /> } &#96;&#96;&#96;<br />其中 waitdisk是等待磁盘准备函数&#xff0c;它读取0x1f7&#xff08;状态、命令寄存器&#xff09;的高两位&#xff0c;当磁盘不忙时为01,ide.c的宏#IDE_BSY 0x80//高两位是10&#xff0c; #IDE_DRDY 0x40<br /><br />这部分outb的输出和下面链接相关&#xff08;LBS模式是可以突破512字节限制的模式&#xff0c;具体原理不求甚解了&#xff09;<br />https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1/lab1_3_2_3_dist_accessing.html<br />以上回答了如何读磁盘数据<br /><br /><br />延伸问题&#xff1a;<br />读取特定磁盘数据如何设置寄存器&#xff1f;<br />上一个问题“如何读磁盘数据”&#xff0c;主要针对读取流程&#xff0c;先等磁盘准备=》设置相应位=》发出读取命令=》等磁盘稳定<br />这个问题针对读取设置<br />初始化参考ide_init()的实现<br /> outb(iobase &#43; ISA_SDH, 0xE0 | ((ideno &amp; 1) &lt;&lt; 4));<br />对应实验指导书<br />0x1f6 第4位&#xff1a;为0主盘&#xff1b;为1从盘 设置ideno的主从<br /> outb(iobase &#43; ISA_COMMAND, IDE_CMD_IDENTIFY);<br />按道理对应<br />0x1f7 状态和命令寄存器。操作时先给命令&#xff0c;再读取&#xff0c;如果不是忙状态就从0x1f0端口读数据<br />IDE_CMD_IDENTIFY // IDE识别命令,用于鉴别设备<br />具体读取参考bootmain.c,把secno写入到1F3~1F6中&#xff0c;最高四位固定0xE<br />&#96;&#96;&#96; c<br /> outb(0x1F2, 1); // count = 1<br /> outb(0x1F3, secno &amp; 0xFF);<br /> outb(0x1F4, (secno &gt;&gt; 8) &amp; 0xFF);<br /> outb(0x1F5, (secno &gt;&gt; 16) &amp; 0xFF);<br /> outb(0x1F6, ((secno &gt;&gt; 24) &amp; 0xF) | 0xE0);<br />&#96;&#96;&#96;<br /><br /><br />感谢路橙助教和向老师的解答</p>"}, {"anon": "no", "uid": "jshne0ytr8i4nb", "subject": "ide小结", "created": "2019-04-23T09:08:09Z", "content": "核心问题&#xff1a;Ide 是什么&#xff0c;和bootloader的关系\nide是电子集成驱动器&#xff0c;它的本意是指把硬盘控制器与盘体集成在一起的硬盘驱动器。一般每个主板上有两个IDE接口&#xff08;IDE1和IDE2&#xff09;&#xff0c;每个接口可以分别接两个硬盘或者两个光驱&#xff08;这也是为什么传统只有4个硬盘的原因吧&#xff09;一般来讲&#xff0c;主要的IDE接口是接硬盘的&#xff0c;次要的接光驱。\n访问第一个硬盘的扇区可设置IO地址寄存器0x1f0-0x1f7实现的。一般第一个IDE通道通过访问IO地址0x1f0-0x1f7来实现&#xff0c;第二个IDE通道通过访问0x170-0x17f实现。每个通道的主从盘的选择通过第6个IO偏移地址寄存器来设置。\n<img src=\"/img/1311-ecbe376683956d03.png\" alt=\"\" />\n考虑到硬盘的最小访问单位是一个扇区&#xff0c;而一个扇区的大小为512&#xff08;2\\^8&#xff09;字节&#xff0c;所以需要8个连续扇区才能放置一个4KB的页。在ucore中&#xff0c;用了第二个IDE硬盘来保存被换出的扇区&#xff0c;根据实验三的输出信息\n“ide 1: 262144(sectors), &#39;QEMU HARDDISK&#39;.”\n\n来自 &lt;https://blog.csdn.net/cs_assult/article/details/46553949&gt; \npizza问答&#xff1a;https://piazza.com/class/i5j09fnsl7k5x0?cid=1310\n\n相关问题&#xff1a;bootloader如何加载磁盘数据&#xff1f;\nBootloader的作用是加载内核到内存&#xff0c;是内开始执行&#xff0c;Grub是linux上面一个功能强大的bootloader\n\n来自 &lt;https://blog.csdn.net/tiankefeng19850520/article/details/22663111&gt; \n\nbootloader让CPU进入保护模式后&#xff0c;下一步的工作就是从硬盘上加载并运行OS。考虑到实现的简单性&#xff0c;bootloader的访问硬盘都是LBA模式的PIO&#xff08;Program IO&#xff09;方式&#xff0c;即所有的IO操作是通过CPU访问硬盘的IO地址寄存器完成。\n当前 硬盘数据是储存到硬盘扇区中&#xff0c;一个扇区大小为512字节。读一个扇区的流程&#xff08;可参看boot/bootmain.c中的readsect函数实现&#xff09;大致如下&#xff1a;\n1. 等待磁盘准备好\n2. 发出读取扇区的命令\n3. 等待磁盘准备好\n4. 把磁盘扇区数据读到指定内存\n&#96;&#96;&#96; c\n/* readsect - read a single sector at &#64;secno into &#64;dst */\nstatic void\nreadsect(void *dst, uint32_t secno) {\n // wait for disk to be ready\n waitdisk();\n\n outb(0x1F2, 1); // count = 1\n outb(0x1F3, secno &amp; 0xFF);\n outb(0x1F4, (secno &gt;&gt; 8) &amp; 0xFF);\n outb(0x1F5, (secno &gt;&gt; 16) &amp; 0xFF);\n outb(0x1F6, ((secno &gt;&gt; 24) &amp; 0xF) | 0xE0);\n outb(0x1F7, 0x20); // cmd 0x20 - read sectors\n\n // wait for disk to be ready\n waitdisk();\n\n // read a sector\n insl(0x1F0, dst, SECTSIZE / 4);\n}\n\n&#96;&#96;&#96;\n 以及在ide_init()也有相关的实现\n&#96;&#96;&#96; c\n/* wait device ready */\n ide_wait_ready(iobase, 0);\n\n /* step1: select drive */\n outb(iobase &#43; ISA_SDH, 0xE0 | ((ideno &amp; 1) &lt;&lt; 4));\n ide_wait_ready(iobase, 0);\n\n /* step2: send ATA identify command */\n outb(iobase &#43; ISA_COMMAND, IDE_CMD_IDENTIFY);\n ide_wait_ready(iobase, 0);\n\n /* step3: polling */\n if (inb(iobase &#43; ISA_STATUS) == 0 || ide_wait_ready(iobase, 1) != 0) {\n continue ;\n }\n\n&#96;&#96;&#96;\n其中 waitdisk是等待磁盘准备函数&#xff0c;它读取0x1f7&#xff08;状态、命令寄存器&#xff09;的高两位&#xff0c;当磁盘不忙时为01,ide.c的宏#IDE_BSY 0x80//高两位是10&#xff0c; #IDE_DRDY 0x40\n\n这部分outb的输出和下面链接相关&#xff08;LBS模式是可以突破512字节限制的模式&#xff0c;具体原理不求甚解了&#xff09;\nhttps://chyyuu.gitbooks.io/ucore_os_docs/content/lab1/lab1_3_2_3_dist_accessing.html\n以上回答了如何读磁盘数据\n\n\n延伸问题&#xff1a;\n读取特定磁盘数据如何设置寄存器&#xff1f;\n上一个问题“如何读磁盘数据”&#xff0c;主要针对读取流程&#xff0c;先等磁盘准备=》设置相应位=》发出读取命令=》等磁盘稳定\n这个问题针对读取设置\n初始化参考ide_init()的实现\n        outb(iobase &#43; ISA_SDH, 0xE0 | ((ideno &amp; 1) &lt;&lt; 4));\n对应实验指导书\n0x1f6\t 第4位&#xff1a;为0主盘&#xff1b;为1从盘 设置ideno的主从\n outb(iobase &#43; ISA_COMMAND, IDE_CMD_IDENTIFY);\n按道理对应\n0x1f7\t状态和命令寄存器。操作时先给命令&#xff0c;再读取&#xff0c;如果不是忙状态就从0x1f0端口读数据\nIDE_CMD_IDENTIFY // IDE识别命令,用于鉴别设备\n具体读取参考bootmain.c,把secno写入到1F3~1F6中&#xff0c;最高四位固定0xE\n&#96;&#96;&#96; c\n outb(0x1F2, 1);                         // count = 1\n    outb(0x1F3, secno &amp; 0xFF);\n    outb(0x1F4, (secno &gt;&gt; 8) &amp; 0xFF);\n    outb(0x1F5, (secno &gt;&gt; 16) &amp; 0xFF);\n    outb(0x1F6, ((secno &gt;&gt; 24) &amp; 0xF) | 0xE0);\n&#96;&#96;&#96;\n\n\n感谢路橙助教和向老师的解答"}, {"anon": "no", "uid": "jshne0ytr8i4nb", "subject": "ide小结", "created": "2019-04-23T08:19:43Z", "content": "核心问题&#xff1a;Ide 是什么&#xff0c;和bootloader的关系\nide是电子集成驱动器&#xff0c;它的本意是指把硬盘控制器与盘体集成在一起的硬盘驱动器。一般每个主板上有两个IDE接口&#xff08;IDE1和IDE2&#xff09;&#xff0c;每个接口可以分别接两个硬盘或者两个光驱&#xff08;这也是为什么传统只有4个硬盘的原因吧&#xff09;一般来讲&#xff0c;主要的IDE接口是接硬盘的&#xff0c;次要的接光驱。\n访问第一个硬盘的扇区可设置IO地址寄存器0x1f0-0x1f7实现的。一般第一个IDE通道通过访问IO地址0x1f0-0x1f7来实现&#xff0c;第二个IDE通道通过访问0x170-0x17f实现。每个通道的主从盘的选择通过第6个IO偏移地址寄存器来设置。\n<img src=\"/img/1311-ecbe376683956d03.png\" alt=\"\" />\n考虑到硬盘的最小访问单位是一个扇区&#xff0c;而一个扇区的大小为512&#xff08;2\\^8&#xff09;字节&#xff0c;所以需要8个连续扇区才能放置一个4KB的页。在ucore中&#xff0c;用了第二个IDE硬盘来保存被换出的扇区&#xff0c;根据实验三的输出信息\n“ide 1: 262144(sectors), &#39;QEMU HARDDISK&#39;.”\n\n来自 &lt;https://blog.csdn.net/cs_assult/article/details/46553949&gt; \npizza问答&#xff1a;https://piazza.com/class/i5j09fnsl7k5x0?cid=1310\n\n相关问题&#xff1a;bootloader如何加载磁盘数据&#xff1f;\nBootloader的作用是加载内核到内存&#xff0c;是内开始执行&#xff0c;Grub是linux上面一个功能强大的bootloader\n\n来自 &lt;https://blog.csdn.net/tiankefeng19850520/article/details/22663111&gt; \n\nbootloader让CPU进入保护模式后&#xff0c;下一步的工作就是从硬盘上加载并运行OS。考虑到实现的简单性&#xff0c;bootloader的访问硬盘都是LBA模式的PIO&#xff08;Program IO&#xff09;方式&#xff0c;即所有的IO操作是通过CPU访问硬盘的IO地址寄存器完成。\n当前 硬盘数据是储存到硬盘扇区中&#xff0c;一个扇区大小为512字节。读一个扇区的流程&#xff08;可参看boot/bootmain.c中的readsect函数实现&#xff09;大致如下&#xff1a;\n1. 等待磁盘准备好\n2. 发出读取扇区的命令\n3. 等待磁盘准备好\n4. 把磁盘扇区数据读到指定内存\n&#96;&#96;&#96; c\n/* readsect - read a single sector at &#64;secno into &#64;dst */\nstatic void\nreadsect(void *dst, uint32_t secno) {\n // wait for disk to be ready\n waitdisk();\n\n outb(0x1F2, 1); // count = 1\n outb(0x1F3, secno &amp; 0xFF);\n outb(0x1F4, (secno &gt;&gt; 8) &amp; 0xFF);\n outb(0x1F5, (secno &gt;&gt; 16) &amp; 0xFF);\n outb(0x1F6, ((secno &gt;&gt; 24) &amp; 0xF) | 0xE0);\n outb(0x1F7, 0x20); // cmd 0x20 - read sectors\n\n // wait for disk to be ready\n waitdisk();\n\n // read a sector\n insl(0x1F0, dst, SECTSIZE / 4);\n}\n\n&#96;&#96;&#96;\n 以及在ide_init()也有相关的实现\n&#96;&#96;&#96; c\n/* wait device ready */\n ide_wait_ready(iobase, 0);\n\n /* step1: select drive */\n outb(iobase &#43; ISA_SDH, 0xE0 | ((ideno &amp; 1) &lt;&lt; 4));\n ide_wait_ready(iobase, 0);\n\n /* step2: send ATA identify command */\n outb(iobase &#43; ISA_COMMAND, IDE_CMD_IDENTIFY);\n ide_wait_ready(iobase, 0);\n\n /* step3: polling */\n if (inb(iobase &#43; ISA_STATUS) == 0 || ide_wait_ready(iobase, 1) != 0) {\n continue ;\n }\n\n&#96;&#96;&#96;\n\n这部分outb的输出和下面链接相关&#xff08;LBS模式是可以突破512字节限制的模式&#xff0c;具体原理不求甚解了&#xff09;\nhttps://chyyuu.gitbooks.io/ucore_os_docs/content/lab1/lab1_3_2_3_dist_accessing.html\n感谢路橙助教和向老师的解答"}], "type": "note", "tags": ["2019", "lab1", "student", "课堂问答"], "tag_good": [{"role": "student", "name": "289212182@qq.com", "endorser": {}, "admin": false, "photo": "1551463481_35.png", "id": "j7f1tr6wJNH", "photo_url": "https://d1b10bmlvqabco.cloudfront.net/photos/j7f1tr6wJNH/1551463481_35.png", "published": true, "us": false, "facebook_id": null}], "unique_views": 126, "children": [], "tag_good_arr": ["j7f1tr6wJNH"], "id": "jutiqn5490o9j", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 3, "num_favorites": 0, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169720090, "default_anonymity": "no"}, "error": null, "aid": "kyv0tqfuvwl55l"}