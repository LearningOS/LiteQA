{"result": {"folders": ["lab5"], "nr": 837, "data": {"embed_links": []}, "created": "2016-04-27T02:15:08Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"uid": "im5xso4yv3Q", "anon": "no", "when": "2016-04-27T02:15:08Z", "data": "ini8beyhpj83yv", "type": "create"}, {"to": "ini8beyfuvl3yu", "uid": "i76z9sx78G8", "anon": "no", "when": "2016-04-29T01:43:41Z", "data": "inl22ot9i8d57z", "type": "i_answer"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "im5xso4yv3Q", "subject": "lab trap实现里有两个分支有什么含意", "created": "2016-04-27T02:15:08Z", "content": "<p>void trap(struct trapframe *tf)</p>\n<p>{</p>\n<p>// dispatch based on what type of trap occurred</p>\n<p>// used for previous projects</p>\n<p>          if (current == NULL)  //这个为空操作为了处理哪一种中断请求</p>\n<p>          {</p>\n<p>                  trap_dispatch(tf);</p>\n<p>           } else</p>\n<p>           {</p>\n<p>           // keep a trapframe chain in stack</p>\n<p>           struct trapframe *otf = current-&gt;tf;   //这里保存current-&gt;tf 是什么作用&#xff1f;&#xff1f;&#xff1f;&#xff1f;</p>\n<p>            current-&gt;tf = tf;             //这里让current-&gt;tf指向tf有什么作用&#xff1f;&#xff1f;&#xff1f;&#xff1f;</p>\n<p>            bool in_kernel = trap_in_kernel(tf);                </p>\n<p>            trap_dispatch(tf);</p>\n<p>            current-&gt;tf = otf;    //这里进行恢复操又有什么作用&#xff1f;&#xff1f; 如果嵌套中断&#xff0c;这里有什么怎样的作用&#xff0c;没有分析出析。望解答</p>\n<p>             if (!in_kernel)</p>\n<p>             {</p>\n<p>                  if (current-&gt;flags &amp; PF_EXITING)   //这里是当前进程被杀掉&#xff0c;那么就直接回收 &#xff0c;为的kill调用</p>\n<p>                  {</p>\n<p>                       do_exit(-E_KILLED);</p>\n<p>                   }</p>\n<p>                   if (current-&gt;need_resched)   //这个是为了 yield的凋用</p>\n<p>                   {</p>\n<p>                        schedule();</p>\n<p>                    }</p>\n<p>              }</p>\n<p>            }</p>\n<p>}</p>"}], "type": "question", "tags": ["lab5", "student"], "tag_good": [], "unique_views": 121, "children": [{"folders": [], "data": {"embed_links": []}, "children": [], "created": "2016-04-29T01:43:41Z", "bucket_order": 3, "tag_endorse": [], "bucket_name": "Today", "id": "inl22ot6iuz57y", "history": [{"anon": "no", "uid": "i76z9sx78G8", "subject": "", "created": "2016-04-29T01:43:41Z", "content": "<p>空操作是在第一个进程完成初始化之前的情况。</p>\n<p>对current的tf进行保存&#xff0c;然后处理当前的tf。这种情况发生在nesting interrupt.</p>"}], "type": "i_answer", "tag_endorse_arr": [], "config": {}, "is_tag_endorse": false}], "tag_good_arr": [], "no_answer": 0, "id": "ini8beyfuvl3yu", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 4, "num_favorites": 0, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643168601132, "default_anonymity": "no"}, "error": null, "aid": "kyv05r1oxqq46u"}