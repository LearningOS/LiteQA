{"result": {"folders": ["2020", "课堂问答", "lecture7"], "nr": 1426, "data": {"embed_links": []}, "created": "2020-03-12T02:11:35Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "hdjonbiyfs62ie", "data": "k7o498447u43vs", "type": "create", "when": "2020-03-12T02:11:35Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "x86-32上4KB页面的自映射页表项的位置", "created": "2020-03-12T02:11:35Z", "content": "<p>下面是曹鼎原的分析&#xff0c;请同学们继续完善和问题。希望通过讨论&#xff0c;能比较清楚地描述出计算x86-32上4KB页面的一级自映射页表项和每个二级自映射页表项的位置计算过程。</p>\n<p></p>\n<p>32位系统每一个页表项为4字节&#xff0c;所以页表项在内存中为4字节对齐。我们可以把32位的地址分为三段来索引页表。</p>\n<p>31-22  pde</p>\n<p>21-12  pte</p>\n<p>11-0    offset&#xff08;在索引页表的时候可以看作11-2&#xff0c;由于对齐&#xff09;</p>\n<p>以下结论都是在虚拟地址里考虑</p>\n<p>假设我们把整个页表放在0xD0000000&#xff0c;我们要找到自映射页表项的地址。首先需要用pde基地址加上0xD0000000的高10位(0x340)来访问页表所在的4MB空间的pte的基址。而由于我们是连续分配了4MB放置所有的页表项&#xff0c;我们可以直接用0xD0000000 &#43; (0x340 &lt;&lt; 10)来访问&#xff01;下面来寻找自映射的pte。由于我们刚刚的分析&#xff0c;自映射页表项应该在页表基地址(0xD0000000)加上(0x340 &lt;&lt; 10)的这一页中&#xff0c;那么自映射的pte需要指向这一页。如何做到呢&#xff1f;不难发现&#xff0c;这个pte在这一页中的偏移正好是0x340&#xff01;所以我们得到了一个简单的公式&#xff1a;假设自映射页表地址为addr&#xff0c;设其高10位为A。那么自映射页表项的地址为&#xff1a;</p>\n<p>A || A || A || 00</p>\n<p>&#xff08;其中 || 表示位连接&#xff09;</p>\n<p>下面回答几个问题&#xff1a;</p>\n<p>第一级页表同时也是一个第二级页表&#xff0c;那么在第二级中它的偏移是&#xff1f;</p>\n<p>设页表基地址的高10位为A&#xff0c;那么它在第二级中的偏移为A</p>\n<p>第二级页表的自映射地址在哪&#xff1f;</p>\n<p>第k个第二级页表在上一问中自映射了第一级页表的第二级页表内偏移k处</p>"}], "type": "note", "tags": ["2020", "instructor-note", "lecture7", "课堂问答"], "tag_good": [], "unique_views": 146, "children": [], "tag_good_arr": [], "id": "k7o49841de3vr", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 1, "num_favorites": 1, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643170018940, "default_anonymity": "no"}, "error": null, "aid": "kyv105187my10f"}