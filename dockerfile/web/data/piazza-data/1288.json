{"result": {"folders": ["2019", "lecture8", "课堂问答"], "nr": 1288, "data": {"embed_links": []}, "created": "2019-03-20T15:18:11Z", "bucket_order": 3, "no_answer_followup": 5, "change_log": [{"anon": "no", "uid": "hdjonbiyfs62ie", "data": "jthcpu748pq6rk", "type": "create", "when": "2019-03-20T15:18:11Z"}, {"anon": "no", "uid": "jshne1wk6724of", "to": "jthcpu71m9k6rj", "type": "followup", "when": "2019-03-21T01:27:20Z"}, {"anon": "no", "uid": "jslfact6jvaN", "to": "jthcpu71m9k6rj", "type": "followup", "when": "2019-03-24T09:35:32Z"}, {"anon": "no", "uid": "jshndy9fxmm4as", "to": "jthcpu71m9k6rj", "type": "followup", "when": "2019-03-24T11:26:48Z"}, {"anon": "no", "uid": "jshndz5tgxj4bq", "to": "jthcpu71m9k6rj", "type": "followup", "when": "2019-03-25T00:28:54Z"}, {"anon": "no", "uid": "jshndz5tgxj4bq", "to": "jthcpu71m9k6rj", "type": "feedback", "when": "2019-03-25T01:15:37Z"}, {"anon": "no", "uid": "jshne3teufu4qt", "to": "jthcpu71m9k6rj", "type": "followup", "when": "2019-03-25T01:36:43Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "2019春季-第八讲课堂实践练习", "created": "2019-03-20T15:18:11Z", "content": "<p>有一台假想的计算机&#xff0c;页大小&#xff08;page size&#xff09;为32 Bytes&#xff0c;支持8KB的虚拟地址空间&#xff08;virtual address space&#xff09;,有4KB的物理内存空间&#xff08;physical memory&#xff09;&#xff0c;采用二级页表&#xff0c;一个页目录项&#xff08;page directory entry &#xff0c;PDE&#xff09;大小为1 Byte,一个页表项&#xff08;page-table entries PTEs&#xff09;大小为1 Byte&#xff0c;1个页目录表大小为32 Bytes&#xff0c;1个页表大小为32 Bytes。页目录基址寄存器&#xff08;page directory base register&#xff0c;PDBR&#xff09;保存了页目录表的物理地址&#xff08;按页对齐&#xff09;。</p>\n<p></p>\n<p>请手工计算后回答下列虚地址是否有合法对应的物理内存&#xff0c;请给出对应的pde index, pde contents, pte index, pte contents&#xff0c;the value of addr in phy page OR disk sector。</p>\n<p></p>\n<p>请写出一个translation程序&#xff08;可基于rust、python、ruby、C、C&#43;&#43;、LISP、JavaScript等&#xff09;&#xff0c;输入是一个虚拟地址&#xff0c;依据物理内存模拟数据文件自动计算出对应的pde index, pde contents, pte index, pte contents&#xff0c;the value of addr in phy page OR disk sector。</p>\n<p></p>\n<p>题目&#xff1a;</p>\n<p><a href=\"https://github.com/chyyuu/os_course_exercises/blob/2019spring/all/04-1-spoc-discussion.md#%E8%99%9A%E6%8B%9F%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2\">https://github.com/chyyuu/os_course_exercises/blob/2019spring/all/04-1-spoc-discussion.md#%E8%99%9A%E6%8B%9F%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2</a></p>\n<p></p>\n<p>然后比较你的回答与往届同学的参考回复有什么不同&#xff0c;并说明原因。</p>\n<p></p>\n<p>下面是往届同学的参考回答&#xff1a;<br /><a href=\"/class/i5j09fnsl7k5x0?cid=1172\">https://piazza.com/class/i5j09fnsl7k5x0?cid=1172</a></p>\n<p><a href=\"/class/i5j09fnsl7k5x0?cid=1012\">https://piazza.com/class/i5j09fnsl7k5x0?cid=1012</a></p>\n<p><a href=\"/class/i5j09fnsl7k5x0?cid=696\">https://piazza.com/class/i5j09fnsl7k5x0?cid=696</a></p>\n<p><a href=\"/class/i5j09fnsl7k5x0?cid=700\">https://piazza.com/class/i5j09fnsl7k5x0?cid=700</a></p>"}], "type": "note", "tags": ["2019", "instructor-note", "lecture8", "课堂问答"], "tag_good": [], "unique_views": 163, "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>C语言版。</p>\n<pre>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint pdbr = 0xd80;\nint disk[128][32];\nint memory[128][32];\n\nvoid read_m(char* filename, int m[][32])\n{\n    FILE* fp;\n    char temp[2];\n    char line[1024];\n    if((fp = fopen(filename, &#34;r&#34;)) == NULL)\n    {\n        printf(&#34;file not found!&#34;);\n        return;\n    }\n    for (int i = 0; i &lt; 128; i&#43;&#43;)\n    {\n        char temp[3];\n        temp[2] = &#39;\\0&#39;;\n        fgets(line, 1024, fp);\n        for (int j = 0; j &lt; 32; j&#43;&#43;)\n        {\n            temp[0] = line[3*j&#43;9];\n            temp[1] = line[3*j&#43;10];\n            sscanf(temp, &#34;%x&#34;, &amp;m[i][j]);\n        }\n    }\n    fclose(fp);\n}\n\nvoid process_va(int va)\n{\n    printf(&#34;Virtual Address %x:\\n&#34;, va);\n    int pde_index = va &gt;&gt; 10;\n    int pde_contents = *((int*)memory&#43;pdbr&#43;pde_index);\n    int pde_valid = pde_contents &gt;&gt; 7;\n    int pde_pfn = pde_contents &amp; 0x7f;\n    printf(&#34;  --&gt; pde index:0x%x  pde contents:(valid %d, pfn 0x%x)\\n&#34;, pde_index, pde_valid, pde_pfn);\n    if (pde_valid == 0)\n    {\n        printf(&#34;Not valid!\\n\\n&#34;);\n        return;\n    }\n    int pte_index = (va &gt;&gt; 5) &amp; 0x1f;\n    int pte_contents = *((int*)memory&#43;pde_pfn*32&#43;pte_index);\n    int pte_valid = pte_contents &gt;&gt; 7;\n    int pte_pfn = pte_contents &amp; 0x7f;\n    printf(&#34;    --&gt; pte index:0x%x  pte contents:(valid %x, pfn 0x%x)\\n&#34;, pte_index, pte_valid, pte_pfn);\n    if (pte_pfn == 0x7f)\n    {\n        printf(&#34;No page!\\n\\n&#34;);\n        return;\n    }\n    int* m;\n    char* d;\n    if (pte_valid == 0)\n    {\n        m = disk;\n        d = &#34;Disk Sector&#34;;\n    }\n    else\n    {\n        m = memory;\n        d = &#34;Physical&#34;;\n    }\n\n    int pa = (pte_pfn*32)&#43;(va&amp;0x1f);\n    int v = *(m&#43;pa);\n    printf(&#34;      --&gt; To %s Address 0x%x --&gt; Value: %x\\n\\n&#34;, d, pa, v);\n}\n\nint main()\n{\n    read_m(&#34;MEMORY.txt&#34;, memory);\n    read_m(&#34;DISK.txt&#34;, disk);\n    process_va(0x6653);\n    process_va(0x1c13);\n    process_va(0x6890);\n    process_va(0x0af6);\n    process_va(0x1e6f);\n    return 0;\n}</pre>\n<p>一一映射在多次换出同一地址的内容时会造成覆盖与冲突&#xff0c;可改进为虚拟内存管理器。</p>\n<p></p>", "created": "2019-03-21T01:27:20Z", "bucket_order": 53, "bucket_name": "Week 3/17 - 3/23", "type": "followup", "tag_good": [], "uid": "jshne1wk6724of", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "jthyh7e1t8fzx", "updated": "2019-03-21T01:27:20Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p></p><pre>#include&lt;fstream&gt;\n#include&lt;cstring&gt;\n#include&lt;cstdio&gt;\n#include&lt;iomanip&gt;\n#include&lt;iostream&gt;\n\nusing namespace std;\n\nint physical[128][32];\nint disk[128][32];\n\nvoid printbit(int a, int length){\n    for(int i = length - 1; i &gt;=0; i--){\n        cout &lt;&lt; ((a &gt;&gt; i) &amp; 1);\n    }\n}\n\nvoid printphysical(int pagenum){\n    cout &lt;&lt; &#34;  page &#34; &lt;&lt; hex &lt;&lt; setw(2) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; pagenum &lt;&lt; &#34;: &#34;;\n    for(int j = 0; j &lt; 32; j&#43;&#43;){\n        cout &lt;&lt; hex &lt;&lt; setw(2) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; physical[pagenum][j] &lt;&lt; &#39; &#39;;\n    }\n    cout &lt;&lt; endl;\n}\n\nvoid printdisk(int disknum){\n    cout &lt;&lt; &#34;  disk &#34; &lt;&lt; hex &lt;&lt; setw(2) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; disknum &lt;&lt; &#34;: &#34;;\n    for(int j = 0; j &lt; 32; j&#43;&#43;){\n        cout &lt;&lt; hex &lt;&lt; setw(2) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; disk[disknum][j] &lt;&lt; &#39; &#39;;\n    }\n    cout &lt;&lt; endl;\n}\n\nint main()\n{\n    int a = 0;\n    int pdbr = 0xd80;\n    char str[256];\n    char byte[3];\n    ifstream phy(&#34;physical.txt&#34;);\n    int line = 0;\n    // read physical address, every row is a page\n    for(line = 0; line &lt; 128; line&#43;&#43;){\n        phy.getline(str, 256);\n        for(int i = 0; i &lt; 32; i&#43;&#43;){\n            byte[0] = str[9 &#43; 3 * i];\n            byte[1] = str[10 &#43; 3 * i];\n            byte[2] = 0;\n            sscanf(byte, &#34;%x&#34;, &amp;physical[line][i]);\n        }\n    }\n    // read disk, every row is a page\n    for(; line &lt; 256; line&#43;&#43;){\n        phy.getline(str, 256);\n        for(int i = 0; i &lt; 32; i&#43;&#43;){\n            byte[0] = str[9 &#43; 3 * i];\n            byte[1] = str[10 &#43; 3 * i];\n            byte[2] = 0;\n            sscanf(byte, &#34;%x&#34;, &amp;disk[line - 128][i]);\n        }\n    }\n    phy.close();\n    ifstream infile;\n    infile.open(&#34;virtualaddress.txt&#34;);\n    while(!infile.eof()){\n        infile.getline(str, 256);\n        sscanf(str, &#34;%x&#34;, &amp;a);\n        cout &lt;&lt; &#34;Virtual Address &#34;;\n        cout &lt;&lt; hex &lt;&lt; setw(4) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; a &lt;&lt; &#34;(&#34;;\n        for(int i = 15; i &gt;=0; i--){\n            cout &lt;&lt; ((a &gt;&gt; i) &amp; 1);\n            if((i == 10) || (i == 5) || (i == 15)){\n                cout &lt;&lt; &#39; &#39;;\n            }\n        }\n        cout &lt;&lt; &#39;)&#39; &lt;&lt; endl;\n        int pde = (a &gt;&gt; 10);\n        int pde_content = physical[(pdbr &gt;&gt; 5)][pde]; // pde&#39;s base address is 0x220\n        int valid = pde_content &gt;&gt; 7;\n        int pt = pde_content &amp; 0x7f;\n        cout &lt;&lt; hex &lt;&lt; &#34;  --&gt; pde index:0x&#34; &lt;&lt; pde &lt;&lt; &#39;(&#39;;\n        printbit(pde, 5);\n        cout &lt;&lt; hex &lt;&lt; &#34;) pde contents:(0x&#34; &lt;&lt; pde_content &lt;&lt; &#34;, &#34;;\n        printbit(pde_content, 8);\n        cout &lt;&lt; hex &lt;&lt; &#34;, valid &#34; &lt;&lt; valid &lt;&lt; &#34;, pfn0x&#34; &lt;&lt; pt &lt;&lt; &#34;(page 0x&#34; &lt;&lt; pt &lt;&lt; &#34;))&#34; &lt;&lt; endl;\n        printphysical(pdbr &gt;&gt; 5);\n        if(valid == 0){\n            cout &lt;&lt; &#34;  内存映射不存在&#xff01;&#34; &lt;&lt; endl;\n            cout &lt;&lt; endl;\n            continue;\n        }\n        printphysical(pt);\n        int pte = (a &gt;&gt; 5) &amp; 0x1f;\n        int pte_content = physical[pt][pte];\n        int pt_valid = pte_content &gt;&gt; 7;\n        int pfn = pte_content &amp; 0x7f;\n        int address = (pfn &lt;&lt; 5) &#43; (a &amp; 0x1f);\n        cout &lt;&lt; hex &lt;&lt; &#34;    --&gt; pte index:0x&#34; &lt;&lt; pte &lt;&lt; &#39;(&#39;;\n        printbit(pte, 5);\n        cout &lt;&lt; hex &lt;&lt; &#34;) pte contents:(0x&#34; &lt;&lt; pte_content &lt;&lt; &#34;, &#34;;\n        printbit(pte_content, 8);\n        cout &lt;&lt; hex &lt;&lt; &#34;, valid &#34; &lt;&lt; pt_valid &lt;&lt; &#34;, pfn0x&#34; &lt;&lt; pfn &lt;&lt; &#34;)&#34; &lt;&lt; endl;\n        if(pt_valid == 1){\n            printphysical(pfn);\n            cout &lt;&lt; &#34;      --&gt; To Physical Address 0x&#34; &lt;&lt; hex &lt;&lt; address &lt;&lt; &#34;(&#34;;\n            printbit(address, 12);\n            cout &lt;&lt; &#34;) --&gt; Value: &#34; &lt;&lt; hex &lt;&lt; setw(2) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; physical[pfn][address &amp; 0x1f] &lt;&lt; endl;\n        }\n        else{\n            printdisk(pfn);\n            cout &lt;&lt; &#34;      --&gt; To Disk Sector Address 0x&#34; &lt;&lt; hex &lt;&lt; address &lt;&lt; &#34;(&#34;;\n            printbit(address, 12);\n            cout &lt;&lt; &#34;) --&gt; Value: &#34; &lt;&lt; hex &lt;&lt; setw(2) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; disk[pfn][address &amp; 0x1f] &lt;&lt; endl;\n        }\n        cout &lt;&lt; endl;\n    }\n    infile.close();\n    return 0;\n}</pre>\n<p>C&#43;&#43;版本</p>", "created": "2019-03-24T09:35:32Z", "bucket_order": 52, "bucket_name": "Week 3/24 - 3/30", "type": "followup", "tag_good": [], "uid": "jslfact6jvaN", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "jtmq8l7kur97a4", "updated": "2019-03-24T09:35:32Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p></p><pre>with open(&#34;04-1-spoc-memdiskdata.md&#34;, &#39;r&#39;) as file:\n    for line in file:\n        if not line.strip():\n            break\n    pdbr = file.readline()\n    pdbr = pdbr[14:].split(&#39;[&#39;)[0]\n    pdbr = int(pdbr, base=16)\n    for line in file:\n        if line.strip() == &#39;~~~&#39;:\n            break\n    memory = []\n    for line in file:\n        line = line.strip()\n        if line == &#39;~~~&#39;:\n            break\n        line = list(map(lambda x:int(x, base=16), line[9:].split()))\n        memory.append(line)\n    for line in file:\n        if line.strip() == &#39;~~~&#39;:\n            break\n    disk = []\n    for line in file:\n        line = line.strip()\n        if line == &#39;~~~&#39;:\n            break\n        line = list(map(lambda x:int(x, base=16), line[9:].split()))\n        disk.append(line)\nwhile True:\n    virtual = int(input(), base=16)\n    pde_index = virtual &gt;&gt; 10\n    pde_addr = pdbr &#43; pde_index\n    pde_contents = memory[pde_addr &gt;&gt; 5][pde_addr &amp; 0x1f]\n    valid = pde_contents &gt;&gt; 7\n    pfn = pde_contents &amp; 0x7f\n    print(&#39;pde index:0x{0:x}({0:b}) pde contents:(0x{1:x}, {1:b}, valid {2}, pfn 0x{3:x}(page 0x{3:x}))&#39;.format(pde_index, pde_contents, valid, pfn))\n    if not valid:\n        continue\n    pte_index = virtual &gt;&gt; 5 &amp; 0x1f\n    pte_contents = memory[pfn][pte_index]\n    valid = pte_contents &gt;&gt; 7\n    pfn = pte_contents &amp; 0x7f\n    print(&#39;pte index:0x{0:x}({0:b}) pte contents:(0x{1:x}, {1:b}, valid {2}, pfn 0x{3:x})&#39;.format(pte_index, pte_contents, valid, pfn))\n    offset = virtual &amp; 0x1f\n    physical = (pfn &lt;&lt; 5) &#43; offset\n    if valid == 1:\n        value = memory[pfn][offset]\n        print(&#34;To Physical Address {0:x}({0:b}) --&gt; Value: {1:x}&#34;.format(physical, value))\n    else:\n        if pfn == 0x7f:\n            print(&#34;Not exist&#34;)\n        else:\n            value = disk[pfn][offset]\n            print(&#34;To Disk Sector Address {0:x}({0:b}) --&gt; Value: {1:x}&#34;.format(physical, value))</pre>\n<p>Python版本</p>", "created": "2019-03-24T11:26:48Z", "bucket_order": 52, "bucket_name": "Week 3/24 - 3/30", "type": "followup", "tag_good": [], "uid": "jshndy9fxmm4as", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "jtmu7oeu4zw3ov", "updated": "2019-03-24T11:26:48Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p></p><pre>    translate(va, pdbr, memory, disk) {<br />      output = []<br />      pde_index = va &gt;&gt; 10<br />      pde_addr = pdbr &#43; pde_index<br />      pde_contents = memory[pde_addr &gt;&gt; 5][pde_addr &amp; 0x1f]<br />      valid = pde_contents &gt;&gt; 7<br />      pfn = pde_contents &amp; 0x7f<br />      output.append(&#96;pde index:0x${pde_index.toString(16)}(${pde_index.toString(2)}) &#96;<br />        &#43; &#96;pde contents:(0x${pde_contents.toString(16)}, ${pde_contents.toString(2)}, &#96;<br />        &#43;  &#96;valid ${valid}, pfn 0x${pfn.toString(16)}(page 0x${pfn.toString(2)})&#96;) <br />      if (!valid)<br />        return output<br />      pte_index = (va &gt;&gt; 5) &amp; 0x1f<br />      pte_contents = memory[pfn][pte_index]<br />      valid = pte_contents &gt;&gt; 7<br />      pfn = pte_contents &amp; 0x7f<br />      output.append(&#96;pte index:0x${pte_index.toString(16)}(${pte_index.toString(2)}) &#96;<br />        &#43; &#96;pte contents:(0x${pte_contents.toString(16)}, ${pte_contents.toString(2)}, &#96;<br />        &#43; &#96;valid ${valid}, pfn 0x${pfn.toString(16)})&#96;) <br />      offset = va &amp; 0x1f<br />      pa = (pfn &lt;&lt; 5) &#43; offset<br />      if (valid) {<br />        value = memory[pfn][offset]<br />        output.append(&#96;To Physical Address 0x${pa.toString(16)}(${pa.toString(2)}) &#96;<br />          &#43; &#96;--&gt; Value: 0x${value.toString(16)}&#96;) <br />      } else if (pfn == 0x7f) {<br />        output.append(&#96;Not exist&#96;)<br />      } else {<br />        value = disk[pfn][offset]<br />        output.append(&#96;To Disk Sector Address ${pa.toString(16)}(${pa.toString(2)}) &#96;<br />          &#43; &#96;--&gt; Value: 0x${value.toString(16)}&#96;) <br />      }<br />      return output<br />    },<br /><br />    handleTranslate() {<br />      axios({<br />        url: DP &#43; &#39;/data&#39;,<br />        method: &#39;GET&#39;,<br />      }).then(res =&gt; {<br />        output = this.translate(this.va, this.pdbr, res.data.memory, res.data.disk).join(&#39;\\n&#39;)<br />        this.$notify({<br />          title: &#39;计算结果&#39;,<br />          message: output,<br />          type: &#39;success&#39;<br />        })<br />      }).catch(err =&gt; {<br />        console.log(err)<br />        this.$message({<br />          message: &#39;未知错误&#39;,<br />          type: &#39;error&#39;<br />        })<br />      })<br />    },</pre>\n<p>JS (Vue) 版本</p>", "created": "2019-03-25T00:28:54Z", "bucket_order": 52, "bucket_name": "Week 3/24 - 3/30", "type": "followup", "tag_good": [], "uid": "jshndz5tgxj4bq", "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "subject": "<p></p><pre>    translate(va, pdbr, memory, disk) {\n      let output = []\n      let pdeIndex = va &gt;&gt; 10\n      let pdeAddr = pdbr &#43; pdeIndex\n      let pdeContents = memory[pdeAddr &gt;&gt; 5][pdeAddr &amp; 0x1f]\n      let valid = pdeContents &gt;&gt; 7\n      let pfn = pdeContents &amp; 0x7f\n      output.push(&#96;pde index:0x${pdeIndex.toString(16)}(${pdeIndex.toString(2)}) &#96; &#43;\n        &#96;pde contents:(0x${pdeContents.toString(16)}, ${pdeContents.toString(2)}, &#96; &#43;\n        &#96;valid ${valid}, pfn 0x${pfn.toString(16)}(page 0x${pfn.toString(2)})&#96;)\n      if (!valid)\n        return output\n      let pteIndex = (va &gt;&gt; 5) &amp; 0x1f\n      let pteContents = memory[pfn][pteIndex]\n      valid = pteContents &gt;&gt; 7\n      pfn = pteContents &amp; 0x7f\n      output.push(&#96;pte index:0x${pteIndex.toString(16)}(${pteIndex.toString(2)}) &#96; &#43;\n        &#96;pte contents:(0x${pteContents.toString(16)}, ${pteContents.toString(2)}, &#96; &#43;\n        &#96;valid ${valid}, pfn 0x${pfn.toString(16)})&#96;)\n      let offset = va &amp; 0x1f\n      let pa = (pfn &lt;&lt; 5) &#43; offset\n      if (valid) {\n        let value = memory[pfn][offset]\n        output.push(&#96;To Physical Address 0x${pa.toString(16)}(${pa.toString(2)}) &#96; &#43;\n          &#96;--&gt; Value: 0x${value.toString(16)}&#96;)\n      } else if (pfn === 0x7f) {\n        output.push(&#96;Not exist&#96;)\n      } else {\n        let value = disk[pfn][offset]\n        output.push(&#96;To Disk Sector Address ${pa.toString(16)}(${pa.toString(2)}) &#96; &#43;\n          &#96;--&gt; Value: 0x${value.toString(16)}&#96;)\n      }\n      return output\n    },\n\n    handleTranslate() {\n      axios({\n        url: DP &#43; &#39;/data&#39;,\n        method: &#39;GET&#39;\n      }).then(res =&gt; {\n        let output = this.translate(parseInt(this.va, 16), parseInt(this.pdbr, 16),\n          res.data.memory, res.data.disk).join(&#39;\\n&#39;)\n        this.$notify({\n          title: &#39;计算结果&#39;,\n          message: output,\n          type: &#39;success&#39;\n        })\n      }).catch(err =&gt; {\n        console.log(err)\n        this.$message({\n          message: &#39;未知错误&#39;,\n          type: &#39;error&#39;\n        })\n      })\n    },</pre>\n<p>更正</p>", "created": "2019-03-25T01:15:37Z", "bucket_order": 52, "bucket_name": "Week 3/24 - 3/30", "type": "feedback", "tag_good": [], "uid": "jshndz5tgxj4bq", "children": [], "tag_good_arr": [], "id": "jtnntk6c6o4615", "updated": "2019-03-25T01:15:37Z", "config": {}}], "tag_good_arr": [], "no_answer": 1, "id": "jtnm5gxpq3865c", "updated": "2019-03-25T00:28:54Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p></p><pre>use std::fs;\n\nfn main() {\n    let pdbr : u16 = 0xd80;\n\n    let mut pde_index : u8;\n    let mut pte_index : u8;\n    let mut page_offset : u8;\n\n    let mut pde_content : u8;\n    let mut pde_valid : u8;\n    let mut pde_addr : u8;\n\n    let mut pte_content : u8;\n    let mut pte_valid : u8;\n    let mut pte_addr : u8;\n\n    let mut paddr : u16;\n    let mut value : u8;\n\n    let mut disk_addr : u16;\n\n    // load memory information\n    let contents = fs::read_to_string(&#34;memory.txt&#34;)\n                .expect(&#34;Something went wrong reading the file&#34;);\n    let mut mem = Vec::new();\n    let split = contents.as_str().split(&#34;\\n&#34;);\n    for s in split {\n        mem.push(s.split(&#34; &#34;).collect::&lt;Vec&lt;&amp;str&gt;&gt;());\n    }\n\n    // load disk information\n    let contents = fs::read_to_string(&#34;disk.txt&#34;)\n                .expect(&#34;Something went wrong reading the disk&#34;);\n    let mut disk = Vec::new();\n    let split_disk = contents.as_str().split(&#34;\\n&#34;);\n    for s in split_disk {\n        disk.push(s.split(&#34; &#34;).collect::&lt;Vec&lt;&amp;str&gt;&gt;());\n    }\n    \n\n    let vec : Vec&lt;u16&gt; = vec![0x6653,0x1c13,0x6890,0x0af6,0x1e6f];\n\n    for addr in vec.into_iter() {\n        print!(&#34;\\nthe virtual addr is {:#x} \\n    &#34;, addr);\n\n        //parse the virtual addr\n        pde_index  = (addr &gt;&gt; 10) as u8;\n        pte_index  = ((addr &lt;&lt; 6) &gt;&gt; 11) as u8;\n        page_offset  = (addr % 32) as u8;\n\n        //get pde\n        pde_content = parse_str(mem[(pdbr &gt;&gt; 5) as usize][2 &#43; pde_index as usize]);\n        pde_valid = pde_content &gt;&gt; 7;\n        pde_addr = pde_content - (pde_valid &lt;&lt; 7);\n\n        //get pte\n        pte_content = parse_str(mem[pde_addr as usize][2&#43; pte_index as usize]);\n        pte_valid = pte_content &gt;&gt; 7;\n        pte_addr = pte_content - (pte_valid &lt;&lt; 7);\n\n        //get physical address and value stored in it\n        paddr = ((pte_addr as u16) &lt;&lt; 5) &#43; page_offset as u16;\n\n        print!(&#34;the pde index is : {:#x}, pde content is {:#x} (valid {}, pfn {:#x})\\n      &#34;, pde_index, pde_content, pde_valid, pde_addr);\n        if pde_valid != 0 {\n            print!(&#34;the pte index is : {:#x}, content is {:#x} (valid {}, pfn {:#x}) \\n         &#34;, pte_index, pte_content, pte_valid, pte_addr);\n        }else{\n            if pde_content == 0x7f {\n                println!(&#34;The pagetable doesn&#39;t exit&#34;);\n            }\n            continue;\n        }\n        if pte_valid != 0 {\n            value = parse_str(mem[(paddr &gt;&gt; 5) as usize][2 &#43; (paddr % 32) as usize]);\n            print!(&#34;the page offset is : {:#x}, the paddr is {:#x}, value is {:#x} \\n       &#34;, page_offset, paddr, value);\n        }else{\n            if pte_content == 0x7f {\n                println!(&#34;The page doesn&#39;t exit&#34;);\n                continue;\n            }else{\n                disk_addr = ((pte_addr as u16) &lt;&lt; 5) &#43; page_offset as u16 ;\n                value = parse_str(disk[pte_addr as usize][2 &#43; page_offset as usize]);\n                print!(&#34;To disk address : {:#x}, value is {:#x} \\n&#34;, disk_addr, value);\n            }\n            continue;\n        }\n    }\n}\n\n// convert str to number, such as &#39;1b&#39; =&gt; 27_u8\nfn parse_str(s : &amp;str) -&gt; u8 {\n    let mut res : u8 = 0;\n    for ch in s.bytes() {\n        res = (res &lt;&lt; 4) &#43; parse_char(ch);\n    }\n    res\n}\n    \n// convert char to number\nfn parse_char(ch : u8) -&gt; u8 {\n    match ch {\n        b&#39;0&#39;=&gt; 0,\n        b&#39;1&#39;=&gt; 1,\n        b&#39;2&#39;=&gt; 2,\n        b&#39;3&#39;=&gt; 3,\n        b&#39;4&#39;=&gt; 4,\n        b&#39;5&#39;=&gt; 5,\n        b&#39;6&#39;=&gt; 6,\n        b&#39;7&#39;=&gt; 7,\n        b&#39;8&#39;=&gt; 8,\n        b&#39;9&#39;=&gt; 9,\n        b&#39;a&#39;=&gt; 10,\n        b&#39;b&#39;=&gt; 11,\n        b&#39;c&#39;=&gt; 12,\n        b&#39;d&#39;=&gt; 13,\n        b&#39;e&#39;=&gt; 14,\n        b&#39;f&#39;=&gt; 15,\n        _ =&gt; 0\n    }\n}</pre>\n<p>rust版本</p>", "created": "2019-03-25T01:36:43Z", "bucket_order": 52, "bucket_name": "Week 3/24 - 3/30", "type": "followup", "tag_good": [], "uid": "jshne3teufu4qt", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "jtnokopnwu326l", "updated": "2019-03-25T01:36:43Z", "config": {}}], "tag_good_arr": [], "id": "jthcpu71m9k6rj", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 6, "num_favorites": 2, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169657114, "default_anonymity": "no"}, "error": null, "aid": "kyv0sduir086q2"}