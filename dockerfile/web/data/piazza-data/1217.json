{"result": {"folders": ["lecture17", "2018"], "nr": 1217, "data": {"embed_links": []}, "created": "2018-05-06T11:57:35Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "je2ib5nk89v6ca", "data": "jgurizhf3hi4r2", "type": "create", "when": "2018-05-06T11:57:35Z"}, {"anon": "no", "uid": "je2ib5nk89v6ca", "data": "jgurzfhty332x5", "type": "update", "when": "2018-05-06T12:10:23Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "data": "jgv04y6itc825s", "type": "update", "when": "2018-05-06T15:58:37Z"}, {"anon": "no", "uid": "hdjonbiyfs62ie", "data": "jgv0zdmzhhu686", "to": "jgurizhdd5o4r1", "type": "i_answer", "when": "2018-05-06T16:22:17Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "对于wikipedia上的Eisenberg算法的理解", "created": "2018-05-06T15:58:37Z", "content": "<p>对于https://en.wikipedia.org/wiki/Eisenberg_%26_McGuire_algorithm上的Eisenberg算法&#xff0c;想请同学们和老师看一下是否正确&#xff0c;</p>\n<p></p>\n<p>代码如下&#xff1a;</p>\n<pre>    repeat {\n\n\t\t/* announce that we need the resource */\n\t\tflags[i] := WAITING;\n\n\t\t/* scan processes from the one with the turn up to ourselves. */\n\t\t/* repeat if necessary until the scan finds all processes idle */\n CYCLE1:\n\t\tindex := turn;\n\t\twhile (index != i) {\n\t\t\tif (flags[index] != IDLE) index := turn;\n\t\t\telse index := (index&#43;1) mod n;\n\t\t}\n\n\t\t/* now tentatively claim the resource */\n\t\tflags[i] := ACTIVE;\nCYCLE2:\n\t\t/* find the first active process besides ourselves, if any */\n\t\tindex := 0;\n\t\twhile ((index &lt; n) &amp;&amp; ((index = i) || (flags[index] != ACTIVE))) {\n\t\t\tindex := index&#43;1;\n\t\t}\n\n\t/* if there were no other active processes, AND if we have the turn\n\t   or else whoever has it is idle, then proceed.  Otherwise, repeat\n\t   the whole sequence. */\n        } until ((index &gt;= n) &amp;&amp; ((turn = i) || (flags[turn] = IDLE)));\n\n        /* Start of CRITICAL SECTION */\n\n\t/* claim the turn and proceed */\n\tturn := i;\n\n        /* Critical Section Code of the Process */\n\n        /* End of CRITICAL SECTION */\n\n        /* find a process which is not IDLE */\n\t/* (if there are no others, we will find ourselves) */\n\n\tindex := (turn&#43;1) mod n;\n\twhile (flags[index] = IDLE) {\n\t\tindex := (index&#43;1) mod n;\n\t}\n\n\t/* give the turn to someone that needs it, or keep it */\n\tturn := index;\n\n\t/* we&#39;re finished now */\n\tflags[i] := IDLE;\n\n       /* REMAINDER Section */</pre>\n<p>首先&#xff0c;我们先把所有的进程从0~n-1想象成一个环&#xff0c;而turn随机指向0&#xff5e;n-1中的一个数&#xff0c;</p>\n<p>那么&#xff0c;这段代码中&#xff0c;首先依次有以下两点&#xff1a;</p>\n<ol><li>没有进入repeat的进程的flag为IDLE</li><li>进入repeat至少执行了一条指令的进程的flag不是IDLE</li></ol>\n<p>于是&#xff0c;假设i是第一个进入repeat的进程&#xff0c;通过CYCLE1中的循环以及index := turn的操作&#xff0c;就只有在进程环的意义上的从turn到i的进程才有可能在i完成临界区操作并退出前执行CYCLE1后面的代码&#xff0c;因为它们一检测到i的flag不是IDLE就跳回了turn进行判断。</p>\n<p></p>\n<p>这样&#xff0c;有可能通过CYCLE1的进程就只有i及其之前&#xff0c;turn及其之后的进程&#xff0c;但实际上i也不一定能通过&#xff0c;不过&#xff0c;总有一个或多个在turn&#xff5e;i范围内的进程通过了CYCLE1&#xff0c;因为总存在一个进入repeat区并与turn最近的进程&#xff08;这也要求了turn必须是0&#xff5e;n-1的数&#xff1f;&#xff09;&#xff0c;而没有通过CYCLE1的进程一直到等待。</p>\n<p></p>\n<p>不妨设通过CYCLE1的进程是从turn开始数依次是j1,j2,...jm&#xff0c;则进入repeat区设置WAITING的顺序必定为逆序&#xff0c;否则不可能通过CYCLE1&#xff0c;但通过CYCLE1的次序不一定。此时设置ACTIVE&#xff0c;然后CYCLE2判断是否还有其他的ACTIVE&#xff0c;虽然第一个设置ACTIVE的进程不一定能够获得权限&#xff0c;因为判断过程中可能有ACTIVE设置&#xff0c;但是后设置ACTIVE的进程一定不能获得权限&#xff0c;由此获得权限可能进入临界区的&#xff08;index加到n的&#xff09;至多一个。</p>\n<p></p>\n<p>而第一个设置ACTIVE的进程没有进入临界区的情况是&#xff0c;通过CYCLE1的第一个设置ACTIVE的进程p1&#xff0c;在检查ACTIVE的时候&#xff0c;还没检查的某个进程p2设置了ACTIVE&#xff0c;导致第一个设置ACTIVE的进程也检测失败&#xff0c;从而无法进入临界区。继而p1 p2都再次进入repeat循环。下面的j1~jm中的进程仍然是先设置ACTICE的才可能实现index加到n。</p>\n<p></p>\n<p>由此可见&#xff0c;整个repeat循环的效果是&#xff0c;至多一个进程k可以在CYCLE2中将index加到n&#xff0c;进而可能进入临界区&#xff0c;而如果turn正好是这个进程&#xff0c;就能够进入临界区&#xff0c;如果turn对应进程还没有进入repeat区&#xff0c;那么进程k也能进入临界区&#xff0c;并修改turn为k&#xff0c;由于此时进程k已经设置了ACTIVE&#xff0c;所以即使在k还没有修改turn的时候&#xff0c;turn对应的进程进入了repeat&#xff0c;也无法通过CYCLE2将index加到n&#xff0c;其他的进程更是由于ACTIVE无法加到n&#xff0c;进程k只有在退出区重新设置flag和turn&#xff0c;在这之后其他进程才有可能进入&#xff0c;这保证了不会有多个进程同时进入临界区。</p>\n<p></p>\n<p>下面说明最终一定有进程可以进入临界区。</p>\n<p></p>\n<p>如果经过上面的流程之后&#xff0c;j1~jm都没有将index加到n&#xff0c;那么这些进程必然全部再次进入repeat循环&#xff0c;并且必定有m大于1&#xff0c;此时&#xff0c;距离比j1距turn更远的进程&#xff08;包括j2~jm&#xff09;都不可能通过CYCLE1&#xff0c;考虑到可能有新的进程进入repeat区&#xff0c;则能通过CYCLE1的进程必定在turn~j1之间&#xff0c;而显然j1在turn~i&#xff08;第一个进入repeat的进程&#xff09;之间&#xff0c;所以从turn~i变为turn~j1&#xff0c;范围是缩小的&#xff0c;由于进程数有限&#xff0c;所以如果前面每次循环都没有进程将index加到n&#xff0c;那么这个范围总会不断缩小&#xff0c;当其中只有一个进程的时候&#xff0c;只有它可以通过CYCLE1&#xff0c;然后通过CYCLE2将index加到n&#xff0c;进而进入临界区。</p>\n<p></p>\n<p>综上&#xff0c;该代码实现了多进程访问下的控制目的。</p>\n<p></p>\n<p>请老师和同学看一下有问题或者疏漏吗&#xff1f;</p>"}, {"anon": "no", "uid": "je2ib5nk89v6ca", "subject": "对于wikipedia上的Eisenberg算法的理解", "created": "2018-05-06T12:10:23Z", "content": "<p>对于https://en.wikipedia.org/wiki/Eisenberg_%26_McGuire_algorithm上的Eisenberg算法&#xff0c;想请同学们和老师看一下是否正确&#xff0c;</p>\n<p></p>\n<p>代码如下&#xff1a;</p>\n<pre>    repeat {\n\n\t\t/* announce that we need the resource */\n\t\tflags[i] := WAITING;\n\n\t\t/* scan processes from the one with the turn up to ourselves. */\n\t\t/* repeat if necessary until the scan finds all processes idle */\n CYCLE1:\n\t\tindex := turn;\n\t\twhile (index != i) {\n\t\t\tif (flags[index] != IDLE) index := turn;\n\t\t\telse index := (index&#43;1) mod n;\n\t\t}\n\n\t\t/* now tentatively claim the resource */\n\t\tflags[i] := ACTIVE;\nCYCLE2:\n\t\t/* find the first active process besides ourselves, if any */\n\t\tindex := 0;\n\t\twhile ((index &lt; n) &amp;&amp; ((index = i) || (flags[index] != ACTIVE))) {\n\t\t\tindex := index&#43;1;\n\t\t}\n\n\t/* if there were no other active processes, AND if we have the turn\n\t   or else whoever has it is idle, then proceed.  Otherwise, repeat\n\t   the whole sequence. */\n        } until ((index &gt;= n) &amp;&amp; ((turn = i) || (flags[turn] = IDLE)));\n\n        /* Start of CRITICAL SECTION */\n\n\t/* claim the turn and proceed */\n\tturn := i;\n\n        /* Critical Section Code of the Process */\n\n        /* End of CRITICAL SECTION */\n\n        /* find a process which is not IDLE */\n\t/* (if there are no others, we will find ourselves) */\n\n\tindex := (turn&#43;1) mod n;\n\twhile (flags[index] = IDLE) {\n\t\tindex := (index&#43;1) mod n;\n\t}\n\n\t/* give the turn to someone that needs it, or keep it */\n\tturn := index;\n\n\t/* we&#39;re finished now */\n\tflags[i] := IDLE;\n\n       /* REMAINDER Section */</pre>\n<p>首先&#xff0c;我们先把所有的进程从0~n-1想象成一个环&#xff0c;而turn随机指向0&#xff5e;n-1中的一个数&#xff0c;</p>\n<p>那么&#xff0c;这段代码中&#xff0c;首先依次有以下两点&#xff1a;</p>\n<ol><li>没有进入repeat的进程的flag为IDLE</li><li>进入repeat至少执行了一条指令的进程的flag不是IDLE</li></ol>\n<p>于是&#xff0c;假设i是第一个进入repeat的进程&#xff0c;通过CYCLE1中的循环以及index := turn的操作&#xff0c;就只有在进程环的意义上的从turn到i的进程才有可能在i完成临界区操作并退出前执行CYCLE1后面的代码&#xff0c;因为它们一检测到i的flag不是IDLE就跳回了turn进行判断。</p>\n<p></p>\n<p>这样&#xff0c;有可能通过CYCLE1的进程就只有i及其之前&#xff0c;turn及其之后的进程&#xff0c;但实际上i也不一定能通过&#xff0c;不过&#xff0c;总有一个或多个在turn&#xff5e;i范围内的进程通过了CYCLE1&#xff0c;因为总存在一个进入repeat区并与turn最近的进程&#xff08;这也要求了turn必须是0&#xff5e;n-1的数&#xff1f;&#xff09;&#xff0c;而没有通过CYCLE1的进程一直到等待。</p>\n<p></p>\n<p>不妨设通过CYCLE1的进程是从turn开始数依次是j1,j2,...jm&#xff0c;则进入repeat区设置WAITING的顺序必定为逆序&#xff0c;否则不可能通过CYCLE1&#xff0c;但通过CYCLE1的次序不一定。此时设置ACTIVE&#xff0c;然后CYCLE2判断是否还有其他的ACTIVE&#xff0c;虽然第一个设置ACTIVE的进程不一定能够获得权限&#xff0c;因为判断过程中可能有ACTIVE设置&#xff0c;但是后设置ACTIVE的进程一定不能获得权限&#xff0c;由此获得权限可能进入临界区的&#xff08;index加到n的&#xff09;至多一个。</p>\n<p></p>\n<p>而第一个设置ACTIVE的进程没有进入临界区的情况是&#xff0c;通过CYCLE1的第一个设置ACTIVE的进程p1&#xff0c;在检查ACTIVE的时候&#xff0c;还没检查的某个进程p2设置了ACTIVE&#xff0c;导致第一个设置ACTIVE的进程也检测失败&#xff0c;从而无法进入临界区。继而p1 p2都再次进入repeat循环。下面的j1~jm中的进程仍然是先设置ACTICE的才可能实现index加到n。</p>\n<p></p>\n<p>由此可见&#xff0c;整个repeat循环的效果是&#xff0c;至多一个进程k可以在CYCLE2中将index加到n&#xff0c;进而可能进入临界区&#xff0c;而如果turn正好是这个进程&#xff0c;就能够进入临界区&#xff0c;如果turn对应进程还没有进入repeat区&#xff0c;那么进程k也能进入临界区&#xff0c;并修改turn为k&#xff0c;由于此时进程k已经设置了ACTIVE&#xff0c;所以即使在k还没有修改turn的时候&#xff0c;turn对应的进程进入了repeat&#xff0c;也无法通过CYCLE2将index加到n&#xff0c;其他的进程更是由于ACTIVE无法加到n&#xff0c;进程k只有在退出区重新设置flag和turn&#xff0c;在这之后其他进程才有可能进入&#xff0c;这保证了不会有多个进程同时进入临界区。</p>\n<p></p>\n<p>下面说明最终一定有进程可以进入临界区。</p>\n<p></p>\n<p>如果经过上面的流程之后&#xff0c;j1~jm都没有将index加到n&#xff0c;那么这些进程必然全部再次进入repeat循环&#xff0c;并且必定有m大于1&#xff0c;此时&#xff0c;距离比j1距turn更远的进程&#xff08;包括j2~jm&#xff09;都不可能通过CYCLE1&#xff0c;考虑到可能有新的进程进入repeat区&#xff0c;则能通过CYCLE1的进程必定在turn~j1之间&#xff0c;而显然j1在turn~i&#xff08;第一个进入repeat的进程&#xff09;之间&#xff0c;所以从turn~i变为turn~j1&#xff0c;范围是缩小的&#xff0c;由于进程数有限&#xff0c;所以如果前面每次循环都没有进程将index加到n&#xff0c;那么这个范围总会不断缩小&#xff0c;当其中只有一个进程的时候&#xff0c;只有它可以通过CYCLE1&#xff0c;然后通过CYCLE2将index加到n&#xff0c;进而进入临界区。</p>\n<p></p>\n<p>综上&#xff0c;该代码实现了多进程访问下的控制目的。</p>\n<p></p>\n<p>请老师和同学看一下有问题或者疏漏吗&#xff1f;</p>"}, {"anon": "no", "uid": "je2ib5nk89v6ca", "subject": "对于wikipedia上的Eisenberg算法的理解", "created": "2018-05-06T11:57:35Z", "content": "<p>对于https://en.wikipedia.org/wiki/Eisenberg_%26_McGuire_algorithm上的Eisenberg算法&#xff0c;想请同学们和老师看一下是否正确&#xff0c;</p>\n<p></p>\n<p>代码如下&#xff1a;</p>\n<pre>    repeat {\n\n\t\t/* announce that we need the resource */\n\t\tflags[i] := WAITING;\n\n\t\t/* scan processes from the one with the turn up to ourselves. */\n\t\t/* repeat if necessary until the scan finds all processes idle */<br /> CYCLE1:\n\t\tindex := turn;\n\t\twhile (index != i) {\n\t\t\tif (flags[index] != IDLE) index := turn;\n\t\t\telse index := (index&#43;1) mod n;\n\t\t}\n\n\t\t/* now tentatively claim the resource */\n\t\tflags[i] := ACTIVE;\n\n\t\t/* find the first active process besides ourselves, if any */\n\t\tindex := 0;\n\t\twhile ((index &lt; n) &amp;&amp; ((index = i) || (flags[index] != ACTIVE))) {\n\t\t\tindex := index&#43;1;\n\t\t}\n\n\t/* if there were no other active processes, AND if we have the turn\n\t   or else whoever has it is idle, then proceed.  Otherwise, repeat\n\t   the whole sequence. */\n        } until ((index &gt;= n) &amp;&amp; ((turn = i) || (flags[turn] = IDLE)));\n\n        /* Start of CRITICAL SECTION */\n\n\t/* claim the turn and proceed */\n\tturn := i;\n\n        /* Critical Section Code of the Process */\n\n        /* End of CRITICAL SECTION */\n\n        /* find a process which is not IDLE */\n\t/* (if there are no others, we will find ourselves) */<br />CYCLE2:\n\tindex := (turn&#43;1) mod n;\n\twhile (flags[index] = IDLE) {\n\t\tindex := (index&#43;1) mod n;\n\t}\n\n\t/* give the turn to someone that needs it, or keep it */\n\tturn := index;\n\n\t/* we&#39;re finished now */\n\tflags[i] := IDLE;\n\n       /* REMAINDER Section */</pre>\n<p>首先&#xff0c;我们先把所有的进程从0~n-1想象成一个环&#xff0c;而turn随机指向0&#xff5e;n-1中的一个数&#xff0c;</p>\n<p>那么&#xff0c;这段代码中&#xff0c;首先依次有以下两点&#xff1a;</p>\n<ol><li>没有进入repeat的进程的flag为IDLE</li><li>进入repeat至少执行了一条指令的进程的flag不是IDLE</li></ol>\n<p>于是&#xff0c;假设i是第一个进入repeat的进程&#xff0c;通过CYCLE1中的循环以及index := turn的操作&#xff0c;就只有在进程环的意义上的从turn到i的进程才有可能在i完成临界区操作并退出前执行CYCLE1后面的代码&#xff0c;因为它们一检测到i的flag不是IDLE就跳回了turn进行判断。</p>\n<p></p>\n<p>这样&#xff0c;有可能通过CYCLE1的进程就只有i及其之前&#xff0c;turn及其之后的进程&#xff0c;但实际上i也不一定能通过&#xff0c;不过&#xff0c;总有一个或多个在turn&#xff5e;i范围内的进程通过了CYCLE1&#xff0c;因为总存在一个进入repeat区并与turn最近的进程&#xff08;这也要求了turn必须是0&#xff5e;n-1的数&#xff1f;&#xff09;&#xff0c;而没有通过CYCLE1的进程一直到等待。</p>\n<p></p>\n<p>不妨设通过CYCLE1的进程是从turn开始数依次是j1,j2,...jm&#xff0c;则进入repeat区设置WAITING的顺序必定为逆序&#xff0c;否则不可能通过CYCLE1&#xff0c;但通过CYCLE1的次序不一定。此时设置ACTIVE&#xff0c;然后CYCLE2判断是否还有其他的ACTIVE&#xff0c;虽然第一个设置ACTIVE的进程不一定能够获得权限&#xff0c;因为判断过程中可能有ACTIVE设置&#xff0c;但是后设置ACTIVE的进程一定不能获得权限&#xff0c;由此获得权限可能进入临界区的&#xff08;index加到n的&#xff09;至多一个。</p>\n<p></p>\n<p>而第一个设置ACTIVE的进程没有进入临界区的情况是&#xff0c;通过CYCLE1的第一个设置ACTIVE的进程p1&#xff0c;在检查ACTIVE的时候&#xff0c;还没检查的某个进程p2设置了ACTIVE&#xff0c;导致第一个设置ACTIVE的进程也检测失败&#xff0c;从而无法进入临界区。继而p1 p2都再次进入repeat循环。下面的j1~jm中的进程仍然是先设置ACTICE的才可能实现index加到n。</p>\n<p></p>\n<p>由此可见&#xff0c;整个repeat循环的效果是&#xff0c;至多一个进程k可以在CYCLE2中将index加到n&#xff0c;进而可能进入临界区&#xff0c;而如果turn正好是这个进程&#xff0c;就能够进入临界区&#xff0c;如果turn对应进程还没有进入repeat区&#xff0c;那么进程k也能进入临界区&#xff0c;并修改turn为k&#xff0c;由于此时进程k已经设置了ACTIVE&#xff0c;所以即使在k还没有修改turn的时候&#xff0c;turn对应的进程进入了repeat&#xff0c;也无法通过CYCLE2将index加到n&#xff0c;其他的进程更是由于ACTIVE无法加到n&#xff0c;进程k只有在退出区重新设置flag和turn&#xff0c;在这之后其他进程才有可能进入&#xff0c;这保证了不会有多个进程同时进入临界区。</p>\n<p></p>\n<p>下面说明最终一定有进程可以进入临界区。</p>\n<p></p>\n<p>如果经过上面的流程之后&#xff0c;j1~jm都没有将index加到n&#xff0c;那么这些进程必然全部再次进入repeat循环&#xff0c;并且必定有m大于1&#xff0c;此时&#xff0c;距离比j1距turn更远的进程&#xff08;包括j2~jm&#xff09;都不可能通过CYCLE1&#xff0c;考虑到可能有新的进程进入repeat区&#xff0c;则能通过CYCLE1的进程必定在turn~j1之间&#xff0c;而显然j1在turn~i&#xff08;第一个进入repeat的进程&#xff09;之间&#xff0c;所以从turn~i变为turn~j1&#xff0c;范围是缩小的&#xff0c;由于进程数有限&#xff0c;所以如果前面每次循环都没有进程将index加到n&#xff0c;那么这个范围总会不断缩小&#xff0c;当其中只有一个进程的时候&#xff0c;只有它可以通过CYCLE1&#xff0c;然后通过CYCLE2将index加到n&#xff0c;进而进入临界区。</p>\n<p></p>\n<p>综上&#xff0c;该代码实现了多进程访问下的控制目的。</p>\n<p></p>\n<p>请老师和同学看一下有问题或者疏漏吗&#xff1f;</p>"}], "type": "question", "tags": ["2018", "lecture17", "student"], "tag_good": [], "unique_views": 112, "children": [{"folders": [], "data": {"embed_links": []}, "children": [], "created": "2018-05-06T16:22:17Z", "bucket_order": 3, "tag_endorse": [], "bucket_name": "Today", "id": "jgv0zdmv9i8685", "history": [{"anon": "no", "uid": "hdjonbiyfs62ie", "subject": "", "created": "2018-05-06T16:22:17Z", "content": "<p>对算法的执行流程进行分析&#xff0c;是验证软件同步算法正确性的方法之一。但不容易确定分析是否有遗漏。一种改进是&#xff0c;在算法执行流程分析&#xff0c;构造测试用例的分类&#xff0c;每一类的测试用例的执行路径是一致的&#xff0c;从而通过枚举所有可能的情况分类来验证算法的正确性。</p>\n<p></p>\n<p>对于eisenberg算法&#xff0c;可以从下面几个角度来进行分类。1&#xff09;线程申请进入临界区时&#xff0c;是否已有线程在临界区&#xff1b;2&#xff09;有一个或两个以上线程同时申请&#xff1b;3&#xff09;有线程正在进入区进行处理时&#xff0c;有新线程开始申请。然后&#xff0c;依据分类结果&#xff0c;构造测试用例&#xff0c;分析测试用例的执行覆盖所有执行路径。</p>\n<p></p>\n<p>下面链接是往届同学的相关讨论。</p>\n<p></p>\n<p><a href=\"https://www.piazza.com/class/i5j09fnsl7k5x0?cid=840\">https://piazza.com/class/i5j09fnsl7k5x0?cid=840</a></p>\n<p></p>\n<p>有兴趣的同学&#xff0c;可以尝试枚举覆盖所有可能的分类&#xff0c;并给出测试用例。</p>"}], "type": "i_answer", "tag_endorse_arr": [], "config": {}, "is_tag_endorse": false}], "tag_good_arr": [], "no_answer": 0, "id": "jgurizhdd5o4r1", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 2, "num_favorites": 2, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169432561, "default_anonymity": "no"}, "error": null, "aid": "kyv0nkkx21u29v"}