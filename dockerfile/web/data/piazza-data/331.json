{"result": {"folders": ["lab4", "课堂问答"], "nr": 331, "data": {"embed_links": []}, "created": "2015-04-20T10:42:37Z", "bucket_order": 3, "no_answer_followup": 1, "change_log": [{"uid": "i6rtbanwzcm5t6", "anon": "no", "when": "2015-04-20T10:42:37Z", "data": "i8pr7baoj2w27m", "type": "create"}, {"uid": "i6rtbanwzcm5t6", "anon": "no", "when": "2015-04-20T10:43:49Z", "data": "i8pr8uesds32ru", "type": "update"}, {"uid": "i6rtbanwzcm5t6", "anon": "no", "when": "2015-04-20T12:30:29Z", "data": "i8pv20pj5nk1q6", "type": "update"}, {"uid": "i6rtbanwzcm5t6", "anon": "no", "when": "2015-04-20T12:36:52Z", "data": "i8pva85tauoyn", "type": "update"}, {"to": "i8pr7balcj327l", "uid": "i6rtbanwzcm5t6", "anon": "no", "when": "2015-04-20T12:44:42Z", "type": "followup"}, {"uid": "hdjoucuyb836fq", "anon": "no", "when": "2015-04-20T12:48:20Z", "data": "i8pvozpfkud4ij", "type": "update"}, {"anon": "no", "uid": "jf86jf5n2SKn", "to": "i8pr7balcj327l", "type": "followup", "when": "2018-04-05T07:14:22Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "hdjoucuyb836fq", "subject": "lab4中do_fork()函数具体如何产生一个新的内核线程的gdb过程展示", "created": "2015-04-20T12:48:20Z", "content": "<p>根据向勇老师的指示&#xff0c;在这里分享一下我跟踪do_fork()及相关创建线程代码的过程。主要内容分为do_fork()主要涉及的子函数功能分析&#xff0c;以及完成do_fork()之后如何启动新的线程init。</p>\n<ol><li>首先把/tools/gdbinit加一条break do_fork()</li><li>可以把makefile里TERMINAL := gnome-terminal改为自己合适的终端&#xff0c;默认的ubuntu不需要改。</li><li>在项目根目录下运行make debug&#xff0c;开始gdb调试。<ol><li>\n<pre>Breakpoint 2, do_fork (clone_flags=256, stack=0, tf=0xc0126f54) at kern/process/proc.c:279\n279     do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf) {\n(gdb) l\n274      * &#64;clone_flags: used to guide how to clone the child process\n275      * &#64;stack:       the parent&#39;s user stack pointer. if stack==0, It means to fork a kernel thread.\n276      * &#64;tf:          the trapframe info, which will be copied to child process&#39;s proc-&gt;tf\n277      */\n278     int\n279     do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf) {\n280         int ret = -E_NO_FREE_PROC;\n281         struct proc_struct *proc;\n282         if (nr_process &gt;= MAX_PROCESS) {\n283             goto fork_out;\n(gdb) n</pre>\n这是初始界面&#xff0c;用list命令查看代码上下文&#xff0c;用next进行下一条代码&#xff08;不进入函数&#xff09;&#xff0c;用step进行下一条代码&#xff08;会进入函数&#xff09;。</li><li>首先会初始化返回值ret&#xff0c;如果进程总数nr_process比最大进程数大&#xff0c;则直接退出&#xff0c;返回-E_NO_FREE_PROC\n<pre>(gdb) n\n280         int ret = -E_NO_FREE_PROC;\n(gdb) p ret\n$1 = 1211072</pre>\n</li><li>然后设置ret为-E_NO_MEM&#xff0c;接着分配TCB&#xff0c;调用alloc_proc()&#xff0c;初始化TCB&#xff0c;具体可以查看alloc_proc()函数&#xff0c;如下\n<pre>    struct proc_struct *proc = kmalloc(sizeof(struct proc_struct));\n    if (proc != NULL) {\n        proc-&gt;state = PROC_UNINIT;\n        proc-&gt;pid = -1;\n        proc-&gt;runs = 0;\n        proc-&gt;kstack = 0;\n        proc-&gt;need_resched = 0;\n        proc-&gt;parent = NULL;\n        proc-&gt;mm = NULL;\n        memset(&amp;(proc-&gt;context), 0, sizeof(struct context));\n        proc-&gt;tf = NULL;\n        proc-&gt;cr3 = boot_cr3;\n        proc-&gt;flags = 0;\n        memset(proc-&gt;name, 0, PROC_NAME_LEN);\n    }\n    return proc;</pre>\n可以看出是对TCB的变量进行初始设置。</li><li>之后分配内核堆栈\n<pre>    struct Page *page = alloc_pages(KSTACKPAGE);\n    if (page != NULL) {\n        proc-&gt;kstack = (uintptr_t)page2kva(page);\n        return 0;\n    }\n    return -E_NO_MEM;</pre>\n这里很重要的一点是<strong>调用之前我们实现的alloc_pages</strong>&#xff0c;并且把proc-&gt;kstack指向新的页面&#xff0c;page2kva会算出page指针相对于pages这个起始地址的偏移&#xff0c;进而可以得到其相对的内核虚拟地址。如果页面内存不足&#xff0c;则返回失败。</li><li>接着会调用copy_mm()&#xff0c;但是lab4不会涉及到内存空间的切换&#xff08;因为都是内核线程&#xff09;&#xff0c;lab5涉及用户进程才会用到&#xff0c;所以这里面只是一个简单的assert&#xff0c;便返回了。</li><li>接着是<strong>最重要的copy_thread(proc, stack, tf);</strong>\n<pre>static void\ncopy_thread(struct proc_struct *proc, uintptr_t esp, struct trapframe *tf) {\n    proc-&gt;tf = (struct trapframe *)(proc-&gt;kstack &#43; KSTACKSIZE) - 1;\n    *(proc-&gt;tf) = *tf;\n    proc-&gt;tf-&gt;tf_regs.reg_eax = 0;\n    proc-&gt;tf-&gt;tf_esp = esp;\n    proc-&gt;tf-&gt;tf_eflags |= FL_IF;\n\n    proc-&gt;context.eip = (uintptr_t)forkret;\n    proc-&gt;context.esp = (uintptr_t)(proc-&gt;tf);\n}</pre>\n利用kstack得到上面我们分配的空间&#xff0c;将proc-&gt;tf指针的地址设置好&#xff0c;<strong>我没有弄明白</strong>的地方在于为什么偏移之后还要<strong>再减一</strong>呢&#xff1f;之后会复制传进来的参数——父进程的trapframe指针&#xff0c;然后设置<strong>子进程中断栈帧中保存的eax</strong>&#xff0c;这是子进程开始运行之后eax会被还原的值。需要明确的是&#xff0c;这一系列操作都是在父进程中进行的&#xff0c;通过父进程设置好子进程中一系列环境之后&#xff0c;再会有相应的函数让子进程开始运行。之后会设置esp、flag等。然后是&#xff1a;\n<pre>    proc-&gt;context.eip = (uintptr_t)forkret;\n    proc-&gt;context.esp = (uintptr_t)(proc-&gt;tf);</pre>\n这里十分重要&#xff0c;会设置指令指针eip为forkret函数&#xff0c;esp为父进程的中断栈帧&#xff0c;这样进入子进程后就会调用forkret函数&#xff0c;具体等我们后面跟踪到子进程启动再说。</li><li>之后返回到do_fork()里&#xff0c;分配pid&#xff0c;值得一提的是这里用了hash_proc&#xff0c;使得根据pid得到相应TCB会更快。具体分配算法这里就不细讲了...</li><li>然后会加入proc_list。然后再wakeup_proc()&#xff0c;设置新创建的线程为RUNNABLE。</li><li>然后我们来看<strong>如何启动</strong>这个我们创建的子线程&#xff1a;<ol><li>继续跟踪&#xff0c;我们发现do_fork()依次会返回到kernel_thread()再到proc_init()&#xff0c;最后到kern_init()&#xff0c;也就是内核初始化里面&#xff0c;再proc_init()之后有\n<pre>    ide_init();                 // init ide devices\n    swap_init();                // init swap\n\n    clock_init();               // init clock interrupt\n    intr_enable();              // enable irq interrupt\n    \n    cpu_idle();                 // run idle process</pre>\n这一系列初始化&#xff0c;而cpu_idle()看名字就知道是我们所关心的了&#xff0c;进去之后&#xff0c;\n<pre>void\ncpu_idle(void) {\n    while (1) {\n        if (current-&gt;need_resched) {\n            schedule();\n        }\n    }\n}</pre>\n我们发现他会循环判断当前进程/线程current-&gt;need_resched是否为真。在之前跟踪的过程中&#xff0c;在alloc_pro()函数里&#xff0c;我们初始化的子线程的need_resched设置的为0&#xff0c;而在proc_init()函数里&#xff1a;\n<pre>    idleproc-&gt;pid = 0;\n    idleproc-&gt;state = PROC_RUNNABLE;\n    idleproc-&gt;kstack = (uintptr_t)bootstack;\n    idleproc-&gt;need_resched = 1;\n    set_proc_name(idleproc, &#34;idle&#34;);\n    nr_process &#43;&#43;;\n    current = idleproc;</pre>\n我们可以看到idleproc也即空闲进程的need_resched初始是为1的&#xff0c;所current-&gt;need_resched为1&#xff0c;所以会在cpu_idle()里判断为真&#xff0c;进入schedule()函数。</li><li>而在schedule()函数里&#xff0c;首先会通过一个do-while loop在proc_list里找到第一个RUNNABLE的进程&#xff0c;如果找到了就break。事实上&#xff0c;循环退出有两种情况&#xff1a;一是找到了一个非空的RUNNABLE的进程&#xff0c;那么会接着往下走&#xff1b;还有一种情况是遍历完了&#xff0c;又回到队列头然后退出循环&#xff0c;此时指针指向的不是一个有效的可以运行的进程&#xff0c;所以它做了判断&#xff0c;将指针换成idleproc也就是空闲进程。这样一来如果队列里没有其他就绪进程的话&#xff0c;便会一直运行idleproc空闲进程。</li><li>如果找到了其他非current的就绪的进程&#xff0c;就会<strong>调用proc_run()&#xff0c;</strong>这就开始运行我们之前创建的init进程了。\n<pre>load_esp0(next-&gt;kstack &#43; KSTACKSIZE);\nlcr3(next-&gt;cr3);\nswitch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context));</pre>\n这三条语句就是proc_run()的核心&#xff0c;第一条语句修改TSS任务状态栈&#xff0c;将TSS的ts_esp0(stack pointers and segment selectors)指向下一个进程的堆栈空间&#xff08;不知这里和copy_thread()里设置proc-&gt;tf = (*trap_frame)(proc-&gt;kstack &#43; KSTACKSIZE) - 1 有什么关联&#xff1f;暂时没有理解&#xff09;。第二条语句修改cr3&#xff0c;即页表基址。第三条语句进行切换&#xff0c;这里便是IDE无法继续查看调用的地方了&#xff0c;而用gdb仍可以很方便地跟踪。</li><li>从进入switch.S到在新进程里运行init_main()的过程如下&#xff1a;\n<pre>switch_to () at kern/process/switch.S:6\n6           movl 4(%esp), %eax          # eax points to from\n(gdb) s\n7           popl 0(%eax)                # save eip !popl\nswitch_to () at kern/process/switch.S:8\n8           movl %esp, 4(%eax)\n9           movl %ebx, 8(%eax)\n10          movl %ecx, 12(%eax)\n11          movl %edx, 16(%eax)\n12          movl %esi, 20(%eax)\n13          movl %edi, 24(%eax)\n14          movl %ebp, 28(%eax)\n17          movl 4(%esp), %eax          # not 8(%esp): popped return address already\n19          movl 28(%eax), %ebp\nswitch_to () at kern/process/switch.S:20\n20          movl 24(%eax), %edi\n21          movl 20(%eax), %esi\n22          movl 16(%eax), %edx\n23          movl 12(%eax), %ecx\n24          movl 8(%eax), %ebx\n25          movl 4(%eax), %esp\n27          pushl 0(%eax)               # push eip\nswitch_to () at kern/process/switch.S:29\n29          ret\nforkret () at kern/process/proc.c:193\n193     forkret(void) {\nforkret () at kern/process/proc.c:194\n194         forkrets(current-&gt;tf);\nforkrets () at kern/trap/trapentry.S:48\n48          movl 4(%esp), %esp\n(gdb) l\n43          iret\n44\n45      .globl forkrets\n46      forkrets:\n47          # set stack to this new process&#39;s trapframe\n48          movl 4(%esp), %esp\n49          jmp __trapret\n(gdb) s\nforkrets () at kern/trap/trapentry.S:49\n49          jmp __trapret\n(gdb) \n__trapret () at kern/trap/trapentry.S:33\n33          popal\n(gdb) \n__trapret () at kern/trap/trapentry.S:36\n36          popl %gs\n37          popl %fs\n38          popl %es\n39          popl %ds\n42          addl $0x8, %esp\n43          iret\n5           pushl %edx              # push arg\n6           call *%ebx              # call fn\n(gdb) s\ninit_main (arg=&lt;error reading variable: Unknown argument list address for &#96;arg&#39;.&gt;)\n    at kern/process/proc.c:359\n359     init_main(void *arg) {</pre>\n可以看到首先是我们讨论很多的两段代码&#xff0c;取esp&#43;4&#xff08;movl 4(%esp), %eax&#xff09;&#xff0c;然后保存现场&#xff0c;存当前一系列寄存器到第一个参数的内存空间里&#xff0c;然后取esp&#43;8&#xff08;movl 4(%esp), %eax&#xff09;&#xff0c;这里由于已经pop过了&#xff0c;所以只需继续&#43;4&#xff0c;然后将第二个参数的内存空间里的值赋给一系列寄存器。事实上两个参数就是&amp;(prev-&gt;context), &amp;(next-&gt;context)&#xff0c;保存了各自的上下文。</li><li>然后ret就是奇妙的地方了&#xff0c;按理说本来调用proc_run()返回也应该返回到这个函数里去&#xff0c;但是由于上下文切换&#xff0c;我们就返回到第二个参数也就是新进程里设置好的上下文中指定的地方去了。我们指定的哪呢&#xff1f;如果还记得的话&#xff0c;我们在copy_thread()里将context的eip变量设为了(uintptr_t)forkret&#xff0c;所以返回应该返回到这去。这个函数又会跳到trapentry.S文件里的forkrets&#xff0c;设置好中断栈帧&#xff0c;再跳到__trapret&#xff0c;进行一系列中断完成前的准备&#xff0c;包括清空栈帧&#xff0c;执行中断前的指令&#xff1a;\n<pre>42          addl $0x8, %esp\n(gdb) \n43          iret\n(gdb) \n5           pushl %edx              # push arg\n(gdb) \n6           call *%ebx              # call fn</pre>\n这里将esp加8&#xff0c;执行中断返回iret&#xff0c;跳转到文件第5、6行&#xff0c;但是并不是原文件的5、6行...后来我发现是entry.S的5、6行&#xff0c;<strong>这里如何自动跳转的我并不明了</strong>。总之call *%ebx就进入了init_main()&#xff0c;就开始执行子进程的代码了。</li><li>当执行完之后&#xff0c;return 0&#xff0c;接着上面entry.S中call之后的代码运行&#xff0c;执行call do_exit&#xff0c;结束了整个程序&#xff0c;跟踪也结束了。<br />\n<pre>(gdb) s\nkernel_thread_entry () at kern/process/entry.S:8\n8           pushl %eax              # save the return value of fn(arg)\n(gdb) \n9           call do_exit            # call do_exit to terminate current thread\n(gdb) \ndo_exit (error_code=&lt;error reading variable: Unknown argument list address for &#96;error_code&#39;.&gt;)\n    at kern/process/proc.c:353\n353     do_exit(int error_code) {\n(gdb) \ndo_exit (error_code=0) at kern/process/proc.c:354\n354         panic(&#34;process exit!!.\\n&#34;);\n(gdb) </pre>\n</li></ol></li></ol></li><li>所以整个流程就是这样&#xff0c;比较繁琐&#xff0c;大家可以就粗体字来一起讨论一下&#xff5e;欢迎回复指出我描述错误或者不明确的地方&#xff5e;</li></ol>"}, {"anon": "no", "uid": "i6rtbanwzcm5t6", "subject": "lab4中do_fork()函数具体如何产生一个新的内核线程的gdb过程展示", "created": "2015-04-20T12:36:52Z", "content": "<p>根据向勇老师的指示&#xff0c;在这里分享一下我跟踪do_fork()及相关创建线程代码的过程。主要内容分为do_fork()主要涉及的子函数功能分析&#xff0c;以及完成do_fork()之后如何启动新的线程init。</p>\n<ol><li>首先把/tools/gdbinit加一条break do_fork()</li><li>可以把makefile里TERMINAL := gnome-terminal改为自己合适的终端&#xff0c;默认的ubuntu不需要改。</li><li>在项目根目录下运行make debug&#xff0c;开始gdb调试。<ol><li>\n<pre>Breakpoint 2, do_fork (clone_flags=256, stack=0, tf=0xc0126f54) at kern/process/proc.c:279\n279     do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf) {\n(gdb) l\n274      * &#64;clone_flags: used to guide how to clone the child process\n275      * &#64;stack:       the parent&#39;s user stack pointer. if stack==0, It means to fork a kernel thread.\n276      * &#64;tf:          the trapframe info, which will be copied to child process&#39;s proc-&gt;tf\n277      */\n278     int\n279     do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf) {\n280         int ret = -E_NO_FREE_PROC;\n281         struct proc_struct *proc;\n282         if (nr_process &gt;= MAX_PROCESS) {\n283             goto fork_out;\n(gdb) n</pre>\n这是初始界面&#xff0c;用list命令查看代码上下文&#xff0c;用next进行下一条代码&#xff08;不进入函数&#xff09;&#xff0c;用step进行下一条代码&#xff08;会进入函数&#xff09;。</li><li>首先会初始化返回值ret&#xff0c;如果进程总数nr_process比最大进程数大&#xff0c;则直接退出&#xff0c;返回-E_NO_FREE_PROC\n<pre>(gdb) n\n280         int ret = -E_NO_FREE_PROC;\n(gdb) p ret\n$1 = 1211072</pre>\n</li><li>然后设置ret为-E_NO_MEM&#xff0c;接着分配TCB&#xff0c;调用alloc_proc()&#xff0c;初始化TCB&#xff0c;具体可以查看alloc_proc()函数&#xff0c;如下\n<pre>    struct proc_struct *proc = kmalloc(sizeof(struct proc_struct));\n    if (proc != NULL) {\n        proc-&gt;state = PROC_UNINIT;\n        proc-&gt;pid = -1;\n        proc-&gt;runs = 0;\n        proc-&gt;kstack = 0;\n        proc-&gt;need_resched = 0;\n        proc-&gt;parent = NULL;\n        proc-&gt;mm = NULL;\n        memset(&amp;(proc-&gt;context), 0, sizeof(struct context));\n        proc-&gt;tf = NULL;\n        proc-&gt;cr3 = boot_cr3;\n        proc-&gt;flags = 0;\n        memset(proc-&gt;name, 0, PROC_NAME_LEN);\n    }\n    return proc;</pre>\n可以看出是对TCB的变量进行初始设置。</li><li>之后分配内核堆栈\n<pre>    struct Page *page = alloc_pages(KSTACKPAGE);\n    if (page != NULL) {\n        proc-&gt;kstack = (uintptr_t)page2kva(page);\n        return 0;\n    }\n    return -E_NO_MEM;</pre>\n这里很重要的一点是<strong>调用之前我们实现的alloc_pages</strong>&#xff0c;并且把proc-&gt;kstack指向新的页面&#xff0c;page2kva会算出page指针相对于pages这个起始地址的偏移&#xff0c;进而可以得到其相对的内核虚拟地址。如果页面内存不足&#xff0c;则返回失败。</li><li>接着会调用copy_mm()&#xff0c;但是lab4不会涉及到内存空间的切换&#xff08;因为都是内核线程&#xff09;&#xff0c;lab5涉及用户进程才会用到&#xff0c;所以这里面只是一个简单的assert&#xff0c;便返回了。</li><li>接着是<strong>最重要的copy_thread(proc, stack, tf);</strong>\n<pre>static void\ncopy_thread(struct proc_struct *proc, uintptr_t esp, struct trapframe *tf) {\n    proc-&gt;tf = (struct trapframe *)(proc-&gt;kstack &#43; KSTACKSIZE) - 1;\n    *(proc-&gt;tf) = *tf;\n    proc-&gt;tf-&gt;tf_regs.reg_eax = 0;\n    proc-&gt;tf-&gt;tf_esp = esp;\n    proc-&gt;tf-&gt;tf_eflags |= FL_IF;\n\n    proc-&gt;context.eip = (uintptr_t)forkret;\n    proc-&gt;context.esp = (uintptr_t)(proc-&gt;tf);\n}</pre>\n利用kstack得到上面我们分配的空间&#xff0c;将proc-&gt;tf指针的地址设置好&#xff0c;<strong>我没有弄明白</strong>的地方在于为什么偏移之后还要<strong>再减一</strong>呢&#xff1f;之后会复制传进来的参数——父进程的trapframe指针&#xff0c;然后设置<strong>子进程中断栈帧中保存的eax</strong>&#xff0c;这是子进程开始运行之后eax会被还原的值。需要明确的是&#xff0c;这一系列操作都是在父进程中进行的&#xff0c;通过父进程设置好子进程中一系列环境之后&#xff0c;再会有相应的函数让子进程开始运行。之后会设置esp、flag等。然后是&#xff1a;\n<pre>    proc-&gt;context.eip = (uintptr_t)forkret;\n    proc-&gt;context.esp = (uintptr_t)(proc-&gt;tf);</pre>\n这里十分重要&#xff0c;会设置指令指针eip为forkret函数&#xff0c;esp为父进程的中断栈帧&#xff0c;这样进入子进程后就会调用forkret函数&#xff0c;具体等我们后面跟踪到子进程启动再说。</li><li>之后返回到do_fork()里&#xff0c;分配pid&#xff0c;值得一提的是这里用了hash_proc&#xff0c;使得根据pid得到相应TCB会更快。具体分配算法这里就不细讲了...</li><li>然后会加入proc_list。然后再wakeup_proc()&#xff0c;设置新创建的线程为RUNNABLE。</li><li>然后我们来看<strong>如何启动</strong>这个我们创建的子线程&#xff1a;<ol><li>继续跟踪&#xff0c;我们发现do_fork()依次会返回到kernel_thread()再到proc_init()&#xff0c;最后到kern_init()&#xff0c;也就是内核初始化里面&#xff0c;再proc_init()之后有\n<pre>    ide_init();                 // init ide devices\n    swap_init();                // init swap\n\n    clock_init();               // init clock interrupt\n    intr_enable();              // enable irq interrupt\n    \n    cpu_idle();                 // run idle process</pre>\n这一系列初始化&#xff0c;而cpu_idle()看名字就知道是我们所关心的了&#xff0c;进去之后&#xff0c;\n<pre>void\ncpu_idle(void) {\n    while (1) {\n        if (current-&gt;need_resched) {\n            schedule();\n        }\n    }\n}</pre>\n我们发现他会循环判断当前进程/线程current-&gt;need_resched是否为真。在之前跟踪的过程中&#xff0c;在alloc_pro()函数里&#xff0c;我们初始化的子线程的need_resched设置的为0&#xff0c;而在proc_init()函数里&#xff1a;\n<pre>    idleproc-&gt;pid = 0;\n    idleproc-&gt;state = PROC_RUNNABLE;\n    idleproc-&gt;kstack = (uintptr_t)bootstack;\n    idleproc-&gt;need_resched = 1;\n    set_proc_name(idleproc, &#34;idle&#34;);\n    nr_process &#43;&#43;;\n    current = idleproc;</pre>\n我们可以看到idleproc也即空闲进程的need_resched初始是为1的&#xff0c;所current-&gt;need_resched为1&#xff0c;所以会在cpu_idle()里判断为真&#xff0c;进入schedule()函数。</li><li>而在schedule()函数里&#xff0c;首先会通过一个do-while loop在proc_list里找到第一个RUNNABLE的进程&#xff0c;如果找到了就break。事实上&#xff0c;循环退出有两种情况&#xff1a;一是找到了一个非空的RUNNABLE的进程&#xff0c;那么会接着往下走&#xff1b;还有一种情况是遍历完了&#xff0c;又回到队列头然后退出循环&#xff0c;此时指针指向的不是一个有效的可以运行的进程&#xff0c;所以它做了判断&#xff0c;将指针换成idleproc也就是空闲进程。这样一来如果队列里没有其他就绪进程的话&#xff0c;便会一直运行idleproc空闲进程。</li><li>如果找到了其他非current的就绪的进程&#xff0c;就会<strong>调用proc_run()&#xff0c;</strong>这就开始运行我们之前创建的init进程了。\n<pre>load_esp0(next-&gt;kstack &#43; KSTACKSIZE);\nlcr3(next-&gt;cr3);\nswitch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context));</pre>\n这三条语句就是proc_run()的核心&#xff0c;第一条语句修改TSS任务状态栈&#xff0c;将TSS的ts_esp0(stack pointers and segment selectors)指向下一个进程的堆栈空间&#xff08;不知这里和copy_thread()里设置proc-&gt;tf = (*trap_frame)(proc-&gt;kstack &#43; KSTACKSIZE) - 1 有什么关联&#xff1f;暂时没有理解&#xff09;。第二条语句修改cr3&#xff0c;即页表基址。第三条语句进行切换&#xff0c;这里便是IDE无法继续查看调用的地方了&#xff0c;而用gdb仍可以很方便地跟踪。</li><li>从进入switch.S到在新进程里运行init_main()的过程如下&#xff1a;\n<pre>switch_to () at kern/process/switch.S:6\n6           movl 4(%esp), %eax          # eax points to from\n(gdb) s\n7           popl 0(%eax)                # save eip !popl\nswitch_to () at kern/process/switch.S:8\n8           movl %esp, 4(%eax)\n9           movl %ebx, 8(%eax)\n10          movl %ecx, 12(%eax)\n11          movl %edx, 16(%eax)\n12          movl %esi, 20(%eax)\n13          movl %edi, 24(%eax)\n14          movl %ebp, 28(%eax)\n17          movl 4(%esp), %eax          # not 8(%esp): popped return address already\n19          movl 28(%eax), %ebp\nswitch_to () at kern/process/switch.S:20\n20          movl 24(%eax), %edi\n21          movl 20(%eax), %esi\n22          movl 16(%eax), %edx\n23          movl 12(%eax), %ecx\n24          movl 8(%eax), %ebx\n25          movl 4(%eax), %esp\n27          pushl 0(%eax)               # push eip\nswitch_to () at kern/process/switch.S:29\n29          ret\nforkret () at kern/process/proc.c:193\n193     forkret(void) {\nforkret () at kern/process/proc.c:194\n194         forkrets(current-&gt;tf);\nforkrets () at kern/trap/trapentry.S:48\n48          movl 4(%esp), %esp\n(gdb) l\n43          iret\n44\n45      .globl forkrets\n46      forkrets:\n47          # set stack to this new process&#39;s trapframe\n48          movl 4(%esp), %esp\n49          jmp __trapret\n(gdb) s\nforkrets () at kern/trap/trapentry.S:49\n49          jmp __trapret\n(gdb) \n__trapret () at kern/trap/trapentry.S:33\n33          popal\n(gdb) \n__trapret () at kern/trap/trapentry.S:36\n36          popl %gs\n37          popl %fs\n38          popl %es\n39          popl %ds\n42          addl $0x8, %esp\n43          iret\n5           pushl %edx              # push arg\n6           call *%ebx              # call fn\n(gdb) s\ninit_main (arg=&lt;error reading variable: Unknown argument list address for &#96;arg&#39;.&gt;)\n    at kern/process/proc.c:359\n359     init_main(void *arg) {</pre>\n可以看到首先是我们讨论很多的两段代码&#xff0c;取esp&#43;4&#xff08;movl 4(%esp), %eax&#xff09;&#xff0c;然后保存现场&#xff0c;存当前一系列寄存器到第一个参数的内存空间里&#xff0c;然后取esp&#43;8&#xff08;movl 4(%esp), %eax&#xff09;&#xff0c;这里由于已经pop过了&#xff0c;所以只需继续&#43;4&#xff0c;然后将第二个参数的内存空间里的值赋给一系列寄存器。事实上两个参数就是&amp;(prev-&gt;context), &amp;(next-&gt;context)&#xff0c;保存了各自的上下文。</li><li>然后ret就是奇妙的地方了&#xff0c;按理说本来调用proc_run()返回也应该返回到这个函数里去&#xff0c;但是由于上下文切换&#xff0c;我们就返回到第二个参数也就是新进程里设置好的上下文中指定的地方去了。我们指定的哪呢&#xff1f;如果还记得的话&#xff0c;我们在copy_thread()里将context的eip变量设为了(uintptr_t)forkret&#xff0c;所以返回应该返回到这去。这个函数又会跳到trapentry.S文件里的forkrets&#xff0c;设置好中断栈帧&#xff0c;再跳到__trapret&#xff0c;进行一系列中断完成前的准备&#xff0c;包括清空栈帧&#xff0c;执行中断前的指令&#xff1a;\n<pre>42          addl $0x8, %esp\n(gdb) \n43          iret\n(gdb) \n5           pushl %edx              # push arg\n(gdb) \n6           call *%ebx              # call fn</pre>\n这里将esp加8&#xff0c;执行中断返回iret&#xff0c;跳转到文件第5、6行&#xff0c;但是并不是原文件的5、6行...后来我发现是entry.S的5、6行&#xff0c;<strong>这里如何自动跳转的我并不明了</strong>。总之call *%ebx就进入了init_main()&#xff0c;就开始执行子进程的代码了。</li><li>当执行完之后&#xff0c;return 0&#xff0c;接着上面entry.S中call之后的代码运行&#xff0c;执行call do_exit&#xff0c;结束了整个程序&#xff0c;跟踪也结束了。<br />\n<pre>(gdb) s\nkernel_thread_entry () at kern/process/entry.S:8\n8           pushl %eax              # save the return value of fn(arg)\n(gdb) \n9           call do_exit            # call do_exit to terminate current thread\n(gdb) \ndo_exit (error_code=&lt;error reading variable: Unknown argument list address for &#96;error_code&#39;.&gt;)\n    at kern/process/proc.c:353\n353     do_exit(int error_code) {\n(gdb) \ndo_exit (error_code=0) at kern/process/proc.c:354\n354         panic(&#34;process exit!!.\\n&#34;);\n(gdb) </pre>\n</li></ol></li></ol></li><li>所以整个流程就是这样&#xff0c;比较繁琐&#xff0c;大家可以就粗体字来一起讨论一下&#xff5e;欢迎回复指出我描述错误或者不明确的地方&#xff5e;</li></ol>"}, {"anon": "no", "uid": "i6rtbanwzcm5t6", "subject": "lab4中do_fork()函数具体如何产生一个新的内核线程的gdb过程展示", "created": "2015-04-20T12:30:29Z", "content": "<p>根据向勇老师的指示&#xff0c;在这里分享一下我跟踪do_fork()及相关创建线程代码的过程。主要内容分为do_fork()主要涉及的子函数功能分析&#xff0c;以及完成do_fork()之后如何启动新的线程init。</p>\n<ol><li>首先把/tools/gdbinit加一条break do_fork()</li><li>可以把makefile里TERMINAL := gnome-terminal改为自己合适的终端&#xff0c;默认的ubuntu不需要改。</li><li>在项目根目录下运行make debug&#xff0c;开始gdb调试。<ol><li>\n<pre>Breakpoint 2, do_fork (clone_flags=256, stack=0, tf=0xc0126f54) at kern/process/proc.c:279\n279     do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf) {\n(gdb) l\n274      * &#64;clone_flags: used to guide how to clone the child process\n275      * &#64;stack:       the parent&#39;s user stack pointer. if stack==0, It means to fork a kernel thread.\n276      * &#64;tf:          the trapframe info, which will be copied to child process&#39;s proc-&gt;tf\n277      */\n278     int\n279     do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf) {\n280         int ret = -E_NO_FREE_PROC;\n281         struct proc_struct *proc;\n282         if (nr_process &gt;= MAX_PROCESS) {\n283             goto fork_out;\n(gdb) n</pre>\n这是初始界面&#xff0c;用list命令查看代码上下文&#xff0c;用next进行下一条代码&#xff08;不进入函数&#xff09;&#xff0c;用step进行下一条代码&#xff08;会进入函数&#xff09;。</li><li>首先会初始化返回值ret&#xff0c;如果进程总数nr_process比最大进程数大&#xff0c;则直接退出&#xff0c;返回-E_NO_FREE_PROC\n<pre>(gdb) n\n280         int ret = -E_NO_FREE_PROC;\n(gdb) p ret\n$1 = 1211072</pre>\n</li><li>然后设置ret为-E_NO_MEM&#xff0c;接着分配TCB&#xff0c;调用alloc_proc()&#xff0c;初始化TCB&#xff0c;具体可以查看alloc_proc()函数&#xff0c;如下\n<pre>    struct proc_struct *proc = kmalloc(sizeof(struct proc_struct));\n    if (proc != NULL) {\n        proc-&gt;state = PROC_UNINIT;\n        proc-&gt;pid = -1;\n        proc-&gt;runs = 0;\n        proc-&gt;kstack = 0;\n        proc-&gt;need_resched = 0;\n        proc-&gt;parent = NULL;\n        proc-&gt;mm = NULL;\n        memset(&amp;(proc-&gt;context), 0, sizeof(struct context));\n        proc-&gt;tf = NULL;\n        proc-&gt;cr3 = boot_cr3;\n        proc-&gt;flags = 0;\n        memset(proc-&gt;name, 0, PROC_NAME_LEN);\n    }\n    return proc;</pre>\n可以看出是对TCB的变量进行初始设置。</li><li>之后分配内核堆栈\n<pre>    struct Page *page = alloc_pages(KSTACKPAGE);\n    if (page != NULL) {\n        proc-&gt;kstack = (uintptr_t)page2kva(page);\n        return 0;\n    }\n    return -E_NO_MEM;</pre>\n这里很重要的一点是<strong>调用之前我们实现的alloc_pages</strong>&#xff0c;并且把proc-&gt;kstack指向新的页面&#xff0c;page2kva会算出page指针相对于pages这个起始地址的偏移&#xff0c;进而可以得到其相对的内核虚拟地址。如果页面内存不足&#xff0c;则返回失败。</li><li>接着会调用copy_mm()&#xff0c;但是lab4不会涉及到内存空间的切换&#xff08;因为都是内核线程&#xff09;&#xff0c;lab5涉及用户进程才会用到&#xff0c;所以这里面只是一个简单的assert&#xff0c;便返回了。</li><li>接着是<strong>最重要的copy_thread(proc, stack, tf);</strong>\n<pre>static void\ncopy_thread(struct proc_struct *proc, uintptr_t esp, struct trapframe *tf) {\n    proc-&gt;tf = (struct trapframe *)(proc-&gt;kstack &#43; KSTACKSIZE) - 1;\n    *(proc-&gt;tf) = *tf;\n    proc-&gt;tf-&gt;tf_regs.reg_eax = 0;\n    proc-&gt;tf-&gt;tf_esp = esp;\n    proc-&gt;tf-&gt;tf_eflags |= FL_IF;\n\n    proc-&gt;context.eip = (uintptr_t)forkret;\n    proc-&gt;context.esp = (uintptr_t)(proc-&gt;tf);\n}</pre>\n利用kstack得到上面我们分配的空间&#xff0c;将proc-&gt;tf指针的地址设置好&#xff0c;<strong>我没有弄明白</strong>的地方在于为什么偏移之后还要<strong>再减一</strong>呢&#xff1f;之后会复制传进来的参数——父进程的trapframe指针&#xff0c;然后设置<strong>子进程中断栈帧中保存的eax</strong>&#xff0c;这是子进程开始运行之后eax会被还原的值。需要明确的是&#xff0c;这一系列操作都是在父进程中进行的&#xff0c;通过父进程设置好子进程中一系列环境之后&#xff0c;再会有相应的函数让子进程开始运行。之后会设置esp、flag等。然后是&#xff1a;\n<pre>    proc-&gt;context.eip = (uintptr_t)forkret;\n    proc-&gt;context.esp = (uintptr_t)(proc-&gt;tf);</pre>\n这里十分重要&#xff0c;会设置指令指针eip为forkret函数&#xff0c;esp为父进程的中断栈帧&#xff0c;这样进入子进程后就会调用forkret函数&#xff0c;具体等我们后面跟踪到子进程启动再说。</li><li>之后返回到do_fork()里&#xff0c;分配pid&#xff0c;值得一提的是这里用了hash_proc&#xff0c;使得根据pid得到相应TCB会更快。具体分配算法这里就不细讲了...</li><li>然后会加入proc_list。然后再wakeup_proc()&#xff0c;设置新创建的线程为RUNNABLE。</li><li>然后我们来看<strong>如何启动</strong>这个我们创建的子线程&#xff1a;<ol><li>继续跟踪&#xff0c;我们发现do_fork()依次会返回到kernel_thread()再到proc_init()&#xff0c;最后到kern_init()&#xff0c;也就是内核初始化里面&#xff0c;再proc_init()之后有\n<pre>    ide_init();                 // init ide devices\n    swap_init();                // init swap\n\n    clock_init();               // init clock interrupt\n    intr_enable();              // enable irq interrupt\n    \n    cpu_idle();                 // run idle process</pre>\n这一系列初始化&#xff0c;而cpu_idle()看名字就知道是我们所关心的了&#xff0c;进去之后&#xff0c;\n<pre>void\ncpu_idle(void) {\n    while (1) {\n        if (current-&gt;need_resched) {\n            schedule();\n        }\n    }\n}</pre>\n我们发现他会循环判断当前进程/线程current-&gt;need_resched是否为真。在之前跟踪的过程中&#xff0c;在alloc_pro()函数里&#xff0c;我们初始化的子线程的need_resched设置的为0&#xff0c;而在proc_init()函数里&#xff1a;\n<pre>    idleproc-&gt;pid = 0;\n    idleproc-&gt;state = PROC_RUNNABLE;\n    idleproc-&gt;kstack = (uintptr_t)bootstack;\n    idleproc-&gt;need_resched = 1;\n    set_proc_name(idleproc, &#34;idle&#34;);\n    nr_process &#43;&#43;;\n    current = idleproc;</pre>\n我们可以看到idleproc也即空闲进程的need_resched初始是为1的&#xff0c;所current-&gt;need_resched为1&#xff0c;所以会在cpu_idle()里判断为真&#xff0c;进入schedule()函数。</li><li>而在schedule()函数里&#xff0c;首先会通过一个do-while loop在proc_list里找到第一个RUNNABLE的进程&#xff0c;如果找到了就break。事实上&#xff0c;循环退出有两种情况&#xff1a;一是找到了一个非空的RUNNABLE的进程&#xff0c;那么会接着往下走&#xff1b;还有一种情况是遍历完了&#xff0c;又回到队列头然后退出循环&#xff0c;此时指针指向的不是一个有效的可以运行的进程&#xff0c;所以它做了判断&#xff0c;将指针换成idleproc也就是空闲进程。这样一来如果队列里没有其他就绪进程的话&#xff0c;便会一直运行idleproc空闲进程。</li><li>如果找到了其他非current的就绪的进程&#xff0c;就会<strong>调用proc_run()&#xff0c;</strong>这就开始运行我们之前创建的init进程了。\n<pre>load_esp0(next-&gt;kstack &#43; KSTACKSIZE);\nlcr3(next-&gt;cr3);\nswitch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context));</pre>\n这三条语句就是proc_run()的核心&#xff0c;第一条语句修改TSS任务状态栈&#xff0c;将TSS的ts_esp0(stack pointers and segment selectors)指向下一个进程的堆栈空间&#xff08;不知这里和copy_thread()里设置proc-&gt;tf = (*trap_frame)(proc-&gt;kstack &#43; KSTACKSIZE) - 1 有什么关联&#xff1f;暂时没有理解&#xff09;。第二条语句修改cr3&#xff0c;即页表基址。第三条语句进行切换&#xff0c;这里便是IDE无法继续查看调用的地方了&#xff0c;而用gdb仍可以很方便地跟踪。</li><li>从进入switch.S到在新进程里运行init_main()的过程如下&#xff1a;\n<pre>switch_to () at kern/process/switch.S:6\n6           movl 4(%esp), %eax          # eax points to from\n(gdb) s\n7           popl 0(%eax)                # save eip !popl\nswitch_to () at kern/process/switch.S:8\n8           movl %esp, 4(%eax)\n9           movl %ebx, 8(%eax)\n10          movl %ecx, 12(%eax)\n11          movl %edx, 16(%eax)\n12          movl %esi, 20(%eax)\n13          movl %edi, 24(%eax)\n14          movl %ebp, 28(%eax)\n17          movl 4(%esp), %eax          # not 8(%esp): popped return address already\n19          movl 28(%eax), %ebp\nswitch_to () at kern/process/switch.S:20\n20          movl 24(%eax), %edi\n21          movl 20(%eax), %esi\n22          movl 16(%eax), %edx\n23          movl 12(%eax), %ecx\n24          movl 8(%eax), %ebx\n25          movl 4(%eax), %esp\n27          pushl 0(%eax)               # push eip\nswitch_to () at kern/process/switch.S:29\n29          ret\nforkret () at kern/process/proc.c:193\n193     forkret(void) {\nforkret () at kern/process/proc.c:194\n194         forkrets(current-&gt;tf);\nforkrets () at kern/trap/trapentry.S:48\n48          movl 4(%esp), %esp\n(gdb) l\n43          iret\n44\n45      .globl forkrets\n46      forkrets:\n47          # set stack to this new process&#39;s trapframe\n48          movl 4(%esp), %esp\n49          jmp __trapret\n(gdb) s\nforkrets () at kern/trap/trapentry.S:49\n49          jmp __trapret\n(gdb) \n__trapret () at kern/trap/trapentry.S:33\n33          popal\n(gdb) \n__trapret () at kern/trap/trapentry.S:36\n36          popl %gs\n37          popl %fs\n38          popl %es\n39          popl %ds\n42          addl $0x8, %esp\n43          iret\n5           pushl %edx              # push arg\n6           call *%ebx              # call fn\n(gdb) s\ninit_main (arg=&lt;error reading variable: Unknown argument list address for &#96;arg&#39;.&gt;)\n    at kern/process/proc.c:359\n359     init_main(void *arg) {</pre>\n可以看到首先是我们讨论很多的两段代码&#xff0c;取esp&#43;4&#xff08;movl 4(%esp), %eax&#xff09;&#xff0c;然后保存现场&#xff0c;存当前一系列寄存器到第一个参数的内存空间里&#xff0c;然后取esp&#43;8&#xff08;movl 4(%esp), %eax&#xff09;&#xff0c;这里由于已经pop过了&#xff0c;所以只需继续&#43;4&#xff0c;然后将第二个参数的内存空间里的值赋给一系列寄存器。事实上两个参数就是&amp;(prev-&gt;context), &amp;(next-&gt;context)&#xff0c;保存了各自的上下文。</li><li>然后ret就是奇妙的地方了&#xff0c;按理说本来调用proc_run()返回也应该返回到这个函数里去&#xff0c;但是由于上下文切换&#xff0c;我们就返回到第二个参数也就是新进程里设置好的上下文中指定的地方去了。我们指定的哪呢&#xff1f;如果还记得的话&#xff0c;我们在copy_thread()里将context的eip变量设为了(uintptr_t)forkret&#xff0c;所以返回应该返回到这去。这个函数又会跳到trapentry.S文件里的forkrets&#xff0c;设置好中断栈帧&#xff0c;再跳到__trapret&#xff0c;进行一系列中断完成前的准备&#xff0c;包括清空栈帧&#xff0c;执行中断前的指令&#xff1a;\n<pre>42          addl $0x8, %esp\n(gdb) \n43          iret\n(gdb) \n5           pushl %edx              # push arg\n(gdb) \n6           call *%ebx              # call fn</pre>\n这里将esp加8&#xff0c;执行中断返回iret&#xff0c;跳转到文件第5、6行&#xff0c;但是并不是原文件的5、6行...后来我发现是entry.S的5、6行&#xff0c;<strong>这里如何自动跳转的我并不明了&#xff08;NEW&#xff1a;在kernel_thread()函数里&#xff0c;一个临时的中断帧tf中设置了eip为kernel_thread_entry&#xff0c;所以会跳到/process/entry.S&#xff09;</strong>。总之call *%ebx就进入了init_main()&#xff0c;就开始执行子进程的代码了。</li><li>当执行完之后&#xff0c;return 0&#xff0c;接着上面entry.S中call之后的代码运行&#xff0c;执行call do_exit&#xff0c;结束了整个程序&#xff0c;跟踪也结束了。<br />\n<pre>(gdb) s\nkernel_thread_entry () at kern/process/entry.S:8\n8           pushl %eax              # save the return value of fn(arg)\n(gdb) \n9           call do_exit            # call do_exit to terminate current thread\n(gdb) \ndo_exit (error_code=&lt;error reading variable: Unknown argument list address for &#96;error_code&#39;.&gt;)\n    at kern/process/proc.c:353\n353     do_exit(int error_code) {\n(gdb) \ndo_exit (error_code=0) at kern/process/proc.c:354\n354         panic(&#34;process exit!!.\\n&#34;);\n(gdb) </pre>\n</li></ol></li></ol></li><li>所以整个流程就是这样&#xff0c;比较繁琐&#xff0c;大家可以就粗体字来一起讨论一下&#xff5e;欢迎回复指出我描述错误或者不明确的地方&#xff5e;</li></ol>"}, {"anon": "no", "uid": "i6rtbanwzcm5t6", "subject": "lab4中do_fork()函数具体如何产生一个新的内核线程的gdb过程展示", "created": "2015-04-20T10:43:49Z", "content": "<p>根据向勇老师的指示&#xff0c;在这里分享一下我跟踪do_fork()及相关创建线程代码的过程。主要内容分为do_fork()主要涉及的子函数功能分析&#xff0c;以及完成do_fork()之后如何启动新的线程init。</p>\n<ol><li>首先把/tools/gdbinit加一条break do_fork()</li><li>可以把makefile里TERMINAL := gnome-terminal改为自己合适的终端&#xff0c;默认的ubuntu不需要改。</li><li>在项目根目录下运行make debug&#xff0c;开始gdb调试。<ol><li>\n<pre>Breakpoint 2, do_fork (clone_flags=256, stack=0, tf=0xc0126f54) at kern/process/proc.c:279\n279     do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf) {\n(gdb) l\n274      * &#64;clone_flags: used to guide how to clone the child process\n275      * &#64;stack:       the parent&#39;s user stack pointer. if stack==0, It means to fork a kernel thread.\n276      * &#64;tf:          the trapframe info, which will be copied to child process&#39;s proc-&gt;tf\n277      */\n278     int\n279     do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf) {\n280         int ret = -E_NO_FREE_PROC;\n281         struct proc_struct *proc;\n282         if (nr_process &gt;= MAX_PROCESS) {\n283             goto fork_out;\n(gdb) n</pre>\n这是初始界面&#xff0c;用list命令查看代码上下文&#xff0c;用next进行下一条代码&#xff08;不进入函数&#xff09;&#xff0c;用step进行下一条代码&#xff08;会进入函数&#xff09;。</li><li>首先会初始化返回值ret&#xff0c;如果进程总数nr_process比最大进程数大&#xff0c;则直接退出&#xff0c;返回-E_NO_FREE_PROC\n<pre>(gdb) n\n280         int ret = -E_NO_FREE_PROC;\n(gdb) p ret\n$1 = 1211072</pre>\n</li><li>然后设置ret为-E_NO_MEM&#xff0c;接着分配TCB&#xff0c;调用alloc_proc()&#xff0c;初始化TCB&#xff0c;具体可以查看alloc_proc()函数&#xff0c;如下\n<pre>    struct proc_struct *proc = kmalloc(sizeof(struct proc_struct));\n    if (proc != NULL) {\n        proc-&gt;state = PROC_UNINIT;\n        proc-&gt;pid = -1;\n        proc-&gt;runs = 0;\n        proc-&gt;kstack = 0;\n        proc-&gt;need_resched = 0;\n        proc-&gt;parent = NULL;\n        proc-&gt;mm = NULL;\n        memset(&amp;(proc-&gt;context), 0, sizeof(struct context));\n        proc-&gt;tf = NULL;\n        proc-&gt;cr3 = boot_cr3;\n        proc-&gt;flags = 0;\n        memset(proc-&gt;name, 0, PROC_NAME_LEN);\n    }\n    return proc;</pre>\n可以看出是对TCB的变量进行初始设置。</li><li>之后分配内核堆栈\n<pre>    struct Page *page = alloc_pages(KSTACKPAGE);\n    if (page != NULL) {\n        proc-&gt;kstack = (uintptr_t)page2kva(page);\n        return 0;\n    }\n    return -E_NO_MEM;</pre>\n这里很重要的一点是<strong>调用之前我们实现的alloc_pages</strong>&#xff0c;并且把proc-&gt;kstack指向新的页面&#xff0c;page2kva会算出page指针相对于pages这个起始地址的偏移&#xff0c;进而可以得到其相对的内核虚拟地址。如果页面内存不足&#xff0c;则返回失败。</li><li>接着会调用copy_mm()&#xff0c;但是lab4不会涉及到内存空间的切换&#xff08;因为都是内核线程&#xff09;&#xff0c;lab5涉及用户进程才会用到&#xff0c;所以这里面只是一个简单的assert&#xff0c;便返回了。</li><li>接着是<strong>最重要的copy_thread(proc, stack, tf);</strong>\n<pre>static void\ncopy_thread(struct proc_struct *proc, uintptr_t esp, struct trapframe *tf) {\n    proc-&gt;tf = (struct trapframe *)(proc-&gt;kstack &#43; KSTACKSIZE) - 1;\n    *(proc-&gt;tf) = *tf;\n    proc-&gt;tf-&gt;tf_regs.reg_eax = 0;\n    proc-&gt;tf-&gt;tf_esp = esp;\n    proc-&gt;tf-&gt;tf_eflags |= FL_IF;\n\n    proc-&gt;context.eip = (uintptr_t)forkret;\n    proc-&gt;context.esp = (uintptr_t)(proc-&gt;tf);\n}</pre>\n利用kstack得到上面我们分配的空间&#xff0c;将proc-&gt;tf指针的地址设置好&#xff0c;<strong>我没有弄明白</strong>的地方在于为什么偏移之后还要<strong>再减一</strong>呢&#xff1f;之后会复制传进来的参数——父进程的trapframe指针&#xff0c;然后设置<strong>子进程中断栈帧中保存的eax</strong>&#xff0c;这是子进程开始运行之后eax会被还原的值。需要明确的是&#xff0c;这一系列操作都是在父进程中进行的&#xff0c;通过父进程设置好子进程中一系列环境之后&#xff0c;再会有相应的函数让子进程开始运行。之后会设置esp、flag等。然后是&#xff1a;\n<pre>    proc-&gt;context.eip = (uintptr_t)forkret;\n    proc-&gt;context.esp = (uintptr_t)(proc-&gt;tf);</pre>\n这里十分重要&#xff0c;会设置指令指针eip为forkret函数&#xff0c;esp为父进程的中断栈帧&#xff0c;这样进入子进程后就会调用forkret函数&#xff0c;具体等我们后面跟踪到子进程启动再说。</li><li>之后返回到do_fork()里&#xff0c;分配pid&#xff0c;值得一提的是这里用了hash_proc&#xff0c;使得根据pid得到相应TCB会更快。具体分配算法这里就不细讲了...</li><li>然后会加入proc_list。然后再wakeup_proc()&#xff0c;设置新创建的线程为RUNNABLE。</li><li>然后我们来看<strong>如何启动</strong>这个我们创建的子线程&#xff1a;<ol><li>继续跟踪&#xff0c;我们发现do_fork()依次会返回到kernel_thread()再到proc_init()&#xff0c;最后到kern_init()&#xff0c;也就是内核初始化里面&#xff0c;再proc_init()之后有\n<pre>    ide_init();                 // init ide devices\n    swap_init();                // init swap\n\n    clock_init();               // init clock interrupt\n    intr_enable();              // enable irq interrupt\n    \n    cpu_idle();                 // run idle process</pre>\n这一系列初始化&#xff0c;而cpu_idle()看名字就知道是我们所关心的了&#xff0c;进去之后&#xff0c;\n<pre>void\ncpu_idle(void) {\n    while (1) {\n        if (current-&gt;need_resched) {\n            schedule();\n        }\n    }\n}</pre>\n我们发现他会循环判断当前进程/线程current-&gt;need_resched是否为真。在之前跟踪的过程中&#xff0c;在alloc_pro()函数里&#xff0c;我们初始化的子线程的need_resched设置的为0&#xff0c;而在proc_init()函数里&#xff1a;\n<pre>    idleproc-&gt;pid = 0;\n    idleproc-&gt;state = PROC_RUNNABLE;\n    idleproc-&gt;kstack = (uintptr_t)bootstack;\n    idleproc-&gt;need_resched = 1;\n    set_proc_name(idleproc, &#34;idle&#34;);\n    nr_process &#43;&#43;;\n    current = idleproc;</pre>\n我们可以看到idleproc也即空闲进程的need_resched初始是为1的&#xff0c;所current-&gt;need_resched为1&#xff0c;所以会在cpu_idle()里判断为真&#xff0c;进入schedule()函数。</li><li>而在schedule()函数里&#xff0c;首先会通过一个do-while loop在proc_list里找到第一个RUNNABLE的进程&#xff0c;如果找到了就break。事实上&#xff0c;循环退出有两种情况&#xff1a;一是找到了一个非空的RUNNABLE的进程&#xff0c;那么会接着往下走&#xff1b;还有一种情况是遍历完了&#xff0c;又回到队列头然后退出循环&#xff0c;此时指针指向的不是一个有效的可以运行的进程&#xff0c;所以它做了判断&#xff0c;将指针换成idleproc也就是空闲进程。这样一来如果队列里没有其他就绪进程的话&#xff0c;便会一直运行idleproc空闲进程。</li><li>如果找到了其他非current的就绪的进程&#xff0c;就会<strong>调用proc_run()&#xff0c;</strong>这就开始运行我们之前创建的init进程了。\n<pre>load_esp0(next-&gt;kstack &#43; KSTACKSIZE);\nlcr3(next-&gt;cr3);\nswitch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context));</pre>\n这三条语句就是proc_run()的核心&#xff0c;第一条语句修改TSS任务状态栈&#xff0c;将TSS的ts_esp0(stack pointers and segment selectors)指向下一个进程的堆栈空间&#xff08;不知这里和copy_thread()里设置proc-&gt;tf = (*trap_frame)(proc-&gt;kstack &#43; KSTACKSIZE) - 1 有什么关联&#xff1f;暂时没有理解&#xff09;。第二条语句修改cr3&#xff0c;即页表基址。第三条语句进行切换&#xff0c;这里便是IDE无法继续查看调用的地方了&#xff0c;而用gdb仍可以很方便地跟踪。</li><li>从进入switch.S到在新进程里运行init_main()的过程如下&#xff1a;\n<pre>switch_to () at kern/process/switch.S:6\n6           movl 4(%esp), %eax          # eax points to from\n(gdb) s\n7           popl 0(%eax)                # save eip !popl\nswitch_to () at kern/process/switch.S:8\n8           movl %esp, 4(%eax)\n9           movl %ebx, 8(%eax)\n10          movl %ecx, 12(%eax)\n11          movl %edx, 16(%eax)\n12          movl %esi, 20(%eax)\n13          movl %edi, 24(%eax)\n14          movl %ebp, 28(%eax)\n17          movl 4(%esp), %eax          # not 8(%esp): popped return address already\n19          movl 28(%eax), %ebp\nswitch_to () at kern/process/switch.S:20\n20          movl 24(%eax), %edi\n21          movl 20(%eax), %esi\n22          movl 16(%eax), %edx\n23          movl 12(%eax), %ecx\n24          movl 8(%eax), %ebx\n25          movl 4(%eax), %esp\n27          pushl 0(%eax)               # push eip\nswitch_to () at kern/process/switch.S:29\n29          ret\nforkret () at kern/process/proc.c:193\n193     forkret(void) {\nforkret () at kern/process/proc.c:194\n194         forkrets(current-&gt;tf);\nforkrets () at kern/trap/trapentry.S:48\n48          movl 4(%esp), %esp\n(gdb) l\n43          iret\n44\n45      .globl forkrets\n46      forkrets:\n47          # set stack to this new process&#39;s trapframe\n48          movl 4(%esp), %esp\n49          jmp __trapret\n(gdb) s\nforkrets () at kern/trap/trapentry.S:49\n49          jmp __trapret\n(gdb) \n__trapret () at kern/trap/trapentry.S:33\n33          popal\n(gdb) \n__trapret () at kern/trap/trapentry.S:36\n36          popl %gs\n37          popl %fs\n38          popl %es\n39          popl %ds\n42          addl $0x8, %esp\n43          iret\n5           pushl %edx              # push arg\n6           call *%ebx              # call fn\n(gdb) s\ninit_main (arg=&lt;error reading variable: Unknown argument list address for &#96;arg&#39;.&gt;)\n    at kern/process/proc.c:359\n359     init_main(void *arg) {</pre>\n可以看到首先是我们讨论很多的两段代码&#xff0c;取esp&#43;4&#xff08;movl 4(%esp), %eax&#xff09;&#xff0c;然后保存现场&#xff0c;存当前一系列寄存器到第一个参数的内存空间里&#xff0c;然后取esp&#43;8&#xff08;movl 4(%esp), %eax&#xff09;&#xff0c;这里由于已经pop过了&#xff0c;所以只需继续&#43;4&#xff0c;然后将第二个参数的内存空间里的值赋给一系列寄存器。事实上两个参数就是&amp;(prev-&gt;context), &amp;(next-&gt;context)&#xff0c;保存了各自的上下文。</li><li>然后ret就是奇妙的地方了&#xff0c;按理说本来调用proc_run()返回也应该返回到这个函数里去&#xff0c;但是由于上下文切换&#xff0c;我们就返回到第二个参数也就是新进程里设置好的上下文中指定的地方去了。我们指定的哪呢&#xff1f;如果还记得的话&#xff0c;我们在copy_thread()里将context的eip变量设为了(uintptr_t)forkret&#xff0c;所以返回应该返回到这去。这个函数又会跳到trapentry.S文件里的forkrets&#xff0c;设置好中断栈帧&#xff0c;再跳到__trapret&#xff0c;进行一系列中断完成前的准备&#xff0c;包括清空栈帧&#xff0c;执行中断前的指令&#xff1a;\n<pre>42          addl $0x8, %esp\n(gdb) \n43          iret\n(gdb) \n5           pushl %edx              # push arg\n(gdb) \n6           call *%ebx              # call fn</pre>\n这里将esp加8&#xff0c;执行中断返回iret&#xff0c;跳转到文件第5、6行&#xff0c;但是并不是原文件的5、6行...后来我发现是entry.S的5、6行&#xff0c;<strong>这里如何自动跳转的我并不明了</strong>。总之call *%ebx就进入了init_main()&#xff0c;就开始执行子进程的代码了。</li><li>当执行完之后&#xff0c;return 0&#xff0c;接着上面entry.S中call之后的代码运行&#xff0c;执行call do_exit&#xff0c;结束了整个程序&#xff0c;跟踪也结束了。<br />\n<pre>(gdb) s\nkernel_thread_entry () at kern/process/entry.S:8\n8           pushl %eax              # save the return value of fn(arg)\n(gdb) \n9           call do_exit            # call do_exit to terminate current thread\n(gdb) \ndo_exit (error_code=&lt;error reading variable: Unknown argument list address for &#96;error_code&#39;.&gt;)\n    at kern/process/proc.c:353\n353     do_exit(int error_code) {\n(gdb) \ndo_exit (error_code=0) at kern/process/proc.c:354\n354         panic(&#34;process exit!!.\\n&#34;);\n(gdb) </pre>\n</li></ol></li></ol></li><li>所以整个流程就是这样&#xff0c;比较繁琐&#xff0c;大家可以就粗体字来一起讨论一下&#xff5e;欢迎回复指出我描述错误或者不明确的地方&#xff5e;</li></ol>"}, {"anon": "no", "uid": "i6rtbanwzcm5t6", "subject": "lab4中do_fork()函数具体如何产生一个新的内核线程的gdb过程展示", "created": "2015-04-20T10:42:37Z", "content": "<p>根据向勇老师的指示&#xff0c;在这里分享一下我跟踪do_fork()及相关创建线程代码的过程。主要内容分为do_fork()主要涉及的子函数功能分析&#xff0c;以及完成do_fork()之后如何启动新的线程init。</p>\n<ol><li>首先把/tools/gdbinit加一条break do_fork()</li><li>可以把makefile里TERMINAL := gnome-terminal改为自己合适的终端&#xff0c;默认的ubuntu不需要改。</li><li>在项目根目录下运行make debug&#xff0c;开始gdb调试。<ol><li>\n<pre>Breakpoint 2, do_fork (clone_flags=256, stack=0, tf=0xc0126f54) at kern/process/proc.c:279<br />279     do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf) {<br />(gdb) l<br />274      * &#64;clone_flags: used to guide how to clone the child process<br />275      * &#64;stack:       the parent&#39;s user stack pointer. if stack==0, It means to fork a kernel thread.<br />276      * &#64;tf:          the trapframe info, which will be copied to child process&#39;s proc-&gt;tf<br />277      */<br />278     int<br />279     do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf) {<br />280         int ret = -E_NO_FREE_PROC;<br />281         struct proc_struct *proc;<br />282         if (nr_process &gt;= MAX_PROCESS) {<br />283             goto fork_out;<br />(gdb) n</pre>\n这是初始界面&#xff0c;用list命令查看代码上下文&#xff0c;用next进行下一条代码&#xff08;不进入函数&#xff09;&#xff0c;用step进行下一条代码&#xff08;会进入函数&#xff09;。</li><li>首先会初始化返回值ret&#xff0c;如果进程总数nr_process比最大进程数大&#xff0c;则直接退出&#xff0c;返回-E_NO_FREE_PROC\n<pre>(gdb) n<br />280         int ret = -E_NO_FREE_PROC;<br />(gdb) p ret<br />$1 = 1211072</pre>\n</li><li>然后设置ret为-E_NO_MEM&#xff0c;接着分配TCB&#xff0c;调用alloc_proc()&#xff0c;初始化TCB&#xff0c;具体可以查看alloc_proc()函数&#xff0c;如下\n<pre>    struct proc_struct *proc = kmalloc(sizeof(struct proc_struct));<br />    if (proc != NULL) {<br />        proc-&gt;state = PROC_UNINIT;<br />        proc-&gt;pid = -1;<br />        proc-&gt;runs = 0;<br />        proc-&gt;kstack = 0;<br />        proc-&gt;need_resched = 0;<br />        proc-&gt;parent = NULL;<br />        proc-&gt;mm = NULL;<br />        memset(&amp;(proc-&gt;context), 0, sizeof(struct context));<br />        proc-&gt;tf = NULL;<br />        proc-&gt;cr3 = boot_cr3;<br />        proc-&gt;flags = 0;<br />        memset(proc-&gt;name, 0, PROC_NAME_LEN);<br />    }<br />    return proc;</pre>\n可以看出是对TCB的变量进行初始设置。</li><li>之后分配内核堆栈\n<pre>    struct Page *page = alloc_pages(KSTACKPAGE);<br />    if (page != NULL) {<br />        proc-&gt;kstack = (uintptr_t)page2kva(page);<br />        return 0;<br />    }<br />    return -E_NO_MEM;</pre>\n这里很重要的一点是<strong>调用之前我们实现的alloc_pages</strong>&#xff0c;并且把proc-&gt;kstack指向新的页面&#xff0c;page2kva会算出page指针相对于pages这个起始地址的偏移&#xff0c;进而可以得到其相对的内核虚拟地址。如果页面内存不足&#xff0c;则返回失败。</li><li>接着会调用copy_mm()&#xff0c;但是lab4不会涉及到内存空间的切换&#xff08;因为都是内核线程&#xff09;&#xff0c;lab5涉及用户进程才会用到&#xff0c;所以这里面只是一个简单的assert&#xff0c;便返回了。</li><li>接着是<strong>最重要的copy_thread(proc, stack, tf);</strong>\n<pre>static void<br />copy_thread(struct proc_struct *proc, uintptr_t esp, struct trapframe *tf) {<br />    proc-&gt;tf = (struct trapframe *)(proc-&gt;kstack &#43; KSTACKSIZE) - 1;<br />    *(proc-&gt;tf) = *tf;<br />    proc-&gt;tf-&gt;tf_regs.reg_eax = 0;<br />    proc-&gt;tf-&gt;tf_esp = esp;<br />    proc-&gt;tf-&gt;tf_eflags |= FL_IF;<br /><br />    proc-&gt;context.eip = (uintptr_t)forkret;<br />    proc-&gt;context.esp = (uintptr_t)(proc-&gt;tf);<br />}</pre>\n利用kstack得到上面我们分配的空间&#xff0c;将proc-&gt;tf指针的地址设置好&#xff0c;<strong>我没有弄明白</strong>的地方在于为什么偏移之后还要<strong>再减一</strong>呢&#xff1f;之后会复制传进来的参数——父进程的trapframe指针&#xff0c;然后设置<strong>子进程中断栈帧中保存的eax</strong>&#xff0c;这是子进程开始运行之后eax会被还原的值。需要明确的是&#xff0c;这一系列操作都是在父进程中进行的&#xff0c;通过父进程设置好子进程中一系列环境之后&#xff0c;再会有相应的函数让子进程开始运行。之后会设置esp、flag等。然后是&#xff1a;\n<pre>    proc-&gt;context.eip = (uintptr_t)forkret;<br />    proc-&gt;context.esp = (uintptr_t)(proc-&gt;tf);</pre>\n这里十分重要&#xff0c;会设置指令指针eip为forkret函数&#xff0c;esp为父进程的中断栈帧&#xff0c;这样进入子进程后就会调用forkret函数&#xff0c;具体等我们后面跟踪到子进程启动再说。</li><li>之后返回到do_fork()里&#xff0c;分配pid&#xff0c;值得一提的是这里用了hash_proc&#xff0c;使得根据pid得到相应TCB会更快。具体分配算法这里就不细讲了...</li><li>然后会加入proc_list。然后再wakeup_proc()&#xff0c;设置新创建的线程为RUNNABLE。</li><li>然后我们来看<strong>如何启动</strong>这个我们创建的子线程&#xff1a;<ol><li>继续跟踪&#xff0c;我们发现do_fork()依次会返回到kernel_thread()再到proc_init()&#xff0c;最后到kern_init()&#xff0c;也就是内核初始化里面&#xff0c;再proc_init()之后有\n<pre>    ide_init();                 // init ide devices<br />    swap_init();                // init swap<br /><br />    clock_init();               // init clock interrupt<br />    intr_enable();              // enable irq interrupt<br />    <br />    cpu_idle();                 // run idle process</pre>\n这一系列初始化&#xff0c;而cpu_idle()看名字就知道是我们所关心的了&#xff0c;进去之后&#xff0c;\n<pre>void<br />cpu_idle(void) {<br />    while (1) {<br />        if (current-&gt;need_resched) {<br />            schedule();<br />        }<br />    }<br />}</pre>\n我们发现他会循环判断当前进程/线程current-&gt;need_resched是否为真。在之前跟踪的过程中&#xff0c;在alloc_pro()函数里&#xff0c;我们初始化的子线程的need_resched设置的为0&#xff0c;而在proc_init()函数里&#xff1a;\n<pre>    idleproc-&gt;pid = 0;<br />    idleproc-&gt;state = PROC_RUNNABLE;<br />    idleproc-&gt;kstack = (uintptr_t)bootstack;<br />    idleproc-&gt;need_resched = 1;<br />    set_proc_name(idleproc, &#34;idle&#34;);<br />    nr_process &#43;&#43;;<br />    current = idleproc;</pre>\n我们可以看到idleproc也即空闲进程的need_resched初始是为1的&#xff0c;所current-&gt;need_resched为1&#xff0c;所以会在cpu_idle()里判断为真&#xff0c;进入schedule()函数。</li><li>而在schedule()函数里&#xff0c;首先会通过一个do-while loop在proc_list里找到第一个RUNNABLE的进程&#xff0c;如果找到了就break。事实上&#xff0c;循环退出有两种情况&#xff1a;一是找到了一个非空的RUNNABLE的进程&#xff0c;那么会接着往下走&#xff1b;还有一种情况是遍历完了&#xff0c;又回到队列头然后退出循环&#xff0c;此时指针指向的不是一个有效的可以运行的进程&#xff0c;所以它做了判断&#xff0c;将指针换成idleproc也就是空闲进程。这样一来如果队列里没有其他就绪进程的话&#xff0c;便会一直运行idleproc空闲进程。</li><li>如果找到了其他非current的就绪的进程&#xff0c;就会<strong>调用proc_run()&#xff0c;</strong>这就开始运行我们之前创建的init进程了。\n<pre>load_esp0(next-&gt;kstack &#43; KSTACKSIZE);<br />lcr3(next-&gt;cr3);<br />switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context));</pre>\n这三条语句就是proc_run()的核心&#xff0c;第一条语句修改TSS任务状态栈&#xff0c;将TSS的ts_esp0(stack pointers and segment selectors)指向下一个进程的堆栈空间&#xff08;不知这里和copy_thread()里设置proc-&gt;tf = (*trap_frame)(proc-&gt;kstack &#43; KSTACKSIZE) - 1 有什么关联&#xff1f;暂时没有理解&#xff09;。第二条语句修改cr3&#xff0c;即页表基址。第三条语句进行切换&#xff0c;这里便是IDE无法继续查看调用的地方了&#xff0c;而用gdb仍可以很方便地跟踪。</li><li>从进入switch.S到在新进程里运行init_main()的过程如下&#xff1a;\n<pre>switch_to () at kern/process/switch.S:6<br />6           movl 4(%esp), %eax          # eax points to from<br />(gdb) s<br />7           popl 0(%eax)                # save eip !popl<br />switch_to () at kern/process/switch.S:8<br />8           movl %esp, 4(%eax)<br />9           movl %ebx, 8(%eax)<br />10          movl %ecx, 12(%eax)<br />11          movl %edx, 16(%eax)<br />12          movl %esi, 20(%eax)<br />13          movl %edi, 24(%eax)<br />14          movl %ebp, 28(%eax)<br />17          movl 4(%esp), %eax          # not 8(%esp): popped return address already<br />19          movl 28(%eax), %ebp<br />switch_to () at kern/process/switch.S:20<br />20          movl 24(%eax), %edi<br />21          movl 20(%eax), %esi<br />22          movl 16(%eax), %edx<br />23          movl 12(%eax), %ecx<br />24          movl 8(%eax), %ebx<br />25          movl 4(%eax), %esp<br />27          pushl 0(%eax)               # push eip<br />switch_to () at kern/process/switch.S:29<br />29          ret<br />forkret () at kern/process/proc.c:193<br />193     forkret(void) {<br />forkret () at kern/process/proc.c:194<br />194         forkrets(current-&gt;tf);<br />forkrets () at kern/trap/trapentry.S:48<br />48          movl 4(%esp), %esp<br />(gdb) l<br />43          iret<br />44<br />45      .globl forkrets<br />46      forkrets:<br />47          # set stack to this new process&#39;s trapframe<br />48          movl 4(%esp), %esp<br />49          jmp __trapret<br />(gdb) s<br />forkrets () at kern/trap/trapentry.S:49<br />49          jmp __trapret<br />(gdb) <br />__trapret () at kern/trap/trapentry.S:33<br />33          popal<br />(gdb) <br />__trapret () at kern/trap/trapentry.S:36<br />36          popl %gs<br />37          popl %fs<br />38          popl %es<br />39          popl %ds<br />42          addl $0x8, %esp<br />43          iret<br />5           pushl %edx              # push arg<br />6           call *%ebx              # call fn<br />(gdb) s<br />init_main (arg=&lt;error reading variable: Unknown argument list address for &#96;arg&#39;.&gt;)<br />    at kern/process/proc.c:359<br />359     init_main(void *arg) {</pre>\n可以看到首先是我们讨论很多的两段代码&#xff0c;取esp&#43;4&#xff08;movl 4(%esp), %eax&#xff09;&#xff0c;然后保存现场&#xff0c;存当前一系列寄存器到第一个参数的内存空间里&#xff0c;然后取esp&#43;8&#xff08;movl 4(%esp), %eax&#xff09;&#xff0c;这里由于已经pop过了&#xff0c;所以只需继续&#43;4&#xff0c;然后将第二个参数的内存空间里的值赋给一系列寄存器。事实上两个参数就是&amp;(prev-&gt;context), &amp;(next-&gt;context)&#xff0c;保存了各自的上下文。</li><li>然后ret就是奇妙的地方了&#xff0c;按理说本来调用proc_run()返回也应该返回到这个函数里去&#xff0c;但是由于上下文切换&#xff0c;我们就返回到第二个参数也就是新进程里设置好的上下文中指定的地方去了。我们指定的哪呢&#xff1f;如果还记得的话&#xff0c;我们在copy_thread()里将context的eip变量设为了(uintptr_t)forkret&#xff0c;所以返回应该返回到这去。这个函数又会跳到trapentry.S文件里的forkrets&#xff0c;设置好中断栈帧&#xff0c;再跳到__trapret&#xff0c;进行一系列中断完成前的准备&#xff0c;包括清空栈帧&#xff0c;执行中断前的指令&#xff1a;\n<pre>42          addl $0x8, %esp<br />(gdb) <br />43          iret<br />(gdb) <br />5           pushl %edx              # push arg<br />(gdb) <br />6           call *%ebx              # call fn</pre>\n这里将esp加8&#xff0c;执行中断返回iret&#xff0c;跳转到文件第5、6行&#xff0c;但是并不是原文件的5、6行...后来我发现是entry.S的5、6行&#xff0c;<strong>这里如何自动跳转的我并不明了</strong>。总之call *%ebx就进入了init_main()&#xff0c;就开始执行子进程的代码了。</li><li>当执行完之后&#xff0c;return 0&#xff0c;接着上面entry.S中call之后的代码运行&#xff0c;执行call do_exit&#xff0c;结束了整个程序&#xff0c;跟踪也结束了。<br />\n<pre>(gdb) s<br />kernel_thread_entry () at kern/process/entry.S:8<br />8           pushl %eax              # save the return value of fn(arg)<br />(gdb) <br />9           call do_exit            # call do_exit to terminate current thread<br />(gdb) <br />do_exit (error_code=&lt;error reading variable: Unknown argument list address for &#96;error_code&#39;.&gt;)<br />    at kern/process/proc.c:353<br />353     do_exit(int error_code) {<br />(gdb) <br />do_exit (error_code=0) at kern/process/proc.c:354<br />354         panic(&#34;process exit!!.\\n&#34;);<br />(gdb) </pre>\n</li></ol></li></ol></li><li>所以整个流程就是这样&#xff0c;比较繁琐&#xff0c;大家可以就粗体字来一起讨论一下&#xff5e;欢迎回复指出我描述错误或者不明确的地方&#xff5e;</li></ol>\n<p> </p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>"}], "type": "note", "tags": ["lab4", "student", "unanswered", "课堂问答"], "tag_good": [{"role": "", "name": "陈振寰", "endorser": {}, "admin": false, "photo": "1425297841_35.png", "id": "i6rtbanwzcm5t6", "photo_url": "https://d1b10bmlvqabco.cloudfront.net/photos/i6rtbanwzcm5t6/1425297841_35.png", "published": true, "us": false, "class_sections": ["清华学生_i5j09fnsl7k5x0"], "facebook_id": null}, {"role": "", "name": "Junjie Mao", "endorser": {}, "admin": false, "photo": "1425891134_35.png", "id": "hdjoucuyb836fq", "photo_url": "https://d1b10bmlvqabco.cloudfront.net/photos/hdjoucuyb836fq/1425891134_35.png", "published": true, "us": false, "class_sections": ["课程设计_i5j09fnsl7k5x0", "清华学生_i5j09fnsl7k5x0", "所有老师和助教_i5j09fnsl7k5x0"], "facebook_id": null}, {"role": "instructor", "name": "Yu Chen", "endorser": {}, "admin": true, "photo": "1378950179_35.png", "id": "hcrrjuyequh4bt", "photo_url": "https://d1b10bmlvqabco.cloudfront.net/photos/hcrrjuyequh4bt/1378950179_35.png", "us": false, "class_sections": ["课程设计_i5j09fnsl7k5x0", "清华学生_i5j09fnsl7k5x0", "所有老师和助教_i5j09fnsl7k5x0", "os2018spring_i5j09fnsl7k5x0"], "facebook_id": null}, {"role": "", "name": "suanrong", "endorser": {}, "admin": false, "photo": "1416753618_35.png", "id": "i0c9nvk0xzc2n3", "photo_url": "https://d1b10bmlvqabco.cloudfront.net/photos/i0c9nvk0xzc2n3/1416753618_35.png", "published": true, "us": false, "class_sections": ["清华学生_i5j09fnsl7k5x0"], "facebook_id": null}, {"role": "student", "name": "吴行行", "endorser": {}, "admin": false, "photo": null, "id": "ie7xy8iscsw1t7", "photo_url": null, "published": true, "us": false, "facebook_id": null}], "unique_views": 201, "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>在读ucore实验指导书的过程中&#xff0c;发现我的两个问题得到了解决&#xff1a;</p>\n<ol><li>为什么在copy_thread()函数里proc-&gt;tf要减1&#xff1a;在setup_kstack()函数里&#xff0c;给子进程分配的内存大小就是KSTACKPAGE&#xff0c;将这块内存的最高地址处转换为trap_frame指针&#xff0c;再减一&#xff0c;就在这块内存的顶部空出了一块trap_frame大小的空间&#xff0c;可以用于存储子进程的trap_frame。所以我们可以看到之后的context.esp设置的就是proc-&gt;tf的位置&#xff0c;也即栈顶是从trap_frame之下开始的&#xff08;栈从高地址往低地址存&#xff09;。</li><li>为什么会在iret之后跳转到/process/entry.S的5、6行&#xff1a;在kernel_thread()函数里&#xff0c;一个临时的中断帧tf中设置了eip为kernel_thread_entry&#xff0c;所以会跳到/process/entry.S</li></ol>", "created": "2015-04-20T12:44:42Z", "bucket_order": 258, "bucket_name": "Week 4/19 - 4/25", "type": "followup", "tag_good": [], "uid": "i6rtbanwzcm5t6", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "i8pvkazchli29e", "updated": "2015-04-20T12:44:42Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "last = (current == idleproc) ? &amp;proc_list : &amp;(current-&gt;list_link);\n 这里要分成两部分是因为在用户态线程里也许找不到&amp;proc_list这个变量?所以用&amp;(current-&gt;list_link),对吗?", "created": "2018-04-05T07:14:22Z", "bucket_order": 104, "bucket_name": "Week 4/1 - 4/7", "type": "followup", "tag_good": [], "uid": "jf86jf5n2SKn", "children": [], "tag_good_arr": [], "no_answer": 1, "id": "jfm6rcwge1170r", "updated": "2018-04-05T07:14:22Z", "config": {}}], "tag_good_arr": ["i6rtbanwzcm5t6", "hdjoucuyb836fq", "hcrrjuyequh4bt", "i0c9nvk0xzc2n3", "ie7xy8iscsw1t7"], "id": "i8pr7balcj327l", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 5, "num_favorites": 5, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643167643392, "default_anonymity": "no"}, "error": null, "aid": "kyuzl81s4u2333"}