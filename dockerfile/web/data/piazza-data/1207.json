{"result": {"folders": ["2018", "lab5", "ucore_plus"], "nr": 1207, "data": {"embed_links": []}, "created": "2018-04-20T14:36:41Z", "bucket_order": 3, "no_answer_followup": 0, "change_log": [{"anon": "no", "uid": "it2wrxu13f13sy", "data": "jg825yich1j6wh", "type": "create", "when": "2018-04-20T14:36:41Z"}, {"anon": "no", "uid": "hcrrjuyequh4bt", "to": "jg825yi98qh6wg", "type": "followup", "when": "2018-04-20T14:44:46Z"}, {"anon": "no", "uid": "it2wrxu13f13sy", "to": "jg825yi98qh6wg", "type": "followup", "when": "2018-04-20T17:05:44Z"}, {"anon": "no", "uid": "isu0wqaoff5125", "to": "jg825yi98qh6wg", "type": "followup", "when": "2018-04-29T11:59:36Z"}], "bucket_name": "Today", "history": [{"anon": "no", "uid": "it2wrxu13f13sy", "subject": "关于ucore与ucore&#43;进程间同步互斥的bugs", "created": "2018-04-20T14:36:41Z", "content": "<p>今天在阅读ucore&#43;和ucore的代码后有一些疑问&#xff0c;在微信群里与谭闻德、于纪平、陈康老师讨论后发现了ucore的一类bug&#xff08;ucore&#43;中也有类似原因的bug&#xff09;&#xff0c;记录如下。</p>\n<p></p>\n<p><strong>ucore中&#xff1a;</strong></p>\n<p>在ucore中&#xff0c;并没有实现本应该实现的原子操作。具体而言&#xff0c;在&#xff1a;</p>\n<p></p>\n<p>1. vmm.h中&#xff0c;mm_count的一系列读、写、加、减操作。</p>\n<p>2. pmm.h中&#xff0c;page_ref的一系列读、写、加、减操作。</p>\n<p></p>\n<p>由于mm和page都可能被多个进程共享&#xff0c;这些操作设置成原子操作才是安全的。由于ucore是个仅用于教学的操作系统&#xff0c;他的功能比较简单&#xff0c;但尽管如此&#xff0c;依然可能会有bug。</p>\n<p></p>\n<p>ucore在调用有关page_ref和mm_count的代码的时候&#xff0c;除了每个lab执行的check函数以外&#xff0c;都只可能是在中断发生时候在中断服务例程中做的&#xff0c;此时在内核态。但我们在ucore中设置的是中断或异常都会屏蔽中断&#xff0c;所以中断服务例程执行的时候不存在进程切换&#xff0c;只有一个进程一直执行&#xff0c;直到中断返回。因此&#xff0c;在发生中断或异常时&#xff0c;中断服务例程执行的所有page_ref和mm_count的代码都不需要考虑同步互斥。</p>\n<p></p>\n<p>但是&#xff0c;在lab5中我们实现了syscall&#xff0c;并且把syscall的idt entry中的istrap位置为了1&#xff0c;这样一来在用户态syscall进入内核态后&#xff0c;是可以继续响应中断的&#xff0c;因此在执行有关page_ref和mm_count的代码时&#xff0c;可能由于进程切换而导致原子操作无法保证。这一类bug是很可能存在的。</p>\n<p></p>\n<p>举个例子&#xff0c;在ucore的sys_exit系统调用中&#xff0c;调用了do_exit&#xff0c;又调用了mm_count_dec。这个函数的实现如下&#xff1a;</p>\n<p></p>\n<pre>static inline int\nmm_count_dec(struct mm_struct *mm) {\n    mm-&gt;mm_count -= 1;\n    return mm-&gt;mm_count;\n}</pre>\n<p>可以看到这里的减等于并不是原子操作&#xff0c;而在这一系列函数的调用过程中都没有关闭中断。这个函数会被编译器编译为多条指令&#xff0c;即读内存到寄存器、寄存器减、寄存器的值放回内存、返回寄存器的值。这一系列的操作中&#xff0c;若发生了中断而进程切换&#xff0c;若在新进程中同样执行了mm_count相关的加减操作&#xff0c;就会破坏原来进程对mm_count操作的原子性从而导致bug。</p>\n<p></p>\n<p>在ucore中&#xff0c;由于这些实现都不是原子性&#xff0c;因此bug的存在可能性是很高的。</p>\n<p></p>\n<p></p>\n<p><strong>ucore&#43;中&#xff1a;</strong></p>\n<p></p>\n<p>选取i386和amd64两个硬件的实现来看。</p>\n<p></p>\n<p>由于ucore&#43;的架构与ucore有很大的不同&#xff0c;上面两种数据的内容分布在&#xff1a;</p>\n<p></p>\n<p>1. mm_count的一系列读、写、加、减操作&#xff0c;在kern-ucore/mm/vmm.h中</p>\n<p>2. page_ref的一系列读、写、加、减操作。在kern-ucore/arch/i386/mm/pmm.h和kern-ucore/arch/amd64/mm/pmm.h中</p>\n<p></p>\n<p>观察可知&#xff0c;这两个文件都调用了&lt;atomic.h&gt;中对应的原子操作函数。而ucore&#43;的编译规则较复杂&#xff0c;对于特定的ARCH而言&#xff0c;它链接的atomic.h放在kern-ucore/arch/ARCH/libs下&#xff0c;因此我们观察amd64和i386的两个atomic.h可以发现&#xff1a;</p>\n<p></p>\n<p>i386中&#xff1a;</p>\n<pre>static inline void atomic_add(atomic_t * v, int i)\n{\n\tasm volatile (&#34;addl %1, %0&#34;:&#34;&#43;m&#34; (v-&gt;counter):&#34;ir&#34;(i));\n}</pre>\n<p>这里加1、写回内存是分开的&#xff0c;当然不是原子操作。</p>\n<p></p>\n<p></p>\n<p>amd64中&#xff1a;</p>\n<pre>static inline int atomic_add_return(atomic_t * v, int i)\n{\n\tint __i = i;\n\tasm volatile (&#34;xaddl %0, %1&#34;:&#34;&#43;r&#34; (i), &#34;&#43;m&#34;(v-&gt;counter)::&#34;memory&#34;);\n\treturn i &#43; __i;\n}</pre>\n<p>这里看起来就靠谱多了&#xff0c;但是陈康老师和谭闻德同时查阅intel手册发现其实这里也是有bug的&#xff1a;</p>\n<p><img src=\"/img/1207-77f748a8a5e84be3.jpg\" alt=\"xadd\" /></p>\n<p>因此&#xff0c;还需要在xadd前面加上前缀LOCK.</p>\n<p></p>\n<p></p>\n<p></p>\n<p>此外&#xff0c;在ucore和ucore&#43;中还有一些是通过关闭中断来保证“原子操作”的&#xff0c;但根据陈康老师所说&#xff0c;<strong>“raw_local_irq_save里面调用了raw_local_irq_disable()&#xff1b;raw_local_irq_restore调用的是popfq的指令码&#xff0c;恢复中断标志位。这些都只能影响当前的处理器。所以&#xff0c;前面的atomic_add_return函数只能disable当前处理器的标志位&#xff0c;对于其他处理器的打断肯定无能为力”。</strong>因此&#xff0c;若想实现SMP&#xff0c;当前ucore&#43;的代码改动也可能会很大。&#xff08;毕竟amd64分支是一个没有完全实现smp的分支&#xff09;</p>\n<p></p>\n<p></p>\n<p>最后&#xff0c;谭闻德查阅risc-v 1.10的手册&#xff0c;发现risc-v的一些原子操作指令&#xff0c;记录如下&#xff1a;</p>\n<p><img src=\"/img/1207-9db8989f3b064c15.jpg\" alt=\"\" /></p>\n<p><img src=\"/img/1207-ad06be0c42fc0095.jpg\" alt=\"\" /></p>"}], "type": "note", "tags": ["2018", "lab5", "student", "ucore_plus"], "tag_good": [{"role": "instructor", "name": "Yu Chen", "endorser": {}, "admin": true, "photo": "1378950179_35.png", "id": "hcrrjuyequh4bt", "photo_url": "https://d1b10bmlvqabco.cloudfront.net/photos/hcrrjuyequh4bt/1378950179_35.png", "us": false, "class_sections": ["课程设计_i5j09fnsl7k5x0", "清华学生_i5j09fnsl7k5x0", "所有老师和助教_i5j09fnsl7k5x0", "os2018spring_i5j09fnsl7k5x0"], "facebook_id": null}, {"role": "student", "name": "Lu Cheng", "endorser": {}, "admin": false, "photo": null, "id": "it2wrxu13f13sy", "photo_url": null, "published": true, "us": false, "class_sections": ["os2018spring_i5j09fnsl7k5x0"], "facebook_id": null}, {"role": "student", "name": "Wende Tan", "endorser": {}, "admin": false, "photo": null, "id": "isu0wqaoff5125", "photo_url": null, "published": true, "us": false, "class_sections": ["os2018spring_i5j09fnsl7k5x0"], "facebook_id": null}], "unique_views": 174, "children": [{"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>建议给出概率大的bug重现方法&#xff0c;并给出修正bug的patch PR.</p>\n<p></p>\n<p>由于linux kernel&#xff08;RT Preempt扩展&#xff09;中会经常出现在atomic context下发生了进程调度的事情&#xff0c;结果也是严重的bug&#xff0c;如果有同学愿意通过静态分析的方法找到bug&#xff0c;欢迎与老师练习&#xff0c;这是lab7中的big challenge &#xff01;</p>", "created": "2018-04-20T14:44:46Z", "bucket_order": 102, "bucket_name": "Week 4/15 - 4/21", "type": "followup", "tag_good": [], "uid": "hcrrjuyequh4bt", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "jg82gcjq9zf3mr", "updated": "2018-04-20T14:44:46Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>通过仔细观察ucore的代码&#xff0c;发现ucore中的page_ref和mm_count其实都并没有得到利用&#xff0c;所以其实ucore中这个bug暂时在用户态是出现不了的。</p>\n<p></p>\n<p>对于page_ref&#xff0c;调用page_ref_inc的函数只有page_insert&#xff0c;经过查找发现所有调用page_insert时的物理页page要么是新alloc出来的物理页&#xff0c;要么是新swap出来的物理页&#xff0c;都不是已经有的物理页。因此ucore中并没有实现多个虚拟地址映射到同一个物理页的机制。</p>\n<p></p>\n<p>对于mm_count&#xff0c;调用mm_count_inc的地方有两个。一个是copy_mm&#xff0c;即do_fork调用copy_mm&#xff0c;而当参数含有CLONE_VM才会使用同一个mm&#xff08;否则mm_create得到新的mm&#xff09;&#xff0c;但这样的fork只在kernel_thread函数中出现&#xff0c;用户syscall调用的do_fork并没有这个flag&#xff0c;因此用户进程无法复用mm。另一个是load_icode&#xff0c;但其中的mm也是mm_create得到的新的mm。因此ucore也并没有实现多个进程使用同一个mm的情况。</p>\n<p></p>\n<p>因此&#xff0c;上面的bug在目前的ucore中其实是不存在的&#xff0c;因为ucore简单到连共享变量机制都没有实现。但对于想要实现COW challenge机制的同学而言&#xff0c;page_ref就是有用的了&#xff0c;此时分析后发现copy_range函数在被调用时是对mm加了锁的&#xff0c;但page_ref并没有同步互斥&#xff0c;因此是可能存在bug的。</p>\n<p></p>\n<p>ucore&#43;较复杂&#xff0c;但ucore&#43;使用了COW机制&#xff0c;需要后续分析。但是有一点&#xff0c;amd64分支打开smp后&#xff0c;想要做原子操作必须加LOCK前缀来占用内存总线&#xff0c;但据说amd64分支现在的smp在内核态只有一个cpu&#xff0c;所以似乎不加LOCK前缀也是可以的。</p>", "created": "2018-04-20T17:05:44Z", "bucket_order": 102, "bucket_name": "Week 4/15 - 4/21", "type": "followup", "tag_good": [], "uid": "it2wrxu13f13sy", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "jg87hmuowvx3pp", "updated": "2018-04-20T17:05:44Z", "config": {}}, {"anon": "no", "folders": [], "data": {"embed_links": null}, "no_upvotes": 0, "subject": "<p>关于内存模型&#xff0c;<a href=\"http://nil.csail.mit.edu/6.824/2016/notes/gomem.pdf\">http://nil.csail.mit.edu/6.824/2016/notes/gomem.pdf</a>、<a href=\"https://www.cl.cam.ac.uk/~pes20/cpp/cpp0xmappings.html\">https://www.cl.cam.ac.uk/~pes20/cpp/cpp0xmappings.html</a>、<a href=\"http://www.cnblogs.com/catch/p/3803130.html\">http://www.cnblogs.com/catch/p/3803130.html</a>等网页讲的不错&#xff0c;特此记录。</p>", "created": "2018-04-29T11:59:36Z", "bucket_order": 101, "bucket_name": "Week 4/22 - 4/28", "type": "followup", "tag_good": [], "uid": "isu0wqaoff5125", "children": [], "tag_good_arr": [], "no_answer": 0, "id": "jgkrily1bxt3qb", "updated": "2018-04-29T11:59:36Z", "config": {}}], "tag_good_arr": ["hcrrjuyequh4bt", "it2wrxu13f13sy", "isu0wqaoff5125"], "id": "jg825yi98qh6wg", "config": {}, "status": "active", "drafts": null, "request_instructor": 0, "request_instructor_me": false, "bookmarked": 3, "num_favorites": 1, "my_favorite": false, "is_bookmarked": false, "is_tag_good": false, "q_edits": [], "i_edits": [], "s_edits": [], "t": 1643169393040, "default_anonymity": "no"}, "error": null, "aid": "kyv0mq34d176qq"}